{"query": "请生成一个BSC-Transaction策略代码", "base_model_response": "示例", "lora_model_response": "", "original_response": "python\n\nfrom web3 import Web3\nimport json\nimport time\nimport urllib.request\n\ndef transaction(my_address, to_address, contract_address, private_key, send, gas):\n    Log(\"start trans \" + contract_coin)\n    bsc = \"https://bsc-dataseed.binance.org/\"\n    web3 = Web3(Web3.HTTPProvider(bsc))\n\n    Log(web3.isConnected())\n\n    balance = web3.eth.get_balance(my_address)\n    humanReadalbe = web3.fromWei(balance, 'ether')\n    Log(humanReadalbe)\n\n    abi = json.loads('[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]')\n\n    nonce = web3.eth.getTransactionCount(my_address)\n\n    contract_address = web3.toChecksumAddress(contract_address)\n    contract = web3.eth.contract(address=contract_address, abi=abi)\n\n    amount = web3.toWei(send, 'ether')\n    Log(amount)\n\n    token_tx = contract.functions.transfer(to_address, amount).buildTransaction({\n        'chainId':56, 'gas': 150000,'gasPrice': web3.toWei(gas,'gwei'), 'nonce':nonce\n    })\n    sign_txn = web3.eth.account.signTransaction(token_tx, private_key=private_key)\n    web3.eth.sendRawTransaction(sign_txn.rawTransaction)\n    Log(\"Transaction has been sent to \" + to_address)\n\ndef transaction_bnb(my_address, to_address, private_key, send, gas):\n    Log(\"start trans \" + contract_coin)\n    bsc = \"https://bsc-dataseed.binance.org/\"\n    web3 = Web3(Web3.HTTPProvider(bsc))\n\n    Log(web3.isConnected())\n\n    balance = web3.eth.get_balance(my_address)\n    humanReadalbe = web3.fromWei(balance, 'ether')\n    Log(humanReadalbe)\n\n    nonce = web3.eth.getTransactionCount(my_address)\n\n    tx = {\n        'nonce': nonce,\n        'to': to_address,\n        'value': web3.toWei(send, 'ether'),\n        'gas': 150000,\n        'gasPrice': web3.toWei(gas, 'gwei')\n    }\n\n    try:\n        signed_tx = web3.eth.account.signTransaction(tx, private_key)\n        tx_hash = web3.eth.sendRawTransaction(signed_tx.rawTransaction)\n        trans = web3.toHex(tx_hash)\n        Log(trans)\n        transaction = web3.eth.get_transaction(trans)\n        Log(\"get \" + trans + \" status!!\")\n    except IOError:\n        Sleep(100)\n        signed_tx = web3.eth.account.signTransaction(tx, private_key)\n        tx_hash = web3.eth.sendRawTransaction(signed_tx.rawTransaction)\n        trans = web3.toHex(tx_hash)\n        Log(\"get hash error retry!!\")\n        transaction = web3.eth.get_transaction(trans)\n        Log(\"get \" + trans + \" status!!\")\n    else:\n        trans_reslut = web3.eth.waitForTransactionReceipt(tx_hash, timeout=30, poll_latency=0.1)\n        trans_reslut = web3.toJSON(trans_reslut)\n        Log(trans_reslut)\n        trans_reslut_status = json.loads(trans_reslut)['status']\n        Log(trans_reslut_status)\n        if trans_reslut_status == 0:\n            Log(\"trans failed retry!!\")\n            transaction_bnb(my_address, to_address, private_key, send, gas)\n\n\ndef doAction():\n    Log(\"Start trasaction!!!\")\n    if contract_coin != 'BNB':\n        transaction(my_address, to_address, contract_address, private_key, send, gas)\n    else:\n        transaction_bnb(my_address, to_address, private_key, send, gas)\n    pass\n    Log(\"trasaction Done!!!\")\n\ndef main():\n    LogReset()\n    while 1:\n        if time.time() > transaction_time:\n            Log(\"Is time to gogogo !!!\")\n            Log(_D(time.time()))\n            doAction()\n            exit(\"End!!!\")\n        pass"}
{"query": "请生成一个BTC-V反策略策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# encoding: utf-8\n\nimport os\nfrom time import time, sleep\nfrom threading import Thread\nfrom socket import socket, AF_INET, SOCK_DGRAM, gethostname, timeout, error\n\nprct = 0.1\npassword = 'test888'\nreq = {}\npos = {}\nrecv = True\ndata = ''\nn=60 #减数触发器，减到零触发\n\ndef trade(req):\n    \"\"\"测试交易\"\"\"\n    for symbol, mpos in req.items():\n        if symbol not in pos.keys():\n            pos[symbol] = 0.0\n        targetPos=round(mpos*prct, 4)\n        Log('targetPos =', targetPos)\n        if targetPos == pos[symbol]:\n            #Log(\"No Trade Operation! client Pos %s is %.3f\" % (symbol, pos[symbol]))\n            continue\n        tick = exchange.GetTicker();\n        if targetPos > pos[symbol]:\n            vol = round(targetPos-pos[symbol], 4)\n            type = 'buy-market'\n            #Log(' Buy btcusdt', vol)\n            id = exchange.Buy(tick.Sell+10, vol)\n            #Log(' Buy btcusdt at %s = %s' %(tick.Sell, vol))\n            Log(\"Order id:\", id);\n        elif targetPos < pos[symbol]:\n            vol = round(pos[symbol]-targetPos, 4)\n            type = 'sell-market'\n            #Log(' Sell btcusdt', vol)\n            id = exchange.Sell(-1, vol)\n            #Log(' Sell btcusdt at %s = %s' %(tick.Buy, vol))\n            Log(\"Order id:\", id);\n        \n        account = exchange.GetAccount()\n        Log(\"账户信息，Balance:\", account.Balance, \"FrozenBalance:\", account.FrozenBalance, \"Stocks:\",\n        account.Stocks, \"FrozenStocks:\", account.FrozenStocks)\n        pos[symbol] = round(account.Stocks, 4)\n        Log('Now Client %s POS = %s' % (symbol, pos[symbol]))\n        \nclass recServer(object):\n    \"\"\"recServer is receving Signal from SigServer\"\"\"\n    def __init__(self, c):\n        self.rcv = True\n        self.t = Thread(target = self.recSig, args = (c,))\n        self.t.start()\n        \n    def recSig(self, c):\n        while self.rcv:\n            try:\n                data, addr = c.recvfrom(1024)\n                #Log('n=',n)\n            except timeout:\n                continue\n            except error:\n                msg = traceback.format_exc()\n                Log(msg)\n                continue\n            if data == 'ok':        \n                #Log('SigServer is alive! Receving \"ok\" from', addr)\n                pass\n            elif 'send password' in data:\n                Log('The client not login, press any key to exit and restart!')\n                self.rcv = False\n            elif not data:\n                Log(\"SigServer is stopped, press any Key to exit SigClient!\")\n                self.rcv = False\n            else:\n                try:\n                    c.sendto('ack', addr)\n                    Log('send ack to ', addr)\n                except error:\n                    Log('Send ack error!')\n                    \n                req = eval(data)\n                Log(req, 'from', addr)\n                trade(req)\n        else:\n            Log('RecSig Thread is Exiting...')\n        return None\n            \n    def heart(self, c, ADDR):      \n        try:\n            c.sendto('live', ADDR)\n        except error:\n            Log('Send keepAlive error!')\n            return None\n                    \n    def close(self):\n        self.rcv = False\n        self.t.join()   \n\ndef main():\n    account = exchange.GetAccount()\n    Log(\"账户信息，Balance:\", account.Balance, \"FrozenBalance:\", account.FrozenBalance, \"Stocks:\",\n        account.Stocks, \"FrozenStocks:\", account.FrozenStocks)\n    pos['btcusdt'] = round(account.Stocks, 4)\n    Log(pos)\n    # 启动UDP客户端\n    c = socket(AF_INET, SOCK_DGRAM)\n    host = '47.98.130.139'\n    port = 1234\n    ADDR = (host, port)\n    c.settimeout(5)\n    try:\n        c.sendto(password, ADDR)\n        data, addr = c.recvfrom(256)\n        Log(data+' from ', addr)\n    except timeout, error:\n        Log('SigServer is not active, client is aborting!')\n        c.close()\n        return None         \n    if 'invalid' in data:\n        Log('\\nYou failed to Login! SigClient is Exiting...')\n        c.close()\n        return None\n\n    # 如果密码正确，开启接收信号模式\n    rc = recServer(c)       \n    sleep(1)\n    global n\n    while recv:\n        n -= 1\n        if not n:\n            rc.heart(c, ADDR)\n            account = exchange.GetAccount()\n            pos['btcusdt'] = round(account.Stocks, 4)\n            #Log(pos)\n            n = 60\n        sleep(1)\n    else:\n        rc.close()\n        Log('Program is End!')"}
{"query": "请生成一个BTCUSDT量化交易执行体策略代码", "base_model_response": "", "lora_model_response": "```python\nimport json\n\nclass BTCUSDTQuantitativeTradeHandler(json.JSONSerializer):\n    def __init__(self, config, **kwargs):\n        super().__init__(config, **kwargs)\n        self.conf = config\n\n    def execute(self, *args, **kwargs):\n        try:\n            if not kwargs.get('currency') in ['BTCUSDT', 'ETH']:\n                raise ValueError('Currency specified must be BTCUSDT or ETH')\n        \n        # If the user is not a member of the network (in case they have set up an account or a different user ID),\n        # we need to retrieve a list of all wallets and then find the one with the highest symbol \n        # value. We can use a built-in `list` function and set the symbol as the first item and then\n        # loop through the list of symbols.\n        self.list_wallets()\n        \n        # Use a built-in `json` function to format the response, which is used to parse JSON data returned from an API such as \n        # GET and POST, but this code will be executed directly by this class.\n        return self.json_response()\n\n    def json_response(self):\n        json_data = json.dumps([f'USD {b['volume']}, BCH {b['volume']}, etc.' for f in self.conf.futures.items()'], indent=4)\n        \n        self.log(\"Status\", \"success\", json_data)\n    \n    def list_wallets(self):\n        return {\n            'symbol': [f'symbols/{x}` for x in range(0, 2161)],\n            'amount': [1000 * x for x in range],\n        }\n```\n`\n要运行这个代码：\n```bash\npython main.py --config BTCUSDT QuantitativeTradeHandler --network testnet\n```", "original_response": "python\nfrom okex.trade import trade,pos_info,acc_info,select_last\nimport okex.api as api\nimport okex.Trade_api as Trade\nimport time\nimport json\nfrom okex.log import log\n\n# 策略源码完整版下载地址 https://github.com/Find-Dream/BTCUSDT\n\ndef main():\n    nowtime = time.time()\n    st = time.localtime(nowtime)\n    update = time.strftime('%Y-%m-%d',st)\n    filenamedate = time.strftime('%Y%m%d',st)\n    logfilename = 'mark_'+ str(filenamedate)\n\n    log(logfilename,'========================【获取基础信息开始】========================')\n\n    btcusdt_api_data = api.btcusdt_api()\n\n    log(logfilename,'btcusdt_api_data：'+str(btcusdt_api_data))\n\n    btcusdt_api = btcusdt_api_data['rule']\n    log(logfilename,'btcusdt_api'+str(btcusdt_api))\n\n    pos_api = btcusdt_api_data['pos']\n    log(logfilename,'pos_api'+str(pos_api))\n\n    pos_okex = {}\n    acc_okex = {}\n    try:\n        acc_api = api.select_acc()\n        log(logfilename,'读取本地保存的账户信息'+str(acc_api))\n    except:\n        acc_okex['lever'] = 1\n\n\n    acc_info_data = acc_info()[0]['details']\n\n\n    for i in acc_info_data:\n        if i['ccy'] == 'USDT':\n            acc_okex['ccy'] = i['cashBal']\n            log(logfilename,'读取接口账户余额'+str(i['cashBal']))\n\n    for i in pos_info():\n        if i['mgnMode'] == 'cross' and i['posSide'] == 'long':\n            pos_okex['long'] = i['pos']\n            if i['pos'] != '0':\n                acc_okex['lever'] = i['lever']\n                log(logfilename,'读取接口long账户杠杆倍数：'+str(i['lever']))\n            else:\n                acc_okex['lever'] = acc_api['lever']\n                log(logfilename,'读取本地long账户杠杆倍数：'+str(acc_api['lever']))\n        elif i['mgnMode'] == 'cross' and i['posSide'] == 'short':\n            pos_okex['short'] = i['pos']\n            if i['pos'] != '0':\n                acc_okex['lever'] = i['lever']\n                log(logfilename,'读取接口short账户杠杆倍数：'+str(i['lever']))\n            \n\n    api.set_acc(json.dumps(acc_okex))\n    log(logfilename,'写入本地账户信息：'+str(acc_okex))\n    last = float(select_last())\n    log(logfilename,'读取当前价格：'+str(last))\n\n    max_sz = int(float(acc_okex['ccy']) * float(acc_okex['lever']) / last * 100)\n    log(logfilename,'最大交易量：'+str(max_sz))\n\n    sz_r = max_sz / 20\n    log(logfilename,'交易量系数：'+str(sz_r))\n\n    pos_api_id = int(btcusdt_api['id'])\n    pos_api_posSide = btcusdt_api['posside']\n    pos_api_side = btcusdt_api['side']\n    pos_api_sz = int(int(btcusdt_api['sz']) * sz_r)\n    pos_api_uptime = int(btcusdt_api['uptime'])\n    pos_api_long = int(int(pos_api['long']) * sz_r)\n    pos_api_short = int(int(pos_api['short']) * sz_r)\n\n    log(logfilename,'pos_api_long：'+str(pos_api_long)+',pos_api_short:'+str(pos_api_short)+',pos_api_sz:'+str(pos_api_sz))\n    log(logfilename,'本地仓位信息pos_okex：'+str(pos_okex))\n\n\n    try:\n        pos_log_done = int(api.pos_log_done())\n    except:\n        pos_log_done = api.pos_log_done()\n    \n    log(logfilename,'pos_log_done:'+str(pos_log_done))\n\n    log(logfilename,'========================【获取基础信息结束】========================')\n    log(logfilename,'========================【mark任务开始】========================')\n    log(logfilename,'判断pos_log_done_id是否为int型:'+str(type(pos_log_done)))\n    if isinstance(pos_log_done,int):\n        log(logfilename,'pos_log_done_id为int型，判断pos_log_done_id与pos_log_id,pos_api_id:'+str(pos_api_id)+',pos_log_done:'+str(pos_log_done))\n        if pos_api_id > pos_log_done:\n            log(logfilename,'API的pos_log_id大于pos_log_done_id，判断API更新时间是否在10秒以内,nowtime:'+str(nowtime)+',pos_api_uptime:'+str(pos_api_uptime))\n            if nowtime < (pos_api_uptime + 13):\n                log(logfilename,'api更新时间在10秒内，判断api交易方向,pos_api_posSide'+str(pos_api_posSide)+',pos_api_side:'+str(pos_api_side))\n                if pos_api_posSide == 'long' and pos_api_side == 'buy':\n                    log(logfilename,'api交易方向：long-buy，判断当前持仓信息与api是否一致')\n                    if int(pos_okex['long']) + int(pos_api_sz) == int(pos_api_long):\n                        log(logfilename,'当前持仓信息与api一致，执行交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_long)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    elif int(pos_okex['long']) + int(pos_api_sz) < int(pos_api_long):\n                        log(logfilename,'当前持仓信息与api一致，执行交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_long)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    else:\n                        log(logfilename,'long仓信息不一致，请将long仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_long)+',API交易数量：'+str(pos_api_sz))\n\n                elif pos_api_posSide == 'long' and pos_api_side == 'sell':\n                    log(logfilename,'api交易方向：long-sell，判断是否符合平仓条件')\n                    if int(pos_okex['long']) > 0:\n                        log(logfilename,'符合平仓条件，当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,int(pos_okex['long']),pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    else:\n                        log(logfilename,'long仓信息不一致，请将long仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n\n                elif pos_api_posSide == 'short' and pos_api_side == 'sell':\n                    log(logfilename,'api交易方向：short-sell，判断当前持仓信息与api是否一致')\n                    if int(pos_okex['short']) + int(pos_api_sz) == int(pos_api_short):\n                        log(logfilename,'符合开仓条件，执行交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    elif int(pos_okex['short']) + int(pos_api_sz) < int(pos_api_short):\n                        log(logfilename,'符合开仓条件，执行交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    else:\n                        log(logfilename,'short仓信息不一致，请将short仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n\n                elif pos_api_posSide == 'short' and pos_api_side == 'buy':\n                    log(logfilename,'api交易方向：short-buy，判断是否符合平仓条件')\n                    if int(pos_okex['short']) > 0:\n                        log(logfilename,'符合平仓条件，当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_okex['short'],pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    else:\n                        log(logfilename,'short仓信息不一致，请将short仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n            else:\n                log(logfilename,'api更新时间超过10秒内，已错过最佳交易时间,nowtime:'+str(nowtime)+',pos_api_uptime:'+str(pos_api_uptime))\n        else:\n            log(logfilename,'API的pos_log_id不大于pos_log_done_id，api无新数据，继续执行监控,pos_api_id:'+str(pos_api_id)+',pos_log_done:'+str(pos_log_done))\n    else:\n        log(logfilename,'pos_log_done_id不为int型')\n        api.set_pos_log_done(pos_api_id)\n    log(logfilename,'========================【mark任务结束】========================')"}
{"query": "请生成一个BitMEX-高级API功能-V110-期货批量下单编辑订单冰山订单一键撤单定时撤单-Python2-3策略代码", "base_model_response": "这个BitMEX-高级API功能可以满足以下需求：", "lora_model_response": "", "original_response": "python\n\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n# BitMEX Advanced API Interface for FMZ.com.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# GNU General Public License v3.0\n#\n\nimport json\nimport math\nimport decimal\n\ndef toNearest(num, tickSize):\n    tickDec = decimal.Decimal(str(tickSize))\n    return float((decimal.Decimal(round(num / tickSize, 0)) * tickDec))\n\nQUOTES = {}\nQUOTES['ZH'] = {\n    'GREET' : '[BitMEX 接口已初始化]  合约: %s. %s',\n    'INITF' : '使用的交易所不正确，当前交易所: %s',\n    'PARAMERR' : '***传的参数不对 检查你的代码*** %s',\n    'NEWORDER' : '[添加订单]  合约: %s 方向: %s 价格: %.8f 数量: %d 张. %s',\n    'MODORDER' : '[修改订单]  orderID/clOrdID: %s 新价格: %.8f 新数量: %d. %s',\n    'MODORDERP' : '[修改订单]  orderID/clOrdID: %s 新价格: %.8f. %s',\n    'MODORDERA' : '[修改订单]  orderID/clOrdID: %s 新数量: %d. %s',\n    'ORDCOUNT' : '[本次批量发送订单]  总计: %d 条. %s',\n    'THISBATCH' : '[信息]  正在处理 合约: %s 条数: %d. %s',\n    'CLEARALL' : '[信息]  已清除所有本地订单. %s',\n    'CLEAR' : '[信息]  已清除所有 %s 本地订单. %s',\n    'CA' : '[订单计划取消]  所有订单都将在 %d 毫秒 后取消. %s'\n}\n\nCOLORS = {\n    'DEEPBLUE' : '#1F618D',\n    'BLUE' : '#0000FF',\n    'LIGHTBLUE' : '#5DADE2',\n    'DEEPGREEN' : '#27AE60',\n    'GREEN' : '#00FF00',\n    'LIGHTGREEN' : '#58D68D',\n    'LAPIS' : '#26619C',\n    'DEEPRED' : '#CB4335',\n    'RED' : '#FF0000',\n    'LIGHTRED' : '#EC7063'\n}\n\n\nclass BitMEX:\n\n    def __init__(self, exchange, silent=False):\n        self.silent = silent\n        exchange.GetCurrency()\n        if isinstance(exchange.GetCurrency(), bytes):\n            self.symbol = str(exchange.GetCurrency(), \"utf-8\").lower()\n            name = str(exchange.GetName(), \"utf-8\")\n        else:\n            self.symbol = exchange.GetCurrency()\n            name = exchange.GetName()\n        self.IO = exchange.IO\n        self.bulks = []\n        self.amends = []\n        if 'BitMEX' in str(name):\n            self.Log(QUOTES[LANG]['GREET'] % (self.symbol.upper(),COLORS['LAPIS']))\n        else:\n            Log(QUOTES[LANG]['INITF'] % (name))\n            \n    def Log(self, *args):\n        if self.silent:\n            return \n        Log(*args)\n\n    def BulkAdd(self, side=None, price=None, amount=None, symbol=None, ordType='Limit', displayQty=None, clOrdID=None, execInst=None):\n        if type is None or price is None or amount is None:\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n            return False\n        side = side.lower()\n        if 'sell' in side:\n            side = 'Sell'\n            cl = COLORS['DEEPRED']\n        else:\n            side = 'Buy'\n            cl = COLORS['DEEPGREEN']\n        if symbol is None:\n            symbol = self.symbol\n\n        # Order structure\n        order = {}\n        order['symbol'] = symbol.upper()            # Symbol\n        order['price'] = price                      # Price\n        order['side'] = side                        # Buy/Sell\n        order['orderQty'] = int(amount)             # Amount\n\n        # Valid order types\n        # Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched, MarketWithLeftOverAsLimit, Pegged\n        # Limit: The default order type. Specify an orderQty and price.\n        # Market: A traditional Market order. A Market order will execute until filled or your bankruptcy price is reached, at which point it will cancel.\n        # MarketWithLeftOverAsLimit: A market order that, after eating through the order book as far as permitted by available margin, will become a limit order. The difference between this type and Market only affects the behavior in thin books. Upon reaching the deepest possible price, if there is quantity left over, a Market order will cancel the remaining quantity. MarketWithLeftOverAsLimit will keep the remaining quantity in the books as a Limit.\n        # Stop: A Stop Market order. Specify an orderQty and stopPx. When the stopPx is reached, the order will be entered into the book.\n        ## On sell orders, the order will trigger if the triggering price is lower than the stopPx. On buys, higher.\n        ## Note: Stop orders do not consume margin until triggered. Be sure that the required margin is available in your account so that it may trigger fully.\n        ## Close Stops don't require an orderQty. See Execution Instructions below.\n        # StopLimit: Like a Stop Market, but enters a Limit order instead of a Market order. Specify an orderQty, stopPx, and price.\n        # MarketIfTouched: Similar to a Stop, but triggers are done in the opposite direction. Useful for Take Profit orders.\n        # LimitIfTouched: As above; use for Take Profit Limit orders.\n        order['ordType'] = ordType\n        # If you want to keep track of order IDs yourself, set a unique clOrdID per order. This clOrdID will come back as a property on the order and any related executions (including on the WebSocket), and can be used to get or cancel the order. Max length is 36 characters.\n        if clOrdID is not None:\n            order['clOrdID'] = clOrdID\n        # The following execInsts are supported. If using multiple, separate with a comma (e.g. LastPrice,Close).\n        # ParticipateDoNotInitiate, MarkPrice, LastPrice, IndexPrice, ReduceOnly, Close\n        # ParticipateDoNotInitiate: Also known as a Post-Only order. If this order would have executed on placement, it will cancel instead.\n        # MarkPrice, LastPrice, IndexPrice: Used by stop and if-touched orders to determine the triggering price. Use only one. By default, 'MarkPrice' is used. Also used for Pegged orders to define the value of 'LastPeg'.\n        # ReduceOnly: A 'ReduceOnly' order can only reduce your position, not increase it. If you have a 'ReduceOnly' limit order that rests in the order book while the position is reduced by other orders, then its order quantity will be amended down or canceled. If there are multiple 'ReduceOnly' orders the least aggressive will be amended first.\n        # Close: 'Close' implies 'ReduceOnly'. A 'Close' order will cancel other active limit orders with the same side and symbol if the open quantity exceeds the current position. This is useful for stops: by canceling these orders, a 'Close' Stop is ensured to have the margin required to execute, and can only execute up to the full size of your position. If orderQty is not specified, a 'Close' order has an orderQty equal to your current position's size.\n        ## Note that a Close order without an orderQty requires a side, so that BitMEX knows if it should trigger above or below the stopPx.\n        if execInst is not None:\n            order['execInst'] = execInst\n            if 'Close' in execInst:\n                del order['orderQty']\n        # Optional quantity to display in the book. Use 0 for a fully hidden order. (Iceberg Order)\n        if displayQty is not None:\n            order['displayQty'] = displayQty\n\n        self.bulks.append(order)\n\n        self.Log(QUOTES[LANG]['NEWORDER'] % (symbol.upper(),side.upper(),price,amount,cl))\n\n        return True\n\n    def BulkClear(self, symbol=None, notify=True):\n        ret = []\n        if symbol is None:\n            ret = self.bulks\n            self.bulks = []\n            if notify:\n                self.Log(QUOTES[LANG]['CLEARALL'] % (COLORS['RED']))\n        else:\n            new = []\n            for i in self.bulks:\n                if i['symbol'] != symbol:\n                    new.append(i)\n                else:\n                    ret.append(i)\n            self.bulks = new\n            self.Log(QUOTES[LANG]['CLEAR'] % (symbol.encode().upper(), COLORS['RED']))\n\n        return ret\n\n    def BulkPost(self, symbol=None):\n        orders = []\n        if symbol is None:\n            orders = self.BulkClear(notify=False)\n        else:\n            orders = self.BulkClear(symbol=symbol, notify=False)\n            \n        if len(orders) == 0:\n            return True\n\n        ret = self.IO(\"api\", \"POST\", \"/api/v1/order/bulk\", 'orders=%s' % json.dumps(orders))\n\n        self.Log(QUOTES[LANG]['ORDCOUNT'] % (len(orders),COLORS['LAPIS']))\n        return ret\n\n    def BulkOrders(self):\n        return self.bulks\n\n    def Amend(self, symbol=None, orderID=None, clOrdID=None, price=None, amount=None):\n        if symbol is None:\n            symbol = self.symbol\n\n        order = {}\n        order['symbol'] = symbol\n        if orderID is None:\n            if clOrdID is None:\n                Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n                return False\n            else:\n                order['clOrdID'] = clOrdID\n        else:\n            order['orderID'] = orderID\n\n        if price is not None:\n            order['price'] = price\n        if amount is not None:\n            order['orderQty'] = amount\n\n        if price is None and amount is None:\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n            return False\n\n        ret = self.IO(\"api\", \"PUT\", \"/api/v1/order/bulk\", 'orders=%s' % json.dumps([order]))\n        if ret == False:\n            return False\n\n        try:\n            id = order['orderID']\n        except:\n            id = order['clOrdID']\n\n        if price is None:\n            self.Log(QUOTES[LANG]['MODORDERA'] % (id, amount, COLORS['LAPIS']))\n            return ret\n        elif amount is None:\n            self.Log(QUOTES[LANG]['MODORDERP'] % (id, price, COLORS['LAPIS']))\n            return ret\n        else:\n            self.Log(QUOTES[LANG]['MODORDER'] % (id, price, amount, COLORS['LAPIS']))\n            return ret\n\n    def AmendAdd(self, symbol=None, orderID=None, clOrdID=None, price=None, amount=None):\n        if symbol is None:\n            symbol = self.symbol\n\n        order = {}\n        order['symbol'] = symbol\n        if orderID is None:\n            if clOrdID is None:\n                Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n                return False\n            else:\n                order['clOrdID'] = clOrdID\n        else:\n            order['orderID'] = orderID\n\n        if price is not None:\n            order['price'] = price\n        if amount is not None:\n            order['orderQty'] = amount\n\n        if price is None and amount is None:\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n            return False\n\n        self.amends.append(order)\n\n        try:\n            id = order['orderID']\n        except:\n            id = order['clOrdID']\n\n        if price is None:\n            self.Log(QUOTES[LANG]['MODORDERA'] % (id, amount, COLORS['LAPIS']))\n            return True\n        elif amount is None:\n            self.Log(QUOTES[LANG]['MODORDERP'] % (id, price, COLORS['LAPIS']))\n            return True\n        else:\n            self.Log(QUOTES[LANG]['MODORDER'] % (id, price, amount, COLORS['LAPIS']))\n            return True\n\n    def AmendClear(self, symbol=None, notify=True):\n        ret = []\n        if symbol is None:\n            ret = self.amends\n            self.amends = []\n            if notify:\n                self.Log(QUOTES[LANG]['CLEARALL'] % (COLORS['RED']))\n        else:\n            new = []\n            for i in self.amends:\n                if i['symbol'] != symbol:\n                    new.append(i)\n                else:\n                    ret.append(i)\n            self.self.amends = new\n            self.Log(QUOTES[LANG]['CLEAR'] % (symbol.encode().upper(), COLORS['RED']))\n\n        return ret\n\n    def AmendPost(self, symbol=None):\n        if symbol is None:\n            symbol = self.symbol\n        orders = self.AmendClear(symbol=symbol, notify=False)\n        if len(orders) == 0:\n            return True\n        param = \"orders=\" + json.dumps(orders)\n        self.Log(QUOTES[LANG]['ORDCOUNT'] % (len(orders),COLORS['LAPIS']))\n        return self.IO(\"api\", \"PUT\", \"/api/v1/order/bulk\", param)\n\n    def AmendOrders(self):\n        return self.amends\n\n    def CancelAllOrders(self, symbol=None, filters=None):\n        param = ''\n        if symbol is not None:\n            param = param + 'symbol=' + symbol\n        if filters is not None:\n            param = param + 'filters=' + json.dumps(filters)\n        return self.IO(\"api\",\"DELETE\",\"/api/v1/order/all\", param)\n\n    def CancelAllAfter(self, timeout=0, notify=True):\n        param = 'timeout=' + str(timeout)\n        if notify:\n            self.Log(QUOTES[LANG]['CA'] % (timeout,COLORS['LAPIS']))\n        return self.IO(\"api\",\"POST\",\"/api/v1/order/cancelAllAfter\", param)\n\n    def GetInstrument(self, symbol='XBTUSD'):\n        try:\n            import requests\n        except ModuleNotFoundError:\n            Log('pip安装requests以使用GetInstrument()函数.')\n            return {}\n        return requests.get('https://www.bitmex.com/api/v1/instrument?symbol=%s&count=1&reverse=false' % symbol).json()[0]\n\next.BitMEXPlus = BitMEX # 导出BitMEX Class, 主策略可以通过BitMEXPlus = ext.BitMEXPlus(exchange)调用\next.toNearest = toNearest\n\n# 模块功能测试\ndef main():\n    LogReset()\n    Log(exchange.GetAccount())\n    BitMEXPlus = ext.BitMEXPlus(exchange)\n    exchange.SetContractType(exchange.GetCurrency())\n    base_price = exchange.GetTicker()['Last']\n    _toNearest = ext.toNearest\n    BitMEXPlus.BulkAdd('sell', _toNearest(base_price*1.4, 0.5), 30)\n    BitMEXPlus.BulkAdd('buy', _toNearest(base_price*0.7, 0.5), 30)\n    Log(BitMEXPlus.BulkOrders())\n    Log(BitMEXPlus.BulkPost())\n    Log(exchange.GetOrders())\n    Log(BitMEXPlus.CancelAllAfter(5000))\n    Sleep(8000)\n    Log(exchange.GetOrders())\n    Log(BitMEXPlus.BulkOrders())"}
{"query": "请生成一个Bn-获取精度最小变动单位-稳定交易系统必备策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!Python3\n\n\"\"\"\n《策略代写》 与 （此程序帮助），致信QQ：35787501\n\n币安合约，可用于解决开单 因精度而产生异常 的问题，获取最小变动单位，用于稳定交易系统的运行\n\"\"\"\n\nimport requests\n\n\ndef get_min_size(symbol: str, host=\"https://www.binancezh.jp\"):\n    \n    \"\"\"\n    获取最小变动单位\n    Args:\n        symbol: 交易对(str)\n                例如: ETHUSDT 等\n        host: 域名将影响访问超时\n              国外地址: https://fapi.binance.com\n              国内地址（变动后需要替换）: https://www.binancezh.jp\n    Returns:\n        最小变动价格(str)，最小变动数量(str)\n    \"\"\"\n    \n    tick_size, step_size = None, None\n    symbols_info = requests.get(f\"{host}/fapi/v1/exchangeInfo\", timeout=5).json()[\"symbols\"]\n    \n    for info in symbols_info:\n        if symbol == info[\"symbol\"]:\n            tick_size, step_size = info[\"filters\"][0][\"tickSize\"], info[\"filters\"][1][\"stepSize\"]\n            break\n            \n    return tick_size, step_size\n\n\ndef main():\n    tick_size, step_size = get_min_size(\"ETHUSDT\")\n    Log(tick_size, step_size)"}
{"query": "请生成一个CoinPark交易所通用协议-627-1600-更新-关闭了SSL验证策略代码", "base_model_response": "", "lora_model_response": "。\n\n```\n//This is the CoinPark main script.\n//It is used for both client and server side\nvoid main( char * argc, char **argv ) {\n   公约();\n   公约Init();\n}\n\n公约() {\n公约Init();\n公约Add公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约Func公约\n\n公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约公约", "original_response": "python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n'''\nCoinPark通用协议,使用Python2.7\n运行地址：http://127.0.0.1:6667，端口可指定\n由于账户没资产，未作详细测试，欢迎反馈Bug\nQQ:1051804485\n反馈地址：https://www.botvs.com/bbs-topic/1963\n2018.6.26 15:57 更新，修改了Bug\n可以把通用协议当成普通机器人，运行在BotVs模拟盘即可，不收取费用\n为了使用IO函数，需要重载exchange里的rpc方法，js的例子如下：\nexchange.rpc = function(path, obj) {\n    return exchange.IO(\"api\",\"POST\", path, \"obj=\"+escape(JSON.stringify(obj)));\n}\nfunction main() {\n\tLog(exchange.rpc(\"/transfer\", {cmd: \"transfer/assets\", body: {select:1}}));\n}\n'''\nfrom BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\nimport json\nimport urllib\nimport urllib2\nimport time\nimport hmac\nimport hashlib\nimport random\nimport ssl\nssl._create_default_https_context = ssl._create_unverified_context\n\ndef httpGet(url):\n    headers = {'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'}\n    req = urllib2.Request(url,headers=headers)\n    response = urllib2.urlopen(req)\n    return json.loads(response.read())\n\ndef getsign(data,secret):\n    result = hmac.new(secret.encode(\"utf-8\"), data.encode(\"utf-8\"), hashlib.md5).hexdigest()\n    return result\n\ndef httpPostWithSign(url, cmds, api_key, api_secret):\n    headers = {'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'}\n    s_cmds = json.dumps(cmds)\n    sign = getsign(s_cmds,api_secret)\n    req = urllib2.Request(url, urllib.urlencode({'cmds': s_cmds, 'apikey': api_key,'sign':sign}), headers=headers)\n    response = urllib2.urlopen(req)\n    return json.loads(response.read())\n\nclass MyExchange:\n\n    market_url = \"https://api.coinpark.cc/v1/mdata\"\n    trade_url = \"https://api.coinpark.cc/v1\"\n    kline_period = {1:'1min', 3:'3min', 5:'5min', 15:'15min', 30:'30min',\\\n                    60:'1hour', 120:'2hour', 240:'4hour', 360:'6hour', \\\n                    60*12:'12hour', 60*24:'day', 60*24*7:'week'}\n    @staticmethod\n    def GetTicker(symbol):\n        url = MyExchange.market_url + \"?cmd=ticker&pair=\" + symbol\n        raw_data = httpGet(url)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\": {\"time\": raw_data['result']['timestamp'], \"buy\": raw_data['result']['buy'],\\\n                    \"sell\": raw_data['result']['sell'], \"last\": raw_data['result']['last'],\\\n                    \"high\": raw_data['result']['high'], \"low\": raw_data['result']['low'],\\\n                    \"vol\": raw_data['result']['vol']}}\n        return ret_data\n    @staticmethod\n    def GetDepth(symbol):\n        url = MyExchange.market_url + \"?cmd=depth&size=10&pair=\" + symbol\n        raw_data = httpGet(url)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\" : {\"time\" : raw_data['result']['update_time'], \"asks\" : [], \"bids\" : []}}\n        for bid in raw_data['result']['bids']:\n            ret_data['data']['bids'].append([bid['price'],bid['volume']])\n        for ask in raw_data['result']['asks']:\n            ret_data['data']['asks'].append([ask['price'],ask['volume']])\n        return ret_data\n    @staticmethod\n    def GetRecords(symbol, period):\n        url = MyExchange.market_url + \"?cmd=kline&size=200&period=%s&pair=\"%MyExchange.kline_period[period] + symbol\n        raw_data = httpGet(url)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\": []}\n        for kline in raw_data['result']:\n            ret_data['data'].append([kline['time'], kline['open'], kline['high'],\\\n            kline['low'], kline['close'], kline['vol']])\n        return ret_data\n    @staticmethod\n    def GetTrades(symbol):\n        url = MyExchange.market_url + \"?cmd=deals&size=50&pair=\" + symbol\n        raw_data = httpGet(url)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\":[]}\n        for trade in raw_data[\"result\"]:\n            ret_data[\"data\"].append({\"id\":trade[\"id\"], \"time\":trade[\"time\"], \\\n            \"price\":trade[\"price\"], \"amount\":trade[\"amount\"],\"type\":\"buy\" if int(trade[\"side\"])==1 else \"sell\"})\n        return ret_data\n    @staticmethod\n    def GetAccount(api_key, api_secret):\n        url = MyExchange.trade_url + \"/transfer\"\n        cmds = [{\"cmd\": \"transfer/assets\", \"body\": {\"select\":1}}]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\": []}\n        if \"assets_list\" in raw_data[\"result\"][0][\"result\"].keys():\n            for asset in raw_data[\"result\"][0][\"result\"][\"assets_list\"]:\n                ret_data[\"data\"].append({\"currency\":asset[\"coin_symbol\"], \\\n                \"free\":asset[\"balance\"], \"frozen\":asset[\"freeze\"]})\n        ret_data[\"raw\"] = raw_data[\"result\"]\n        return ret_data\n    @staticmethod\n    def Trade(api_key, api_secret, pair, order_type, order_side, price, amount):\n        url = MyExchange.trade_url + \"/orderpending\"\n        cmds = [{\n                'cmd':\"orderpending/trade\",\n                'index': random.randint(0,2000), \n                'body':{\n                    'pair':pair,\n                    'account_type':0,\n                    'order_type':order_type,\n                    'order_side':order_side,\n                    'price':price,\n                    'amount':amount,\n                    }\n                }]\n        if order_type==1:\n            cmds['money'] = amount\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\": {'id':raw_data['result'][0]['result']}}\n        return ret_data\n    @staticmethod\n    def CancelOrder(api_key, api_secret, orders_id):\n        url = MyExchange.trade_url + \"/orderpending\"\n        cmds = [{\n                'cmd':\"orderpending/cancelTrade\",\n                'index': random.randint(0,2000), \n                'body':{'orders_id':orders_id}\n                }]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\":True}\n        try:\n            result = raw_data['result'].encode('utf8')\n        except:\n            ret_data = {\"data\":False}\n        ret_data['raw'] = raw_data\n        return ret_data\n    @staticmethod\n    def GetOrder(api_key, api_secret, orders_id):\n        url = MyExchange.trade_url + \"/orderpending\"\n        cmds = [{\n                'cmd':\"orderpending/order\",\n                'index': random.randint(0,2000), \n                'body':{'id':orders_id}\n                }]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        status = 'open'\n        if not raw_data['result'][0]['result']:\n            return {\"error\":'Id not found'}\n        if int(raw_data['result'][0]['result']['status'])==3:\n            status = 'closed'\n        if int(raw_data['result'][0]['result']['status'])==5:\n            status = 'canceled'\n        ret_data = { \n                    \"data\": {\n                        \"id\": raw_data['result'][0]['result']['id'],\n                        \"amount\": raw_data['result'][0]['result']['amount'],\n                        \"price\": raw_data['result'][0]['result']['price'],\n                        \"status\": status,\n                        \"deal_amount\": raw_data['result'][0]['result']['deal_amount'],\n                        \"type\": \"buy\" if raw_data['result'][0]['result']['order_side']==1 else \"sell\", \n                        \"avg_price\": 0,\n                    }\n                }\n        ret_data['raw'] = raw_data\n        return ret_data\n    @staticmethod\n    def GetOrders(api_key, api_secret, pair):\n        url = MyExchange.trade_url + \"/orderpending\"\n        cmds = [{\n                'cmd':\"orderpending/orderPendingList\",\n                'body':{\n                    'pair':pair, \n                    'page':1, \n                    'size':50\n                    }\n                }]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\":[]}\n        for order in raw_data[\"result\"][0][\"result\"][\"items\"]:\n            status = 'open'\n            if int(order['status'])==3:\n                status = 'closed'\n            if int(order['status'])==5:\n                status = 'canceled'\n            ret_data[\"data\"].append(\n                {\n                    \"id\": order['id'],\n                    \"amount\": order['amount'],\n                    \"price\": order['price'],\n                    \"status\": status,\n                    \"deal_amount\": order['deal_amount'],\n                    \"type\": \"buy\" if order['order_side']==1 else \"sell\", \n                }\n            )\n        ret_data['raw'] = raw_data\n        return ret_data\n    @staticmethod\n    def IO(api_key, api_secret, path, params):\n        url = MyExchange.trade_url + path\n        cmds = [json.loads(str(urllib.unquote(params['obj'])))]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        return {\"data\":raw_data}\n\nclass Server(BaseHTTPRequestHandler):\n\n    def do_HEAD(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'application/json')\n        self.end_headers()\n        \n    def do_POST(self):\n\n        self.data_string = self.rfile.read(int(self.headers['Content-Length']))\n        data =json.loads(self.data_string.replace(\"'\", '\"'))\n        sent_data = {}\n        if data['method'] == \"ticker\":\n            symbol = data['params']['symbol'].upper()\n            sent_data = MyExchange.GetTicker(symbol)\n        elif data['method'] == \"depth\":\n            symbol = data['params']['symbol'].upper()\n            sent_data = MyExchange.GetDepth(symbol)\n        elif data['method'] == \"records\":\n            symbol = data['params']['symbol'].upper()\n            period = data['params']['period']\n            sent_data = MyExchange.GetRecords(symbol, int(period))\n        elif data['method'] == \"trades\":\n            symbol = data['params']['symbol'].upper()\n            sent_data = MyExchange.GetTrades(symbol)\n        elif data['method'] == \"accounts\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            sent_data = MyExchange.GetAccount(access_key, secret_key)\n        elif data['method'] == \"trade\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            pair = data['params']['symbol'].upper()\n            order_side = 1 if data['params']['type'] == 'buy' else 2\n            price = data['params']['price']\n            order_type = 2 if price > 0 else 1\n            amount = data['params']['amount']\n            sent_data = MyExchange.Trade(access_key, secret_key, pair, order_type, order_side, price, amount)\n        elif data['method'] == \"cancel\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            orders_id = int(data['params']['id'])\n            sent_data = MyExchange.CancelOrder(access_key, secret_key, orders_id)\n        elif data['method'] == \"order\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            orders_id = int(data['params']['id'])\n            sent_data = MyExchange.GetOrder(access_key, secret_key, orders_id)\n        elif data['method'] == \"orders\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            pair = data['params']['symbol'].upper()\n            sent_data = MyExchange.GetOrders(access_key, secret_key, pair)\n        elif data['method'][:2] == \"__\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            path = data[\"method\"].split('_')[-1]\n            params = data[\"params\"]\n            sent_data = MyExchange.IO(access_key, secret_key, path, params)\n\n        self.do_HEAD()\n        self.wfile.write(json.dumps(sent_data))\n        \ndef run(server_class=HTTPServer, handler_class=Server, port=6667):\n    server_address = ('', port)\n    httpd = server_class(server_address, handler_class)\n    print 'Starting http server...'\n    httpd.serve_forever()\n\nif __name__ == \"__main__\":\n    from sys import argv\n    if len(argv) == 2:\n        run(port=int(argv[1]))\n    else:\n        run()"}
{"query": "请生成一个FMZ实盘机器人自动检测重启程序微信推送策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''\n代码可以直接放到本地运行，\n不过需要一直开启电脑，也可以放到自己的服务器上运行\n'''\n\nimport time\nimport json\nimport ssl\nimport requests\nssl._create_default_https_context = ssl._create_unverified_context\n\ntry:\n    import md5\n    import urllib2\n    from urllib import urlencode\nexcept:\n    import hashlib as md5\n    import urllib.request as urllib2\n    from urllib.parse import urlencode\n\naccessKey = '48xxxxxxxxxxxxxxxxxxxxxxxxxxxxde'\nsecretKey = '91xxxxxxxxxxxxxxxxxxxxxxxxxxxx84'\n\ndef api(method, *args):\n    d = {\n        'version': '1.0',\n        'access_key': accessKey,\n        'method': method,\n        'args': json.dumps(list(args)),\n        'nonce': int(time.time() * 1000),\n        }\n\n    d['sign'] = md5.md5(('%s|%s|%s|%d|%s' % (d['version'], d['method'], d['args'], d['nonce'], secretKey)).encode('utf-8')).hexdigest()\n    # 注意： urllib2.urlopen 函数，超时问题，可以设置超时时间，urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8'), timeout=10) 设置超时 10秒\n    return json.loads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\n\ndef send_wechat(msg):\n    token = '93xxxxxxxxxxxxxxxxxxxxxxxxxxxx57'  # 前边复制到那个token\n    title = '【Waring】 策略信息'\n    content = msg\n    template = 'html'\n    url = f\"https://www.pushplus.plus/send?token={token}&title={title}&content={content}&template={template}\"\n    #print(url)\n    r = requests.get(url=url)\n    print(json.loads(r.text)['msg'])\n\nrobotId = [xxx,xxx,xxx]    #需要监视的机器人代码\n\n\nwhile True:\n    for j in range(len(robotId)):\n        detail = api('GetRobotDetail', robotId[j])\n        if detail['data']['result']['robot']['status'] == 1 and detail['data']['result']['robot']['wd'] == 1:\n            print(f\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视已打开 wd = {detail['data']['result']['robot']['wd']}\")\n            pass\n        elif detail['data']['result']['robot']['status'] == 1 :\n            print(f\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视未打开 wd = {detail['data']['result']['robot']['wd']}\")\n            pass\n        else:\n            print(f\"实盘{robotId[j]}状态异常 status = {detail['data']['result']['robot']['status']}\")\n            #尝试重启实盘   尝试次数 = 4    每5s 尝试一次\n            status = False\n            for i in range(4):\n                api('RestartRobot', robotId[j])\n                robotDetail = api('GetRobotDetail', robotId[j])\n                print(f\"尝试重启实盘{robotId[j]}第 {i+1} 次\")\n                if robotDetail['data']['result']['robot']['status'] == 1 :\n                    mess = api('GetRobotLogs',robotId[j],0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                    print(f\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\n\"\n                          f\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\n\"\n                          f\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\n\")\n                    send_wechat(f\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\n\"\n                                f\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\n\"\n                                f\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\n\")\n                    status = True\n                    break\n                else:\n                    print(f\"第 {i+1} 次 重启失败!!\")\n                time.sleep(5)\n            if status == False :\n                print(f\"尝试 4 次重启实盘{robotId[j]}失败，发送警告信息！！\")\n                send_wechat(f\"尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\n\")\n    time.sleep(60*10)"}
{"query": "请生成一个FMZ教程-Python速成手册策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# 单行注释\n\"\"\" 多行字符串可以用\n    三个引号包裹，不过这也可以被当做\n    多行注释\n\"\"\"\n\n####################################################\n## 1. 原始数据类型和操作符\n####################################################\n\n# 数字类型\n3  # => 3\n\n# 简单的算数\n1 + 1  # => 2\n8 - 1  # => 7\n10 * 2  # => 20\n35 / 5  # => 7\n\n# 整数的除法会自动取整\n5 / 2  # => 2\n\n# 要做精确的除法，我们需要引入浮点数\n2.0     # 浮点数\n11.0 / 4.0  # => 2.75 精确多了\n\n# 括号具有最高优先级\n(1 + 3) * 2  # => 8\n\n# 布尔值也是基本的数据类型\nTrue\nFalse\n\n# 用 not 来取非\nnot True  # => False\nnot False  # => True\n\n# 相等\n1 == 1  # => True\n2 == 1  # => False\n\n# 不等\n1 != 1  # => False\n2 != 1  # => True\n\n# 更多的比较操作符\n1 < 10  # => True\n1 > 10  # => False\n2 <= 2  # => True\n2 >= 2  # => True\n\n# 比较运算可以连起来写！\n1 < 2 < 3  # => True\n2 < 3 < 2  # => False\n\n# 字符串通过 \" 或 ' 括起来\n\"This is a string.\"\n'This is also a string.'\n\n# 字符串通过加号拼接\n\"Hello \" + \"world!\"  # => \"Hello world!\"\n\n# 字符串可以被视为字符的列表\n\"This is a string\"[0]  # => 'T'\n\n# % 可以用来格式化字符串\n\"%s can be %s\" % (\"strings\", \"interpolated\")\n\n# 也可以用 format 方法来格式化字符串\n# 推荐使用这个方法\n\"{0} can be {1}\".format(\"strings\", \"formatted\")\n# 也可以用变量名代替数字\n\"{name} wants to eat {food}\".format(name=\"Bob\", food=\"lasagna\")\n\n# None 是对象\nNone  # => None\n\n# 不要用相等 `==` 符号来和None进行比较\n# 要用 `is`\n\"etc\" is None  # => False\nNone is None  # => True\n\n# 'is' 可以用来比较对象的相等性\n# 这个操作符在比较原始数据时没多少用，但是比较对象时必不可少\n\n# None, 0, 和空字符串都被算作 False\n# 其他的均为 True\n0 == False  # => True\n\"\" == False  # => True\n\n\n####################################################\n## 2. 变量和集合\n####################################################\n\n# 很方便的输出\nprint \"I'm Python. Nice to meet you!\"\n\n\n# 给变量赋值前不需要事先声明\nsome_var = 5    # 一般建议使用小写字母和下划线组合来做为变量名\nsome_var  # => 5\n\n# 访问未赋值的变量会抛出异常\n# 可以查看控制流程一节来了解如何异常处理\nsome_other_var  # 抛出 NameError\n\n# if 语句可以作为表达式来使用\n\"yahoo!\" if 3 > 2 else 2  # => \"yahoo!\"\n\n# 列表用来保存序列\nli = []\n# 可以直接初始化列表\nother_li = [4, 5, 6]\n\n# 在列表末尾添加元素\nli.append(1)    # li 现在是 [1]\nli.append(2)    # li 现在是 [1, 2]\nli.append(4)    # li 现在是 [1, 2, 4]\nli.append(3)    # li 现在是 [1, 2, 4, 3]\n# 移除列表末尾元素\nli.pop()        # => 3 li 现在是 [1, 2, 4]\n# 重新加进去\nli.append(3)    # li is now [1, 2, 4, 3] again.\n\n# 像其他语言访问数组一样访问列表\nli[0]  # => 1\n# 访问最后一个元素\nli[-1]  # => 3\n\n# 越界会抛出异常\nli[4]  # 抛出越界异常\n\n# 切片语法需要用到列表的索引访问\n# 可以看做数学之中左闭右开区间\nli[1:3]  # => [2, 4]\n# 省略开头的元素\nli[2:]  # => [4, 3]\n# 省略末尾的元素\nli[:3]  # => [1, 2, 4]\n\n# 删除特定元素\ndel li[2]  # li 现在是 [1, 2, 3]\n\n# 合并列表\nli + other_li  # => [1, 2, 3, 4, 5, 6] - 并不会不改变这两个列表\n\n# 通过拼接来合并列表\nli.extend(other_li)  # li 是 [1, 2, 3, 4, 5, 6]\n\n# 用 in 来返回元素是否在列表中\n1 in li  # => True\n\n# 返回列表长度\nlen(li)  # => 6\n\n\n# 元组类似于列表，但它是不可改变的\ntup = (1, 2, 3)\ntup[0]  # => 1\ntup[0] = 3  # 类型错误\n\n# 对于大多数的列表操作，也适用于元组\nlen(tup)  # => 3\ntup + (4, 5, 6)  # => (1, 2, 3, 4, 5, 6)\ntup[:2]  # => (1, 2)\n2 in tup  # => True\n\n# 你可以将元组解包赋给多个变量\na, b, c = (1, 2, 3)     # a 是 1，b 是 2，c 是 3\n# 如果不加括号，将会被自动视为元组\nd, e, f = 4, 5, 6\n# 现在我们可以看看交换两个数字是多么容易的事\ne, d = d, e     # d 是 5，e 是 4\n\n\n# 字典用来储存映射关系\nempty_dict = {}\n# 字典初始化\nfilled_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\n\n# 字典也用中括号访问元素\nfilled_dict[\"one\"]  # => 1\n\n# 把所有的键保存在列表中\nfilled_dict.keys()  # => [\"three\", \"two\", \"one\"]\n# 键的顺序并不是唯一的，得到的不一定是这个顺序\n\n# 把所有的值保存在列表中\nfilled_dict.values()  # => [3, 2, 1]\n# 和键的顺序相同\n\n# 判断一个键是否存在\n\"one\" in filled_dict  # => True\n1 in filled_dict  # => False\n\n# 查询一个不存在的键会抛出 KeyError\nfilled_dict[\"four\"]  # KeyError\n\n# 用 get 方法来避免 KeyError\nfilled_dict.get(\"one\")  # => 1\nfilled_dict.get(\"four\")  # => None\n# get 方法支持在不存在的时候返回一个默认值\nfilled_dict.get(\"one\", 4)  # => 1\nfilled_dict.get(\"four\", 4)  # => 4\n\n# setdefault 是一个更安全的添加字典元素的方法\nfilled_dict.setdefault(\"five\", 5)  # filled_dict[\"five\"] 的值为 5\nfilled_dict.setdefault(\"five\", 6)  # filled_dict[\"five\"] 的值仍然是 5\n\n\n# 集合储存无顺序的元素\nempty_set = set()\n# 初始化一个集合\nsome_set = set([1, 2, 2, 3, 4])  # some_set 现在是 set([1, 2, 3, 4])\n\n# Python 2.7 之后，大括号可以用来表示集合\nfilled_set = {1, 2, 2, 3, 4}  # => {1 2 3 4}\n\n# 向集合添加元素\nfilled_set.add(5)  # filled_set 现在是 {1, 2, 3, 4, 5}\n\n# 用 & 来计算集合的交\nother_set = {3, 4, 5, 6}\nfilled_set & other_set  # => {3, 4, 5}\n\n# 用 | 来计算集合的并\nfilled_set | other_set  # => {1, 2, 3, 4, 5, 6}\n\n# 用 - 来计算集合的差\n{1, 2, 3, 4} - {2, 3, 5}  # => {1, 4}\n\n# 用 in 来判断元素是否存在于集合中\n2 in filled_set  # => True\n10 in filled_set  # => False\n\n\n####################################################\n## 3. 控制流程\n####################################################\n\n# 新建一个变量\nsome_var = 5\n\n# 这是个 if 语句，在 python 中缩进是很重要的。\n# 下面的代码片段将会输出 \"some var is smaller than 10\"\nif some_var > 10:\n    print \"some_var is totally bigger than 10.\"\nelif some_var < 10:    # 这个 elif 语句是不必须的\n    print \"some_var is smaller than 10.\"\nelse:           # 这个 else 也不是必须的\n    print \"some_var is indeed 10.\"\n\n\n\"\"\"\n用for循环遍历列表\n输出:\n    dog is a mammal\n    cat is a mammal\n    mouse is a mammal\n\"\"\"\nfor animal in [\"dog\", \"cat\", \"mouse\"]:\n    # 你可以用 % 来格式化字符串\n    print \"%s is a mammal\" % animal\n\n\"\"\"\n`range(number)` 返回从0到给定数字的列表\n输出:\n    0\n    1\n    2\n    3\n\"\"\"\nfor i in range(4):\n    print i\n\n\"\"\"\nwhile 循环\n输出:\n    0\n    1\n    2\n    3\n\"\"\"\nx = 0\nwhile x < 4:\n    print x\n    x += 1  #  x = x + 1 的简写\n\n# 用 try/except 块来处理异常\n\n# Python 2.6 及以上适用:\ntry:\n    # 用 raise 来抛出异常\n    raise IndexError(\"This is an index error\")\nexcept IndexError as e:\n    pass    # pass 就是什么都不做，不过通常这里会做一些恢复工作\n\n\n####################################################\n## 4. 函数\n####################################################\n\n# 用 def 来新建函数\ndef add(x, y):\n    print \"x is %s and y is %s\" % (x, y)\n    return x + y    # 通过 return 来返回值\n\n# 调用带参数的函数\nadd(5, 6)  # => 输出 \"x is 5 and y is 6\" 返回 11\n\n# 通过关键字赋值来调用函数\nadd(y=6, x=5)   # 顺序是无所谓的\n\n# 我们也可以定义接受多个变量的函数，这些变量是按照顺序排列的\ndef varargs(*args):\n    return args\n\nvarargs(1, 2, 3)  # => (1,2,3)\n\n\n# 我们也可以定义接受多个变量的函数，这些变量是按照关键字排列的\ndef keyword_args(**kwargs):\n    return kwargs\n\n# 实际效果：\nkeyword_args(big=\"foot\", loch=\"ness\")  # => {\"big\": \"foot\", \"loch\": \"ness\"}\n\n# 你也可以同时将一个函数定义成两种形式\ndef all_the_args(*args, **kwargs):\n    print args\n    print kwargs\n\"\"\"\nall_the_args(1, 2, a=3, b=4) prints:\n    (1, 2)\n    {\"a\": 3, \"b\": 4}\n\"\"\"\n\n# 当调用函数的时候，我们也可以进行相反的操作，把元组和字典展开为参数\nargs = (1, 2, 3, 4)\nkwargs = {\"a\": 3, \"b\": 4}\nall_the_args(*args)  # 等价于 foo(1, 2, 3, 4)\nall_the_args(**kwargs)  # 等价于 foo(a=3, b=4)\nall_the_args(*args, **kwargs)  # 等价于 foo(1, 2, 3, 4, a=3, b=4)\n\n# 函数在 python 中是一等公民\ndef create_adder(x):\n    def adder(y):\n        return x + y\n    return adder\n\nadd_10 = create_adder(10)\nadd_10(3)  # => 13\n\n# 匿名函数\n(lambda x: x > 2)(3)  # => True\n\n# 内置高阶函数\nmap(add_10, [1, 2, 3])  # => [11, 12, 13]\nfilter(lambda x: x > 5, [3, 4, 5, 6, 7])  # => [6, 7]\n\n# 可以用列表方法来对高阶函数进行更巧妙的引用\n[add_10(i) for i in [1, 2, 3]]  # => [11, 12, 13]\n[x for x in [3, 4, 5, 6, 7] if x > 5]  # => [6, 7]\n\n####################################################\n## 5. 类\n####################################################\n\n# 我们新建的类是从 object 类中继承的\nclass Human(object):\n\n     # 类属性，由所有类的对象共享\n    species = \"H. sapiens\"\n\n    # 基本构造函数\n    def __init__(self, name):\n        # 将参数赋给对象成员属性\n        self.name = name\n\n    # 成员方法，参数要有 self\n    def say(self, msg):\n        return \"%s: %s\" % (self.name, msg)\n\n    # 类方法由所有类的对象共享\n    # 这类方法在调用时，会把类本身传给第一个参数\n    @classmethod\n    def get_species(cls):\n        return cls.species\n\n    # 静态方法是不需要类和对象的引用就可以调用的方法\n    @staticmethod\n    def grunt():\n        return \"*grunt*\"\n\n\n# 实例化一个类\ni = Human(name=\"Ian\")\nprint i.say(\"hi\")     # 输出 \"Ian: hi\"\n\nj = Human(\"Joel\")\nprint j.say(\"hello\")  # 输出 \"Joel: hello\"\n\n# 访问类的方法\ni.get_species()  # => \"H. sapiens\"\n\n# 改变共享属性\nHuman.species = \"H. neanderthalensis\"\ni.get_species()  # => \"H. neanderthalensis\"\nj.get_species()  # => \"H. neanderthalensis\"\n\n# 访问静态变量\nHuman.grunt()  # => \"*grunt*\"\n\n\n####################################################\n## 6. 模块\n####################################################\n\n# 我们可以导入其他模块\nimport math\nprint math.sqrt(16)  # => 4\n\n# 我们也可以从一个模块中导入特定的函数\nfrom math import ceil, floor\nprint ceil(3.7)   # => 4.0\nprint floor(3.7)  # => 3.0\n\n# 从模块中导入所有的函数\n# 警告：不推荐使用\nfrom math import *\n\n# 简写模块名\nimport math as m\nmath.sqrt(16) == m.sqrt(16)  # => True\n\n# Python的模块其实只是普通的python文件\n# 你也可以创建自己的模块，并且导入它们\n# 模块的名字就和文件的名字相同\n\n# 也可以通过下面的方法查看模块中有什么属性和方法\nimport math\ndir(math)"}
{"query": "请生成一个Fomo3D-智能合约监控-Fomo3D-Smart-Contract-Monitoring策略代码", "base_model_response": "```python\nimport json\nfrom fomo3d import Fomo3D\n\n# 加载Fomo3D数据集\ndf = Fomo3D.load_data_from_folder('Fomo3D_Dataset.json')\n\n# 初始化Fomo3D对象\nfomo3d = Fomo3D(df['Token'], df['Address'], df['TokenType'], df['ContractName'])\n\n# 定义监控参数\nparams = {\n    'monitor': 'Fomo3D_Smart Contract_Monitoring',\n    'time': 120,\n}\n\n# 创建Fomo3D监控对象\nwatch = fomo3d[watch_key]\n\n# 添加监控事件到列表中，指定要监控的对象和时间\nlist_to Watch = ['fomo3d', params['monitors'][0]]\n\n# 添加监控事件到数据库中，指定监控的ID和要监控的对象\ndata_to_database = [{'ID': data_to_database.get(0)[0], 'MonitoringId': params['monitors'][0][1]}, {'ID': data_to_database.get(1)[0], 'MonitoringId': params['monitors'][1][1]}]\n\n# 更新监控状态\nwatch.set_status(data_to_database)\n\n# 记录数据到数据库中\nwatch.db.insert(data_to_database, data_to_db.to_json())\n\n# 获取监控状态\nstatus = watch.db.get('monitorStatus')\n\nprint(status)\n```\n\n这个Fomo3D-智能合约监控-Fomo3D-Smart-Contract-Monitoring策略代码首先加载Fomo3D数据集，并初始化Fomo3D对象。然后定义了监控参数，包括要监控的对象、时间和监控的时间。接着创建了一个名为`watch`的Fomo3D监控对象，添加了监控事件到一个列表中，指定要监控的对象和时间。最后更新了监控状态，记录了数据到数据库中，并获取了监控状态。", "lora_model_response": "", "original_response": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n# \n# Fomo3D Smart Contract Monitoring\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\nimport requests\nimport re\nimport json\nimport time\nimport datetime\n\nLogReset()\n\nif TG == 1:\n    TG_ENABLE = True \nelse:\n    TG_ENABLE = False\nif WECHAT == 1:\n    WC_ENABLE = True \nelse:\n    WC_ENABLE = False\n    \nTG_BOT_KEY = TGKEY\n\nTGURL = 'https://api.telegram.org/bot%s/sendMessage' % TG_BOT_KEY\nTGPARAM = {}\nTGPARAM['chat_id'] = TGID\n\ndef Send(message):\n    if TG_ENABLE == False:\n        return\n    try:\n        TGPARAM['text'] = message\n        res = requests.post(TGURL, data = TGPARAM)\n        return\n    except IOError as e:\n        print(e)\n        return\n\n\ndef Refresh():\n    URL = 'https://mainnet.infura.io/%s' % INFURAKEY\n    HEADER = {'Content-Type': 'application/json'}\n    PARAM = '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"eth_call\", \"params\": [{\"data\":\"0x747dff42\",\"to\":\"%s\"},\"latest\"]}' % CONTRACT\n    data = requests.post(URL,data=PARAM,headers=HEADER).json()\n    HEX = re.sub('(0{2,})','X',data['result']).split('X')[3]\n    print(HEX)\n    INT = int(HEX, 16)\n    NOW = int(time.time())\n    LEFT = INT - NOW\n    return LEFT\n\ndef main():\n    Log('Started!')\n    Log('ContractAddress: ' + CONTRACT)\n    Log('Telegram Enabled: ' + str(TG_ENABLE))\n    Log('WeChat Enabled: ' + str(WC_ENABLE))\n    while True:\n        try:\n            DATE = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            TIMELEFT = Refresh()\n            message = 'Time before FOMO ENDING : %d' % TIMELEFT\n            if TIMELEFT < 0:\n                TIMELEFT = THRESHOLD + 10\n            if TIMELEFT <= THRESHOLD:\n                Send(message)\n                if WC_ENABLE == True:\n                    message = message + ' !@'\n                    \n                Log(message)\n            else:\n                Log(message)\n\n        except IOError as e:\n            print(e)\n            time.sleep(REFRESH_DELAY)\n            pass\n\n        time.sleep(REFRESH_DELAY)"}
{"query": "请生成一个Keltner通道突破止损加盈利10即长期持有策略-v23-dev-多周期策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''\nstart: 2020-01-01 00:00:00\nend: 2020-04-24 00:00:00\nperiod: 1h\nexchanges: [{\"eid\":\"huobi\",\"currency\":\"BTC_USDT\",\"stocks\":0,\"meta\":{\"AccessKey\":\"7yngd7gh5g-a7ed9b1a-c05064c3-bab33\",\"SecretKey\":\"553c2cd1-e229e1d2-25a536cb-db7d3\"}}]\n'''\n\nimport talib as ta\nimport pandas as pd\nfrom datetime import datetime\nfrom datetime import timedelta\nimport math\n#coding:utf8\nimport sys\n\neid = -1\nlast_price = -1\n\ndef main():\n    global eid\n    global last_price\n    global ma\n\n    while True:\n\n        records = exchange.GetRecords(1*60*60)\n        e = exchange\n        kline1 = pd.DataFrame(records)\n        kline1['Time'] = kline1['Time'].map(lambda x: datetime.utcfromtimestamp(x/1000)+timedelta(hours=8))\n        kline1.columns = ['time','open','high','low','close','volume','oi']\n       \n        r = kline1\n        #Log('最新k线时间',r.iloc[-1].time, ' 最新价格收盘价', r.iloc[-1].close)\n    \n        leadLine1 = ta.EMA(r.close, 30)\n        leadLine2 = ta.SMA(r.close, 30)\n        UT=leadLine2 < leadLine1\n        DT=leadLine2 > leadLine1\n    \n        # keltner channel\n        ma  = ta.EMA(kline1.close, 80)\n        # 真实的范围函数\n        range1 = ta.TRANGE(kline1.high, kline1.low, kline1.close)\n        rangema = ta.EMA(range1, 80)\n        upper = ma + 3*rangema\n        lower = ma - 3*rangema\n       \n        # minus and plus of adx/dmi\n        minus = ta.MINUS_DI(kline1.high,kline1.low, kline1.close,14) \n        plus = ta.PLUS_DI(kline1.high, kline1.low, kline1.close ,14)\n                   \n        volume0 = r.iloc[-1].volume\n        volume1 = r.iloc[-2].volume\n        rn = r.iloc[-1]\n       \n        entry_long = rn.close > upper.iloc[-1] and (r.iloc[-1].volume+ r.iloc[-2].volume) >1.5 *(r.iloc[-4].volume+ r.iloc[-5].volume)\n        long = entry_long\n        exit_long = (rn.close < ma.iloc[-1] )\n        account = exchange.GetAccount()\n        amount = account.Stocks\n        #Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n        # 如果处于空仓状态\n        if (account['Balance'] >= 600 and amount < 0.001):\n            if long==True and account['Balance'] < 400 and amount<0.01:\n                Log('balance is ', account['Balance'], ' 余额不足400，退出！')\n                return\n            elif long== True  and account['Balance'] >= 600: #第一次开多仓\n                Log('balance is ', account['Balance'])\n                Log('多仓位时间: ', rn.time, ' open is ', rn.open , ' close is ', rn.close, ' upper is ', upper.iloc[-1], ' volume 0\\1 is', volume0 , 'volume 1 is ', volume1 , \n                ' plus is ',plus.iloc[-1], ' minus is ', minus.iloc[-1], '@')\n                exchange.Buy(-1,600)\n                last_price = rn.close + 10\n                Sleep(1000*60*15)\n        # 如果处于持仓状态\n        if  amount>0.001 :\n            if  amount > 0.0001 and rn.close <= last_price*0.94: \n                Log('止损平仓事件: ','balance is ', account['Balance'], rn.time, ' rn.close is ', rn.close, ' @')\n                id = exchange.Sell(-1, amount);\n                account = exchange.GetAccount()\n                amount = account.Stocks\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n                eid = -1\n       #如果处于一直持仓又大跌状态，才卖出\n            elif  amount > 0.0001 and rn.close >= last_price * 1.1 and rn.close <= r.iloc[-24].close*0.9:\n                Log('持仓周期内的大跌止损平仓事件: ', rn.time, ' rn.close is ', rn.close, ' @')\n                id = exchange.Sell(-1, amount);\n                eid = -1\n                account = exchange.GetAccount()\n                amount = account.Stocks\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n            elif amount > 0.0001 and exit_long == True :\n                if rn.close <= last_price:\n                    Log('位置下滑平仓位事件,亏损:  amount is ',amount ,' time is ', rn.time, ' 价格是：',rn.close,' ma is ', ma.iloc[-1], ' 开仓价格',last_price,' 亏损幅度：',100*(last_price -rn.close)/last_price ,'% @')\n                    eid = exchange.Sell(-1, amount)\n#                print(r.tail(10))\n#                print('ma is ' ,ma)\n                    account = exchange.GetAccount()\n                    amount = account.Stocks\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n                elif rn.close > last_price*1.1 :\n                    Log('超出10%盈利继续持仓')\n                    account = exchange.GetAccount()\n                    amount = account.Stocks\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n                    return \n                elif rn.close > last_price  and rn.close <=last_price*1.1:\n                    eid = exchange.Sell(-1, amount);\n                    account = exchange.GetAccount()\n                    amount = account.Stocks\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n                    Log('位置下滑平仓位事件,赚钱啦: amount is ',amount, ' time is ', rn.time, ' 价格是： ',rn.close,' ma is ', ma.iloc[-1],' 开仓价格',last_price,' 盈利幅度：',100*(rn.close-last_price )/last_price ,'% @' )\n                else:\n                    id = exchange.Sell(-1, amount);\n                    Log('最终位置下滑平仓位事件,赚钱啦: amount is ',amount, ' time is ', rn.time, ' 价格是： ',rn.close,' ma is ', ma.iloc[-1],' 开仓价格',last_price,' 盈利幅度：',100*(rn.close-last_price )/last_price ,'% @' )\n                    eid = -1\n                    account = exchange.GetAccount()\n                    amount = account.Stocks\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n            Sleep(1000*60*15)"}
{"query": "请生成一个Lbuy_Hsell-低买高卖策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2020-05-31 00:00:00\nend: 2020-08-28 00:00:00\nperiod: 1day\nexchanges: [{\"eid\":\"huobi\",\"currency\":\"BTC_USDT\"}]\n'''\n\nratio = 0.01\nacc = 0\nminStock = 0.01\n\ndef main():\n    global ratio,acc,minStock\n    exchanges[0].SetPrecision(2, 3)\n    Log('hello sltrain@')\n    #Log(exchanges[0].GetAccount())\n    tickers = _C(exchanges[0].GetTicker)\n    #Log(tickers)   \n    while(True):\n        tickers_new = _C(exchanges[0].GetTicker)\n        if tickers_new.Last > tickers.Last * (1 + ratio):\n            acc = _C(exchanges[0].GetAccount)\n            id = exchanges[0].Sell(tickers_new.Last, acc.Stocks * ratio)\n            Log(\"id:\", id)\n        elif tickers_new.Last < tickers.Last * (1 + ratio):\n            acc = _C(exchanges[0].GetAccount)\n            id = exchanges[0].Buy(tickers_new.Last, (acc.Balance * ratio)/tickers_new.Last)\n            Log(\"id:\", id)\n        if tickers_new.Last == tickers.Last:\n            continue\n        tickers = tickers_new \n        Sleep(20*60*1000)"}
{"query": "请生成一个MACD逃顶策略策略代码", "base_model_response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 定义MACD指标\nmacd = {'macd': 0, 'rsi': 25}\n\n# 连接数据框\ndf = pd.DataFrame({'date': ['2017-08-06', '2017-09-23', '2018-05-26', '2018-06-13'],\n                   'value': [50, 35, 40, 55],\n                   'color': [0, 255, 0, 0.1]})\n\n# 创建时间序列图\nplt.figure(figsize=(12, 6))\nplt.plot(df['date'], df['value'], label='Date')\nplt.plot([df['date'].idxmax(), df['date'].idxmin()], [1, -1], label='Time sequence')\nplt.xlabel('Date')\nplt.ylabel('Value')\nplt.title('MACD逃跑 strategy')\n\n# 设置时间窗口（年、月）\ndt = np.timedelta(days=365)\nfor month in range(1, dt):\n    for day in range(day, 365):\n        if month == 1 or day == 365:\n            continue\n        if month == 7 and day == 365:\n            day -= 7 * dt\n            while (df.month == month and df.day >= day) and (df.day <= day + 365):\n                break\n        elif month < 7:\n            day += 7 * dt\n        df['data'].append(df.values[day])\n    \n# 假设我们有一个每日的交易量，即每天买入和卖出的交易金额\ndaily_spent = []\n\n# 将每日的交易量用CSV文件保存\ndaily_spent.to_csv('daily_spent.csv', index=False)\n\n# 绘制每日交易量分布情况，以防止数据丢失\nplt.bar(daily_spent.index, daily_spent.values)\nplt.xlabel('Daily transaction amount')\nplt.ylabel('Frequency')\nplt.title('Daily trading volume distribution')\nplt.show()\n\n# 每日移动平均线\nma = ma[::]\n\n# 如果MacD模型运行在安全边界，则没有逃顶迹象\nif ma.close > ma.max()[::-1]:\n    print('MACD model not safe to run')\nelse:\n    # 根据当前价格进行操作\n    df['new_value'] = df['value'].apply(lambda x: x * x - maclose)\n    df['new_date'] = df['date'].apply(lambda x: datetime.date(x.year, x.month, x.day))\n\n# 绘制新的交易量分布情况\nplt.bar(df['new_date'], df['new_value'])\nplt.xlabel('New date')\nplt.ylabel('Value')\nplt.title('New trading volume distribution')\nplt.show()\n```\n\n这个策略使用了MACD指标来预测未来的市场走势，并通过设置时间窗口和移动平均线来检测信号。它假设了每个交易都是独立的，但实际情况下可能会影响到其他指标的变化。\n\n注意：这段代码只是一个基本的例子，实际应用时需要根据自己的具体需求进行调整。", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2023-01-01 00:00:00\nend: 2023-05-12 00:00:00\nperiod: 1d\nbasePeriod: 1h\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\",\"stocks\":10}]\n'''\n\n\n# from matplotlib import pyplot as plt\n# plt.figure()\n\nclass ExitTop(object):\n    def __init__(self,index):\n        self.index = index \n        self.totestlist = [] # MACD数据\n        self.klist = [] # k线数据\n        self.toplus = []\n        self.tocpn = []\n        self.Sell = False\n    \n    # 获取k线及MACD数据\n    def GetRecord(self) -> bool:\n        self.totestlist = []\n        self.klist = []\n        self.toplus = []\n        self.tocpn = []\n        records = exchanges[self.index].GetRecords()\n        macd = TA.MACD(records, 12, 26, 9)\n        # 判断DIF是否大于DEA\n        if not macd[0][-2] > macd[1][-2] and macd[0][-3] < macd[1][-3] or not macd[0][-2] > macd[1][-2] and macd[0][-4] < macd[1][-4]:\n            return False\n        self.totestlist = macd[0][len(macd[0])-80:]\n        # 封装k线数据\n        for get in range(len(records)):\n            self.klist.append(records[get][\"Close\"])\n        self.klist = self.klist[len(self.klist)-80:]\n        return True\n    \n    def mepath(self):\n        if not self.GetRecord():\n            return False\n        # 向前遍历发现最大值\n        maxsign = -1000000000000\n        for i in range(len(self.totestlist)-1,-1,-1):\n            if self.totestlist[i] > maxsign:\n                maxsign = self.totestlist[i]\n                self.tocpn.append([1,i])\n            else:\n                if len(self.tocpn) > 0:\n                    self.tocpn[-1][0] = self.tocpn[-1][0]+1\n            self.toplus.insert(0,maxsign)\n        sign = False\n        shorttime = [0,0] # 步长 , 索引\n        for i in range(len(self.tocpn)):\n            if self.tocpn[i][0] > 15 and sign == False:\n                shorttime = [self.tocpn[i][0],self.tocpn[i][1]]\n                sign = True\n        # 如果最大索引不是自己\n        if shorttime[1] < len(self.klist)-4:\n            # 锁定区域内最高价格\n            are = max(self.klist[shorttime[1]:-4])\n            # 判断是否存在大于当前macd值,如果当前价格大于区域内最高价格\n            if self.totestlist[-2]+300 < self.totestlist[shorttime[1]] and self.klist[-2] >= are:\n                return True\n            return False\n        return False\n    \n    def main(self):\n        result = self.mepath()\n        if result == True and self.Sell == False:\n            exchanges[self.index].Sell(-1, num)\n            self.Sell = True\n        elif result == False:\n            if self.Sell == True:\n                self.Sell = False\n        # plt.plot(self.totestlist)\n        # plt.plot(self.toplus)\n        # LogStatus(plt)\n\n\ndef main():\n    transaction = []\n    for index in range(len(exchanges)):\n        transaction.append(ExitTop(index))\n    while True:\n        for tran in range(len(transaction)):\n            transaction[tran].main()\n            Sleep(1000*60)"}
{"query": "请生成一个OKEX-V5-K线数据分页查询例子-Python版策略代码", "base_model_response": "```python\nimport requests\nfrom bs4 import BeautifulSoup\n\nclass OkexV5KLineQueryTask:\n    def __init__(self, url):\n        self.url = url\n\n    def process(self, response):\n        data = response.json()\n\n        for k in data['k']:\n            line = k.split('-')\n\n            if len(line) > 2:\n                url += f\"{line[0]}-{line[-1]}\"\n                break\n\n        return {\"status\": 200, \"url\": url}\n\ndef main():\n    url = \"https://okexapi.com/v5/klines/price?symbol=OKX&params={}&size=5\"\n    task = OkexV5KLineQueryTask(url)\n    response = request.get(task.url)\n\n    if not response.status_code == 200:\n        print(\"Error: \", response.text)\n\n    print(\"\\nOkex V5 K线数据分页查询结果如下:\")\n    for i in range(len(response.data)):\n        result = response.data[i]\n        print(f\"{i+1}. {result['open']}, {result['close']}, {result['high']}, {result['low']}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n请注意，这只是一个基础的示例。在实际使用中，你需要处理更多的错误情况，例如URL不可用、API未返回等。\n\n此外，你还需要安装requests库和BeautifulSoup库才能运行这个程序。如果你还没有安装这些库，请使用以下命令进行安装：\n\n```bash\npip install requests\npip install beautifulsoup4\n```\n\n最后，在运行这段代码之前，确保你的系统已经设置了访问 Okex API 的权限，并且你可以访问到它。", "lora_model_response": "", "original_response": "js\nfunction main() {\n    // 访问接口获取数据\n    var r = GetRecords(\"ETH-USDT-SWAP\", \"1H\")   // 例如获取ETH U本位永续合约的1小时K线数据\n\n    // 输出数据\n    Log(\"K线数据：\", r)\n    Log(\"K线数据数量：\", r.length)\n\n    // 画图输出\n    $.PlotRecords(r, \"K\")\n\n    // 简单验证\n    for (var i = 0 ; i < r.length - 1 ; i++) {\n        if (r[i + 1].Time - r[i].Time != 1000 * 60 * 60) {\n            Log(_D(r[i + 1].Time), _D(r[i].Time), r[i + 1].Time - r[i].Time)\n        }\n    }\n}\n\n# ==========================================\n\npython\nimport json\nimport urllib.request\n\ndef encodeParams(params):\n    ret = \"\"\n    index = 0 \n    for key in params:\n        if index == 0:\n            ret += key + \"=\" + str(params[key])\n        else :\n            ret += \"&\" + key + \"=\" + str(params[key])\n        index += 1\n    return ret \n\ndef GetRecords(symbol, period):\n    arr = []\n    after = 0\n    while True:\n        params = {\n            \"instId\": symbol,\n            \"bar\": period,\n            \"limit\": 100,\n        }\n        if after != 0 :\n            params[\"after\"] = after\n        query = encodeParams(params)        \n        try :\n            headers = {\n                'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\n                'Accept-Language':'zh-CN,zh;q=0.9',\n                'Connection':'keep-alive',\n                'Cookie':'uuid_tt_dd=10_35489889920-1563497330616-876822; ...... ',\n                'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'\n            }           \n\n            url = \"https://www.okex.com/api/v5/market/candles?\" + query\n            req = urllib.request.Request(url=url,headers=headers)\n            r = json.loads(urllib.request.urlopen(req).read().decode('utf-8'))[\"data\"]\n            for i in range(len(r)):\n                record = {}\n                record[\"Time\"] = int(r[i][0])\n                record[\"High\"] = float(r[i][2])\n                record[\"Open\"] = float(r[i][1])\n                record[\"Low\"] = float(r[i][3])\n                record[\"Close\"] = float(r[i][4])\n                record[\"Volume\"] = float(r[i][5])\n                arr.append(record)\n                after = record[\"Time\"]\n            if len(arr) >= 1440 or len(r) == 0:\n                break\n        except Exception as e:\n            Log(e)\n            return \n        Sleep(1000)\n    arr.reverse()    \n    return arr \n    \ndef main():\n    r = GetRecords(\"ETH-USDT-SWAP\", \"1H\")\n    \n    Log(\"K线数据：\", r)\n    Log(\"K线数据数量：\", len(r))\n    \n    ext.PlotRecords(r, \"K\")\n    \n    for i in range(len(r) - 1):\n        if r[i + 1][\"Time\"] - r[i][\"Time\"] != 1000 * 60 * 60:\n            Log(_D(r[i + 1][\"Time\"] / 1000), _D(r[i][\"Time\"] / 1000), r[i + 1][\"Time\"] - r[i][\"Time\"])"}
{"query": "请生成一个OKX部分交易封装示例策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!/usr/bin/python\n# coding=UTF-8\n\nimport hmac\nimport base64\nimport urllib\nfrom hashlib import sha256\nimport datetime\nimport json\nimport requests\nfrom logger import logger\n\n\nclass Okex(object):\n\n    def __init__(self, api_key, secret_key, passphrase):\n        self.api_key = api_key\n        self.secret_key = secret_key\n        self.passphrase = passphrase\n        self.host = 'https://www.okex.com'\n        self.timestamp = ''\n        self.method = ''\n        self.request_path = ''\n\n    # 下单\n    def trade_order(self, symbol, pos_side, trade_side, sz, client_id, ord_type=\"market\", px=None):\n        self.request_path = '/api/v5/trade/order'\n        self.method = 'POST'\n        inst_id = symbol.upper() + '-USDT-SWAP'\n        post_data = {\n            'instId': inst_id,\n            'tdMode': 'cross',\n            'side': trade_side,\n            'ordType': ord_type,\n            'posSide': pos_side,\n            'sz': str(sz),\n            'tag': 'BrokerCode',\n            'clOrdId': '4dc650bdb59cBCDE' + str(client_id)\n        }\n        if ord_type == 'limit':\n            post_data['px'] = str(px)\n        try:\n            # 0 成功 1暂停几秒 2忽略此次交易 3 用户停止策略\n            order = self.send(post_data)\n            # print(order)\n            if len(order['data']) == 0:\n                return {\"code\": 2, \"msg\": 'OKEX下单接口返回数据错误', \"data\": {}}\n            order_info = order['data'][0]\n            if order['code'] == '0' and order_info['sCode'] == '0':\n                return {\"code\": 0, \"msg\": 'success', \"data\": order_info}\n\n            if order_info['sCode'] == '50004' or order_info['sCode'] == '51029' or order_info['sCode'] == '51030':\n                #  失败, 稍后可重试\n                return {\"code\": 1, \"msg\": order_info['sMsg'], \"data\": {}}\n            if order_info['sCode'] == '51008':\n                # 失败, 暂停买入\n                return {\"code\": 3, \"msg\": order_info['sMsg'], \"data\": {}}\n        except Exception as e:\n            return {\"code\": 2, \"msg\": str(e), \"data\": {}}\n        # 失败, 暂停运行\n        return {\"code\": 2, \"msg\": order_info['sMsg'], \"data\": {}}\n\n    # 撤单\n    def cancel_order(self, data):\n        self.request_path = '/api/v5/trade/cancel-batch-orders'\n        self.method = 'POST'\n        try:\n            order = self.send(data)\n            if len(order['data']) == 0:\n                return {\"code\": 3, \"msg\": 'OKEX撤单接口返回数据错误', \"data\": {}}\n            if order['code'] == '0':\n                return {\"code\": 0, \"msg\": 'success', \"data\": order}\n\n        except Exception as e:\n            # logger.error(e)\n            return {\"code\": 3, \"msg\": str(e), \"data\": {}}\n        # 失败, 暂停运行\n        return {\"code\": 3, \"msg\": order['msg'], \"data\": {}}\n\n    # 获取挂单列表\n    def get_open_order(self):\n        self.request_path = '/api/v5/trade/orders-pending'\n        self.method = 'GET'\n        post_data = {\n            'instType': 'SWAP',\n        }\n        order = self.send(post_data)\n        if order['code'] != '0':\n            raise ValueError(order['msg'])\n        return order['data']\n\n    # 获取持仓列表\n    def get_positions(self, symbol=None):\n        self.request_path = '/api/v5/account/positions'\n        self.method = 'GET'\n        post_data = {\n            'instType': 'SWAP',\n        }\n        if symbol:\n            post_data['instId'] = symbol.upper() + '-USDT-SWAP'\n\n        order = self.send(post_data)\n        if order['code'] != '0':\n            raise ValueError(order['msg'])\n        return order['data']\n\n    # 获取k线\n    def get_kline(self, symbol, limit, interval, after=None):\n        self.request_path = '/api/v5/market/history-candles'\n        self.method = 'GET'\n\n        post_data = {\n            'instId': symbol.upper() + '-USDT-SWAP',\n            'bar': interval,\n            'limit': limit,\n        }\n        if after:\n            post_data['after'] = after\n        order = self.send(post_data)\n        if order['code'] != '0':\n            raise ValueError(order['msg'])\n        return order['data']\n\n    # 签名\n    def generate_sign(self, data):\n        if self.method == 'GET':\n            self.request_path = self.request_path + '?' + urllib.parse.urlencode(data)\n        req_str = self.timestamp + self.method + self.request_path\n\n        if self.method == 'POST':\n            req_str = (req_str + json.dumps(data))\n\n        req_strs = req_str.encode('utf-8')\n        signature = base64.b64encode(hmac.new(self.secret_key.encode('utf-8'), req_strs, digestmod=sha256).digest())\n        return signature\n\n    # 时间戳\n    def set_timestamp(self):\n        utc_t = datetime.datetime.utcnow().isoformat()\n        self.timestamp = utc_t[:-3] + 'Z'\n\n    # 请求\n    def send(self, data):\n        self.set_timestamp()\n        headers = {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json',\n            'OK-ACCESS-KEY': self.api_key,\n            'OK-ACCESS-SIGN': self.generate_sign(data),\n            'OK-ACCESS-TIMESTAMP': self.timestamp,\n            'OK-ACCESS-PASSPHRASE': self.passphrase,\n        }\n        if self.method == 'GET':\n            response = requests.get(self.host + self.request_path, headers=headers, timeout=30)\n        else:\n            post_data = json.dumps(data)\n            response = requests.post(self.host + self.request_path, headers=headers, data=post_data, timeout=30)\n        # logger.info('okex请求信息')\n        # logger.info(data)\n        # logger.info(response.text)\n        return json.loads(response.text)"}
{"query": "请生成一个OkEX-Websocket-Realtime-v3策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n# \n# Market Real-time Subscription v3\n#\n# Copyright 2019 FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\n\nimport time\nimport ssl\nimport sys\nimport code\nimport json\nimport hashlib\nimport hmac\nimport urllib\nimport threading\nimport websocket\nimport zlib\nimport string\n\ntry:\n    import readline\nexcept ImportError:\n    pass\n\npong = time.time()\n\nclass WSSubscription:\n\n    def __init__(self, instrument_id='BTC-USD-190517', market='futures', on_message=None):\n        self.__iid = instrument_id\n        self.__market = market\n        self.__Depth = {}\n        \n        if on_message is not None:\n            self.__callbackEnabled = True\n            self.__callback = on_message\n        else:\n            self.__callbackEnabled = False\n\n        thread = threading.Thread(target=self.sub, args=())\n        thread.daemon = True\n        thread.start()\n\n    def GetDepth(self):\n        return self.__Depth\n\n    def subscribe(self, ws):\n        \n        def operator(op, args):\n            message = {\n                'op': op,\n                'args': args\n            }\n            ws.send(json.dumps(message))\n\n        def run(*args):\n            operator('subscribe', ['%s/depth5:%s' % (self.__market, self.__iid)])\n            operator('subscribe', ['%s/trade:%s' % (self.__market, self.__iid)])\n\n            while True:\n                ws.send(\"ping\")\n                time.sleep(30)\n\n        threading.Thread(target=run).start()\n\n    def sub(self):\n\n        websocket.enableTrace(False)\n        URL = \"wss://real.okex.com:10442/ws/v3\"\n        ws = websocket.WebSocketApp(URL,\n                                    on_message=self.incoming,\n                                    on_error=self.error_handling,\n                                    on_close=self.closing)\n\n        ws.on_open = self.subscribe\n\n        while True:\n            try:\n                ws.run_forever()\n            except:\n                pass\n\n        pass\n\n    def incoming(self,ws,message):\n        message = zlib.decompress(message, -zlib.MAX_WBITS)\n        message = message.decode('utf-8')\n        global pong\n        if 'pong' in message:\n            pong = time.time()\n        if 'asks' in message and 'bids' in message:\n            d = json.loads(message)\n            self.__Depth = d['data'][0]\n            \n        if self.__callbackEnabled:\n            self.__callback(message)\n    \n\n    def error_handling(self,ws,error):\n        print(str(error))\n\n    def closing(self,ws):\n        print(\"WebSocket Closing...\")\n        \next.OkEXWS = WSSubscription\n\n# 模块测试\ndef main():\n    OkEX = ext.OkEXWS('BTC-USD-190517', 'futures')\n    while (True):\n        Log(OkEX.GetDepth())\n        time.sleep(1)"}
{"query": "请生成一个OkEX-高级API功能-V110-期货批量下单现货TBD-Python2-3策略代码", "base_model_response": "", "lora_model_response": "好的，你已经准备好了。为了更好地帮助你完成任务，请将以下内容粘贴到对话框中。", "original_response": "python\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n# OkEX Advanced API Interface for FMZ.com.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# GNU General Public License v3.0\n#\n\nimport json\nimport time\n\nQUOTES = {}\nQUOTES['ZH'] = {\n    'GREET' : '[OkEX 接口已初始化]  币种: %s 合约: %s. %s',\n    'INITF' : '使用的交易所不正确，当前交易所: %s',\n    'PARAMERR' : '***传的参数不对 检查你的代码*** %s',\n    'NEWORDER' : '[添加订单]  币种: %s 合约: %s 方向: %s 价格: %.4f 数量: %d 张. %s',\n    'ORDCOUNT' : '[本次批量发送订单]  总计: %d 条. %s',\n    'THISBATCH' : '[信息]  正在处理 币种: %s 合约: %s 条数: %d. %s',\n    'ORDSENT' : '[已发送订单]  币种: %s 合约: %s 条数: %d. %s',\n    'NEEDSPLIT' : '[信息]  由于单合约单量大于5条 需要进行分片处理. %s',\n    'CLEARALL' : '[信息]  已清除所有本地订单. %s',\n    'CLEARS' : '[信息]  已清除所有 %s 本地订单. %s',\n    'CLEAR' : '[信息]  已清除所有 %s %s 本地订单. %s'\n}\n\nCOLORS = {\n    'DEEPBLUE' : '#1F618D',\n    'BLUE' : '#0000FF',\n    'LIGHTBLUE' : '#5DADE2',\n    'DEEPGREEN' : '#27AE60',\n    'GREEN' : '#00FF00',\n    'LIGHTGREEN' : '#58D68D',\n    'LAPIS' : '#26619C',\n    'DEEPRED' : '#CB4335',\n    'RED' : '#FF0000',\n    'LIGHTRED' : '#EC7063'\n}\n\n\nclass OkEXFuture:\n\n    def __init__(self, exchange, future='this_week'):\n        self.QUOTES = {}\n        exchange.GetCurrency()\n        if isinstance(exchange.GetCurrency(), bytes):\n            self.symbol = str(exchange.GetCurrency(), \"utf-8\").lower()\n            name = str(exchange.GetName(), \"utf-8\")\n        else:\n            self.symbol = exchange.GetCurrency()\n            name = exchange.GetName()\n        self.IO = exchange.IO\n        self.future = future\n        self.bulks = {}\n        self.bulks[self.symbol] = {}\n        self.bulks[self.symbol][self.future] = []\n        if 'OKCoin' in str(name):\n            Log(QUOTES[LANG]['GREET'] % (self.symbol.upper(),self.future.upper(),COLORS['LAPIS']))\n        else:\n            Log(QUOTES[LANG]['INITF'] % (name))\n\n    def BulkAdd(self, side=None, price=None, amount=None, matchPrice=False, symbol=None, future=None):\n        if type is None or price is None or amount is None:\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n            return False\n        side = side.lower()\n        if side == 'buy':\n            tp = 1\n            cl = COLORS['DEEPGREEN']\n        if side == 'sell':\n            tp = 2\n            cl = COLORS['DEEPRED']\n        if side == 'closebuy':\n            tp = 3\n            cl = COLORS['LIGHTRED']\n        if side == 'closesell':\n            tp = 4\n            cl = COLORS['LIGHTGREEN']\n        if symbol is None:\n            symbol = self.symbol\n        if future is None:\n            future = self.future\n\n        order = {}\n        order['price'] = price\n        order['amount'] = amount\n        order['type'] = tp\n\n        if matchPrice:\n            order['matchPrice'] = 1\n\n        try:\n            self.bulks[symbol]\n        except KeyError:\n            self.bulks[symbol] = {}\n        try:\n            self.bulks[symbol][future]\n        except KeyError:\n            self.bulks[symbol][future] = []\n\n        self.bulks[symbol][future].append(order)\n\n        Log(QUOTES[LANG]['NEWORDER'] % (symbol.upper(),future.upper(),side.upper(),price,amount,cl))\n\n        return True\n\n    def BulkOrders(self, symbol=None, future=None):\n        if symbol is None:\n            return self.bulks\n        else:\n            if future is None:\n                return self.bulks[symbol]\n            else:\n                return self.bulks[symbol][future]\n\n    def BulkClear(self, symbol=None, future=None, notify=True):\n        if symbol is None:\n            self.bulks = {}\n            if notify:\n                Log(QUOTES[LANG]['CLEARALL'] % (COLORS['RED']))\n        else:\n            if future is None:\n                self.bulks[symbol] = {}\n                if notify:\n                     Log(QUOTES[LANG]['CLEARS'] % (symbol.encode().upper(), COLORS['RED']))\n            else:\n                self.bulks[symbol][future] = []\n                if notify:\n                    Log(QUOTES[LANG]['CLEAR'] % (symbol.encode().upper(), future.encode().upper(), COLORS['RED']))\n                    #Log(QUOTES[LANG]['CLEAR'] % (symbol.upper(), future.upper(), COLORS['RED']))\n\n        return True\n\n    #exchange.IO(\"api\", \"POST\", \"/api/v1/future_batch_trade.do\", \"symbol=etc_usd&contract_type=this_week&orders_data=\"+json.dumps(orders))\n    def __post(self, symbol='', future=''):\n        count = len(self.bulks[symbol][future])\n        orders = self.bulks[symbol][future]\n        ret = []\n        if count == 0:\n            return\n        Log(QUOTES[LANG]['THISBATCH'] % (symbol.upper(),future.upper(),count,COLORS['LAPIS']))\n        if count <= 5:\n            params = 'symbol=%s&contract_type=%s&orders_data=%s' % (symbol, future, json.dumps(orders))\n            res = self.IO(\"api\", \"POST\", \"/api/v1/future_batch_trade.do\", params)\n            ret+=res['order_info']\n            Log(QUOTES[LANG]['ORDSENT'] % (symbol.upper(),future.upper(),len(orders),COLORS['LAPIS']))\n        if count > 5:\n            Log(QUOTES[LANG]['NEEDSPLIT'] % (COLORS['LAPIS']))\n            batch = []\n            for item in orders:\n                batch.append(item)\n                if len(batch) == 5:\n                    params = 'symbol=%s&contract_type=%s&orders_data=%s' % (symbol, future, json.dumps(batch))\n                    res = self.IO(\"api\", \"POST\", \"/api/v1/future_batch_trade.do\", params)\n                    try:\n                        ret+=res['order_info']\n                    except:\n                        pass\n                    Log(QUOTES[LANG]['ORDSENT'] % (symbol.upper(),future.upper(),len(batch),COLORS['LAPIS']))\n                    batch = []\n                    time.sleep(0.3)               # OkEX限制每秒只能进行三个请求\n\n            params = 'symbol=%s&contract_type=%s&orders_data=%s' % (symbol, future, json.dumps(batch))\n            res = self.IO(\"api\", \"POST\", \"/api/v1/future_batch_trade.do\", params)\n            try:\n                ret+=res['order_info']\n            except:\n                pass\n            Log(QUOTES[LANG]['ORDSENT'] % (symbol.upper(),future.upper(),len(batch),COLORS['LAPIS']))\n\n        return ret\n\n    def BulkPost(self, symbol=None, future=None):\n        ret = []\n        count = 0\n        if symbol is None:\n            symbols = self.bulks.keys()\n            for s in symbols:\n                futures = self.bulks[s].keys()\n                for f in futures:\n                    count+=len(self.bulks[s][f])\n                    ret+=self.__post(s, f)\n                    time.sleep(0.3)               # OkEX限制每秒只能进行三个请求\n\n            self.BulkClear(notify=False)\n        else:\n            if future is None:\n                futures = self.bulks[symbol].keys()\n                for f in futures:\n                    count+=len(self.bulks[symbol][f])\n                    ret+=self.__post(symbol, f)\n                    time.sleep(0.3)               # OkEX限制每秒只能进行三个请求\n\n                self.BulkClear(symbol=symbol, notify=False)\n            else:\n                count+=len(self.bulks[symbol][future])\n                ret+=self.__post(symbol, future)\n\n                self.BulkClear(symbol=symbol, future=future, notify=False)\n\n        Log(QUOTES[LANG]['ORDCOUNT'] % (count,COLORS['LAPIS']))\n        return ret\n\nclass OkEXSpot:\n\n    def __init__(self, exchange):\n        self.IO = exchange.IO\n\n    #TBD\n\next.OkEXFuturePlus = OkEXFuture # 导出OkEXFuture Class, 主策略可以通过FuturePlus = ext.OkEXFuturePlus(exchange, future)调用\next.OkEXSpotPlus = OkEXSpot # 导出OkEXSpot Class, 主策略可以通过SpotPlus = ext.OkEXSpotPlus(exchange)调用\n\n# 模块功能测试\ndef main():\n    LogReset()\n    Log(exchange.GetAccount())\n    OKEXPlus = ext.OkEXFuturePlus(exchange)\n    # 4 Buy 2 Sell 1 next_week\n    base_price = exchange.GetTicker()['Last']\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"closebuy\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.3, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.7, 1, future='next_week')\n\n    OKEXPlus.BulkClear()\n\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.8, 1)\n    OKEXPlus.BulkAdd(\"closebuy\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.3, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.7, 1, future='next_week')\n\n    OKEXPlus.BulkClear(symbol=(exchange.GetCurrency()).lower(),future='this_week')\n    OKEXPlus.BulkClear(symbol=(exchange.GetCurrency()).lower(),future='next_week')\n\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.8, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.7, 1, future='next_week')\n    OKEXPlus.BulkClear(symbol=(exchange.GetCurrency()).lower())\n\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.8, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.81, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.82, 1)\n    OKEXPlus.BulkAdd(\"closesell\", base_price*0.8, 1)\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"closebuy\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.3, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.7, 1, future='next_week')\n\n    Log(OKEXPlus.BulkOrders())\n    for item in OKEXPlus.BulkPost():\n        Log(str(item))\n    Log(OKEXPlus.BulkOrders())"}
{"query": "请生成一个OkEX合约-仓位管理系统策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n\nimport time\nimport math\nimport threading\nimport decimal\nfrom uuid import uuid4 as _uuid\n\ndef genUUID():\n    return str(_uuid())\n\nclass PositionManager:\n\n    def __init__(self, exchange, symbol, contract, getDepth, tickSize=0.01):\n        self.okex = exchange\n        self.symbol = symbol\n        self.contract = contract\n        self.tickSize = tickSize\n        self.isFMZ = False\n        if 'Asks' in getDepth().keys():\n            self.isFMZ = True\n        self.okexGetDepth = getDepth\n        self.orderLock = threading.Lock()\n        self.orderLocks = {}\n        self.orders = {}\n        self.cancels = []\n        self.completeds = []\n        self.init()\n\n    def init(self):\n        self.okex.IO(\"currency\", self.symbol.upper())\n        self.okex.SetContractType(self.contract)\n        self.order_logs = {\n            'buySent': 0,\n            'buyCanceled': 0,\n            'sellSent': 0,\n            'sellCanceled': 0\n        }\n\n    def toNearest(self, num):\n        tickDec = decimal.Decimal(str(self.tickSize))\n        return float((decimal.Decimal(round(num / self.tickSize, 0)) * tickDec))\n\n    def getDepth(self):\n        depth = self.okexGetDepth()\n        if self.isFMZ:\n            depth['asks'] = [[x['Price'], x['Amount']] for x in depth['Asks']]\n            depth['bids'] = [[x['Price'], x['Amount']] for x in depth['Bids']]\n        return depth\n\n    def getOrderLogs(self):\n        return self.order_logs\n\n    def getBestPrices(self):\n        bestPrices = {}\n        depth = self.getDepth()\n        ask, bid = depth['asks'][0][0], depth['bids'][0][0]\n        spread = ask - bid\n        if spread <= self.tickSize*2:\n            bestPrices['ask'] = ask\n            bestPrices['bid'] = bid\n        elif spread <= self.tickSize*6:\n            bestPrices['ask'] = ask-self.tickSize\n            bestPrices['bid'] = bid+self.tickSize\n        elif spread >= self.tickSize*20:\n            bestPrices['ask'] = ask-self.tickSize*5\n            bestPrices['bid'] = bid+self.tickSize*5\n        else:\n            midPrice = self.toNearest((ask+bid)/2)\n            bestPrices['ask'] = midPrice+self.tickSize*2\n            bestPrices['bid'] = midPrice-self.tickSize*2\n        return {\n            'ask': self.toNearest(bestPrices['ask']),\n            'bid': self.toNearest(bestPrices['bid'])\n        }\n\n    def getPositions(self, noRetry=False, maxRetries=10):\n        if noRetry:\n            return self.okex.GetPosition()\n        attempts = 0\n        while True:\n            time.sleep(0.4)\n            positions = self.okex.GetPosition()\n            attempts+=1\n            if len(positions) != 0:\n                return positions\n            if attempts == maxRetries:\n                return False\n\n    def havePosition(self, type=None, noRetry=True, maxRetries=10):\n        positions = self.getPositions(noRetry=True)\n        if not positions:\n            positions = []\n        if type == None:\n            pass\n        elif type == 'buy':\n            key = 'buy_amount'\n        elif type == 'sell':\n            key = 'sell_amount'\n        for position in positions:\n            if type is not None:\n                if position['Info'][key] != 0:\n                    return positions\n            else:\n                return positions\n        if noRetry:\n            return False\n        attempts = 0\n        while True:\n            time.sleep(0.4)\n            positions = self.getPositions(noRetry=True)\n            if not positions:\n                positions = []\n            attempts+=1\n            for position in positions:\n                if type is not None:\n                    if position['Info'][key] != 0:\n                        return positions\n                else:\n                    return positions\n            if attempts == maxRetries:\n                return False\n\n    def orderDone(self, orderID):\n        orders = self.okex.GetOrders()\n        for order in orders:\n            if order['Info']['order_id'] == orderID:\n                return order['Info']['price'], order['Info']['amount']-order['Info']['deal_amount']\n        return True\n\n    def getOrder(self, uuid):\n        try:\n            self.orders[uuid]\n        except KeyError:\n            Log('不存在订单 %s' % uuid)\n            return 0\n        return self.orders[uuid]\n\n    def getOrderInfo(self, uuid):\n        return self.okex.GetOrder(self.getOrder(uuid))\n\n    def awaitOrder(self, uuid, timeout=None):\n        start = time.time()\n        try:\n            self.orderLocks[uuid]\n        except KeyError:\n            return False\n        while True:\n            if self.orderLocks[uuid].acquire(False):\n                del self.orderLocks[uuid]\n                return self.getOrder(uuid)\n            else:\n                if timeout is not None:\n                    if time.time()-timeout>start:\n                        Log('等待订单成交已超时.')\n                        return\n            time.sleep(0.001)\n\n    def isDone(self, uuid):\n        if uuid in self.completeds:\n            return True\n        return False\n\n    def cancel(self, uuid):\n        self.cancels.append(uuid)\n        _cancel = self.okex.CancelOrder(self.getOrder(uuid))\n        self.orderLocks[uuid].acquire()\n        self.orderLocks[uuid].release()\n        if _cancel:\n            Log(uuid, str(self.getOrder(uuid)), '已取消.')\n            return True\n        Log(uuid, str(self.getOrder(uuid)), '取消失败.', str(self.okex.GetRawJSON()))\n        return False\n\n    def trade(self, type, price, amount, matchPrice=False, noRetry=False, uuid=None):\n        if type == 'buy' or type == 'closesell':\n            _trader = self.okex.Buy\n            _side = 'buy'\n            __side = 'bid'\n        else:\n            _trader = self.okex.Sell\n            _side = 'sell'\n            __side = 'ask'\n        def trader(price, amount):\n            self.orderLock.acquire()\n            self.okex.SetDirection(type)\n            order = _trader(price, amount)\n            self.orders[uuid] = order\n            self.orderLock.release()\n            self.order_logs['%sSent' % _side]+=1\n            return order\n        def isBestPrice(currentPrice, depth):\n            ret = False\n            if _side == 'buy':\n                if currentPrice > depth['bids'][1][0]:\n                    ret = True\n            else:\n                if currentPrice < depth['asks'][1][0]:\n                    ret = True\n            return ret\n        if price is None:\n            price = self.getBestPrices()[__side]\n        if matchPrice:\n            price = -1\n        order = trader(price, amount)\n        if noRetry:\n            self.completeds.append(uuid)\n            self.orderLocks[uuid].release()\n            return\n        if order == False:\n            if 20016 in str(self.okex.GetRawJSON()):\n                order = trader(price, amount)\n            if order == False:\n                Log('%s 返回值: %s', (uuid, str(self.okex.GetRawJSON())))\n                self.completeds.append(uuid)\n                self.orderLocks[uuid].release()\n                return\n        time.sleep(1)\n        while True:\n            if uuid in self.cancels:\n                Log('%s 已停止下单尝试.' % uuid)\n                self.completeds.append(uuid)\n                self.orderLocks[uuid].release()\n                return\n            time.sleep(1)\n            depth = self.getDepth()\n            isDone = self.orderDone(order)\n            if isDone == True:\n                self.completeds.append(uuid)\n                self.orderLocks[uuid].release()\n                return\n            if isBestPrice(isDone[0], depth):\n                continue\n            if not self.okex.CancelOrder(order):\n                time.sleep(1)\n                if self.orderDone(order):\n                    self.completeds.append(uuid)\n                    self.orderLocks[uuid].release()\n                    return\n            self.order_logs['%sCanceled' % _side]+=1\n            time.sleep(1)\n            if price != -1:\n                price = self.getBestPrices()[__side]\n            if uuid in self.cancels:\n                Log('%s 已停止下单尝试.' % uuid)\n                self.completeds.append(uuid)\n                self.orderLocks[uuid].release()\n                return\n            order = trader(price, isDone[1])\n\n    def openLong(self, amount, price=None, matchPrice=False, noRetry=False):\n        uuid = genUUID()\n        Log('%s 买入做多 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'buy',\n                                                        'price': price,\n                                                        'amount': amount,\n                                                        'matchPrice': matchPrice,\n                                                        'noRetry': noRetry,\n                                                        'uuid': uuid}), daemon=True).start()\n        self.orderLocks[uuid] = threading.Lock()\n        self.orderLocks[uuid].acquire()\n        return uuid\n\n    def openShort(self, amount, price=None, matchPrice=False, noRetry=False):\n        uuid = genUUID()\n        Log('%s 卖出做空 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'sell',\n                                                        'price': price,\n                                                        'amount': amount,\n                                                        'matchPrice': matchPrice,\n                                                        'noRetry': noRetry,\n                                                        'uuid': uuid}), daemon=True).start()\n        self.orderLocks[uuid] = threading.Lock()\n        self.orderLocks[uuid].acquire()\n        return uuid\n\n    def coverLong(self, amount, price=None, matchPrice=False, noRetry=False):\n        uuid = genUUID()\n        Log('%s 卖出平多 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'closebuy',\n                                                        'price': price,\n                                                        'amount': amount,\n                                                        'matchPrice': matchPrice,\n                                                        'noRetry': noRetry,\n                                                        'uuid': uuid}), daemon=True).start()\n        self.orderLocks[uuid] = threading.Lock()\n        self.orderLocks[uuid].acquire()\n        return uuid\n\n    def coverShort(self, amount, price=None, matchPrice=False, noRetry=False):\n        uuid = genUUID()\n        Log('%s 买入平空 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'closesell',\n                                                        'price': price,\n                                                        'amount': amount,\n                                                        'matchPrice': matchPrice,\n                                                        'noRetry': noRetry,\n                                                        'uuid': uuid}), daemon=True).start()\n        self.orderLocks[uuid] = threading.Lock()\n        self.orderLocks[uuid].acquire()\n        return uuid\n\next.okexPositionManager = PositionManager"}
{"query": "请生成一个Paul-The-Gambler-Lévy-Gold-Edition策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n#  Paul \"The Gambler\" Lévy.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\nimport random\nimport talib\nimport numpy as np\nfrom math import *\n\nAccount = {}\nTicker = {}\nRecords = {}\nLPosition = 0\nSPosition = 0\nPositions = {}\nTotalLoss = 0\nTotalWin = 0\nFullLoss = 0\nMaxPosition = 0\nTotalLongs = 0\nTotalShorts = 0\n\ndef cancelAllOrders():\n    orders = exchange.GetOrders()\n    for order in orders:\n        exchange.CancelOrder(order['Id'], order)\n    return True\n\ndef updateMarket():\n    global Ticker\n    global Records\n\n    Ticker = exchange.GetTicker()\n    Records = exchange.GetRecords()\n\n    return True\n\ndef getTAFormat(Records):\n    Close = []\n    for item in Records:\n        Close.append(item['Close'])\n\n    return np.array(Close)\n\ndef updateAccount():\n    global Account\n    global LPosition\n    global SPosition\n    global Positions\n    global MaxPosition\n\n    LPosition = 0\n    SPosition = 0\n    Positions = {}\n    for item in exchange.GetPosition():\n        if item['MarginLevel'] == LEVERAGE_RATE:\n            if item['Type'] == 1:\n                Positions['Short'] = item\n                SPosition += item['Amount']\n            else:\n                Positions['Long'] = item\n                LPosition += item['Amount']\n        MaxPosition = max(MaxPosition, SPosition, LPosition)\n\n    Account = exchange.GetAccount()\n\n    return True\n\ndef updatePositions():\n    global TotalWin\n    global TotalLoss\n    global FullLoss\n\n    opened = False\n\n    try:\n        Long = Positions['Long']['Amount']\n        LongEntry = Positions['Long']['Price']\n        Current = Ticker['Sell']\n\n        StopLoss = LongEntry * (1-STOP_LOSS)\n        TakeProfit = LongEntry * (1+TAKE_PROFIT)\n\n        if Current > TakeProfit:\n            Risked = True\n            Log('多仓达到预设止盈价位. #0000FF')\n            TotalWin+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverLong(Long, True)\n        if Current < StopLoss:\n            Risked = True\n            Log('多仓达到预设止损价位. #FF0000')\n            TotalLoss+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverLong(Long, True)\n            if Long*AMP < RISK_LIMIT:\n                openShort(Long*AMP, True)\n            else:\n                FullLoss+=1\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n\n        opened = True\n    except KeyError:\n        pass\n\n    try:\n        Short = Positions['Short']['Amount']\n        ShortEntry = Positions['Short']['Price']\n        Current = Ticker['Buy']\n\n        StopLoss = ShortEntry * (1+STOP_LOSS)\n        TakeProfit = ShortEntry * (1-TAKE_PROFIT)\n\n        if Current < TakeProfit:\n            Risked = True\n            Log('空仓达到预设止盈价位. #0000FF')\n            TotalWin+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverShort(Short, True)\n        if Current > StopLoss:\n            Risked = True\n            Log('空仓达到预设止损价位. #FF0000')\n            TotalLoss+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverShort(Short, True)\n            if Short*AMP < RISK_LIMIT:\n                openLong(Short*AMP, True)\n            else:\n                FullLoss+=1\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n\n        opened = True\n    except KeyError:\n        pass\n\n    if not opened:\n        Log('还没开仓，随便开个仓位.')\n        RSI = talib.RSI(getTAFormat(Records), timeperiod=14)\n        if RSI[-2]<RSI[-1]:\n            Log('RSI14: ', RSI[-1],' 正在开多.')\n            openLong(START_SIZE, True)\n        else:\n            Log('RSI14: ', RSI[-1],' 正在开空.')\n            openShort(START_SIZE, True)\n\n    return True\n\ndef openLong(Amount=0, marketPrice=False):\n    global TotalLongs\n\n    Amount = floor(Amount)\n\n    TotalLongs+=Amount\n\n    exchange.SetDirection('buy')\n\n    if marketPrice:\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\n    else:\n        exchange.Buy(Ticker['Sell'], Amount)\n\n    return True\n\ndef coverLong(Amount=0, marketPrice=False):\n    exchange.SetDirection('closebuy')\n\n    if marketPrice:\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\n    else:\n        exchange.Sell(Ticker['Buy'], Amount)\n\n    return True\n\ndef openShort(Amount=0, marketPrice=False):\n    global TotalShorts\n\n    Amount = floor(Amount)\n\n    TotalShorts+=Amount\n\n    exchange.SetDirection('sell')\n\n    if marketPrice:\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\n    else:\n        exchange.Sell(Ticker['Buy'], Amount)\n\n    return True\n\ndef coverShort(Amount=0, marketPrice=False):\n    exchange.SetDirection('closesell')\n\n    if marketPrice:\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\n    else:\n        exchange.Buy(Ticker['Sell'], Amount)\n\n    return True\n\ndef onTick():\n    cancelAllOrders()\n    updateMarket()\n    updateAccount()\n    updatePositions()\n\n    return True\n\ndef main():\n    exchange.SetContractType(CONTRACT_TYPE)\n    exchange.SetMarginLevel(LEVERAGE_RATE)\n\n    while True:\n        onTick()\n        Sleep(DELAY*1000)"}
{"query": "请生成一个Paul-The-Gambler-Lévy策略代码", "base_model_response": "。\n\n```python\nclass Strategy:\n    def __init__(self, player, start):\n        self.player = player\n        self.start = start\n\n    def is_valid(self):\n        if self.player == 'Paul':\n            return True\n        if not self.start.is_valid():\n            return False\n        return self.player in 'Levy'\n\n    def play(self):\n        self.player += 1\n        return self.start.play()\n```\n\n在上面的代码中，`Strategy`类有两个属性：`player`和`start`。`is_valid`方法用于检查玩家是否合法（即是否为`Paul`)。`play`方法用于执行当前玩家的操作（即增加1）。\n\n请注意，在`Paul-The-Gambler-Lévy`策略中，`Levery`是一个策略对象，代表一个可能的行动路径。玩家可以在多个时间窗口内选择这个策略对象，每次选择都会改变当前操作者的行为。", "lora_model_response": "", "original_response": "python\n\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n#  Paul \"The Gambler\" Lévy.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\nimport random\nfrom math import *\n\nAccount = {}\nTicker = {}\nLPosition = 0\nSPosition = 0\nPositions = {}\nTotalLoss = 0\nTotalWin = 0\nFullLoss = 0\nMaxPosition = 0\nTotalLongs = 0\nTotalShorts = 0\n\ndef cancelAllOrders():\n    orders = exchange.GetOrders()\n    for order in orders:\n        exchange.CancelOrder(order['Id'], order)\n    return True\n\ndef updateMarket():\n    global Ticker\n\n    Ticker = exchange.GetTicker()\n\n    return True\n\ndef updateAccount():\n    global Account\n    global LPosition\n    global SPosition\n    global Positions\n    global MaxPosition\n\n    LPosition = 0\n    SPosition = 0\n    Positions = {}\n    for item in exchange.GetPosition():\n        if item['MarginLevel'] == LEVERAGE_RATE:\n            if item['Type'] == 1:\n                Positions['Short'] = item\n                SPosition += item['Amount']\n            else:\n                Positions['Long'] = item\n                LPosition += item['Amount']\n        MaxPosition = max(MaxPosition, SPosition, LPosition)\n\n    Account = exchange.GetAccount()\n\n    return True\n\ndef updatePositions():\n    global TotalWin\n    global TotalLoss\n    global FullLoss\n\n    opened = False\n\n    try:\n        Long = Positions['Long']['Amount']\n        LongEntry = Positions['Long']['Price']\n        Current = Ticker['Sell']\n\n        StopLoss = LongEntry * (1-STOP_LOSS)\n        TakeProfit = LongEntry * (1+TAKE_PROFIT)\n\n        if Current > TakeProfit:\n            Risked = True\n            Log('多仓达到预设止盈价位. #0000FF')\n            TotalWin+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverLong(Long, True)\n        if Current < StopLoss:\n            Risked = True\n            Log('多仓达到预设止损价位. #FF0000')\n            TotalLoss+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverLong(Long, True)\n            if Long*AMP < RISK_LIMIT:\n                openShort(Long*AMP, True)\n            else:\n                FullLoss+=1\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n\n        opened = True\n    except KeyError:\n        pass\n\n    try:\n        Short = Positions['Short']['Amount']\n        ShortEntry = Positions['Short']['Price']\n        Current = Ticker['Buy']\n\n        StopLoss = ShortEntry * (1+STOP_LOSS)\n        TakeProfit = ShortEntry * (1-TAKE_PROFIT)\n\n        if Current < TakeProfit:\n            Risked = True\n            Log('空仓达到预设止盈价位. #0000FF')\n            TotalWin+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverShort(Short, True)\n        if Current > StopLoss:\n            Risked = True\n            Log('空仓达到预设止损价位. #FF0000')\n            TotalLoss+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverShort(Short, True)\n            if Short*AMP < RISK_LIMIT:\n                openLong(Short*AMP, True)\n            else:\n                FullLoss+=1\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n\n        opened = True\n    except KeyError:\n        pass\n\n    if not opened:\n        Log('还没开仓，随便开个仓位.')\n        rand = random.choice([1,2,3,4,5,6])\n        if rand in [1,3,5]:\n            Log('骰子抛到了: ',rand,' 正在开多.')\n            openLong(START_SIZE, True)\n        else:\n            Log('骰子抛到了: ',rand,' 正在开空.')\n            openShort(START_SIZE, True)\n\n    return True\n\ndef openLong(Amount=0, marketPrice=False):\n    global TotalLongs\n\n    Amount = floor(Amount)\n\n    TotalLongs+=Amount\n\n    exchange.SetDirection('buy')\n\n    if marketPrice:\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\n    else:\n        exchange.Buy(Ticker['Sell'], Amount)\n\n    return True\n\ndef coverLong(Amount=0, marketPrice=False):\n    exchange.SetDirection('closebuy')\n\n    if marketPrice:\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\n    else:\n        exchange.Sell(Ticker['Buy'], Amount)\n\n    return True\n\ndef openShort(Amount=0, marketPrice=False):\n    global TotalShorts\n\n    Amount = floor(Amount)\n\n    TotalShorts+=Amount\n\n    exchange.SetDirection('sell')\n\n    if marketPrice:\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\n    else:\n        exchange.Sell(Ticker['Buy'], Amount)\n\n    return True\n\ndef coverShort(Amount=0, marketPrice=False):\n    exchange.SetDirection('closesell')\n\n    if marketPrice:\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\n    else:\n        exchange.Buy(Ticker['Sell'], Amount)\n\n    return True\n\ndef onTick():\n    cancelAllOrders()\n    updateMarket()\n    updateAccount()\n    updatePositions()\n\n    return True\n\ndef main():\n    exchange.SetContractType(CONTRACT_TYPE)\n    exchange.SetMarginLevel(LEVERAGE_RATE)\n\n    while True:\n        onTick()\n        Sleep(DELAY*1000)"}
{"query": "请生成一个Python-API-测试策略代码", "base_model_response": "```python\nimport unittest\nfrom typing import List\n\nclass TestAPI(unittest.TestCase):\n\n    def test_api(self):\n        self.api.get('some value')\n        self.api.get('not some value')\n\n    @unittest.Test)\n    def test_get_not_value(self):\n        self.api.get('not some value')\n        self.api.get('some other value')\n\n    @unittest.Test)\n    def test_list_get(self):\n        self.api.get_all(['a', 'b'])\n        self.api.get_all(['c', 'd'])\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n这个测试策略包含五个测试：`test_api`，`test_get_not_value`，`test_list_get`和`test_get_all`。每个测试都使用了Python的内置模块`pytest`来编译测试用例，并且在每次运行时都会自动执行它们。\n\n注意：你可能需要根据你的实际情况调整这个策略。例如，如果你的API支持多种类型的参数，那么你可能需要定义更多的测试用例来覆盖所有的可能性。", "lora_model_response": "", "original_response": "python\n\n'''backtest\nstart: 2019-09-14 00:00:00\nend: 2019-10-13 00:00:00\nperiod: 1h\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport sys\nimport time\nimport talib\nimport json\nimport traceback\nimport matplotlib\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport mpl_toolkits.mplot3d\n\ndef main():\n    testGlobal = [\n            'Version', ['Log', 'ok', 3.5, True], ['Sleep', 100], ['LogProfit', 10.5],\n            'LogProfitReset', ['LogProfit', 10.8], 'GetCommand', 'LogReset', ['LogStatus', 'x', True], ['EnableLog', True], \n            ['SetErrorFilter', 'xxx'], 'GetPid', 'GetLastError', ['_G', 'x', 10], ['_G', 'x'], ['_G', 'x', None], '_G',\n        ]\n    g = globals()\n    for item in testGlobal:\n        if isinstance(item, list):\n            ret = g[item[0]](*item[1:])\n        else:\n            ret = g[item]()\n        Log('%s => %s' % (item, ret))\n    Log(sys.version)\n    testExchanges = [\n            'GetName', 'GetUSDCNY', 'GetRate', ['SetRate', 1.0], 'GetAccount', 'GetCurrency', 'GetLabel', 'GetMinStock', 'GetMinPrice', 'GetFee',\n            'GetRecords',\n            ['Buy', 100, 0.1, \"OK\"],\n            'GetOrders',\n            ['GetOrder', 1],\n            'GetAccount',\n            'GetRawJSON',\n            ['CancelOrder', 1],\n            ['Buy', -1, 1000.0],\n            'GetAccount',\n            ['Sell', -1, 1],\n            'GetAccount',\n            ['Sell', 9999.9, 0.2, \"OK\"],\n            'GetOrders',\n            'GetAccount',\n            ['CancelOrder', 2],\n            ['Go', 'GetAccount'],\n            ['IO', 'status'],\n        ]\n    for item in testExchanges:\n        try:\n            if isinstance(item, list):\n                ret = getattr(exchange, item[0])(*item[1:])\n            else:\n                ret = getattr(exchange, item)()\n        except:\n            ret = traceback.format_exc()\n        Log('exchange.%s => %s' % (item, ret))\n    \n    # test market order\n    exchange.Buy(-1, 1000)\n    exchange.Buy(-1, 200, \"buy 200 \")\n    exchange.Sell(-1, exchange.GetAccount().Stocks)\n    # test Go\n    ret, ok = exchange.Go(\"GetTicker\").wait()\n    if ok:\n        Log(\"Go GetTicker\", ret)\n    Log(\"EMA\", len(TA.EMA(exchange.GetRecords())))\n    Log(\"EMA H1\", len(TA.EMA(exchange.GetRecords(PERIOD_H1))))\n    \n\n    # test plot image\n    plt.plot([3,6,2,4,7,1])\n    Log('支持直接打印plt图片 ', plt)\n    \n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    t = ax.scatter(np.random.rand(20), np.random.rand(20))\n    Log(fig)\n    \n    x = np.linspace(0, 10, 1000)\n    y = np.sin(x)\n    z = np.cos(x**2)\n\n    plt.figure(figsize=(8,4))\n    plt.plot(x,y,label=\"$sin(x)$\",color=\"red\",linewidth=2)\n    plt.plot(x,z,\"b--\",label=\"$cos(x^2)$\")\n    plt.xlabel(\"Time(s)\")\n    plt.ylabel(\"Volt\")\n    plt.title(\"PyPlot Example\")\n    plt.ylim(-1.2,1.2)\n    plt.legend()\n    Log(plt)\n\n    x,y=np.mgrid[-2:2:20j,-2:2:20j]\n    z=x*np.exp(-x**2-y**2)\n    ax=plt.subplot(111,projection='3d')\n    ax.plot_surface(x,y,z,rstride=2,cstride=1,cmap=plt.cm.coolwarm,alpha=0.8)\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n    ax.set_zlabel('z')\n    # plot image to status bar\n    LogStatus(plt)\n    \n    # test plot chart\n    x = Chart({\n        'title' : { 'text' : 'test chart'},\n        'xAxis': { 'type': 'datetime'},\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\n        })\n    x.reset()\n    for i in range(100):\n        ts = int(time.time() * 1000)\n        ticker = _C(exchange.GetTicker)\n        x.add(0, [ts, ticker.Buy])\n        x.add(1, [ts, ticker.Sell])\n        Sleep(10000)"}
{"query": "请生成一个Python-KLineChart策略代码", "base_model_response": "```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef line_data(data):\n    x = data[:, 0]\n    y = data[:, 1]\n    width, height = data.shape[0], data.shape[1]\n\n    ax = plt.subplot(121)\n    line = ax.plot(x, y)\n\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n\n    return line\n\ndef set_x limits(x_min, x_max, y_min, y_max):\n    min_x = min{x_min, x_max}\n    max_x = max{x_min, x_max}\n\n    min_y = min+y_min\n    max_y = max+y_max\n\n    line.set_xlim(min_x, max_x)\n    line.set_ylim(min_y, max_y)\n\n    return line\n\ndef plot_kline(data, fig_name, line_to_km=350, line_to_km_path=None):\n    ax = plt.subplots()\n    ax.set_aspect('equal')\n    ax.set_title(fig_name)\n\n    data = line_data(data)\n\n    if line_to_km is None:\n        line_to_km_path = np.linspace(0.0, 1.0, 60)\n\n    data /= 1e-8\n\n    ax.plot(data, line_to_km)\n\n    if line_to_km_path is not None:\n        ax.plot(line_to_km_path, line_to_km_data)\n\n    plt.show()\n\nif __name__ == \"__main__\":\n    fig_name = \"myfig\"\n    data = np.array([[4, 3], [2, 7], [9, 6]], dtype=np.float32)\n    fig = plot_kline(data, fig_name, line_to_km=40, line_to_km_path=\"path/to/your/kline/data\")\n\nif __name__ == \"__main__\":\n    plt.show()\n```\n\n在这个例子中，我们定义了一个函数`line_data`，它接受一个包含两个整数的列表，并返回一条从第一个数字到第二个数字的直线。然后，我们定义了两个函数`set_xlim`和`plot_kline`，它们分别用于设置坐标轴的范围和绘制线图。\n\n在`plot_kline`函数中，我们首先计算数据，然后将数据除以1e-8，以获得最小值和最大值。然后，我们将数据按照指定的比例绘制在坐标轴上。最后，我们将画出线图。\n\n你可以根据你的需要修改这个策略代码。例如，你可能想要在图表中添加更多的元素或调整线条的样式，或者只在某些特定的时间点显示图表。", "lora_model_response": "，该策略可以用于跟踪股票市场。\n\n```python\nimport matplotlib.pyplot as plt\nfrom pandas import DataFrame\n\ndef closeBar(df, barStyle, style=None):\n    df['Bar'].style = (barStyle, barStyle)\n    if style is None:\n        style = barStyle\n    df['Bar'].barcolor(style=colorize证券.COLOR_H黄2L)\n\n# 定义K线的样式\ndef klineStyle(x, y, label, data):\n    return {\n        'x': x,\n        'y': y,\n        'label': label,\n        'data': data,\n        'line风格': klineStyle,\n    }\n    \n# 定义k线的参数\ndef kline参数(x, y, barStyle, style=None):\n    return {\n        'x': x,\n        'y': y,\n        'label': 'Close Chart',\n        'type': 'kline',\n        'style': style or {'line style': klineStyle},\n        'xscale': 0.9,\n        'yscale': 0.9,\n        'barStyle': style or 'h1',\n        'data': data,\n    }\n\n# 定义K线的配置函数\ndef kline配置(name, args, env):\n    env.KlineConfig(name=env.get('name'))\n    env.KlineBar(align=4,\n                    title='Closing Chart on Line'\n                  )\n\n# 使用方法\ndef main():\n    # 利用自定义函数来设置K线参数\n    args = klineConfiguration('Open', [8600], False)\n    env = KlineEnvironment(args=args)\n\n    # 等待用户输入时间，然后开始绘制\n    while True:\n        # 等待用户点击'OK'按钮结束绘图\n        if not env.isOk('OK'):\n            break\n\n    # 获取时间\n    time = time.time()\n\n    # 获取当前日期时间\n    now = datetime.now(time.strftime('%Y-%m-%d %H:%M:%S'))\n\n    # 根据用户设定的图表类型绘制K线\n    bar = env.KlineBar(list(range(now.year, now.year + 1),\n                           list(now.month, now.month + 1),\n                           list(now.day, now.day + 1)) # 不包括闰年\n    bar.config.style=klineStyle(now, now)\n    bar.config.label=data\n\n    # 绘制图表\n    fig = plt.figure(figsize=(11, 7))\n    ax = fig.add_subplot(111, projection=\"3d\")\n\n    # 由于我们没有实际的数据进行计算，所以没有需要画出的饼图\n    bar.plot(data[now.month], data而现在.day)\n\n    if bar.title:\n        if not env.isOk(\"OK\"):\n            break\n        print(bar.title)\n        bar.statusbar()\n```\n\n以上是K线的简单配置，可以根据需要添加更多的数据和样式。", "original_response": "python\n'''backtest\nstart: 2022-03-30 09:00:00\nend: 2022-06-30 15:00:00\nperiod: 1h\nbasePeriod: 15m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\"}]\n'''\n\n\nimport sys\ndef main():\n    Log(sys.version)\n    c = KLineChart()\n    c.reset(0)\n\n    bars = exchange.GetRecords()\n    for bar in bars:\n        c.begin(bar)\n        c.barcolor('rgba(255, 0, 0, 0.2)' if bar.Close > bar.Open else 'rgba(0, 0, 0, 0.2)')\n        if bar.Close > bar.Open:\n            c.bgcolor('rgba(0, 255, 0, 0.5)')\n        \n        h = c.plot(bar.High, 'high')\n        l = c.plot(bar.Low, 'low')\n        c.fill(h, l, 'rgba(255, 0, 0, 1)' if bar.Close > bar.Open else '#000000')\n        c.hline(bar.High)\n        c.plotarrow(bar.Close - bar.Open)\n        c.plotshape(bar.Low, style = 'diamond')\n        c.plotchar(bar.Close, char = 'X')\n        c.plotcandle(bar.Open*0.9, bar.High*0.9, bar.Low*0.9, bar.Close*0.9)\n        if bar.Close > bar.Open:\n            c.signal(\"long\", bar.High, 1.5, \"LONG\")\n        elif bar.Close < bar.Open:\n            c.signal(\"closelong\", bar.Low, 1.5)\n        c.close()"}
{"query": "请生成一个Python-机器学习之-SVM-预测买卖策略代码", "base_model_response": "```python\nimport numpy as np\nfrom sklearn import svm\nfrom sklearn.metrics import mean_squared_error\n\n# 假设我们有一个包含股票价格的数据集，其中包含两个列：时间（t）和股价(Price)。\n\ndf = pd.DataFrame({\n    'time': ['2021-01-01', '2021-01-02', '2021-01-03', ...],\n    'Price': [40, 45, 48, ..., 50]\n})\n\nX = df['time'].values.reshape(-1, 1)\ny = df['Price'].values.reshape(-1, 1)\n\n# 创建SVM模型\nclf = svm.SVC()\n\n# 将数据输入到模型中\nclf.fit(X, y)\n\n# 评估模型\nprint(mean_squared_error(clf.predict(X), y))\n```\n\n在这个例子中，我们将使用一个简单的线性SVM模型来预测股票的价格。在实际应用中，你可能需要考虑其他因素，如市场趋势、风险承受能力等，来优化模型的性能。", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2019-09-06 00:00:00\nend: 2019-10-05 00:00:00\nperiod: 1h\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\"}]\n'''\n\nfrom sklearn import svm\nimport numpy as np\n\ndef main():\n    preTime = 0\n    n = 0\n    success = 0\n    predict = None\n    pTime = None\n    marketPosition = 0\n    initAccount = exchange.GetAccount()\n    Log(\"Running...\")\n    while True:\n        r = exchange.GetRecords()\n        if len(r) < 60:\n            continue\n        bar = r[len(r)-1]\n        if bar.Time > preTime:\n            preTime = bar.Time\n            if pTime is not None and r[len(r)-2].Time == pTime:\n                diff = r[len(r)-2].Close - r[len(r)-3].Close\n                if diff > SpreadVal:\n                    success += 1 if predict == 0 else 0\n                elif diff < -SpreadVal:\n                    success += 1 if predict == 1 else 0\n                else:\n                    success += 1 if predict == 2 else 0\n                pTime = None\n                LogStatus(\"预测次数\", n, \"成功次数\", success, \"准确率:\", '%.3f %%' % round(float(success) * 100 / n, 2))\n        else:\n            Sleep(1000)\n            continue\n        inputs_X, output_Y = [], []\n        sets = [None, None, None]\n        for i in xrange(1, len(r)-2, 1):\n            inputs_X.append([r[i].Open, r[i].Close])\n            Y = 0\n            diff = r[i+1].Close - r[i].Close\n            if diff > SpreadVal:\n                Y = 0\n                sets[0] = True\n            elif diff < -SpreadVal:\n                Y = 1\n                sets[1] = True\n            else:\n                Y = 2\n                sets[2] = True\n            output_Y.append(Y)\n        if None in sets:\n            Log(\"样本不足, 无法预测 ...\")\n            continue\n        n += 1\n        clf = svm.LinearSVC()\n        clf.fit(inputs_X, output_Y)\n        predict = clf.predict(np.array([bar.Open, bar.Close]).reshape((1, -1)))[0]\n        pTime = bar.Time\n        Log(\"预测当前Bar结束:\", bar.Time, ['涨', '跌', '横'][predict])\n        if marketPosition == 0:\n            if predict == 0:\n                exchange.Buy(-1, initAccount.Balance/2)\n                marketPosition = 1\n            elif predict == 1:\n                exchange.Sell(-1, initAccount.Stocks/2)\n                marketPosition = -1\n        else:\n            nowAccount = exchange.GetAccount()\n            if marketPosition > 0 and predict != 0:\n                exchange.Sell(-1, nowAccount.Stocks - initAccount.Stocks)\n                nowAccount = exchange.GetAccount()\n                marketPosition = 0\n            elif marketPosition < 0 and predict != 1:\n                while True:\n                    dif = initAccount.Stocks - nowAccount.Stocks\n                    if dif < 0.01:\n                        break\n                    ticker = exchange.GetTicker()\n                    exchange.Buy(ticker.Sell + (ticker.Sell-ticker.Buy)*2, dif)\n                    while True:\n                        Sleep(1000)\n                        orders = exchange.GetOrders()\n                        for order in orders:\n                            exchange.CancelOrder(order.Id)\n                        if len(orders) == 0:\n                            break\n                    nowAccount = exchange.GetAccount()\n                marketPosition = 0\n            if marketPosition == 0:\n                LogProfit(_N(nowAccount.Balance - initAccount.Balance, 4), nowAccount)"}
{"query": "请生成一个Python版-TableTemplet-测试版Python-Version-TableTemplet-Beta-Version策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# TableTemplet\nimport json\nlistener = {}\n\nclass Table():\n    \"\"\"docstring for Table\"\"\"\n    def __init__(self):\n        self.tb = {\n            \"type\" : \"table\",\n            \"title\" : \"Table\",\n            \"cols\" : [],\n            \"rows\" : []\n        }\n\n    def SetColRow(self, col_index, row_index, row):\n        if (type(col_index) is int) and (type(row_index) is int) :\n            if (col_index > len(self.tb[\"cols\"])) or (row_index > len(self.tb[\"rows\"])) :\n                Log(\"索引超出范围！col_index:\", col_index, \"row_index:\", row_index)\n            else :\n                self.tb[\"rows\"][row_index - 1][col_index - 1] = row\n        else :\n            Log(\"col_index:\", col_index, \"row_index:\", row_index)\n            raise \"SetColRow 参数错误!\"\n\n    def SetBtn(self, col_index, row_index, cmd, name, callback):\n        global listener\n        if (type(col_index) is int) and (type(row_index) is int) :\n            if (col_index > len(self.tb[\"cols\"])) or (row_index > len(self.tb[\"rows\"])) :\n                Log(\"索引超出范围！col_index:\", col_index, \"row_index:\", row_index)\n            else :\n                self.tb[\"rows\"][row_index - 1][col_index - 1] = {\"type\" : \"button\", \"cmd\" : cmd, \"name\" : name}\n                listener[cmd] = callback\n        else :\n            Log(\"col_index:\", col_index, \"row_index:\", row_index)\n            raise \"SetColRow 参数错误!\"\n    \n    def SetRows(self, row_index, Rows):\n        pass\n\n    def SetCols(self, Cols):\n        self.tb[\"cols\"] = Cols\n\n    def GetRows(self, row_index):\n        if (type(row_index) is int) and (row_index < len(self.tb[\"rows\"])) :\n            return self.tb[\"rows\"][row_index - 1]\n        else :\n            Log(\"参数错误！ 或者 参数索引超出范围！\")\n\n    def Init(self, title, col_length, row_length):  \n        self.tb[\"title\"] = title\n        for i in range(1, row_length + 1) :\n            if i == 1 :\n                for n in range(1, col_length + 1) :\n                    self.tb[\"cols\"].append(n)\n            self.tb[\"rows\"].append([])\n            for m in range(1, col_length + 1) :\n                self.tb[\"rows\"][i - 1].append(str(i) + \"/\" + str(m))\n\n\nclass CreateTableManager():\n    \"\"\"docstring for CreateTableManager\"\"\"\n    def __init__(self):        # CreateTableManager 构造函数\n        self.tables = []       # 用于储存 table 对象\n    \n    def GetTable(self, index):\n        if type(index) is int :\n            return self.tables[index]\n        elif type(index) is str :\n            for i in range(len(self.tables)) :\n                if self.tables[i][\"title\"] == index:\n                    return self.tables[i]\n        else :\n            Log(\"GetTable参数:\", index)\n            raise \"GetTable 参数错误！\"\n    \n    def AddTable(self, title, col_length, row_length):    # cols, rows\n        tb = Table()\n        tb.Init(title, col_length, row_length)\n        self.tables.append(tb.tb)\n        return tb\n\n    def UpdateCMD(self):\n        global listener\n        cmd = GetCommand()\n        if cmd :\n            cmdList = cmd.split(\":\")\n            if len(cmdList) == 2 :                                         # 增加了 对于 主策略 交互的 冲突 检测。\n                Log(\"接收到 TableTemplet 模板以外的 交互命令！\", cmdList)     \n                return\n            if listener[cmd] :\n                listener[cmd](cmd)\n            else :\n                Log(\"TableTemplet 模板中找不到名为：\" + cmd + \"的命令\")\n    \n    def LogStatus(self, before, end):\n        self.UpdateCMD()\n        LogStatus(before + '\\n`' + json.dumps(self.tables) + '`\\n' + end)\n\n# 导出函数\next.CreateTableManager = CreateTableManager\n\n# 测试代码\n\ndef test1(cmd):        # 用作函数回调\n    Log(_D(), cmd)\n\ndef main():\n    account = exchange.GetAccount()\n    array1 = [\"aa\", \"bb\", \"cc\"]\n    array2 = [1, 2, 4, 55]\n\n    TbM = ext.CreateTableManager()\n    tb1 = TbM.AddTable(\"tb1\", 6, 7)\n    \n    tb1.SetColRow(3, 4, \"hello\")\n    tb1.SetColRow(3, 5, 12)\n    tb1.SetColRow(3, 6, account)\n    tb1.SetColRow(3, 7, array1)\n    tb1.SetColRow(3, 2, array2)\n    tb1.SetBtn(3, 1, \"Cover\", \"平仓\", test1)    # 由于 python 没有多行 匿名函数（如JS 的 function(){...}）所以可以声明普通函数传入。\n    tb_1 = TbM.GetTable(0)\n    tb_2 = TbM.GetTable(\"tb1\")\n    Log(tb_1)\n    Log(tb_2, \"#FF0000\")\n    tb1_row1 = tb1.GetRows(1)\n    Log(tb1_row1)\n    tb1_row1[0] = \"修改\"\n    x = 0\n    \n    # tb2\n    tb2 = TbM.AddTable(\"tb2\", 4, 4)\n\n    while True :\n        x = x + 1\n        tb1_row1[0] = _D()\n        tb1.SetCols([x + 1, x + 2, x + 3, x + 4, x + 5, x + 6])\n        TbM.LogStatus(\"begin\", \"end\")\n        Sleep(1000)"}
{"query": "请生成一个Python版MACD指标画图范例策略代码", "base_model_response": "首先，你需要安装matplotlib库并编写一段代码来定义一个简单的 MACD 图形。\n\n```python\nimport matplotlib.pyplot as plt\n\ndef macd_data(data, start, end):\n    # 返回 MacD 数据\n    return data[start:end]\n\n# 创建一个包含数据的列表\ndata = [0.125, 0.836, 0.497, 0.710, 0.287, 0.712, 0.496, 0.229, 0.704]\n\n# 根据数据创建MACD 图形\nplt.plot(data,macd_data)\n\n# 设置图形的标题和轴标签\nplt.title('MacD Data')\nplt.xlabel('Time (hours)')\nplt.ylabel('MacD Value')\n\n# 显示图形\nplt.show()\n```\n\n这个代码定义了一个函数 `macd_data`，它接受数据和时间作为参数，返回一个包含时间戳和MACD值的列表。然后，我们创建了一个包含数据的列表，并根据它们调用 `macd_data` 函数，最后计算并显示了图表。\n\n注意：这只是一个基本的示例。在实际应用中，你可能需要使用更复杂的算法来预测MACD 价格波动。此外，如果你不希望手动设置图形标题和轴标签，你可以将这两个函数重写为函数 `plt.plot` 和 `plt.xlabel`，并在此基础上编写更多的代码。", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2020-01-28 00:00:00\nend: 2020-02-26 00:00:00\nperiod: 1d\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\"}]\n'''\n\nChartCfg = {\n    '__isStock': True,\n    'title': {\n        'text': 'Python画图'\n    },\n    'yAxis': [{\n        'title': {'text': 'K线'},\n        'style': {'color': '#4572A7'},\n        'opposite': False\n    }, {\n        'title': {'text': '指标轴'},\n        'opposite': True\n    }],\n    'series': [{\n        'type': 'candlestick',\n        'name': '当前周期',\n        'id': 'primary',\n        'data': []\n    }, {\n        'type': 'line',\n        'id': 'dif',\n        'name': 'DIF',\n        \"yAxis\" : 1,\n        'data': []\n    }, {\n        'type': 'line',\n        'id': 'dea',\n        'name': 'DEA',\n        \"yAxis\" : 1,\n        'data': []\n    }, {\n        'type': 'line',\n        'id': 'macd',\n        'name': 'MACD',\n        \"yAxis\" : 1,\n        'data': []\n    }]\n}\n\ndef main():\n    global ChartCfg\n    preTime = 0\n    chart = Chart(ChartCfg)\n    chart.reset()\n    while True:\n        while True:\n            r = _C(exchange.GetRecords)\n            if len(r) > 50:\n                break\n        # 计算指标\n        macd = TA.MACD(r)\n        \n        LogStatus(_D(), len(r))\n        \n        # 画图\n        for i in range(len(r)):\n            if r[i][\"Time\"] == preTime:\n                chart.add(0, [r[i][\"Time\"], r[i][\"Open\"], r[i][\"High\"], r[i][\"Low\"], r[i][\"Close\"]], -1)\n                chart.add(1, [r[i][\"Time\"], macd[0][i]], -1)\n                chart.add(2, [r[i][\"Time\"], macd[1][i]], -1)\n                chart.add(3, [r[i][\"Time\"], macd[2][i]], -1)\n            elif r[i][\"Time\"] > preTime:\n                chart.add(0, [r[i][\"Time\"], r[i][\"Open\"], r[i][\"High\"], r[i][\"Low\"], r[i][\"Close\"]])\n                chart.add(1, [r[i][\"Time\"], macd[0][i]])\n                chart.add(2, [r[i][\"Time\"], macd[1][i]])\n                chart.add(3, [r[i][\"Time\"], macd[2][i]])\n                preTime = r[i][\"Time\"]\n        Sleep(500)"}
{"query": "请生成一个Python版冰山委托-买入策略代码", "base_model_response": "```python\nclass IceCowlCommand:\n    def __init__(self, asset_code):\n        self AssetCode = asset_code\n\n    def execute(self):\n        try:\n            if self._is_in_range():\n                order = self._order()\n                # Calculate the total quantity of the order by adding all items in the order to their market price\n                total_quantity = sum(order['items'].price * order['items']['quantity'])\n                order.set_order_price(total_quantity)\n            else:\n                raise ValueError('Order not within the range')\n        except ValueError as e:\n            print(f'Error: {e}')\n        return order\n\n    def _is_in_range(self):\n        if 0 <= self资产_code <= len(self.order['items']):\n            return True\n        return False\n\n# Usage example\nice_cowl_command = IceCowlCommand('A1234567890')  # Set an asset code\norder = ice_cowl_command.execute()  # Execute the order\nprint(order.get_order_price())  # Print the final order price\n```\n这个Python版本的`IceCowlCommand`类实现了客户端之间的交互，它接受一个参数`asset_code`来指定购买的冰山类型。在这个方法中，首先检查订单是否满足交易规则（`__is_in_range()`）。如果满足，则执行订单。否则，抛出一个错误。最后返回订单。\n\n请注意，这个API只是一个基本的示例，您需要根据自己的业务和需求进行调整。", "lora_model_response": "", "original_response": "python\nimport random\n\ndef CancelPendingOrders():\n    while True:\n        orders = _C(exchange.GetOrders)\n        if len(orders) == 0 :\n            return \n\n        for j in range(len(orders)):\n            exchange.CancelOrder(orders[j][\"Id\"])\n            if j < len(orders) - 1:\n                Sleep(Interval)\n\nLastBuyPrice = 0\nInitAccount = None\n\ndef dispatch():\n    global InitAccount, LastBuyPrice\n    account = None\n    ticker = _C(exchange.GetTicker)\n    LogStatus(_D(), \"ticker:\", ticker)\n    if LastBuyPrice > 0:\n        if len(_C(exchange.GetOrders)) > 0:\n            if ticker[\"Last\"] > LastBuyPrice  and ((ticker[\"Last\"] - LastBuyPrice) / LastBuyPrice) > (2 * (EntrustDepth / 100)): \n                Log(\"偏离过多, 最新成交价:\", ticker[\"Last\"], \"委托价\", LastBuyPrice)\n                CancelPendingOrders()\n            else :\n                return True\n        else :\n            account = _C(exchange.GetAccount)\n            Log(\"买单完成, 累计花费:\", _N(InitAccount[\"Balance\"] - account[\"Balance\"]), \"平均买入价:\", _N((InitAccount[\"Balance\"] - account[\"Balance\"]) / (account[\"Stocks\"] - InitAccount[\"Stocks\"])))\n        LastBuyPrice = 0\n\n    BuyPrice = _N(ticker[\"Buy\"] * (1 - EntrustDepth / 100))\n    if BuyPrice > MaxBuyPrice:\n        return True\n\n    if not account:\n        account = _C(exchange.GetAccount)\n\n    if (InitAccount[\"Balance\"] - account[\"Balance\"]) >= TotalBuyNet:\n        return False\n\n    RandomAvgBuyOnce = (AvgBuyOnce * ((100.0 - FloatPoint) / 100.0)) + (((FloatPoint * 2) / 100.0) * AvgBuyOnce * random.random())   # 随机数 0~1\n    UsedMoney = min(account[\"Balance\"], RandomAvgBuyOnce, TotalBuyNet - (InitAccount[\"Balance\"] - account[\"Balance\"]))\n\n    BuyAmount = _N(UsedMoney / BuyPrice)\n    if BuyAmount < MinStock:\n        return False \n    LastBuyPrice = BuyPrice\n    exchange.Buy(BuyPrice, BuyAmount, \"花费：￥\", _N(UsedMoney), \"上次成交价\", ticker[\"Last\"])\n    return True\n\ndef main():\n    global LoopInterval, InitAccount\n    CancelPendingOrders()\n    InitAccount = _C(exchange.GetAccount)\n    Log(InitAccount)\n    if InitAccount[\"Balance\"] < TotalBuyNet:\n        raise Exception(\"账户余额不足\")\n    LoopInterval = max(LoopInterval, 1)\n    while dispatch():\n        Sleep(LoopInterval * 1000)\n    Log(\"委托全部完成\", _C(exchange.GetAccount))"}
{"query": "请生成一个Python版冰山委托-卖出策略代码", "base_model_response": "", "lora_model_response": "```python\n# 首先，你需要导入一些库，并定义一些变量来处理委托交易数据\n\nimport pandas as pd\nimport numpy as np\nimport time\nfrom __future__ import print_function\nimport random\n\nclass Client:\n    def __init__(self, client_name=\"MyClient\", ip_address=\"10.0.0.1\", port_number=80):\n        self.client_name = client_name\n        self.ip_address = ip_address\n        self.port_number = port_number\n        self.client_id = random.randint(0, 9)\n        \n        # 将当前日交易时间设置为时间戳与小时的乘积加上一天\n        self.client_id = (int(time.time()) - self.client_id) % (24 * 60 * 60 + 1)\n\n        self.date = pd.to_datetime(self.client_id)\n        self.date.set_index(\"client_id\", inplace=True)\n\n        df = pd.DataFrame({\"date\": self.date})\n        df[\"price\"] = self.price\n        self.data_df = df\n        \n        self.max_time = float(\"inf\")\n\n    def buy(self, amount):\n        try:\n            # 检查是否持有足够多的股份\n            if not self.max_time > self.client_id:\n                self.max_time = self.client_id\n                # 转换自Binance API 的JSON格式，便于后续进行配置\n                self.client.binance_url = \"http://openapi.binance.com/v1/papi.json\"\n                self.binance_get_params = {\n                    \"appid\": self.client_id,\n                    \"appSecret\": self.client_secret,\n                    \"region\": \"us\",\n                    \"base\": \"US\",\n                    \"currency\": \"USDT\",\n                }\n\n                # 在这里修改参数并返回 json 数据。这里是参数列表：投资期限、每日最大价格、每天执行次数和每次执行后5分钟\n                return json.dumps({'result': True, 'data': {'amount': amount}, 'code': 200})\n            else:\n                return {\"msg\":\"未获得API密钥\"}\n        except Exception as e:\n            return {\"msg\":\"网络出错，请求失败，请检查您的网络连接\" , \"data\": None}\n```\n\n在这个例子中，我们首先使用IP地址获取到客户端的ID和密码。然后我们将该ID赋值给`self.client_id`。接着，我们可以修改`df`的数据，并在当天发送一个购买指令。\n\n当`buy` 方法返回时，它会根据你设定的投资期限发送一个买入指令，同时告诉你所花费的时间。这可以让你在某一时刻做决定（即“卖掉”或“买回”，取决于你的投资期限）。\n\n请注意，这个代码假设你在使用`pandas`和`python-binance-api-python`的库，并且已经安装了这些库。如果没有，你可以通过以下命令来安装：\n```\npip install pandas python-binance-api-python\n```\n\n如果你对这个代码有任何问题，欢迎随时向我提问！", "original_response": "python\nimport random\n\ndef CancelPendingOrders():\n    while True:\n        orders = _C(exchange.GetOrders)\n        if len(orders) == 0:\n            return\n        \n        for j in range(len(orders)):\n            exchange.CancelOrder(orders[j][\"Id\"])\n            if j < len(orders) - 1:\n                Sleep(Interval)\n\nLastSellPrice = 0\nInitAccount = None\n\ndef dispatch():\n    global LastSellPrice, InitAccount\n    account = None\n    ticker = _C(exchange.GetTicker)\n    LogStatus(_D(), \"ticker:\", ticker)\n    if LastSellPrice > 0:\n        if len(_C(exchange.GetOrders)) > 0:\n            if ticker[\"Last\"] < LastSellPrice and ((LastSellPrice - ticker[\"Last\"]) / ticker[\"Last\"]) > (2 * (EntrustDepth / 100)):\n                Log(\"偏离过多，最新成交价：\", ticker[\"Last\"], \"委托价\", LastSellPrice)\n                CancelPendingOrders()\n            else :\n                return True\n        else :\n            account = _C(exchange.GetAccount)\n            Log(\"买单完成，累计卖出：\", _N(InitAccount[\"Stocks\"] - account[\"Stocks\"]), \"平均卖出价：\", _N((account[\"Balance\"] - InitAccount[\"Balance\"]) / (InitAccount[\"Stocks\"] - account[\"Stocks\"])))\n            LastSellPrice = 0\n\n    SellPrice = _N(ticker[\"Sell\"] * (1 + EntrustDepth / 100))\n    if SellPrice < MinSellPrice:\n        return True\n\n    if not account:\n        account = _C(exchange.GetAccount)\n\n    if (InitAccount[\"Stocks\"] - account[\"Stocks\"]) >= TotalSellStocks:\n        return False \n\n    RandomAvgSellOnce = (AvgSellOnce * ((100.0 - FloatPoint) / 100.0)) + (((FloatPoint * 2) / 100.0) * AvgSellOnce * random.random())\n    SellAmount = min(TotalSellStocks - (InitAccount[\"Stocks\"] - account[\"Stocks\"]), RandomAvgSellOnce)\n    if SellAmount < MinStock:\n        return False \n\n    LastSellPrice = SellPrice\n    exchange.Sell(SellPrice, SellAmount, \"上次成交价\", ticker[\"Last\"])\n    return True\n\ndef main():\n    global InitAccount, LoopInterval\n    CancelPendingOrders()\n    InitAccount = _C(exchange.GetAccount)\n    Log(InitAccount)\n    if InitAccount[\"Stocks\"] < TotalSellStocks:\n        raise Exception(\"账户币数不足\")\n    LoopInterval = max(LoopInterval, 1)\n    while dispatch():\n        Sleep(LoopInterval)\n    Log(\"委托全部完成\", _C(exchange.GetAccount))"}
{"query": "请生成一个Python版单平台均衡策略教学策略代码", "base_model_response": "```python\nclass SinglePlatform均衡Policy:\n\n    def __init__(self):\n        self.single platform policy = None\n        \n    def get_single_platform_policy(self):\n        return self single platform policy\n    \n    def put_single_platform_policy(self, single platform policy):\n        \n        # 重新分配资源，这样单点故障也不会影响到其他部分的正常运行\n        self.single platform policy = single platform policy\n        \n    def add_function_to_single平台上(self, function):\n        self single platform policy.add_function(function)\n\n# 测试单平台均衡策略\nsingle_planned_strategy = SinglePlatform均衡Policy()\nprint(f\"Single platform均衡策略的设置是：{single_planned_strategy.get_single_platform_policy()}\")\nprint(f\"单平台均衡策略的添加函数是：{single_planned_strategy.add_function_to_single平台上}\")\n\n\ntry:\n    single_planned_strategy.put_singleplatform_policy('Function1')\nexcept Exception as e:\n    print(f\"Failed to execute the policy: {e}\")\n```\n\n在这个教学策略中，我们定义了一个 `SinglePlatform均衡Policy` 类来实现单点故障和重分布资源的功能。在测试类中，我们创建了一个 `SinglePlatform均衡Policy` 对象，并设置了相应的单点故障策略。然后我们通过调用这个 `put_single_platform_policy` 方法将策略应用于单点故障，最后输出了策略是否成功执行的结果。", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2019-12-01 00:00:00\nend: 2020-02-01 11:00:00\nperiod: 1m\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\",\"stocks\":1}]\n'''\n\nInitAccount = None\n\ndef CancelPendingOrders():\n    ret = False\n    while True:\n        orders = _C(exchange.GetOrders)\n        if len(orders) == 0 :\n            return ret\n\n        for j in range(len(orders)):\n            exchange.CancelOrder(orders[j].Id)\n            ret = True\n            if j < len(orders) - 1:\n                Sleep(Interval)\n    return ret \n\ndef onTick():\n    acc = _C(exchange.GetAccount)\n    ticker = _C(exchange.GetTicker)\n    spread = ticker.Sell - ticker.Buy\n    diffAsset = (acc.Balance - (acc.Stocks * ticker.Sell)) / 2\n    ratio = diffAsset / acc.Balance\n    LogStatus(\"ratio:\", ratio, _D())\n    if abs(ratio) < threshold:\n        return False\n    if ratio > 0 :\n        buyPrice = _N(ticker.Sell + spread, ZPrecision)\n        buyAmount = _N(diffAsset / buyPrice, XPrecision)\n        if buyAmount < MinStock:\n            return False\n        exchange.Buy(buyPrice, buyAmount, diffAsset, ratio)\n    else :\n        sellPrice = _N(ticker.Buy - spread, ZPrecision)\n        sellAmount = _N(-diffAsset / sellPrice, XPrecision)\n        if sellAmount < MinStock:\n            return False \n        exchange.Sell(sellPrice, sellAmount, diffAsset, ratio)\n    return True\n\ndef main():\n    global InitAccount, LoopInterval\n    InitAccount = _C(exchange.GetAccount)\n    LoopInterval = max(LoopInterval, 1)\n    while True:\n        if onTick():\n            Sleep(1000)\n            CancelPendingOrders()\n            Log(_C(exchange.GetAccount))\n        Sleep(LoopInterval * 1000)"}
{"query": "请生成一个Python版多品种追涨杀跌策略教学策略代码", "base_model_response": "", "lora_model_response": "```python\ndef strategy_invest():\n    # 主动买入，根据买卖情况，判断是否是主动跟仓或被动持有\n    pass\n    \ndef strategy_outperform():\n    # 主动卖出，如果市场情绪有变或者趋势明显\n    pass\n    \ndef strategy_win():\n    # 按照时间的顺序进行，先买进、然后卖出\n    pass\n    \ndef strategy_loss():\n    # 采取止损策略\n    pass\n    \ndef trade():\n    \n    # 主动买入和卖出去\n    if strategy_invest() and strats_outperform():\n        trade(\"in\")\n        if strategy_invest():\n            strategy_invest()\n    elif strategy_invest():\n        trade(\"out\")\n        \nif __name__ == \"__main__\":\n    \n    # 事件触发回调\n    event = \"order raised\"\n    print(event)\n    print(\"1. 停止交易, 进行交易.\")\n    print(\"2. 准备再次发布订单\")\n    strats_invest()\n    strats_outperform()\n    \n    # 如果是主动跟进并确认无误后进行盈利退出\n    if strategy_win():\n        trade()\n    \n    # 启动新的交易周期\n    if strats_outperform():\n        event = \"stop order raise\"\n        print(event)\n        print(\"3. 自定义回调规则或参数\")\n        print()\n        strats_win()\n    \n    # 当前时间结束\n    print(\"\\n当前时间: %s\" % time.strftime(\"%Y-%m-%d %H:%M:%S\"))\n```\n\n注意：这个教学策略的目的是为了提高投资者的投资效率和收益。由于涉及到多个函数的执行，因此在实际的开发中需要注意代码的可读性和清晰性，并且可能会出现各种可能出现的问题，如错误处理、资源耗尽等。", "original_response": "python\n'''backtest\nstart: 2019-02-20 00:00:00\nend: 2020-01-10 00:00:00\nperiod: 1m\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\"},{\"eid\":\"OKEX\",\"currency\":\"ETH_USDT\",\"stocks\":30},{\"eid\":\"OKEX\",\"currency\":\"LTC_USDT\",\"stocks\":100}]\n'''\n\nimport time\nimport json\n\nparams = {\n    \"arrBasePrice\": [-1, -1, -1],     # -1\n    \"arrRatio\": [0.05, 0.05, 0.05],         # 0.05\n    \"arrAcc\": [],           # _C(exchange.GetAccount)\n    \"arrLastCancelAll\": [0, 0, 0], # 0\n    \"arrMinStocks\": [0.01, 0.01, 0.01],     # 0.01\n    \"arrPricePrecision\": [2, 2, 2], # 2\n    \"arrAmountPrecision\": [3, 2, 2], # 2\n    \"arrTick\":[]\n}\n\ndef CancelAll(e):\n    while True : \n        orders = _C(e.GetOrders)\n        for i in range(len(orders)) :\n            e.CancelOrder(orders[i][\"Id\"], orders[i])\n        if len(orders) == 0 :\n            break\n        Sleep(1000)\n\ndef process(e, index):\n    global params\n    ticker = _C(e.GetTicker)\n    params[\"arrTick\"][index] = ticker\n    if params[\"arrBasePrice\"][index] == -1 :\n        params[\"arrBasePrice\"][index] = ticker.Last\n    if ticker.Last - params[\"arrBasePrice\"][index] > 0 and (ticker.Last - params[\"arrBasePrice\"][index]) / params[\"arrBasePrice\"][index] > params[\"arrRatio\"][index]:\n        params[\"arrAcc\"][index] = _C(e.GetAccount)\n        if params[\"arrAcc\"][index].Balance * params[\"arrRatio\"][index] / ticker.Last > params[\"arrMinStocks\"][index]:\n            e.Buy(ticker.Last, params[\"arrAcc\"][index].Balance * params[\"arrRatio\"][index] / ticker.Last)\n            params[\"arrBasePrice\"][index] = ticker.Last\n    if ticker.Last - params[\"arrBasePrice\"][index] < 0 and (params[\"arrBasePrice\"][index] - ticker.Last) / params[\"arrBasePrice\"][index] > params[\"arrRatio\"][index]: \n        params[\"arrAcc\"][index] = _C(e.GetAccount)\n        if params[\"arrAcc\"][index].Stocks * params[\"arrRatio\"][index] > params[\"arrMinStocks\"][index]:\n            e.Sell(ticker.Last, params[\"arrAcc\"][index].Stocks * params[\"arrRatio\"][index])\n            params[\"arrBasePrice\"][index] = ticker.Last\n    ts = time.time()\n    if ts - params[\"arrLastCancelAll\"][index] > 60 * 5 :\n        CancelAll(e)\n        params[\"arrLastCancelAll\"][index] = ts \n\ndef main():\n    global params\n    \n    for i in range(len(exchanges)) :    \n        params[\"arrAcc\"].append(_C(exchanges[i].GetAccount))\n        params[\"arrTick\"].append(_C(exchanges[i].GetTicker))\n        exchanges[i].SetPrecision(params[\"arrPricePrecision\"][i], params[\"arrAmountPrecision\"][i])\n\n    for key in params :\n        if len(params[key]) < len(exchanges):\n            raise \"params error!\"\n\n    while True:\n        tblAcc = {\n            \"type\" : \"table\",\n            \"title\": \"account\",\n            \"cols\": [\"账户信息\"], \n            \"rows\": []\n        }        \n\n        tblTick = {\n            \"type\" : \"table\",\n            \"title\": \"ticker\",\n            \"cols\": [\"行情信息\"], \n            \"rows\": []\n        }\n        for i in range(len(exchanges)): \n            process(exchanges[i], i)\n\n        for i in range(len(exchanges)):\n            tblAcc[\"rows\"].append([json.dumps(params[\"arrAcc\"][i])])\n            tblTick[\"rows\"].append([json.dumps(params[\"arrTick\"][i])])\n\n        LogStatus(_D(), \"\\n`\" + json.dumps([tblAcc, tblTick]) + \"`\")\n        Sleep(500)"}
{"query": "请生成一个Python版多图表范例策略代码", "base_model_response": "```python\nimport matplotlib.pyplot as plt\nfrom pandas import DataFrame as pd\n\n# 假设df 是你要用的多图表数据\ndf = {'name': ['John', 'Jane', 'Bob'], 'age': [25, 30, 40]}\ndf['income'] = df['age'].cumsum()\n\n# 绘制多图表的数据\nfig, ax = plt.subplots(1, 2)\n\n# 比例：绘制两个饼图，左侧是收入高的人数，右侧是收入低的人数\nax.pie(df income, labels=df['income'])\nax.set_title('Average Income')\n\n# 比例：绘制收入与年龄的折线图\nax.plot(df['age'], df['income'])\nax.set_xlabel('Age')\nax.set_ylabel('Income')\n\n# 比例：绘制工资、学历等信息的条形图\nax.bar(df['salary'], df['education'])\nax.set_xlabel('Salary')\nax.set_ylabel('Education')\n\n# 配置图形标题和轴标签，可以自定义图形名称\nplt.title('Average Income vs. Age and Education')\nplt.xlabel('Age')\nplt.ylabel('Income')\nplt.legend(loc='lower left', prop={'shared': False})\n\n# 显示图例\nplt.show()\n```\n\n这个例子使用了matplotlib库来创建复杂的多图表，包括饼图、折线图、条形图以及他们的对应轴标签。同时，它还根据用户的需求进行了更改和调整。\n\n注意，这个例子假设你的数据是以数值类型（如`int`, `float`, `char`）表示的，并且你的图表在`matplotlib`库下运行。如果你的数据是其他类型（如列表或字符串），你可能需要先将它们转换为数值类型然后再绘制。", "lora_model_response": "，生成的多图表的参数包括：标题，颜色范围，标签，坐标轴，图形类型\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    # 获取数据\n    df = pd.read_csv('data.csv')\n    # 设置日期格式为MM-DD\n    df['Date'] = pd.to_datetime(df['Date'])\n    # 获取所有的列，并按照顺序排序\n    columns = df.columns.tolist()\n    print(columns)\n    # 按照指定的时间值获取每一列的数据\n    column_list = df[column].tolist()\n    \n    # 连接到数组的后端，获取新的日期和时间\n    url = 'http://www.example.com/data'\n    data = json.loads(url)\n    \n    # 根据新的日期和时间设置图并返回结果\n    result = df.plot(column_list, x=data.keys(), y=data.values())\n    return result\n\nif __name__ == '__main__':\n    main()\n```\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom datetime import date, timedelta\n\n\ndef main():\n    # 将列表添加到字典中（用于获取日期）\n    dates = ['2018-04-30', '2017-05-01']\n    dates_dict = {date: date for date in dates}\n    # 创建一个新的字典用来存储已经计算过的日期和时间\n    dates_dict['Last'] = date + timedelta(days=1)  # 重复使用\n    date = date + timedelta(days=1)\n\n    # 计算并打印所有列\n    rows = df[df.columns].values\n    if len(rows) != len(date):\n        rows = rows[0]\n        date = date\n    else:\n        date = row\n\n    # 再次创建一个新的字典来存储已经计算过的日期和时间\n    dates_dict['Last'] = date - timedelta(days=1)  # 重复使用\n    date = date + timedelta(days=1)\n\n    # 将新日期转换为字符串\n    date_str = date.strftime('%Y-%m-%d')\n\n    # 将第一个元素添加到字典中（用于计算当前日期）同时添加日期\n    # 初始时是完整的日期\n    dates_dict[date_str] = date + timedelta(days=1)  # 转换为字符串\n    # 如果第一个元素是一个列表，就更新第一个元素的长度\n    if date_str.split('-')[0]:\n        for i in range(len(date_str)):\n            dates_dict[date_str[i]] = date + timedelta(days=i+1)  # 把新的日期加入第二个元素\n    return dates_dict\n\n\ndef main():\n    # 将列表添加到字典中（用于计算时间）\n    times = [123456, 123457, 123458, 123459, 123460]\n    times_dict = {time: time*10 for time in times}\n    # 创建一个新的字典用来存储已经计算过的日期和时间\n    times_dict['Last'] = time + timedelta(hours=1)  # 重复使用\n    time = time + timedelta(hours=1)\n\n    # 计算并打印所有列\n    rows = df[df.columns].values\n    if len(rows) != len(time):\n        rows = rows[0]\n        time = time + timedelta(hours=1)  # 重复使用\n    else:\n        time = row\n\n    # 将新日期转换为字符串\n    date_str = date.strftime('%H:%M:%S')\n    time_str = time.strftime('%A:%d %Y')\n\n    # 将第一个元素添加到字典中（用于计算当前时间）\n    dates_dict[date_str] = time + timedelta(hours=1)  # 转换为字符串\n    # 如果第一个元素是一个列表，就更新第一个元素的长度\n    if time_str.split('-')[0]:\n        for i in range(len(time_str)):\n            dates_dict[date_str[i]] = time + timedelta(hours=i+1)  # 把新的日期加入第三个元素\n    return dates_dict\n\n\ndef main():\n    # 将列表添加到字典中（用于计算时间）\n    counts = {1:1,2:1,3:2,4:1}\n    counts_dict = {count: count*1000 for count in counts}\n    # 创建一个新的字典用来存储已经计算过的日期和时间\n    counts_dict['Last'] = counts_time + timedelta(hours=1)  # 转换为字符串\n    # 如果第一个元素是一个列表，就更新第一个元素的长度\n    if time_str.split('-')[0]:\n        for i in range(len(time_str)):\n            counts_dict[counts_str[i]] = counts[i", "original_response": "python\n'''backtest\nstart: 2019-01-22 00:00:00\nend: 2019-01-23 00:00:00\nperiod: 30m\nexchanges: [{\"eid\":\"OKCoin_EN\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport random\nimport time\ndef main():\n    cfgA = {\n        \"extension\" : {\n            \"layout\" : \"single\", \n            \"height\" : 300,\n            \"col\" : 8\n        }, \n        \"title\" : {\n            \"text\" : \"盘口图表\"\n        },\n        \"xAxis\" : {\n            \"type\" : \"datetime\" \n        }, \n        \"series\" : [{\n            \"name\" : \"买一\",\n            \"data\" : []\n        }, {\n            \"name\" : \"卖一\", \n            \"data\" : []\n        }]\n    }    \n\n    cfgB = {\n        \"title\" : {\n            \"text\" : \"差价图\"\n        }, \n        \"xAxis\" : {\n            \"type\" : \"datetime\",\n        }, \n        \"series\" : [{\n            \"name\" : \"差价\", \n            \"type\" : \"column\", \n            \"data\" : []\n        }]\n    }    \n\n    cfgC = {\n        \"__isStock\" : False,\n        \"title\" : {\n            \"text\" : \"饼图\"\n        }, \n        \"series\" : [{\n            \"type\" : \"pie\", \n            \"name\" : \"one\", \n            \"data\" : [\n                [\"A\", 25],\n                [\"B\", 25],\n                [\"C\", 25],\n                [\"D\", 25],\n            ]\n        }]\n    }    \n\n    cfgD = {\n        \"extension\" : {\n            \"layout\" : \"single\",\n            \"col\" : 8,\n            \"height\" : \"300px\"\n        }, \n        \"title\" : {\n            \"text\" : \"盘口图表\"\n        }, \n        \"series\" : [{\n            \"name\" : \"买一\", \n            \"data\" : []\n        }, {\n            \"name\" : \"卖一\",\n            \"data\" : []\n        }]\n    }    \n\n    cfgE = {\n        \"__isStock\" : False, \n        \"extension\" : {\n            \"layout\" : \"single\", \n            \"col\" : 4,\n            \"height\" : \"300px\"\n        }, \n        \"title\" : {\n            \"text\" : \"饼图2\"\n        },\n        \"series\" : [{\n            \"type\" : \"pie\",\n            \"name\" : \"one\", \n            \"data\" : [\n                [\"A\", 25], \n                [\"B\", 25], \n                [\"C\", 25], \n                [\"D\", 25]\n            ]\n        }]\n    }\n    \n    chart = Chart([cfgA, cfgB, cfgC, cfgD, cfgE])\n    chart.reset()\n    chart.add(3, {\n        \"name\" : \"ZZ\",\n        \"y\" : random.random() * 100\n    })\n    \n    while True:\n        Sleep(1000)\n        ticker = exchange.GetTicker()\n        if not ticker :\n            continue\n        diff = ticker[\"Sell\"] - ticker[\"Buy\"]\n        cfgA[\"subtitle\"] = {\n            \"text\" : \"买一\" + str(ticker[\"Buy\"]) + \"卖一\" + str(ticker[\"Sell\"])\n        }\n        cfgB[\"subtitle\"] = {\n            \"text\" : \"价差 \" + str(diff)\n        }\n        \n        chart.add(0, [time.time() * 1000, ticker[\"Buy\"]])\n        chart.add(1, [time.time() * 1000, ticker[\"Sell\"]])\n        chart.add(2, [time.time() * 1000, diff])\n        chart.add(4, [time.time() * 1000, ticker[\"Buy\"]])\n        chart.add(5, [time.time() * 1000, ticker[\"Buy\"]])\n        cfgC[\"series\"][0][\"data\"][0][1] = random.random() * 100\n        cfgE[\"series\"][0][\"data\"][0][1] = random.random() * 100"}
{"query": "请生成一个Python版简单网格策略教学策略代码", "base_model_response": "示例\n\n```python\nclass GridGame:\n    def __init__(self):\n        self.grid = [['', ''], ['', ''], ['', '']], [''], [''], ['']\n        self.player_name = None\n\n    def setPlayer(self, player_name):\n        self.player_name = player_name\n\n\n    def run(self):\n        while True:\n            grid = self.grid\n            print(\"Start of game...\")\n            for row in grid:\n                for col in row:\n                    if board[row][col] != '':\n                        board[row][col] = self.player_name\n                        break\n            print(\"\\n\")\n            print(\"Game over!\")\n            break\n        print(\"\\n\")\n```\n\n这是一个简单的网格策略，玩家可以通过控制行数和列数来改变游戏状态。在运行此程序时，它将显示开始与结束的屏幕，并每过一段时间就打印出游戏的状态。\n\n请注意，此程序是一个基本的示例，实际的游戏可能需要更复杂的策略，并且会考虑更多的因素，例如：棋盘的大小、对手的策略等等。", "lora_model_response": "，", "original_response": "python\n'''backtest\nstart: 2019-07-01 00:00:00\nend: 2020-01-03 00:00:00\nperiod: 1m\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\"}]\n'''\n\nimport json\n\n# 参数\nbeginPrice = 5000\nendPrice = 8000\ndistance = 20\npointProfit = 50\namount = 0.01\nminBalance = 300\n\n# 全局变量\narrNet = []\narrMsg = []\nacc = None\n\ndef findOrder (orderId, NumOfTimes, ordersList = []) :\n    for j in range(NumOfTimes) :\n        orders = None\n        if len(ordersList) == 0:\n            orders = _C(exchange.GetOrders)\n        else :\n            orders = ordersList\n        for i in range(len(orders)):\n            if orderId == orders[i][\"Id\"]:\n                return True\n        Sleep(1000)\n    return False\n\ndef cancelOrder (price, orderType) :\n    orders = _C(exchange.GetOrders)\n    for i in range(len(orders)) : \n        if price == orders[i][\"Price\"] and orderType == orders[i][\"Type\"]: \n            exchange.CancelOrder(orders[i][\"Id\"])\n            Sleep(500)\n\ndef checkOpenOrders (orders, ticker) :\n    global arrNet, arrMsg\n    for i in range(len(arrNet)) : \n        if not findOrder(arrNet[i][\"id\"], 1, orders) and arrNet[i][\"state\"] == \"pending\" :\n            orderId = exchange.Sell(arrNet[i][\"coverPrice\"], arrNet[i][\"amount\"], arrNet[i], ticker)\n            if orderId :\n                arrNet[i][\"state\"] = \"cover\"\n                arrNet[i][\"id\"] = orderId                \n            else :\n                # 撤销\n                cancelOrder(arrNet[i][\"coverPrice\"], ORDER_TYPE_SELL)\n                arrMsg.append(\"挂单失败!\" + json.dumps(arrNet[i]) + \", time:\" + _D())\n\ndef checkCoverOrders (orders, ticker) :\n    global arrNet, arrMsg\n    for i in range(len(arrNet)) : \n        if not findOrder(arrNet[i][\"id\"], 1, orders) and arrNet[i][\"state\"] == \"cover\" :\n            arrNet[i][\"id\"] = -1\n            arrNet[i][\"state\"] = \"idle\"\n            Log(arrNet[i], \"节点平仓，重置为空闲状态。\", \"#FF0000\")\n\n\ndef onTick () :\n    global arrNet, arrMsg, acc\n\n    ticker = _C(exchange.GetTicker)\n    for i in range(len(arrNet)):\n        if i != len(arrNet) - 1 and arrNet[i][\"state\"] == \"idle\" and ticker.Sell > arrNet[i][\"price\"] and ticker.Sell < arrNet[i + 1][\"price\"]:\n            acc = _C(exchange.GetAccount)\n            if acc.Balance < minBalance :\n                arrMsg.append(\"资金不足\" + json.dumps(acc) + \"！\" + \", time:\" + _D())\n                break\n\n            orderId = exchange.Buy(arrNet[i][\"price\"], arrNet[i][\"amount\"], arrNet[i], ticker)\n            if orderId : \n                arrNet[i][\"state\"] = \"pending\"\n                arrNet[i][\"id\"] = orderId\n            else :\n                # 撤单\n                cancelOrder(arrNet[i][\"price\"], ORDER_TYPE_BUY)\n                arrMsg.append(\"挂单失败!\" + json.dumps(arrNet[i]) + \", time:\" + _D())\n    Sleep(1000)\n    orders = _C(exchange.GetOrders)\n    checkOpenOrders(orders, ticker)\n    Sleep(1000)\n    orders = _C(exchange.GetOrders)\n    checkCoverOrders(orders, ticker)\n\n    tbl = {\n        \"type\" : \"table\", \n        \"title\" : \"网格状态\",\n        \"cols\" : [\"节点索引\", \"详细信息\"], \n        \"rows\" : [], \n    }    \n\n    for i in range(len(arrNet)) : \n        tbl[\"rows\"].append([i, json.dumps(arrNet[i])])\n\n    errTbl = {\n        \"type\" : \"table\", \n        \"title\" : \"记录\",\n        \"cols\" : [\"节点索引\", \"详细信息\"], \n        \"rows\" : [], \n    }\n\n    orderTbl = {\n     \t\"type\" : \"table\", \n        \"title\" : \"orders\",\n        \"cols\" : [\"节点索引\", \"详细信息\"], \n        \"rows\" : [],    \n    }\n\n    while len(arrMsg) > 20 : \n        arrMsg.pop(0)\n\n    for i in range(len(arrMsg)) : \n        errTbl[\"rows\"].append([i, json.dumps(arrMsg[i])])    \n\n    for i in range(len(orders)) : \n        orderTbl[\"rows\"].append([i, json.dumps(orders[i])])\n\n    LogStatus(_D(), \"\\n\", acc, \"\\n\", \"arrMsg length:\", len(arrMsg), \"\\n\", \"`\" + json.dumps([tbl, errTbl, orderTbl]) + \"`\")\n\n\ndef main ():\n    global arrNet\n    for i in range(int((endPrice - beginPrice) / distance)):\n        arrNet.append({\n            \"price\" : beginPrice + i * distance,\n            \"amount\" : amount,\n            \"state\" : \"idle\",    # pending / cover / idle\n            \"coverPrice\" : beginPrice + i * distance + pointProfit,\n            \"id\" : -1,\n        })\n        \n    while True:\n        onTick()\n        Sleep(500)"}
{"query": "请生成一个Python版追涨杀跌策略教学策略代码", "base_model_response": "。\n\n```python\nclass FinancialProphet:\n    def __init__(self):\n        self.model = None\n\n    def add_to_model(self, y_data, z_data):\n        \"\"\"\n        This method adds the data from both input sources to the model.\n        \"\"\"\n        self.model.add_data((y_data, z_data))\n\n    def predict(self, x_data):\n        \"\"\"\n        This method makes an prediction based on the input data.\n        \"\"\"\n        return self.model.predict(x_data)\n\n# Use the class to make predictions for historical prices\nprophet = FinancialProphet()\npredicted_prices = prophet.predict([1, 2, 3, 4, 5])\nprint(predicted_prices)\n```\n\n这个脚本是一个简单的追涨杀跌策略。它首先定义了一个`FinancialProphet`类，然后创建了一个`add_to_model`方法来将输入数据添加到模型中。`predict`方法用于根据输入数据预测未来价格。最后，它使用`prophet.predict`方法来预测未来的股票价格。\n\n请注意，这只是一个基本的框架，你可能需要根据你的具体情况进行调整和优化。例如，你可能需要对数据进行预处理（如移除异常值或缺失值），或者学习如何构建更复杂的机器学习模型。", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2019-02-20 00:00:00\nend: 2020-01-10 00:00:00\nperiod: 1m\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\"}]\n'''\n\nimport time\n\nbasePrice = -1\nratio = 0.05\nacc = _C(exchange.GetAccount)\nlastCancelAll = 0\nminStocks = 0.01\n\ndef CancelAll():\n    while True : \n        orders = _C(exchange.GetOrders)\n        for i in range(len(orders)) :\n            exchange.CancelOrder(orders[i][\"Id\"], orders[i])\n        if len(orders) == 0 :\n            break\n        Sleep(1000)\n\ndef main():\n    global basePrice, acc, lastCancelAll\n    exchange.SetPrecision(2, 3)\n    while True:\n        ticker = _C(exchange.GetTicker)\n        if basePrice == -1 :\n            basePrice = ticker.Last\n        if ticker.Last - basePrice > 0 and (ticker.Last - basePrice) / basePrice > ratio :\n            acc = _C(exchange.GetAccount)\n            if acc.Balance * ratio / ticker.Last > minStocks :\n                exchange.Buy(ticker.Last, acc.Balance * ratio / ticker.Last)\n                basePrice = ticker.Last\n        if ticker.Last - basePrice < 0 and (basePrice - ticker.Last) / basePrice > ratio : \n            acc = _C(exchange.GetAccount)\n            if acc.Stocks * ratio > minStocks :\n                exchange.Sell(ticker.Last, acc.Stocks * ratio)\n                basePrice = ticker.Last\n        ts = time.time()\n        if ts - lastCancelAll > 60 * 5 :\n            CancelAll()\n            lastCancelAll = ts \n        LogStatus(_D(), \"\\n\", \"行情信息:\", ticker, \"\\n\", \"账户信息:\", acc)\n        Sleep(500)"}
{"query": "请生成一个Python版追涨杀跌策略教学币安USDT永续合约策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2021-05-01 00:00:00\nend: 2021-05-29 00:00:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"BTC_USDT\"}]\n'''\n\n# 原版代码是现货版：\n# https://www.fmz.com/bbs-topic/4908\n\n# 现在改为合约版。\n\n# ———— 韬奋量化（微信：himandy）\n\n\n# 好的交易平台可以让你的策略扶摇直上九万里，通过链接注册可获得两个月VIP5的手续费率优惠：\n# （现货：挂单0%，吃单0.07%。合约：挂单0%，吃单0.04%）\n# https://www.kucoin.cc/ucenter/signup?rcode=1wxJ2fQ&lang=zh_CN&utmsource=VIP_TF\n\nimport time\n\nbasePrice = -1\nratio = 0.05\nacc = _C(exchange.GetAccount)\npos = _C(exchange.GetPosition)\nlastCancelAll = 0\nminStocks = 0.01\n\ndef CancelAll():\n    while True : \n        orders = _C(exchange.GetOrders)\n        for i in range(len(orders)) :\n            exchange.CancelOrder(orders[i][\"Id\"], orders[i])\n        if len(orders) == 0 :\n            break\n        Sleep(1000)\n\ndef main():\n    global basePrice, acc, lastCancelAll, leverage, StopGain, StopLoss\n    #Log(StopLoss * -1)\n    exchange.SetContractType(\"swap\")\n    exchange.SetMarginLevel(leverage)\n    exchange.SetPrecision(2, 3)\n    pos = _C(exchange.GetPosition)\n    while True:\n        ticker = _C(exchange.GetTicker)\n        if basePrice == -1 :\n            basePrice = ticker.Last\n        if ticker.Last - basePrice > 0 and (ticker.Last - basePrice) / basePrice > ratio :\n            acc = _C(exchange.GetAccount)            \n            if acc.Balance * ratio * leverage / ticker.Last > minStocks and len(pos) == 0:\n                exchange.SetDirection(\"buy\")\n                exchange.Buy(_N(ticker.Last, 2), _N(acc.Balance * ratio / ticker.Last, 3))\n                basePrice = ticker.Last\n                ts = time.time()\n                if ts - lastCancelAll > 60 * 5 :\n                    CancelAll()\n                    lastCancelAll = ts\n                pos = _C(exchange.GetPosition)\n        if ticker.Last - basePrice < 0 and (basePrice - ticker.Last) / basePrice > ratio : \n            acc = _C(exchange.GetAccount)\n            pos = _C(exchange.GetPosition)\n            if acc.Balance * ratio * leverage / ticker.Last > minStocks and len(pos) == 0:\n                exchange.SetDirection(\"sell\")\n                exchange.Sell(_N(ticker.Last, 2), _N(acc.Balance * ratio / ticker.Last, 3))\n                basePrice = ticker.Last\n                ts = time.time()\n                if ts - lastCancelAll > 60 * 5 :\n                    CancelAll()\n                    lastCancelAll = ts\n                pos = _C(exchange.GetPosition)\n        if len(pos) == 1 :\n        \t#Log(pos)\n            if pos[0][\"Profit\"] / pos[0][\"Margin\"] > StopGain :\n                if pos[0][\"Type\"] == 0 :\n                    exchange.SetDirection(\"closebuy\")\n                    exchange.Sell(-1, pos[0][\"Amount\"])\n                    pos = _C(exchange.GetPosition)\n                elif pos[0][\"Type\"] == 1 :\n                    exchange.SetDirection(\"closesell\")\n                    exchange.Buy(-1, pos[0][\"Amount\"])\n                    pos = _C(exchange.GetPosition)\n            elif pos[0][\"Profit\"] / pos[0][\"Margin\"] < StopLoss * -1 :\n                if pos[0][\"Type\"] == 0 :\n                    exchange.SetDirection(\"closebuy\")\n                    exchange.Sell(-1, pos[0][\"Amount\"])\n                    pos = _C(exchange.GetPosition)\n                elif pos[0][\"Type\"] == 1 :\n                    exchange.SetDirection(\"closesell\")\n                    exchange.Buy(-1, pos[0][\"Amount\"])\n                    pos = _C(exchange.GetPosition)\n\n        LogStatus(_D(), \"\\n\", \"行情信息:\", ticker, \"\\n\", \"账户信息:\", acc)\n        if exchange.GetName() == \"Futures_Binance\" and IsVirtual() == false :\n            LogProfit(_N(float(acc[\"Info\"][\"totalWalletBalance\"], 4)))\n        Sleep(500)"}
{"query": "请生成一个Python简单测试策略策略代码", "base_model_response": "", "lora_model_response": "。\n\n```python\ndef strategy(prices):\n    \"\"\"\n    A simple strategy for the return of a given price. Returns the price if it's not sold yet,\n    returns 0 otherwise.\n    \"\"\"\n    # First, we check if the market is closed\n    if prices[-1] == prices[-2]:\n        return 0\n\n    # For now, we'll look at the open day price and check if it matches the closing price\n    # The last day price can be obtained by subtracting the first from the second\n    close_price = prices[-3]\n    open_price = prices[-1]\n\n    if close_price - open_price > 5:  # 5 is the floor price limit\n        return prices[-1] + 5\n\n    else:  # This case we don't need to check opening\n        return 0\n```\n\n该策略假设当价格低于5时，它只返回卖出价，而其他情况则返回0。如果您需要考虑更多的因素，您可以在代码中添加更复杂或更精确的逻辑。", "original_response": "python\nimport time\nimport talib\n\ndef main():\n    LogProfitReset()\n    LogReset()\n    Log(\"init OK\", time.strftime('%Y-%m-%d %X', time.localtime(time.time())))\n    Log(a,b,c,d)\n    _G(\"ok\", 123)\n    Log(GetPid(), _G(), _G(\"ok\"), _G(\"dummy\"))\n    Sleep(1000)\n    _G(None)\n    Log(_G(\"ok\"))\n\n    LogStatus(\"Time\", time.time())\n    EnableLog(True)\n    SetErrorFilter(\"net\")\n    Log(GetLastError())\n    Log(GetCommand())\n    ticker = exchange.GetTicker()\n    Log('ticker buy', ticker.Buy, ticker['Buy']);\n    \n    r = _C(exchange.GetRecords)\n    Log(TA.ATR(r))\n    Log(TA.EMA(r, 10))\n    # test talib\n    Log(str(talib.EMA(r.Close, 10)))\n\n    for e in exchanges:\n        Log(e.GetName(), e.GetRate(), e.GetCurrency())\n        Log(e.GetAccount())\n        Log(_C(e.GetOrders))\n        Log(e.GetOrder(10))\n        Log(e.CancelOrder(10000))\n \n        Log(e.GetUSDCNY())\n        #Log(e.GetPosition())\n        #Log(e.SetContractType(\"next_week\"))\n        Log(e.GetTicker())\n        Log('Asks:', len(e.GetDepth().Asks))\n        #Log(e.SetMarginLevel(10))\n        #Log(e.SetDirection(\"buy\"))\n        #Log(e.SetContractType(\"quarter\"))\n        #Log(e.GetRecords(PERIOD_M30)[0])\n        Log(e.GetRecords()[0])\n    x = Chart({\n        'title' : { 'text' : 'test chart'},\n        'xAxis': { 'type': 'datetime'},\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\n        })\n    x.reset()\n    Log(\"策略将每10秒更新一次ticker\");\n    for i in range(100):\n        ts = int(time.time() * 1000)\n        ticker = _C(exchange.GetTicker)\n        x.add(0, [ts, ticker.Buy])\n        x.add(1, [ts, ticker.Sell])\n        LogStatus(ticker)\n        Sleep(10000)"}
{"query": "请生成一个R-Breaker-交易策略策略代码", "base_model_response": "```R\n# 定义一个函数来执行交易，参数包括资金金额、最小单位（可选）和最大单位\nlibrary(Rvest)\n\n# 设置函数的返回值类型\nreturn_type <- '交易结果'\n\n# 函数将使用内置的Rvest库进行操作，并返回处理后的交易结果\ndef on交易(event, data) {\n  # 将事件传递给Rvest包中定义的函数\n  response <- fetch({\n    .result <- data\n    .error <- 0\n  })\n\n  # 如果数据成功解析并发送给服务器，则返回处理后的结果\n  if (response$success) {\n    return_data(response)\n  } else {\n    return_error(\"没有正确解析\")\n  }\n}\n\n# 定义一个主函数，接受用户输入，然后运行on交易函数并将结果封装成一个Rvest对象\nmain <- function() {\n  # 获取用户输入的金额\n  amount <- read.csv('amount.csv')\n\n  # 使用Rvest库进行交易\n  on交易(amount, data.frame(date = as.Date(date), product = as.Date(product)))\n\n  # 检查交易是否成功\n  return_data(on_test())\n\n}\n\n# 主函数将包含以下代码\nmain()\n```\n\n这个R-R Breaker交易策略策略首先定义了一个函数`on交易`，该函数接受用户输入的金额，然后调用Rvest包中的函数执行交易。函数将使用内置的Rvest库进行操作，并返回处理后的结果。如果交易成功解析并发送给服务器，则返回处理后的结果。否则，返回错误信息。\n\n请注意，这只是一个基础的R-R Breaker策略，实际交易可能会根据具体情况进行调整。例如，您可能需要使用不同的查询语言或者参数，以实现更复杂的交易功能。", "lora_model_response": "", "original_response": "python\n#!/usr/local/bin/python\n#-*- coding: UTF-8 -*-\n#R-Breaker 交易策略\n#策略提供者 @FJK   QQ:171938416\n#改进  @太极  QQ:7650371\n\ndef my_buy(): #开仓\n    try:\n        global buy_price,buy_qty\n        initAccount = ext.GetAccount()  #交易模板的导出函数， 获得账户状态，保存策略运行前账户初始状态\n        opAmount=1\n        PositionRatio =1\n        #开仓之前判断有币没有没有先进行买入\n        if int(initAccount.Stocks)>1:\n            if buy_price<1:\n                buy_price=_C(exchange.GetTicker).Last\n                buy_qty=initAccount.Stocks\n            #Log('开仓信息1 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\n            return 1\n        if int(initAccount.Stocks)<1:\n            if int(str(initAccount.Stocks).replace('0.',''))>=3:\n                if buy_price<1:\n                    buy_price=_C(exchange.GetTicker).Last\n                    buy_qty=initAccount.Stocks\n                #Log('开仓信息2 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\n                return 1\n\n        #if int(str(initAccount.Stocks).replace('0.',''))==0:\n        opAmount = _N(initAccount.Balance*PositionRatio,3)  #买入数量\n        Log(\"开仓没有币先进行 开仓买入%s元\"%(str(opAmount)))   #生成LOG日志\n\n        Dict = ext.Buy(opAmount)  #买入ext.Buy\n        if(Dict):#确认开仓成功\n            buy_price=Dict['price'] #买入价格   #{'price': 4046.446, 'amount': 1.5}\n            buy_qty=Dict['amount']  #买入数量\n            #LogProfit(_N(gains,4),'开仓信息 钱:',initAccount.Balance,'--币:',initAccount.Stocks,'--开仓详情:',Dict)\n            print_log(1,initAccount)\n            return 1\n        return 0\n\n    except Exception,ex:\n        Log('except Exception my_buy:',ex)\n        return 0\n\n\nimport time\nimport datetime\ndef Caltime(date1,date2):   #计算运行天数\n    try:\n        date1=time.strptime(date1,\"%Y-%m-%d %H:%M:%S\")\n        date2=time.strptime(date2,\"%Y-%m-%d %H:%M:%S\")\n        date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])\n        date2=datetime.datetime(date2[0],date2[1],date2[2],date2[3],date2[4],date2[5])\n        return date2-date1\n    except Exception,ex:\n        Log('except Exception Caltime:',ex)\n        return \"except Exception\"\n\nstart_timexx =time.localtime(time.time()) #time.clock()\nstart_time=time.strftime(\"%Y-%m-%d %H:%M:%S\",start_timexx)\nbuy_price=0 #买入价格\nbuy_qty=0  #买入数量\ngains=0  #盈利\n\nbeng_Account = ext.GetAccount()  #初始化信息\nbeng_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\nbeng_Balance=(beng_Account.Stocks*beng_ticker)+beng_Account.Balance #初始化账户钱\ndef print_log(k_p,data=\"\"):  #输出\n    try:\n        name=\"\"\n        if k_p:\n            name=\"开仓\"\n        else:\n            name=\"平仓\"\n        global beng_Account,beng_ticker,beng_Balance\n        global gains\n        end_Account = ext.GetAccount()  #当前账户信息\n        end_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\n        #################################################\n        date1=time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime(time.time()))\n        msg_data0=(\"本次开始运行时间:%s已运行:%s\\r\\n\"%(start_time,Caltime(start_time,date1)))\n        #################################################\n        msg_data1=(\"本次初始化状态:%s\\r\\n当前运行状态:%s\\r\\n\"%(beng_Account,end_Account))\n        #################################################\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\n        msg_data2=(\"初始化钱:%s现在钱:%s盈亏:%s\\r\\n\"%(str(beng_Balance),str(end_Balance),str(end_Balance-beng_Balance)))\n        #################################################\n        total = end_Account.Balance+end_Account.Stocks*_C(exchange.GetTicker).Last #账户总额\n        roi = ((total/beng_Balance) -1)*100\n        msg_data3=(\"当前状态:%s--钱:%s--币:%s--总值约:%.2f\\r\\n\"%(str(name),str(end_Account.Balance),str(end_Account.Stocks),roi))\n        #################################################\n        income = total - beng_Account['Balance'] - beng_Account['Stocks']*beng_ticker #总盈亏\n        msg_data4=(\"本次盈亏:%s(RMB)\\t总盈亏:%.2f(RMB) %.2f\\r\\n\"%(str(gains),income,roi))\n        #################################################\n        #盈利计算方法\n        #盈利计算方法   浮动利润： 按 （现在币 - 初始币）x 现在的价格 + （现在的钱 - 初始的钱）\n        diff_stocks=end_Account.Stocks-beng_Account.Stocks    #比的差值\n        diff_balance=end_Account.Balance-beng_Account.Balance   #钱的差值\n        new_end_balance=diff_stocks*end_ticker+diff_balance #实现盈亏   #当前的盈利\n        #盈利计算方法   账面利润 ： （现在币 x 现在价格+现在钱） - （初始币 x 初始价格 + 初始钱）\n        new_end_balance2=(end_Account.Stocks*end_ticker+end_Account.Balance)-(beng_Account.Stocks*beng_ticker+beng_Account.Balance)\n        msg_data5=(\"浮动利润:%s(RMB)\\r\\n账面利润:%s(RMB)\\r\\n\"%(str(_N(new_end_balance,3)),str(_N(new_end_balance2,3))))\n        #################################################\n        LogStatus(\"初始化投入2016/9/24  投入0.2个币=等于行情800RMB\\r\\n\",\n                  msg_data0,msg_data1,msg_data2,msg_data3,msg_data4,msg_data5,\n                  \"更新时间:%s\\r\\n\"%(date1),\n                  \"%s\"%(data)\n                  )\n        #################################################\n        #################################################\n        #################################################\n    except Exception,ex:\n        Log('except Exception print_log:',ex)\n\ndef my_sell(): #平仓\n    try:\n        global buy_price,buy_qty,gains,ExitPeriod\n        ExitPeriod = 0\n        nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\n        if nowAccount.Stocks<=0.002:  #保证满足交易量\n            #Log('不满足最小交易量:',nowAccount.Stocks)\n            return 1\n\n        #history_Last=_N(Volume_averages(Ticker_list),2)    #历史均价\n        #cur_last = _N(_C(exchange.GetTicker).Last,2)\n\n        #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod :   #当前价格一定要大于  开仓价格\n        if True:\n            #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod and  history_Last - cur_last >0 and  history_Last - cur_last < 2 :   #当前价格一定要大于  开仓价格\n            #Log('历史差价:',history_Last - cur_last)\n            Dict = ext.Sell(nowAccount.Stocks)\n            #Dict ={\"price\":_C(exchange.GetTicker).Last}\n            if(Dict):\n                #sell_count+=1\n                sell_gains=(Dict['price']-buy_price)*Dict['amount']\n                gains=gains+sell_gains\n                buy_price=0 #买入价格\n                buy_qty=0  #买入数量\n                LogProfit(_N(gains,4),'平仓信息 钱:',nowAccount.Balance,'--币:',nowAccount.Stocks,'--平仓详情:',Dict)#收益曲线\n                print_log(0,nowAccount)\n                return 1\n        else:\n            current_Last = _N(_C(exchange.GetTicker).Last,2)    ##当前价格\n            data=\"不具备平仓条件:买入-当前=差价:%s-%s=%s\"%(buy_price,current_Last,_N(buy_price-current_Last,2))\n            print_log(0,nowAccount,data)\n        return 0\n    except Exception,ex:\n        Log('except Exception my_sell:',ex)\n        return 0\n\n########################################################\ndef onTick():\n    try:\n        records =exchange.GetRecords()  #由你自己设定的周期数返回的数据\n        HH = records[-2]['High'] #最日最高\n        LC = records[-2]['Low']  #昨日最低\n        HC = records[-2]['Close'] #昨日收盘\n        LL = records[-2]['Low']  #昨日最低\n        Pivot = (HH+HC+LC)/3 #枢轴点\n        R1 = 2*Pivot-LC #阻力1\n        R2 = Pivot+(HH-LC) #阻力2\n        R3 = HH +2*(Pivot-LC) #阻力3\n\n        S1 = 2*Pivot-HH  #支撑位1\n        S2 = Pivot - (HH-LC)  #支撑位2\n        S3 = LC-2*(HH-Pivot)  #支撑位3\n        #Log('r1',R1,\"R2\",R2,'R3',R3)\n        #Log('S1',S1,\"S2\",S2,'S3',S3)\n        To = records[-1]['Open'] #今日开盘价\n        Th = records[-1]['High'] #今日最高价\n        Tl = records[-1]['Low'] #今日最低价\n        current_price = _C(exchange.GetTicker).Last #当前价格\n\n        #当前价格>阻力3   开仓\n        if current_price > R3: #突破上轨开多\n            if my_buy(): #Log('多')\n                return\n\n        #当前价格<支撑位3  平仓\n        if current_price < S3: #突破下轨卖空\n            if my_sell(): #Log('空')\n                return\n\n        # 条件1   今日最高价>阻力2\n        # 条件2   今日最高价<阻力3\n        # 条件3   当前价格<阻力1\n        # 同时具备这3个条件平仓\n        if Th >R2 and Th <R3 and current_price <R1: #趋势反转卖出\n            if my_sell(): #Log('空')\n                return\n\n        # 条件1   今日最低价<支撑位2\n        # 条件2   今日最低价>支撑位3\n        # 条件3   当前价格<支撑位1\n        # 同时具备这3个条件开仓\n        if Tl <S2 and Tl >S3 and current_price <S1: #支撑位1\n            if my_buy(): #Log('多')\n                return\n                # Log(records[-1])#今日K\n                # Log(records[-2])#昨日K\n                # Log(exchange.GetTicker())#当前\n\n    except Exception,ex:\n        Log('except Exception onTick:',ex)\n\n\n\ndef main():\n    global outAccount\n    outAccount = ext.GetAccount()  #初始化信息\n    Log(\"run  \",outAccount)  #输出初始账户信息\n    while True:\n        onTick()\n        Sleep(1000)"}
{"query": "请生成一个R-Breaker11-交易策略策略代码", "base_model_response": "```r\n# 定义股票和市场参数\nstock <- c(20, 35)\nmarket <- c(2.5, 4)\norder <- c(5, 7)\n\n# 定义交易日期\n交易_date <- \"2022-06-01\"\n\n# 定义交易开始时间\nstart_time <- \"13:00:00\"\n\n# 定义交易结束时间\nend_time <- \"16:00:00\"\n\n# 绘制图表\nplot(stock, market)\nset title(\"股票市场波动率分析\")\n\n# 选择模型类型和参数\nmodel_type <- \"ARIMA\"\nalpha <- 1\nbeta <- 0.9\n\n# 设置模型\nmodel <- lmer(formula = rbind(order, stock * order - start_time), data = test_data, method = \"ARIMA\", model = model_type, alpha = alpha, beta = beta)\n\n# 计算预测值\npredictions <- predict(model, test_data)\n\n# 预测结果\npredictions[order == 7] <- 110\n\n# 比较实际和预测的偏差\ndiff <- diff(predictions, test_data) / length(test_data)\n\n# 如果差异超过设定的标准差，表示有风险\nif (diff > 2 * sqrt(diff)) {\n    cat(\"当前是高风险期，建议谨慎投资。\")\n} else {\n    cat(\"当前是低风险期，持有中等收益。\")\n}\n```\n\n这个R-Breaker11-交易策略代码定义了一个简单的ARIMA模型，用于预测股票市场的价格变化。在交易过程中，我们设置了每日的价格变化数据，并计算了每个时间段的实际收益率。\n\n注意：这只是一个基本的示例，并且你可能需要根据你的具体需求进行修改和扩展。例如，你可以增加更多的交易日，或者调整模型的参数，以适应更复杂的市场环境。", "lora_model_response": "```\n## 代码描述\n### 1. **函数定义**：这里是R-Breaker11-的函数定义。\n```cpp\n/**\n * R-Breaker11- 单个操作函数\n *\n * @param {Array} inputs 进入执行位数组的输入数据，如0-100\n * @return {Array} 返回在执行位数组中正确的输出结果\n */\nfunc (p: Array) RBRreaker11(inputs: Array, out: Array) {\n    // 获取所有参数\n    for (i = 0; i < len(p); i++) {\n        p[i] = 0\n        // 取出上一步的值，计算新进位\n        let current = p[i]\n        let count = int(toInt(current)) - 1\n        if count > 0 {\n            // 等待新的进位被出现\n            p[i] = int(toInt(p[i]) + Int(count))\n            // 将当前的值（上一步的值）放入下一个进位，并更新\n            p[i + 1] = current % 256\n            // 进行循环\n            break loop()\n        }\n    }\n}\n```\n\n## 2. **数据加载**：假设我们有一个名为 `input` 的数组，它包含每一步的操作数。每次操作后，它会增加一到二十六七四个数字。因此，我们需要从这个数组中提取这些数字，然后将其转换为1到1674431859之间的整数。\n\n### 3. **将操作数据转换为整数**：首先，我们将输入的数据转换成一个长度为8个的数组，以便于我们在操作后进行处理。然后，我们从数组的第一个元素开始遍历，直到所有的操作都被执行完毕。在这个过程中，我们将遍历到每个操作的结果。\n\n### 4. **将操作结果插入`out`数组**：对于每个处理过的操作，我们都将其添加到`out`数组中。当所有的处理都完成时，`out`数组中的值就是整个操作的结果，即原始输入数组中的结果。\n\n### 5. **返回`out`数组**：最后，我们将`out`数组返回给调用者作为原始输入数组的反转。\n\n## 6. **使用R-Breaker11-**：以上步骤可以用于创建一个R-Breaker11-的交易策略。具体来说，你需要编写如下R脚本：\n\n```r\n# 假设你已经在R中安装了`cborog`库\nif (!cborog::import()) {\n    error(\"Failed to import 'cborog' in your environment.\")\n}\n\n# 打印原始输入数组\nprint(input)\n\n# 记录每个操作的处理次数\ncounter <- list(inc=1)\ncounter[counter$inc] = 1\n\n# 模拟操作\nfor (p in input[1..4]) {\n    counter <- list(inc=p)\n    counter[p] = counter$inc + 1\n}\n\n# 对每一个操作执行R-Breaker11，并获取结果\nstart_time <- Sys.time() / 60 # 每秒计数一次，每次计算两个操作\nwhile counter == 0 || counter == 1674431859 {\n\n    # 计算R-Breaker11并从输入取值\n    res <- (counter[[1]] + counter[[2]]) - counter[[3]]\n    # 判断结果是否和预期相符\n    if (res >= 0) {\n        # 如果R-Breaker11成功，则在输出中显示结果\n        out[[1]] <- counter[[1]]\n        if (res < 0) {\n            # 如果R-Breaker11失败，则提示用户没有完成任务，需要重新进行\n            output[[2]] <- \"用户无法完成\"", "original_response": "python\n# botvs@f976b25629baf8373e73da860a54030d\n#!/usr/local/bin/python\n#-*- coding: UTF-8 -*-\n#删除反转止损\nimport math\nimport talib\ndef adjustFloat(v):\n    v =math.floor(v*1000)\n    return v/1000\n\ndef GetAccount():\n    account = _C(exchange.GetAccount)\n    while account == null:\n        account = _C(exchange.GetAccount)\n        Sleep(1000)\n    return account\n\ndef GetTicker():\n    ticker = exchange.GetTicker()\n    while ticker ==null:\n        ticker = exchange.GetTicker()\n        Sleep(1000)\n    return ticker\n# def updateProfit(accountInit, accountNow, ticker):\n#     netNow = accountNow.Balance + accountNow.FrozenBalance + ((accountNow.Stocks + accountNow.FrozenStocks) * ticker.Buy)\n#     netInit = accountInit.Balance + accountInit.FrozenBalance + ((accountInit.Stocks + accountInit.FrozenStocks) * ticker.Buy)\n#     LogProfit(adjustFloat(netNow - netInit), accountNow)\n\n#获取当期账户总额\ndef GetNowamount():\n    account =GetAccount()\n    ticker = exchange.GetTicker()\n    return account.Balance + account.FrozenBalance + ((account.Stocks + account.FrozenStocks) * ticker.Buy)\n#获取当前账户市值\ndef GetStockcap():\n    account=GetAccount()\n    ticker = GetTicker()\n    return (account.Stocks + account.FrozenStocks) * ticker.Buy\n\n\n\n#type 0 总持仓比例 1 可买入币的百分比\ndef my_buy(ratio,type):\n    try:\n        global InitAccount\n        account = GetAccount()\n        ticker=_C(exchange.GetTicker)\n        #计算买入量\n        if type == 0:\n            unit =(GetNowamount()/ticker.Buy)*ratio - account.Stocks - account.FrozenStocks\n        else:\n            unit =((GetNowamount()/ticker.Buy) - account.Stocks - account.FrozenStocks)*ratio\n        \n        #不足最低交易退出买入操作\n        if unit < exchange.GetMinStock():\n            return 0\n        Dict = ext.Buy(unit)  #买入ext.Buy\n        if(Dict):#确认开仓成功\n            #buy_price=Dict['price'] #买入价格   #{'price': 4046.446, 'amount': 1.5}\n            #buy_qty=Dict['amount']  #买入数量\n            #LogProfit(_N(gains,4),'开仓信息 钱:',initAccount.Balance,'--币:',initAccount.Stocks,'--开仓详情:',Dict)\n            #updateProfit(InitAccount, GetAccount(), GetTicker())\n            Balance_log() #收益计算\n            print_log(1,InitAccount)\n            return 1\n        return 0\n    except Exception,ex:\n        Log('except Exception my_buy:',ex)\n        return 0\n\ndef my_sell(ratio,type):\n    try:\n        global InitAccount\n        account = GetAccount()\n        if type == 0:\n            unit = 1\n        else:\n            unit =(account.Stocks + account.FrozenStocks)*ratio\n\n        if unit<exchange.GetMinStock():\n            return 0\n\n        Dict = ext.Sell(unit)\n            #Dict ={\"price\":_C(exchange.GetTicker).Last}\n        if(Dict):\n            #updateProfit(InitAccount, GetAccount(), GetTicker())\n            Balance_log() #收益计算\n            print_log(0,GetAccount())\n            return 1\n    except Exception,ex:\n        Log('except Exception my_sell:',ex)\n        return 0\n\n\n########################################################\nimport datetime\ndef Caltime(date1,date2):\n    try:\n        date1=time.strptime(date1,\"%Y-%m-%d %H:%M:%S\")\n        date2=time.strptime(date2,\"%Y-%m-%d %H:%M:%S\")\n        date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])\n        date2=datetime.datetime(date2[0],date2[1],date2[2],date2[3],date2[4],date2[5])\n        return date2-date1\n    except Exception,ex:\n        Log('except Exception Caltime:',ex)\n        return \"except Exception\"\n\n\nimport time\nstart_timexx =time.localtime(time.time()) #time.clock()\nstart_time=time.strftime(\"%Y-%m-%d %H:%M:%S\",start_timexx)\nbuy_price=0 #买入价格\nbuy_qty=0  #买入数量\ngains=0  #盈利\n\nbeng_Account = ext.GetAccount()  #初始化信息\nbeng_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\nbeng_Balance=(beng_Account.Stocks*beng_ticker)+beng_Account.Balance #初始化账户钱\n\ndef Balance_log(): #收益计算\n    try:\n        end_Account = ext.GetAccount()  #当前账户信息\n        end_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\n        LogProfit(end_Balance-beng_Balance) \t#记录盈利值\n    except Exception,ex:\n        Log('except Exception Balance_log:',ex)\n\ndef print_log(k_p,data=\"\"):  #输出\n    try:\n        name=\"\"\n        if k_p:\n            name=\"开仓\"\n        else:\n            name=\"平仓\"\n        global beng_Account,beng_ticker,beng_Balance\n        global R1,R2,R3,S1,S2,S3\n        global gains\n        end_Account = ext.GetAccount()  #当前账户信息\n        end_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\n        #################################################\n        date1=time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime(time.time()))\n        msg_data0=(\"本次开始运行时间:%s已运行:%s\\r\\n\"%(start_time,Caltime(start_time,date1)))\n        #################################################\n        msg_data1=(\"本次初始化状态:%s\\r\\n当前运行状态:%s\\r\\n\"%(beng_Account,end_Account))\n        #################################################\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\n        msg_data2=(\"初始化钱:%s现在钱:%s盈亏:%s\\r\\n\"%(str(beng_Balance),str(end_Balance),str(end_Balance-beng_Balance)))\n        #################################################\n        total = end_Account.Balance+end_Account.Stocks*_C(exchange.GetTicker).Last #账户总额\n        roi = ((total/beng_Balance) -1)*100\n        msg_data3=(\"当前状态:%s--钱:%s--币:%s--总值约:%.2f\\r\\n\"%(str(name),str(end_Account.Balance),str(end_Account.Stocks),roi))\n        #################################################\n        income = total - beng_Account['Balance'] - beng_Account['Stocks']*beng_ticker #总盈亏\n        msg_data4=(\"本次盈亏:%s(RMB)\\t总盈亏:%.2f(RMB) %.2f\\r\\n\"%(str(gains),income,roi))\n        #################################################\n        #盈利计算方法\n        #盈利计算方法   浮动利润： 按 （现在币 - 初始币）x 现在的价格 + （现在的钱 - 初始的钱）\n        diff_stocks=end_Account.Stocks-beng_Account.Stocks    #比的差值\n        diff_balance=end_Account.Balance-beng_Account.Balance   #钱的差值\n        new_end_balance=diff_stocks*end_ticker+diff_balance #实现盈亏   #当前的盈利\n        #盈利计算方法   账面利润 ： （现在币 x 现在价格+现在钱） - （初始币 x 初始价格 + 初始钱）\n        new_end_balance2=(end_Account.Stocks*end_ticker+end_Account.Balance)-(beng_Account.Stocks*beng_ticker+beng_Account.Balance)\n        msg_data5=(\"浮动利润:%s(RMB)\\r\\n账面利润:%s(RMB)\\r\\n\"%(str(_N(new_end_balance,3)),str(_N(new_end_balance2,3))))\n        msg_data6 ='R1',R1,'R2',R2,'R3',R3,'\\r\\n'\n        msg_data7 ='S1',S1,'S2',S2,'S3',S3,'\\r\\n'\n        msg_data8 =\"当前价格:\",end_ticker,'\\r\\n'\n        #################################################\n        LogStatus(\"初始化投入2016/9/24  投入0.2个币=等于行情800RMB\\r\\n\",\n                  msg_data0,msg_data1,msg_data2,msg_data3,msg_data4,msg_data5,msg_data6,msg_data7,msg_data8,\n                  \"更新时间:%s\\r\\n\"%(date1),\n                  \"%s\"%(data)\n                  )\n        #################################################\n        #################################################\n        #################################################\n    except Exception,ex:\n        Log('except Exception print_log:',ex)\n\n\n\n\ndef _GetCommand():\n    get_command=GetCommand()\n    if get_command:\n        global K1,K2,N\n        arr =get_command.split(\":\")\n        if arr[0] == 'K1':\n            K1 = float(arr[-1])\n        if arr[0] =='K2':\n            K2 = float(arr[-1])\n        if arr[0] =='N':\n            N = int(arr[-1])\n\n\nN=2\n\nLastDeal = 0 #上次交易时间\ndef onTick(exchange):\n    try:\n        global R1,R2,R3,S1,S2,S3,short_state_buy,short_state_sell,LastDeal,task_state,buy_count,sell_count\n        amount = GetAccount() # 获取账户状态\n        records =exchange.GetRecords() #默认5分钟\n        To = records[-1]['Open'] #今日开盘价\n        Th = records[-1]['High'] #今日最高价\n        Tl = records[-1]['Low'] #今日最低\n        time = records[-1].Time\n        if LastDeal == time:\n            return 0\n        else:\n            LastDeal = 0\n\n        \n        records1 =exchange.GetRecords(PERIOD_M30) #监控周期\n        #time =(records1[-2].Time - records1[-1].Time)/(60*1000)\n        #Log(time);\n        records.pop()\n        records1.pop()\n        ma5 = TA.MA(records1,5)\n        ma10 = TA.MA(records1,10)\n     \n\n\n        # HH = records[-2]['High'] #最日最高\n        # LC = records[-2]['Low']  #昨日最低\n        HC = records[-1]['Close'] #昨日收盘\n        # LL = records[-2]['Low']  #昨日最低\n        HH = TA.Highest(records,N,'High') #N日high的最高价\n            #lc = records[-2]['Low']\n        #HC = TA.Lowest(records,N,'Close') #//N日close的最低价\n            #hc = records[-2]['Close']\n        #HH = TA.Highest(records,N,'Close') #N日close的最高价\n            #ll = records[-2]['Low']\n        LC = TA.Lowest(records,N,'Low') #//N日low的最低价\n        #HC = TA.Highest(records,N,'Close')\n        if ma5[-1] <ma10[-1]:\n            HC = records[-1]['Open']\n\n        Pivot = (HH+HC+LC)/3 #枢轴点\n        Pivot = Pivot\n        R1 = 2*Pivot-LC #阻力1W\n        R2 = Pivot+(HH-LC) #阻力2\n        R3 = HH +2*(Pivot-LC) #阻力3\n\n        S1 = 2*Pivot-HH\n        S2 = Pivot - (HH-LC)\n        S3 = LC-2*(HH-Pivot)\n        # Log('r1',R1,\"R2\",R2,'R3',R3)\n        # Log('S1',S1,\"S2\",S2,'S3',S3)\n        \n        current_price = _C(exchange.GetTicker).Last #当前价格\n        capratio = (amount.Stocks + amount.FrozenStocks)/GetNowamount()\n        #突破上轨 和半小时 均线向上 资金大于100 则买入\n        if ma5[-1] >ma10[-1] :\n            if current_price > R3 and amount.Balance > 100 and ma5[-1] >ma10[-1] and capratio <0.8 and buy_count <3 :\n               # Log(ma5[-1],ma10[-1])\n                Log('开多')\n                if my_buy(0.4,1):\n                    LastDeal = time\n                    sell_count = 0\n                    buy_count+=1\n                    return\n            #突破下轨卖空 有币 进入卖出操作\n            if current_price < S3 and amount.Stocks > 0.03 :\n                Log('清仓')\n                if my_sell(1,0):\n                    sell_count+=1\n                    buy_count = 0\n                    LastDeal = time\n                    return\n            if Th >R2 and Th <R3 and current_price <R1 and current_price >S1   and amount.Stocks > 0.003 and buy_count <3:\n                Log('趋势反转卖')\n                if my_sell(0.5,1):\n                    LastDeal = time\n                    buy_count = 0\n                    sell_count+=1\n                    return\n            if Tl <S2 and Tl >S3 and current_price <S1  and current_price < R1 and capratio <0.6 and ma5[-1] >ma10[-1] and buy_count <3 :\n                #Log(ma5[-1],ma10[-1])\n                Log('趋势反转买')\n                if my_buy(0.2,1):\n                    buy_count+=1\n                    sell_count = 0\n                    LastDeal = time\n                    return\n        else :\n            if(current_price > R3 and amount.Stocks > 0.03):\n                if my_sell(0.5,1):\n                    Log('测试买')\n                    LastDeal = time\n                    return\n\n            if (current_price < S3 and ma5[-1] >ma5[-5]):\n                if my_buy(0.05,1):\n                    Log('测试买入')\n                    LastDeal = time\n                    buy_count = 0\n                    return\n\n\n\n\n\n\n        \n\n\n    except Exception,ex:\n        Log('except Exception onTick:',ex)\n        return 0\n\n\ndef main():\n    global outAccount,init_price,InitAccount,short_state_buy,short_state_sell,task_state,buy_count,sell_count\n    init_price = _C(exchange.GetTicker).Last\n    InitAccount = GetAccount()\n    Log(init_price)\n    short_state_buy =short_state_sell = 0\n    task_state =0\n    buy_count = 0\n    sell_count = 0\n    while True:\n            onTick(exchange)\n            nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\n            print_log(0,nowAccount)\n            Sleep(1000)"}
{"query": "请生成一个RecordsCollecter-升级提供自定义数据源功能策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport _thread\nimport pymongo\nimport json\nimport math\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse\n\ndef url2Dict(url):\n    query = urlparse(url).query  \n    params = parse_qs(query)  \n    result = {key: params[key][0] for key in params}  \n    return result\n\nclass Provider(BaseHTTPRequestHandler):\n    def do_GET(self):\n        try:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"application/json\")\n            self.end_headers()\n\n            dictParam = url2Dict(self.path)\n            Log(\"自定义数据源服务接收到请求，self.path:\", self.path, \"query 参数：\", dictParam)\n            \n            # 目前回测系统只能从列表中选择交易所名称，在添加自定义数据源时，设置为币安，即：Binance\n            exName = exchange.GetName()                                     \n            # 注意，period为底层K线周期\n            tabName = \"%s_%s\" % (\"records\", int(int(dictParam[\"period\"]) / 1000))  \n            priceRatio = math.pow(10, int(dictParam[\"round\"]))\n            amountRatio = math.pow(10, int(dictParam[\"vround\"]))\n            fromTS = int(dictParam[\"from\"]) * int(1000)\n            toTS = int(dictParam[\"to\"]) * int(1000)\n            \n            \n            # 连接数据库\n            Log(\"连接数据库服务，获取数据，数据库：\", exName, \"表：\", tabName)\n            myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")\n            ex_DB = myDBClient[exName]\n            exRecords = ex_DB[tabName]\n            \n            \n            # 要求应答的数据\n            data = {\n                \"schema\" : [\"time\", \"open\", \"high\", \"low\", \"close\", \"vol\"],\n                \"data\" : []\n            }\n            \n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\n            dbQuery = {\"$and\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\n            Log(\"查询条件：\", dbQuery, \"查询条数：\", exRecords.find(dbQuery).count(), \"数据库总条数：\", exRecords.find().count())\n            \n            for x in exRecords.find(dbQuery).sort(\"Time\"):\n                # 需要根据请求参数round和vround，处理数据精度\n                bar = [x[\"Time\"], int(x[\"Open\"] * priceRatio), int(x[\"High\"] * priceRatio), int(x[\"Low\"] * priceRatio), int(x[\"Close\"] * priceRatio), int(x[\"Volume\"] * amountRatio)]\n                data[\"data\"].append(bar)\n            \n            Log(\"数据：\", data, \"响应回测系统请求。\")\n            # 写入数据应答\n            self.wfile.write(json.dumps(data).encode())\n        except BaseException as e:\n            Log(\"Provider do_GET error, e:\", e)\n\n\ndef createServer(host):\n    try:\n        server = HTTPServer(host, Provider)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except BaseException as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\ndef main():\n    LogReset(1)\n    exName = exchange.GetName()\n    period = exchange.GetPeriod()\n    Log(\"收集\", exName, \"交易所的K线数据，\", \"K线周期:\", period, \"秒\")\n    \n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\n    Log(\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\")\n    myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")   \n    # 创建数据库\n    ex_DB = myDBClient[exName]\n    \n    # 打印目前数据库表\n    collist = ex_DB.list_collection_names()\n    Log(\"mongodb \", exName, \" collist:\", collist)\n    \n    # 检测是否删除表\n    arrDropNames = json.loads(dropNames)\n    if isinstance(arrDropNames, list):\n        for i in range(len(arrDropNames)):\n            dropName = arrDropNames[i]\n            if isinstance(dropName, str):\n                if not dropName in collist:\n                    continue\n                tab = ex_DB[dropName]\n                Log(\"dropName:\", dropName, \"删除：\", dropName)\n                ret = tab.drop()\n                collist = ex_DB.list_collection_names()\n                if dropName in collist:\n                    Log(dropName, \"删除失败\")\n                else :\n                    Log(dropName, \"删除成功\")\n    \n    # 开启一个线程，提供自定义数据源服务\n    try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))     # 本机测试\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))         # VPS服务器上测试\n        Log(\"开启自定义数据源服务线程\", \"#FF0000\")\n    except BaseException as e:\n        Log(\"启动自定义数据源服务失败！\")\n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")\n    \n    # 创建records表\n    ex_DB_Records = ex_DB[\"%s_%d\" % (\"records\", period)]\n    Log(\"开始收集\", exName, \"K线数据\", \"周期：\", period, \"打开（创建）数据库表：\", \"%s_%d\" % (\"records\", period), \"#FF0000\")\n    preBarTime = 0\n    index = 1\n    while True:\n        r = _C(exchange.GetRecords)\n        if len(r) < 2:\n            Sleep(1000)\n            continue\n        if preBarTime == 0:\n            # 首次写入所有BAR数据\n            for i in range(len(r) - 1):\n                bar = r[i]\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\n                retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n                if retQuery.count() > 0:\n                    continue\n                \n                # 写入bar到数据库表\n                ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})                \n                index += 1\n            preBarTime = r[-1][\"Time\"]\n        elif preBarTime != r[-1][\"Time\"]:\n            bar = r[-2]\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\n            retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n            if retQuery.count() > 0:\n                continue\n            \n            ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})\n            index += 1\n            preBarTime = r[-1][\"Time\"]\n        LogStatus(_D(), \"preBarTime:\", preBarTime, \"_D(preBarTime):\", _D(preBarTime/1000), \"index:\", index)\n        # 增加画图展示\n        ext.PlotRecords(r, \"%s_%d\" % (\"records\", period))\n        Sleep(10000)"}
{"query": "请生成一个RecordsCollecter-升级提供自定义数据源功能支持CSV数据文件提供数据源策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport _thread\nimport pymongo\nimport json\nimport math\nimport csv\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse\n\ndef url2Dict(url):\n    query = urlparse(url).query  \n    params = parse_qs(query)  \n    result = {key: params[key][0] for key in params}  \n    return result\n\nclass Provider(BaseHTTPRequestHandler):\n    def do_GET(self):\n        global isOnlySupportCSV, filePathForCSV\n        try:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"application/json\")\n            self.end_headers()\n\n            dictParam = url2Dict(self.path)\n            Log(\"自定义数据源服务接收到请求，self.path:\", self.path, \"query 参数：\", dictParam)\n            \n            # 目前回测系统只能从列表中选择交易所名称，在添加自定义数据源时，设置为币安，即：Binance\n            exName = exchange.GetName()                                     \n            # 注意，period为底层K线周期\n            tabName = \"%s_%s\" % (\"records\", int(int(dictParam[\"period\"]) / 1000))  \n            priceRatio = math.pow(10, int(dictParam[\"round\"]))\n            amountRatio = math.pow(10, int(dictParam[\"vround\"]))\n            fromTS = int(dictParam[\"from\"]) * int(1000)\n            toTS = int(dictParam[\"to\"]) * int(1000)\n\n            # 要求应答的数据\n            data = {\n                \"schema\" : [\"time\", \"open\", \"high\", \"low\", \"close\", \"vol\"],\n                \"data\" : []\n            }\n            \n            if isOnlySupportCSV:\n                # 处理CSV读取,filePathForCSV路径\n                listDataSequence = []\n                with open(filePathForCSV, \"r\") as f:\n                    reader = csv.reader(f)\n                    # 获取表头\n                    header = next(reader)\n                    headerIsNoneCount = 0\n                    if len(header) != len(data[\"schema\"]):\n                        Log(\"CSV文件格式有误，列数不同，请检查！\", \"#FF0000\")\n                        return \n                    for ele in header:\n                        for i in range(len(data[\"schema\"])):\n                            if data[\"schema\"][i] == ele or ele == \"\":\n                                if ele == \"\":\n                                    headerIsNoneCount += 1\n                                if headerIsNoneCount > 1:\n                                    Log(\"CSV文件格式有误，请检查！\", \"#FF0000\")\n                                    return \n                                listDataSequence.append(i)\n                                break\n                    \n                    # 读取内容\n                    while True:\n                        record = next(reader, -1)\n                        if record == -1:\n                            break\n                        index = 0\n                        arr = [0, 0, 0, 0, 0, 0]\n                        for ele in record:\n                            arr[listDataSequence[index]] = int(ele) if listDataSequence[index] == 0 else (int(float(ele) * amountRatio) if listDataSequence[index] == 5 else int(float(ele) * priceRatio))\n                            index += 1\n                        data[\"data\"].append(arr)\n                \n                Log(\"数据：\", data, \"响应回测系统请求。\")\n                self.wfile.write(json.dumps(data).encode())\n                return \n            \n            # 连接数据库\n            Log(\"连接数据库服务，获取数据，数据库：\", exName, \"表：\", tabName)\n            myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")\n            ex_DB = myDBClient[exName]\n            exRecords = ex_DB[tabName]\n            \n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\n            dbQuery = {\"$and\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\n            Log(\"查询条件：\", dbQuery, \"查询条数：\", exRecords.find(dbQuery).count(), \"数据库总条数：\", exRecords.find().count())\n            \n            for x in exRecords.find(dbQuery).sort(\"Time\"):\n                # 需要根据请求参数round和vround，处理数据精度\n                bar = [x[\"Time\"], int(x[\"Open\"] * priceRatio), int(x[\"High\"] * priceRatio), int(x[\"Low\"] * priceRatio), int(x[\"Close\"] * priceRatio), int(x[\"Volume\"] * amountRatio)]\n                data[\"data\"].append(bar)\n            \n            Log(\"数据：\", data, \"响应回测系统请求。\")\n            # 写入数据应答\n            self.wfile.write(json.dumps(data).encode())\n        except BaseException as e:\n            Log(\"Provider do_GET error, e:\", e)\n\n\ndef createServer(host):\n    try:\n        server = HTTPServer(host, Provider)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except BaseException as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\ndef main():\n    LogReset(1)\n    if (isOnlySupportCSV):\n        try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))         # 本机测试\n            _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))         # VPS服务器上测试\n            Log(\"开启自定义数据源服务线程，数据由CSV文件提供。\", \"#FF0000\")\n        except BaseException as e:\n            Log(\"启动自定义数据源服务失败！\")\n            Log(\"错误信息：\", e)\n            raise Exception(\"stop\")\n        while True:\n            LogStatus(_D(), \"只启动自定义数据源服务，不收集数据！\")\n            Sleep(2000)\n    \n    exName = exchange.GetName()\n    period = exchange.GetPeriod()\n    Log(\"收集\", exName, \"交易所的K线数据，\", \"K线周期:\", period, \"秒\")\n    \n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\n    Log(\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\")\n    myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")   \n    # 创建数据库\n    ex_DB = myDBClient[exName]\n    \n    # 打印目前数据库表\n    collist = ex_DB.list_collection_names()\n    Log(\"mongodb \", exName, \" collist:\", collist)\n    \n    # 检测是否删除表\n    arrDropNames = json.loads(dropNames)\n    if isinstance(arrDropNames, list):\n        for i in range(len(arrDropNames)):\n            dropName = arrDropNames[i]\n            if isinstance(dropName, str):\n                if not dropName in collist:\n                    continue\n                tab = ex_DB[dropName]\n                Log(\"dropName:\", dropName, \"删除：\", dropName)\n                ret = tab.drop()\n                collist = ex_DB.list_collection_names()\n                if dropName in collist:\n                    Log(dropName, \"删除失败\")\n                else :\n                    Log(dropName, \"删除成功\")\n    \n    # 开启一个线程，提供自定义数据源服务\n    try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))     # 本机测试\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))         # VPS服务器上测试\n        Log(\"开启自定义数据源服务线程\", \"#FF0000\")\n    except BaseException as e:\n        Log(\"启动自定义数据源服务失败！\")\n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")\n    \n    # 创建records表\n    ex_DB_Records = ex_DB[\"%s_%d\" % (\"records\", period)]\n    Log(\"开始收集\", exName, \"K线数据\", \"周期：\", period, \"打开（创建）数据库表：\", \"%s_%d\" % (\"records\", period), \"#FF0000\")\n    preBarTime = 0\n    index = 1\n    while True:\n        r = _C(exchange.GetRecords)\n        if len(r) < 2:\n            Sleep(1000)\n            continue\n        if preBarTime == 0:\n            # 首次写入所有BAR数据\n            for i in range(len(r) - 1):\n                bar = r[i]\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\n                retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n                if retQuery.count() > 0:\n                    continue\n                \n                # 写入bar到数据库表\n                ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})                \n                index += 1\n            preBarTime = r[-1][\"Time\"]\n        elif preBarTime != r[-1][\"Time\"]:\n            bar = r[-2]\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\n            retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n            if retQuery.count() > 0:\n                continue\n            \n            ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})\n            index += 1\n            preBarTime = r[-1][\"Time\"]\n        LogStatus(_D(), \"preBarTime:\", preBarTime, \"_D(preBarTime):\", _D(preBarTime/1000), \"index:\", index)\n        # 增加画图展示\n        ext.PlotRecords(r, \"%s_%d\" % (\"records\", period))\n        Sleep(10000)"}
{"query": "请生成一个RecordsCollecter-教学策略代码", "base_model_response": "```python\nclass Recordscollecter(RecordsCollecter):\n    def __init__(self, records, start_time, end_time, mode):\n        super().__init__(records, start_time, end_time, mode)\n\n    def get_records(self):\n        return self.receives\n\n    def process_records(self, records):\n        self.receives = records\n\n    def add_recieve(self, rec):\n        self.receives.append(rec)\n\n    def remove_recive(self, rec):\n        self.receives.remove(rec)\n```\n\n以上是一个基本的记录收集器类，它具有获取、处理和添加接收等操作。在使用这个类时，你需要指定接收（receives）和处理（processes）的字段，以便该类能够根据输入数据进行相应的操作。\n\n请注意，这个类并没有实现任何特定的数据结构或库功能，例如用于存储和检索数据。此外，这个类也没有处理可能发生的异常，如果你需要处理这种情况，你可能需要创建一个新的类来替代这个类。", "lora_model_response": "", "original_response": "python\nimport pymongo\nimport json\n\ndef main():\n    Log(\"测试数据收集\")\n    \n    # 连接数据库服务\n    myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")   # mongodb://127.0.0.1:27017\n    # 创建数据库\n    huobi_DB = myDBClient[\"huobi\"]\n    \n    # 打印目前数据库表\n    collist = huobi_DB.list_collection_names()\n    Log(\"collist:\", collist)\n    \n    # 检测是否删除表\n    arrDropNames = json.loads(dropNames)\n    if isinstance(arrDropNames, list):\n        for i in range(len(arrDropNames)):\n            dropName = arrDropNames[i]\n            if isinstance(dropName, str):\n                if not dropName in collist:\n                    continue\n                tab = huobi_DB[dropName]\n                Log(\"dropName:\", dropName, \"删除：\", dropName)\n                ret = tab.drop()\n                collist = huobi_DB.list_collection_names()\n                if dropName in collist:\n                    Log(dropName, \"删除失败\")\n                else :\n                    Log(dropName, \"删除成功\")\n    \n    # 创建records表\n    huobi_DB_Records = huobi_DB[\"records\"]\n    \n    # 请求数据\n    preBarTime = 0\n    index = 1\n    while True:\n        r = _C(exchange.GetRecords)\n        if len(r) < 2:\n            Sleep(1000)\n            continue\n        if preBarTime == 0:\n            # 首次写入所有BAR数据\n            for i in range(len(r) - 1):\n                # 逐根写入\n                bar = r[i]\n                huobi_DB_Records.insert_one({\"index\": index, \"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})                \n                index += 1\n            preBarTime = r[-1][\"Time\"]\n        elif preBarTime != r[-1][\"Time\"]:\n            bar = r[-2]\n            huobi_DB_Records.insert_one({\"index\": index, \"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})\n            index += 1\n            preBarTime = r[-1][\"Time\"]\n        LogStatus(_D(), \"preBarTime:\", preBarTime, \"_D(preBarTime):\", _D(preBarTime/1000), \"index:\", index)\n        Sleep(10000)"}
{"query": "请生成一个SpotGridStra策略代码", "base_model_response": "", "lora_model_response": "，", "original_response": "python\n# 现货网格管理\n'''\n# Example:\n\ndef main():\n    spot_g_stra = ext.SpotGridStra({'exchange': exchanges[1],    #现货交易所\n                         'ZPrecision': 2,\n                         'XPrecision': 3,\n                          'MinStock': 0.001,\n                          'GridSize': 0.03,\n                          'Symbol': 'BNB',\n                          'BalancePoint': 0.5\n                         })\n    while True:\n        spot_g_stra.run()\n        Sleep(60*10000)\n\n'''\n\n\nclass SpotGridStra():\n    \n    def __init__(self, cfg):\n        self.cfg = cfg\n        self.exchange = cfg['exchange']                     #交易所\n        self.ZPrecision = cfg['ZPrecision']                 #币的价格精度, 整数\n        self.XPrecision = cfg['XPrecision']                 #币的交易量最小分位数， 如BNB是2\n        self.Symbol = cfg['Symbol']                         #币的符号\n        self.GridSize = cfg['GridSize']                     #差额多大就调整\n        self.MinStock = cfg['MinStock']                     #币的最小交易量\n        self.BalancePoint = cfg.get('BalancePoint', 0.5)    #特定币种占仓位的平衡点\n        \n    def CancelPendingOrders(self):\n        ret = False\n        while True:\n            orders = _C(self.exchange.GetOrders)\n            if len(orders) == 0 :\n                return ret\n\n            for j in range(len(orders)):\n                self.exchange.CancelOrder(orders[j].Id)\n                ret = True\n                if j < len(orders) - 1:\n                    Sleep(1000)\n        return ret \n\n    def onTick(self):\n        self.exchange.SetCurrency(self.Symbol + '_USDT')\n        acc = _C(self.exchange.GetAccount)\n        #Log(acc)\n        ticker = _C(self.exchange.GetTicker)\n        spread = ticker.Sell - ticker.Buy\n        account_info = acc['Info']\n        bals = account_info['balances']\n        sel_asset = None \n        usdt_val = 0.0\n        for asset in bals:\n            if asset['asset'] == self.Symbol:\n                sel_asset = asset\n            if asset['asset'] == 'USDT':\n                usdt_val = float(asset['free'])\n        assert sel_asset is not None, '找不到对应资产:' + self.Symbol\n        asset_val = ((float(sel_asset['free']) + float(sel_asset['locked'])) * ticker.Sell)\n        total_val = usdt_val + asset_val\n        Log(self.Symbol, total_val, '=', acc.Balance, '+', asset_val)\n        diffAsset = (total_val*self.BalancePoint  - asset_val)\n        ratio = diffAsset / total_val\n        #Log(\"ratio:\", ratio, _D())\n        if abs(ratio) < self.GridSize:\n            return False\n        if ratio > 0 :\n            buyPrice = _N(ticker.Sell + spread, self.ZPrecision)\n            buyAmount = _N(diffAsset / buyPrice, self.XPrecision)\n            if buyAmount < self.MinStock:\n                return False\n            self.exchange.Buy(buyPrice, buyAmount, diffAsset, ratio)\n        else :\n            sellPrice = _N(ticker.Buy - spread, self.ZPrecision)\n            sellAmount = _N(-diffAsset / sellPrice, self.XPrecision)\n            if sellAmount < self.MinStock:\n                return False \n            self.exchange.Sell(sellPrice, sellAmount, diffAsset, ratio)\n        return True\n    \n    def run(self):\n        if self.onTick():\n            Sleep(1000)\n            self.CancelPendingOrders()\n\next.SpotGridStra = SpotGridStra"}
{"query": "请生成一个SuperTrend-V1策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2020-01-01 00:00:00\nend: 2020-04-01 00:00:00\nperiod: 15m\nexchanges: [{\"eid\":\"Futures_OKCoin\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport pandas as pd\nimport time\n\ndef main():\n    exchange.SetContractType(\"quarter\")\n    preTime = 0\n    Log(exchange.GetAccount())\n    while True:\n        records = exchange.GetRecords(PERIOD_M15)\n        if records and records[-2].Time > preTime:\n            preTime = records[-2].Time\n            doTicker(records[:-1])\n        Sleep(1000 *60)\n    '''\n    while True:  \n        a=time.localtime(Unix())\n        if(14<a.tm_min<16):\n            Log(a)\n        if(a.tm_min==0 or a.tm_min==15 or a.tm_min==30 or a.tm_min==45):\n            doTicker()\n        Sleep(1000 *60)\n    '''\n\n        \ndef doTicker(records):\n    #Log('onTick',exchange.GetTicker())\n    M15 = pd.DataFrame(records)\n\n    #Factor=3\n    #Pd=7\n    \n    M15.columns = ['time','open','high','low','close','volume','OpenInterest']  \n    \n    #HL2\n    M15['hl2']=(M15['high']+M15['low'])/2\n\n    #ATR(PD)\n    length=Pd\n    M15['prev_close']=M15['close'].shift(1)\n    ranges= [M15['high'] - M15['low'],M15['high']-M15['prev_close'],M15['low']-M15['prev_close']]\n    M15['tr'] = pd.DataFrame(ranges).T.abs().max(axis=1)\n    alpha = (1.0 / length) if length > 0 else 0.5\n    M15['atr']=M15['tr'].ewm(alpha=alpha, min_periods=length).mean()\n\n\n    M15['Up']=M15['hl2']-(Factor*M15['atr'])\n    M15['Dn']=M15['hl2']+(Factor*M15['atr'])\n    \n    M15['TrendUp']=0.0\n    M15['TrendDown']=0.0\n    M15['Trend']=1\n    M15['Tsl']=0.0\n    M15['linecolor']='Homily'\n    M15 = M15.fillna(0)\n\n    for x in range(len(M15)):\n        M15['TrendUp'].values[x] = max(M15['Up'].values[x],M15['TrendUp'].values[x-1]) if (M15['close'].values[x-1]>M15['TrendUp'].values[x-1]) else M15['Up'].values[x]\n        M15['TrendDown'].values[x] = min(M15['Dn'].values[x],M15['TrendDown'].values[x-1]) if (M15['close'].values[x-1]<M15['TrendDown'].values[x-1]) else M15['Dn'].values[x]\n        M15['Trend'].values[x] = 1 if (M15['close'].values[x] > M15['TrendDown'].values[x-1]) else ( -1 if (M15['close'].values[x]< M15['TrendUp'].values[x-1])else M15['Trend'].values[x-1] )\n        M15['Tsl'].values[x] = M15['TrendUp'].values[x] if  (M15['Trend'].values[x]==1) else M15['TrendDown'].values[x]\n        M15['linecolor'].values[x]= 'Long' if ( M15['Trend'].values[x]==1) else  'Short'\n \n\n    linecolor=M15['linecolor'].values[-2]\n    close=M15['close'].values[-2]\n    Tsl=M15['Tsl'].values[-2] \n\n    \n    if(M15['Trend'].values[-1] == 1 and M15['Trend'].values[-2] == -1):\n\n        Log('SuperTrend V.1 Alert Long','Create Order Buy')\n        Log('Tsl=',Tsl)\n        position = exchange.GetPosition()\n        if len(position) > 0:\n            Amount=position[0][\"Amount\"]\n            exchange.SetDirection(\"closesell\")\n            exchange.Buy(_C(exchange.GetTicker).Sell*1.01, Amount);\n        \n        exchange.SetDirection(\"buy\")\n        exchange.Buy(_C(exchange.GetTicker).Sell*1.01, vol);\n\n    if(M15['Trend'].values[-1] == -1 and M15['Trend'].values[-2] == 1):\n        Log('SuperTrend V.1 Alert Long','Create Order Sell')\n        Log('Tsl=',Tsl)\n        position = exchange.GetPosition()\n        if len(position) > 0:\n            Amount=position[0][\"Amount\"]\n            exchange.SetDirection(\"closebuy\")\n            exchange.Sell(_C(exchange.GetTicker).Buy*0.99,Amount);\n        exchange.SetDirection(\"sell\")\n        exchange.Sell(_C(exchange.GetTicker).Buy*0.99, vol*2);"}
{"query": "请生成一个TD狄马克序列策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2021-01-01 00:00:00\nend: 2021-03-12 00:00:00\nperiod: 15m\nexchanges: [{\"eid\":\"Futures_OKCoin\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport time\nimport pandas as pd\nimport numpy as np\n\ndef main():\n    exchange.SetContractType(\"quarter\")\n    while True:\n        #start_time = time.time()\n        records = exchange.GetRecords(PERIOD_H1)\n        if len(records) < 100:\n            Sleep(1000)\n            return\n        kline = pd.DataFrame(records)\n        kline.columns = ['time','open','high','low','close','volume','OpenInterest']\n        i = 0\n        j = 0\n        for x in range(len(kline)-40,len(kline)):\n            if kline['close'].values[x] > kline['close'].values[x-4]:\n                i += 1\n            else:\n                i = 0\n            if kline['close'].values[x] < kline['close'].values[x-4]:\n                j -= 1\n            else:\n                j = 0\n        TDindex = i if i>0 else j\n        #if 13 > TDindex >= 8 :\n            #Log('温馨警告，进入超买区域，可考虑卖出止盈：')\n        #elif 21 > TDindex >= 13 :\n            #Log('一般警告，进入超级超买区域，可考虑卖出止盈：')\n        #elif TDindex >= 21 :\n            #Log('严重警告，进入超级超级超买区域，可考虑清仓止盈：')\n        #elif -13 < TDindex <= -8 :\n            #Log('温馨警告，进入超卖区域，可考虑买入博个反弹：')\n        #elif -21 < TDindex <= -13 :\n            #Log('一般警告，进入超级超卖区域，可考虑加仓买入：')\n        #elif TDindex <= -21 :\n            #Log('严重警告，进入超级超级超卖区域，可考虑全仓杀入：')\n        position = exchange.GetPosition()\n        #if len(position) > 0:\n            #Log(position[0][\"Type\"])\n        if TDindex == 9 or TDindex == 13 or TDindex == 22:  #and len(position) == 0 :\n            Log('上根K线的TD序列为：',TDindex)\n            exchange.SetDirection(\"sell\")\n            id2 = exchange.Sell(-1, 1)\n        \n        if TDindex == -9 or TDindex == -13 or TDindex == -22:  #and len(position) == 0 :\n            Log('上根K线的TD序列为：',TDindex)\n            exchange.SetDirection(\"buy\")\n            id2 = exchange.Buy(-1, 1)\n        if len(position) > 0:\n            if position[0][\"Type\"] ==0 and TDindex >= 2 :\n                #Log(position[0][\"Type\"])\n                Log('上根K线的TD序列为：',TDindex)\n                exchange.SetDirection(\"closebuy\")\n                id2 = exchange.Sell(-1, 1)\n            \n            if position[0][\"Type\"] ==1 and TDindex <= -2 :\n                #Log(position[0][\"Type\"])\n                Log('上根K线的TD序列为：',TDindex)\n                exchange.SetDirection(\"closesell\")\n                id2 = exchange.Buy(-1, 1)\n        # end_time = time.time()\n        #spend_time = end_time - start_time\n        Sleep(1000*900)"}
{"query": "请生成一个Telegram-发信接口-V200-Python策略代码", "base_model_response": "", "lora_model_response": "示例\n\n```python\nfrom Telegram import Client, auth, commands, config, db\nimport logging\n\ndef get_db():\n    global DB\n\n    db = {}\n    for path, action in DB.items():\n        dbpath = os.path.join(path, \".\")\n        if path not in db:\n            dbpath = os.path.join(dbpath, \"db\")\n            dbpath += action + \".txt\"\n        if os.path.exists(dbpath):\n            dbpath = path.replace(os.path.basename(dbpath), \".\")\n\n\ndef auth_set(token, user_id, password, scope=\"\"):\n    \"\"\"User authenticate using token\"\"\"\n    client = auth.Client(token=token)\n    db = client.db()\n    with open(\"/var/log/auth.log\", \"a\") as f:\n        log.info(\"User authenticated\", msg={\"user\": user_id, \"scope\": scope})\n        db.execute(f\"INSERT INTO users (username, email) VALUES (?, ?)\", (user_id, db.get(\"email\").value))\n        db.commit()\n\n    return True\n\n\nclass ChatbotClient(TCPClient, commands.TextMessageHandler, auth.SignedTokenAuth):\n    def __init__(self, log, config, db=None, session=None, **kwargs):\n        super().__init__(log, config, db)\n        self.config = config\n        self.session = session\n        self.session.save_user()\n        self.config.load_json(self.session)\n\n    def login(self, username, password):\n        # Check token\n        if auth_set(username, 'me', password):\n            self.user = self.session.get_user(username)\n            self.log.info(\"User logged in\", msg={\"user\": username, \"password\": password})\n            return False\n\n        return True\n\n\n    def message(self, message):\n        # Get user ID and send message\n        # This is just a simple way to test the method.  You would want to add logic\n        # to handle this.\n        # I'll leave this implementation as it's pretty straightforward.\n        msg = self.message(message)\n        self.send_message(msg)\n        self.login(msg[\"msg\"][\"user\"][\"id\"], msg[\"msg\"][\"message\"])\n\n    def text_message(self, message, **kwargs):\n        pass\n\n\n    def send_message(self, msg):\n        # Send message via body\n        jsonmsg = {\"msg\": msg}\n        self.send_response(200, jsonmsg)\n        data = {\"data\": jsonmsg}\n        self.send_data(data)\n\n\nif __name__ == \"__main__\":\n    app = ChatbotClient()\n    server = app.run('YOUR_SERVER')\n```\n\n在上面的代码中，你需要提供一个服务器地址。你可以在这里找到它的值，例如: `http://127.0.0.1/your_server`。", "original_response": "# key 为 Bot key\n## 获取 Bot key 可以参考 https://www.ccino.org/create-a-telegram-bot.html\n# chat_id 为收信用户Telegram ID\n## Telegram ID 可以通过 @dwx_aibot 机器人获取， 连接至此机器人后发送 /getid 即可获得 ChatID\nTelegram = ext.Telegram(key=string, chat_id=integer)    # 创建一个新的接口对象\n\n# ==========================================\n\npython\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n# \n# Telegram Interface for FMZ.com\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\ntry:\n    import requests\nexcept:\n    print('Requests not installed. Try: pip install requests')\n    Log('Requests not installed. Try: pip install requests')\n    \n    raise Exception('Requests not installed. Try: pip install requests')\n\nclass Telegram:\n    def __init__(self):\n        self.key = KEY\n        self.chat_id = CHATID\n        self.url = 'https://api.telegram.org/bot%s' % self.key\n        \n    def Send(self, message='', chat_id=None):\n        if chat_id is None:\n            chat_id = self.chat_id\n        PARAM = {}\n        PARAM['chat_id'] = chat_id\n        PARAM['text'] = message\n        PARAM['parse_mode'] = 'markdown'\n        URL = self.url + '/sendMessage'\n        try:\n            res = requests.post(URL, data = PARAM)\n            return True\n        except IOError as e:\n            print(e)\n            return False\n        \n\next.Telegram = Telegram\n\n# 模块功能测试\ndef main():\n    if DEBUG == 1:\n        msger = ext.Telegram(KEY, CHATID)\n        msger.Send(\"Hello World!\")\n    \n    return True"}
{"query": "请生成一个TradingViewWebHook直连策略策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''\n请求格式：http://x.x.x.x:xxxx/data?access_key=xxx&secret_key=yyy&type=buy&amount=0.001\n策略机器人参数：\n- 类型：加密字符串，AccessKey , SecretKey ，可以用FMZ平台的低权限的API KEY，或者自己生成KEY也可以。\n- 类型：字符串，合约ID，ContractType\n- 类型：数值，端口号，Port\n'''\n\nimport re\nimport _thread\nimport json\nfrom http.server import ThreadingHTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse\n\ndef url2Dict(url):\n    query = urlparse(url).query  \n    params = parse_qs(query)  \n    result = {key: params[key][0] for key in params}  \n    return result\n\nclass Executor(BaseHTTPRequestHandler):\n    def do_GET(self):\n        try:\n            dictParam = url2Dict(self.path)\n            Log(\"测试\", dictParam)\n        except Exception as e:\n            Log(\"Provider do_GET error, e:\", e)\n    def do_POST(self):\n        try:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"application/json\")\n            self.end_headers()\n            dictParam = url2Dict(self.path)\n            \n            # 测试POST请求Body信息            \n            data = self.rfile.read(200)   # 指定了读取长度\n            Log(\"data:\", data)            # 打印POST请求的数据，可以根据请求中的数据具体再让机器人执行对应的操作\n            \n            # 校验\n            if len(dictParam) == 4 and dictParam[\"access_key\"] == AccessKey and dictParam[\"secret_key\"] == SecretKey:\n                del dictParam[\"access_key\"]\n                del dictParam[\"secret_key\"]\n                Log(\"接收到请求\", \"参数：\", dictParam, \"#FF0000\")\n                '''\n                map[access_key:xxx amount:0.001 secret_key:yyy type:buy]\n                '''\n                isSpot = True\n                if exchange.GetName().find(\"Futures\") != -1:\n                    if ContractType != \"\":\n                        exchange.SetContractType(ContractType)\n                        isSpot = False \n                    else :\n                        raise \"未设置期货合约\"\n                                \n                q = None\n                if exchange.GetName() == \"Futures_CTP\" and UseMarketOrderForCTP == False:\n                    q = ext.NewTaskQueue()\n                \n                if isSpot and dictParam[\"type\"] == \"buy\":\n                    exchange.Buy(-1, float(dictParam[\"amount\"]))\n                    Log(exchange.GetAccount())\n                elif isSpot and dictParam[\"type\"] == \"sell\":\n                    exchange.Sell(-1, float(dictParam[\"amount\"]))\n                    Log(exchange.GetAccount())\n                elif not isSpot and dictParam[\"type\"] == \"long\":\n                    exchange.SetDirection(\"buy\")\n                    if not q:\n                        exchange.Buy(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"buy\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                elif not isSpot and dictParam[\"type\"] == \"short\":\n                    exchange.SetDirection(\"sell\")\n                    if not q:\n                        exchange.Sell(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"sell\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                elif not isSpot and dictParam[\"type\"] == \"cover_long\":\n                    exchange.SetDirection(\"closebuy\")\n                    if not q:\n                        exchange.Sell(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"closebuy\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                elif not isSpot and dictParam[\"type\"] == \"cover_short\":\n                    exchange.SetDirection(\"closesell\")\n                    if not q:\n                        exchange.Buy(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"closesell\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                \n                if q is not None:\n                    while q.size() > 0:\n                        q.poll()\n                        Sleep(500)\n            \n            # 处理body数据\n            if isDealBodyMsg:\n                if exchange.GetName().find(\"Futures\") != -1:\n                    Log(\"data:\", data.decode('utf-8'))  # 测试\n                    if re.search(r'buy', data.decode('utf-8')):\n                        Log(\"触发buy\")\n                        exchange.SetContractType(ct)\n                        exchange.SetDirection(\"buy\")\n                        exchange.Buy(-1, amount)\n                    elif re.search(r'sell', data.decode('utf-8')):\n                        Log(\"触发sell\")\n                        exchange.SetContractType(ct)\n                        exchange.SetDirection(\"sell\")\n                        exchange.Sell(-1, amount)\n            \n            # 写入数据应答\n            self.wfile.write(json.dumps({\"state\": \"ok\"}).encode())\n        except Exception as e:\n            Log(\"Provider do_POST error, e:\", e)\n\n\ndef createServer(host):\n    try:\n        server = ThreadingHTTPServer(host, Executor)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except Exception as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\ndef main():\n    # 开启一个线程\n    try:\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", Port), ))         # VPS服务器上测试           \n    except Exception as e:        \n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")    \n    if exchange.GetName().find(\"Futures\") != -1:\n        exchange.SetContractType(ContractType)\n    Log(\"账户资产信息：\", _C(exchange.GetAccount))\n    while True:\n        if exchange.GetName() == \"Futures_CTP\":\n            if exchange.IO(\"status\"):\n                LogStatus(_D(), \"CTP连接\")\n            else:\n                LogStatus(_D(), \"CTP未连接\")\n        else:\n            LogStatus(_D())\n        Sleep(2000)"}
{"query": "请生成一个VNC-SVM-Test策略代码", "base_model_response": "```javascript\n// 定义VNC连接参数\nconst host = '192.168.1.100';\nconst user = 'admin';\nconst passwd = 'password';\n\n// 定义机器配置参数\nconst machineName = 'server';\nconst cpuCount = 4;\nconst memory = 1G;\n\n// 定义测试策略\nconst test策略 = {\n  num: 0,\n  run次数: 0,\n  stopCount: 0,\n  logFilePath: './log.txt',\n  startTime: new Date(),\n};\n\n// 创建VNC连接\nVNC.connect(host, user, passwd);\n\n// 获取VNC连接信息\nlet connected = false;\nfor (let i = 0; i < test策略.num; i++) {\n  let tryConnect = VNC.connect(host, user, passwd);\n  if (tryConnect) {\n    connected = true;\n    break;\n  }\n}\n\nif (!connected) {\n  console.log('No connection to host');\n  return;\n}\n```\n\n上面的代码定义了一个`VNC-SVM-Test`策略，它通过监听VNC连接并执行机器配置检查和测试。在每次尝试登录VNC时，都打印一条消息告知用户没有连接到主机。如果连接成功，则继续执行测试；如果未连接，就打印一条消息告知用户已经连接到主机。\n\n你可以根据你的需求修改这个策略代码来满足你的特定需求。例如，你可能想要添加更多的测试用例，或者设置不同的测试时间间隔。", "lora_model_response": "，包括：输入口、输出口以及控制台", "original_response": "python\nimport numpy as np\nimport pandas as pd\n\ndata = DataAPI.MktIdxdGet(indexID=u\"\",ticker=u\"000300\",tradeDate=u\"\",beginDate=u\"20100101\",endDate=u\"20180501\",exchangeCD=u\"XSHE,XSHG\",field=u\"\",pandas=\"1\")\ndata.set_index('tradeDate', inplace = True)\n# 获取HS300的每日价格数据\n\nfor i in range(1, 21, 1):\n    data['close-' + str(i) + 'd'] = data['closeIndex'].shift(i)\n# 对于收盘价，在data中增加了20列数据，分别为1天前的收盘价至20天前的收盘价\n    \nhs_close = data[[x for x in data.columns if 'close' in x]].iloc[20:]\n# 选取今天及1-20天前的收盘价，iloc[20:]剔除了无效数据\n\nhs_close = hs_close.iloc[:, ::-1]\n# 将新DataFrame的列按倒序排列\n################################################################################################\nfrom sklearn import svm\n# 从sklearn库中导入svm算法\n\ndays = 1500\n# 设定全局变量，分割训练集和测试集的数据，1500在上文数据中约占75%\n\nclf_close = svm.SVR(kernel='linear')\n# 使用svm下的SVR算法，'linear'表示线性核\nf_close_train = hs_close[:days]\n# 训练集features\nl_close_train = hs_close['closeIndex'].shift(-1)[:days]\n# 训练集labels，将收盘价shift(-1)表示预测的是下一天的收盘价\nf_close_test = hs_close[days:]\n# 测试集features\nl_close_test = hs_close['closeIndex'].shift(-1)[days:]\n# 训练集labels，将收盘价shift(-1)表示预测的是下一天的收盘价\nclf_close.fit(f_close_train, l_close_train)\n# 训练模型\n\n######################################################################################\n\np_close_train = clf_close.predict(f_close_train)\n# 将训练集features导入模型进行预测，生成预测的收盘价\ndf_close_train = pd.DataFrame(l_close_train)\n# 新建一个DataFrame，内容为训练集labels,即下一天的收盘价\ndf_close_train.columns = ['next close']\n# 列名重命名为'next close'\ndf_close_train['predicted next close'] = p_close_train\n# 加入一列预测的收盘价数据\ndf_close_train['next open'] = data['openIndex'][20:20 + days].shift(-1)\n# 加入一列下一天开盘价的数据，从data而非hs_close中获取，需要切片\n\ntrigger = 1.0\ndf_close_train['position'] = np.where(df_close_train['predicted next close'] > df_close_train['next open'] * trigger, 1, 0)\n# 通过np.where函数判断，当预测的下一天收盘价 > 下一天开盘价相乘或相加一个trigger时，仓位设置为1，否则为0\ndf_close_train['PL'] = np.where(df_close_train['position'] == 1, (df_close_train['next close'] - df_close_train['next open']) / df_close_train['next open'], 0)\n# 当仓位为1时，在下一天开盘时买入，收盘时卖出，记录下一天应获得的收益率，否则收益率为0\n\ndf_close_train['strategy'] = (df_close_train['PL'].shift(1) + 1).cumprod()\n# 策略每日收益的累积收益率，其中shift(1)表示当日记录的是下一天才能获得的收益率，当日无法获得\ndf_close_train['return'] = (df_close_train['next close'].pct_change() + 1).cumprod()\n# benchmark的累积收益率\n\ndf_close_train[['strategy', 'return']].dropna().plot()\n# 画出策略与benchmark的累计收益率图\n\n##########################################################################\ndef main():\n    Log(exchange.GetAccount())"}
{"query": "请生成一个WR-突破马丁策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2021-03-19 05:00:00\nend: 2021-03-21 00:00:00\nperiod: 15m\nbasePeriod: 15m\nexchanges: [{\"eid\":\"Futures_HuobiDM\",\"currency\":\"BTC_USD\"},{\"eid\":\"Futures_HuobiDM\",\"currency\":\"ETH_USD\",\"stocks\":300},{\"eid\":\"Futures_HuobiDM\",\"currency\":\"EOS_USD\",\"stocks\":5000}]\nargs: [[\"openConMode\",null]]\n'''\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport json\nimport time\nimport talib\nimport math\nimport urllib.request\n\nChartCfg = {\n    '__isStock': True,\n    'title': {\n        'text': 'WR'\n    },\n    'yAxis': [{\n        'title': {'text': 'WR'},\n        'style': {'color': '#4572A7'},\n        'opposite': False #右边轴\n    }],\n    'series': [{\n        'type': 'line',\n        'id': 'wr',\n        'name': 'wr',\n        'data': []\n    }]\n}\n\ndef MyLog(str1,ktime,price=''):\n    if (_G('str')!=str1 or _G('ktime')!=ktime) and  not (_G('str2')==str1 and ktime==_G('ktime2')) :\n        _G('str2',_G('str'))\n        _G('ktime2',_G('ktime'))\n\n        _G('str',str1)\n        _G('ktime',ktime)\n        Log(str1+str(price)) \n\n\ndef moveStocks(_moveStocks):\n    global todayProfit\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance  只有币本位有交割且共用资金 2-U本位向现货   4-币本位向现货  返回tranId\n        if exchanges[0].GetCurrency().find('USDT')>=0:\n            movecurrency = 'USDT'\n            mtype = 2\n        else:#币本位\n            movecurrency = 'BTC'\n            mtype = 4\n        timestamp = Unix()*1000       \n        params = \"type=\"+str(mtype)+\"&asset=\"+movecurrency+\"&amount=\"+str(_moveStocks)+\"&timestamp=\"+str(timestamp)\n        exchanges[0].SetBase('https://api.binance.com')\n        moveid = exchange.IO(\"api\", \"POST\", \"/sapi/v1/futures/transfer\", params)   \n        exchanges[0].SetBase('https://fapi.binance.com')\n        if moveid is not None:\n            Log('资金转出成功',moveid)\n            _G('moveStocks',_G('moveStocks')+_moveStocks)\n            todayProfit[\"initStocks\"] = todayProfit[\"initStocks\"] - _moveStocks\n            _G('todayProfit',todayProfit)\n            \n        else:\n            Log('资金转出失败')\n    else:\n        Log('暂不支持该交易所转移')\n    \ndef cancelOD(i):\n    orders = _C(exchanges[i].GetOrders)\n    for order in orders:\n        exchanges[i].CancelOrder(order.Id)\n        Sleep(100)\n\ndef coverAll(i):\n    position = _C(exchanges[i].GetPosition)\n    cancelOD(i)\n    Sleep(200)\n    for j in range(len(position)):\n        pamount = position[j][\"Amount\"] #-position[0][\"FrozenAmount\"]\n        if position[j][\"Type\"]==0:     #持多单\n            Deal(-1 , pamount, \"closebuy\", exchanges[i].GetCurrency()+'手动市价清仓',i)\n        elif position[j][\"Type\"]==1:     #持空单\n            Deal(-1 , pamount, \"closesell\", exchanges[i].GetCurrency()+'手动市价清仓',i)\n        \ndef  getOpenPrice(position):\n    if hasattr(position[0],'Info') and hasattr(position[0].Info,'cost_open'):#huobi\n        return position[0].Info.cost_open\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'avg_cost'):#ok\n        return position[0].Info.avg_cost\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'entryPrice'):#binance\n        return position[0].Info.entryPrice\n    else:\n        return position[0][\"Price\"] \n\n    \ndef UpdateAccout():\n    accout = _C(exchanges[0].GetAccount)\n    acc1 = accout.FrozenBalance    #其它币的冻结余额  是否共用?\n    acc2 = accout.Balance\n    \n    _G(\"ableAccount\", acc2)#当前可用U\n    _G(\"allAccount\",acc1+acc2+GetMargin()) #没计算浮盈\n    if acc2<1:\n        Log(\"账户保证金余额不足\")\n        Sleep(8000)\n\ndef GetMargin():\n    allMargin = 0\n    for i in range(len(exchanges)):\n        allMargin += _G(\"margin\")[i]\n    return _N(allMargin,2)\n\n\ndef GetHighest(records,i,period):\n    high = 0\n    for i in range(i-period+1,i+1):\n        if records[i].High > high:\n            high = records[i].High\n    return high\n\ndef GetLowest(records,i,period):\n    low = 1000000\n    for i in range(i-period+1,i+1):\n        if records[i].Low < low:\n            low = records[i].Low\n    return low\n    \n        \ndef SetType(type):\n    if type==0:\n        _G(\"contractType\",\"swap\")\n    elif type==1:\n        _G(\"contractType\",\"this_week\")\n    elif type==2:\n        _G(\"contractType\",\"next_week\")\n    elif type==3:\n        _G(\"contractType\",\"quarter\")\n    elif type==4:\n        _G(\"contractType\",\"next_quarter\")\n        \ndef Deal(price, num, btype, beizhu='',i=0 ):\n    Sleep(50)\n    #if beizhu!='':\n    #    Log(beizhu)\n    exchanges[i].SetDirection(btype)\n    if btype==\"closebuy\" or btype==\"sell\" :\n        exchanges[i].Sell(price , num, beizhu)\n        #Log('开空',price)\n    else:\n        exchanges[i].Buy(price , num, beizhu)\n        #Log('开多',price)\n\n\ndef myProfit():\n    LogProfit( _G(\"allAccount\")-_G(\"initStocks\") )\n\n\ndef initData():\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|No need to change|reused\")\n    global allCoinData\n    Log(\"正在初始化...\")\n\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance\n        getBinanceAllCoinData()\n        Sleep(3000)\n        Log(\"获取交易所信息结束\")\n    else:\n        Log('暂不支持该交易所')\n        return\n    \n    if _G(\"moveStocks\") is None:\n        _G(\"moveStocks\",0)\n    if _G(\"moveInStocks\") is None:\n        _G(\"moveInStocks\",0)\n        \n    for i in range(len(exchanges)):#初始化 交易所\n        symbol = exchanges[i].GetCurrency().split('_')[0]\n        exchanges[i].SetContractType(\"swap\")\n        exchanges[i].SetPrecision(allCoinData[symbol]['tick_size'], allCoinData[symbol]['size_increment'])\n        exchanges[i].SetMarginLevel(marginLevel)\n        timestamp = Unix()*1000      \n        exchanges[i].IO(\"api\", \"POST\", \"/fapi/v1/positionSide/dual\", \"dualSidePosition=true&timestamp=\"+str(timestamp))\n        \n    \n        \ndef main():\n    global allCoinData, orderID\n    if _G(\"contractType\") is None:\n        _G(\"contractType\",\"swap\")\n    global ChartCfg\n    preTime = 0\n    chart = Chart(ChartCfg)\n    chart.reset()\n    \n    margin = [0 for i in range(len(exchanges)) ] \n    _G(\"margin\",margin)\n    preTime = 0\n    bucTimes = [0 for i in range(len(exchanges)) ] \n    initData()\n    #LogProfitReset(1)\n    #暂未考虑仓位不足\n    while(true):\n        #Log('测试循环')\n        cmd = GetCommand()\n        if cmd:\n            if cmd == \"清仓停机\":\n                for i in range(len(exchanges)):\n                    Sleep(100)\n                    coverAll(i)\n                Sleep(1000)\n                return\n            if cmd.find('cover-')>=0:\n                arr = cmd.split(\"-\")\n                coverAll(int(arr[1]))\n                Sleep(2000)\n            elif cmd == 'cancelOD':\n                cancelOD()\n                Sleep(1000)\n        \n        tab1 = {\n            \"type\": \"table\", \n            \"title\": \"账户信息\", \n            \"cols\": [\"初始资金\", \"当前资金\" , \"可用资金\", \"已移出资金\", \"总盈利率\"], \n            \"rows\": []\n        }\n        tab2 = {\n            \"type\": \"table\", \n            \"title\": \"持仓状态\", \n            \"cols\": [\"币种\", \"最新价\",\"持仓数\", \"持仓均价\",  \"浮动盈亏\",\"操作\"], \n            \"rows\": []\n        }\n        \n        \n        UpdateAccout() \n        if _G(\"initStocks\") is None or _G(\"initStocks\")<10 :\n            _G(\"initStocks\", _G(\"allAccount\"))\n        if autoMoveStocks>100 and _G('ableAccount')>autoMoveStocks :\n                Log('自动移出资金：100U#32CD32')\n                moveStocks(100)\n                continue\n\n        for i in range(len(exchanges)):\n            Sleep(100)\n            records = _C(exchanges[i].GetRecords,60 * period)\n            #wr_high = TA.Highest(records, WRperiod, 'High')\n            #wr_low = TA.Lowest(records, WRperiod, 'Low')\n            #wr = (records[-1].Close-wr_high)/(wr_high-wr_low)*100\n            position = _C(exchanges[i].GetPosition)\n            margin = _G(\"margin\")\n            if len(position)>0:\n                oprice = float(getOpenPrice(position))\n                margin[i] = position[0][\"Margin\"]\n                floatProfit =  float(position[0][\"Profit\"])\n                pamount = float(position[0]['Amount'])\n                #止损\n                if -1*floatProfit > oprice*pamount/marginLevel*zhis/100:\n                    if position[0]['Type']==0:\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止损'+format(records[-1].Close,'.4f'),i)\n                    else:\n                        Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止损'+format(records[-1].Close,'.4f'),i)\n                    Sleep(500)\n                    myProfit()\n                    bucTimes[i] += 1\n                    if bucTimes[i]>maxBuc:\n                        bucTimes[i] = maxBuc\n                #止盈\n                if floatProfit > oprice*pamount/marginLevel*zhiy/100:\n                    if position[0]['Type']==0:\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止盈'+format(records[-1].Close,'.4f'),i)\n                    else:\n                        Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止盈'+format(records[-1].Close,'.4f'),i)\n                    Sleep(500)\n                    myProfit()\n                    bucTimes[i] = 0\n            else:\n                oprice = 0\n                margin[i] = 0\n                floatProfit = ''\n\n            _G(\"margin\", margin)\n            \n            \n            for k in range(50, len(records)):\n\n                wr_high1 = GetHighest(records,k, WRperiod)\n                wr_low1 = GetLowest(records,k, WRperiod)\n                wr1 = (records[k].Close-wr_high1)/(wr_high1-wr_low1)*100\n                if k==len(records)-1:\n                    if wr1>-5:#开空\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==0):#平多\n                            if len(position)>0:\n                                Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单清仓'+format(records[-1].Close,'.4f'),i)\n                                Sleep(500)\n                                myProfit()\n                                if floatProfit<0:\n                                    bucTimes[i] += 1\n                                    if bucTimes[i]>maxBuc:\n                                        bucTimes[i] = maxBuc\n                                else:\n                                    bucTimes[i] = 0\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\n                            if famount==0:\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\n                                continue\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\n                            Deal(-1, pamount, 'sell',exchanges[i].GetCurrency()+' 空单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)\n                    elif wr1<-95:#开多\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==1):#平空\n                            if len(position)>0:\n                                Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单清仓'+format(records[-1].Close,'.4f'),i)\n                                Sleep(500)\n                                myProfit()\n                                if floatProfit<0:\n                                    bucTimes[i] += 1\n                                    if bucTimes[i]>maxBuc:\n                                        bucTimes[i] = maxBuc\n                                else:\n                                    bucTimes[i] = 0\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\n                            if famount==0:\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\n                                continue\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\n                            Deal(-1, pamount, 'buy',exchanges[i].GetCurrency()+' 多单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)        \n                    #Log(wr1)\n                \n                #画图\n                if i==0 and records[k]['Time'] == preTime:\n                    chart.add(0, [records[k]['Time'], wr1], -1)\n                elif i==0 and records[k]['Time'] > preTime:\n                    #Log('insert',records[k]['Time'],wr_high1,wr_low1,records[k].Close,wr1)\n                    chart.add(0, [records[k]['Time'], wr1])\n                    preTime = records[k]['Time']\n            \n\n            #myProfit()\n\n            if len(position)>0 and position[0]['Type']==0:\n                pamount = '多：'+str(position[0]['Amount'])+str('#32CD32')\n            elif len(position)>0 and position[0]['Type']==1:\n                pamount = '空：'+str(position[0]['Amount'])+str('#BC1717')\n            else:\n                pamount = ''\n            if len(position)>0:\n                floatProfit = format( position[0][\"Profit\"],'.2f')\n            symbol = exchanges[i].GetCurrency().split('_')[0]\n            tab2[\"rows\"].append([ exchanges[i].GetCurrency() , records[-1].Close \\\n                             , pamount, format(oprice,'.'+str(allCoinData[symbol]['tick_size'])+'f'), floatProfit \\\n                             , { \"type\": \"button\",  \"cmd\": 'cover-'+str(i), \"name\": \"清仓\" } ])\n\n        #总盈利\n        allzhiy = float(_G('allAccount'))-float(_G('moveInStocks'))+float(_G('moveStocks'))-float(_G('initStocks'))\n        if _G('initStocks')==0:\n            allzhiyl=0\n        else:\n            allzhiyl = (float(_G('moveStocks'))+float(_G('allAccount'))-float(_G('moveInStocks'))-float(_G('initStocks')))/float(_G('initStocks'))*100\n         \n        tab1[\"rows\"].append([format(_G('initStocks'),'.1f')+'U', format(_G('allAccount'),'.1f')+'U', format(_G('ableAccount'),'.1f')+'U', format(_G('moveStocks'),'.1f')+'U' \\\n                             , format(allzhiyl,'.1f')+'%('+format(allzhiy,'.1f')+'U)'])    \n        LogStatus(  '`' +json.dumps(tab1) + \"`\\n\" +\"`\" + json.dumps(tab2) + \"`\\n\"  )\n           \n        Sleep(1000)\n           \n                \n\n# 获取Binance永续合约所有币对消息\ndef getBinanceAllCoinData():\n    global allCoinData\n    tmp = dict()\n    data = getUrlData(\"http://fapi.binance.com/fapi/v1/exchangeInfo\")\n    for item in data['symbols']:\n        # 需要USDT为衡量币对\n        if \"USDT\" in item[\"symbol\"]:\n            size = item['filters'][1]['stepSize']    # DOGE 1.00000000   BTC 0.00000100\n            if float(size) == 1:\n                sizein = 0\n            elif len(size.split(\".\"))>1:\n                sizein = str(size).split(\".\")[1].find('1')+1\n            else:\n                sizein = 0\n            tmp[item[\"baseAsset\"]] = {\n                'tick_size': int(item['pricePrecision']),  # 价格精度\n                'old_increment': item['filters'][1]['stepSize'],#最小购买值\n                'size_increment': sizein # 折算数量\n            }\n    allCoinData = tmp\n    \n    \n# 通过url获取数据\ndef getUrlData(url):\n    response = urllib.request.urlopen(url)\n    html = response.read().decode('utf-8')#decode('utf-8') 解决:the JSON object must be str, not 'bytes'\n    try:\n        tmp = json.loads(html)\n        return json.loads(html)\n    except Exception as e:\n        Log('e:',e)      \n\n        \n# 对合约进行止盈止损   cangType=0默认逐仓  =1全仓\ndef zhiyingzhisun(i, amount, directionStr, positionSide, zhiying, zhisun, cangType = 0):\n    return bianSwap(i, amount, directionStr, positionSide, zhiying, zhisun)\n \n# 发送请求\ndef AsynIo(i, paramList):\n        if (len(paramList) == 3):\n            arrRoutine = exchanges[i].Go(\"IO\", paramList[0], paramList[1], paramList[2])\n        elif (len(paramList) == 4):\n            arrRoutine = exchanges[i].Go(\"IO\", paramList[0], paramList[1], paramList[2], paramList[3])\n        elif (len(paramList) == 5):\n            arrRoutine = exchanges[i].Go(\"IO\", paramList[0], paramList[1], paramList[2], paramList[3], paramList[4])\n        data, ok = arrRoutine.wait()\n        Log(data)\n        return data\n\n# 币安合约\ndef bianSwap(i, amount, directionStr, positionSide, zhiying, zhisun):\n    global orderID\n    instrument_id = exchanges[i].GetCurrency().replace('_',\"\")\n    # U本位或币本位，设置请求url\n    if instrument_id.find('USDT') >= 0 :\n        url = \"/fapi/v1/order\"\n    elif instrument_id.find('USD') >= 0 :\n        url = '/dapi/v1/order'\n    else:\n        return False\n    # 止损  side = SELL  BUY\n    '''\n    timestamp = Unix()*1000      \n    params = \"symbol=\"+instrument_id+\"&side=\"+str(directionStr)+\"&positionSide=\"+positionSide+\"&type=STOP_MARKET&stopPrice=\"+str(zhisun)+\"&closePosition=true&timestamp=\"+str(timestamp)\n    Log(params)\n    zhisunData = exchanges[i].IO(\"api\", \"POST\", \"/fapi/v1/order\", params)\n    Log(zhisunData)\n    '''\n    zhisunData = AsynIo(i, ['api', 'POST', url , '', json.dumps({\n        \"symbol\": instrument_id,\n        \"side\": directionStr,\n        \"positionSide\":positionSide,\n        \"type\": \"STOP_MARKET\",\n        #\"quantity\": amount,\n        \"closePosition\":\"true\",\n        #\"price\": zhisun,\n        \"stopPrice\": zhisun,\n        \"timestamp\": str(int(round(time.time() * 1000)))\n    })])\n\n    if int(float(zhisunData['stopPrice'])) != int(float(zhisun)):\n        Log('止损价格不一样',float(zhisunData['stopPrice']),int(float(zhisunData['stopPrice'])), float(zhisun), int(float(zhisun)) )\n        return False\n    orderID[i][0] = zhisunData['orderId']\n    Log('设置'+exchanges[i].GetCurrency()+'止损，订单号：'+str(orderID[i][0]))\n    # 止盈\n    zhiyingData = AsynIo(i, ['api', 'POST', url , '', json.dumps({\n        \"symbol\": instrument_id,\n        \"side\": directionStr,\n        \"positionSide\":positionSide,\n        \"type\": \"TAKE_PROFIT_MARKET\",\n        #\"quantity\": amount,\n        \"closePosition\":\"true\",\n        #\"price\": zhiying,\n        \"stopPrice\": zhiying,\n        \"timestamp\": str(int(round(time.time() * 1000)))\n    })])\n    if int(float(zhiyingData['stopPrice'])) != int(zhiying):\n        Log('止盈价格不一样',float(zhiyingData['stopPrice']),int(float(zhiyingData['stopPrice'])), float(zhiying), int(float(zhiying)) )\n        return False\n    orderID[i][1] = zhiyingData['orderId']\n    Log('设置'+exchanges[i].GetCurrency()+'止盈，订单号：'+str(orderID[i][1]))\n    _G(\"orderID\",orderID)\n    return True"}
{"query": "请生成一个ZT-交易所接口可用于对接平台暂不支持的冷门交易所-ZT策略代码", "base_model_response": "。", "lora_model_response": "", "original_response": "python\n#!Python3\n\n\"\"\"\n《策略代写》 与 （此程序帮助），致信QQ：35787501\n\nZT 交易所接口，可用于对接 平台暂不支持的冷门交易所 ZT\n\"\"\"\n\nfrom requests import get, post\nfrom hashlib import md5\nfrom urllib.parse import urlencode\n\n\nclass ZT:\n    def __init__(self, api_key, secret_key):\n        self.api_key = api_key\n        self.secret_key = secret_key\n        self.host = \"https://www.ztb.im\"\n        self.headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\n                          'AppleWebKit/537.36 (KHTML, like Gecko) '\n                          'Chrome/92.0.4515.159 Safari/537.36',\n            \"content-type\": \"application/x-www-form-urlencoded\",\n            'X-SITE-ID': '1',\n        }\n\n    def http_post(self, path, params):\n        return post(f\"{self.host}{path}\", data=urlencode(params), headers=self.headers, timeout=5)\n\n    def get_sign(self, params):\n        return md5((urlencode(params) + f\"&secret_key={self.secret_key}\").encode()).hexdigest().upper()\n\n    def get_ticker(self, symbol):\n        return float(\n            get(\n                f\"{self.host}/api/v1/trades?symbol={symbol}&size=1\", headers=self.headers, timeout=5\n            ).json()[0][\"price\"]\n        )\n\n    def send_order(self, symbol, side, price, amount):\n        path = \"/api/v1/private/trade/limit\"\n        params = {\n            \"amount\": amount,\n            \"api_key\": self.api_key,\n            \"market\": symbol,\n            \"price\": price,\n        }\n        all_side = {\"close_sell\": 1, \"open_buy\": 2}\n        params[\"side\"] = all_side[side]\n        params[\"sign\"] = self.get_sign(params)\n        return str(self.http_post(path, params).json().get(\"result\", {'id': \"0\"})[\"id\"])\n\n    def select_order(self, symbol, oid):\n        path = \"/api/v1/private/order/pending/detail\"\n        params = {\n            \"api_key\": self.api_key,\n            \"market\": symbol,\n            \"order_id\": oid,\n        }\n        params[\"sign\"] = self.get_sign(params)\n        return not self.http_post(path, params).json()['result']\n\n    def cancel_order(self, symbol, oid):\n        path = \"/api/v1/private/trade/cancel\"\n        params = {\n            \"api_key\": self.api_key,\n            \"market\": symbol,\n            \"order_id\": oid,\n        }\n        params[\"sign\"] = self.get_sign(params)\n        return self.http_post(path, params).json()"}
{"query": "请生成一个binance部分交易封装示例策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# -*- coding = utf-8 -*-\n# @Time:2023/2/20 11:04\n# @Author: 作手君\n# @File: binance.py\n# @Software: PyCharm\n\nimport json\nimport time\nimport hmac\nfrom hashlib import sha256\nimport requests\nfrom logger import logger\n\n\ndef cleanNoneValue(d) -> dict:\n    out = {}\n    for k in d.keys():\n        if d[k] is not None:\n            out[k] = d[k]\n    return out\n\n\ndef get_timestamp() -> int:\n    return int(time.time()) * 1000\n    # cet_tz = pytz.timezone('Etc/GMT+0')\n    # t = datetime.now(cet_tz)\n    # return int(time.mktime(t.timetuple())) * 1000\n    # return (int(time.time()) - (8*60*60)) * 1000\n    # utc_t = datetime.datetime.utcnow().timestamp()\n    # return int(utc_t * 1000)\n\n\nclass Binance(object):\n    def __init__(self, api_key, secret_key):\n        self.api_key = api_key\n        self.secret_key = secret_key\n        self.host = 'https://fapi.binance.com'\n        self.timestamp = ''\n        self.method = ''\n        self.request_path = ''\n\n    # 交易\n    def trade_order(self, symbol, pos_side, trade_side, sz, client_id, ord_type=\"market\", px=None):\n        self.request_path = '/fapi/v1/order'\n        self.method = 'POST'\n        params = {\n            'symbol': symbol.upper() + 'USDT',\n            'side': trade_side.upper(),  # 买卖方向 SELL, BUY\n            'positionSide': pos_side,  # long short\n            'type': ord_type.upper(),\n            'quantity': sz,  # 数量\n            'newClientOrderId': 'x-YZChr3zS' + str(client_id),  # 客户订单号\n            # 'timeInForce': 'GTC',\n        }\n        if ord_type == 'limit':\n            params['timeInForce'] = 'GTC'\n            params['price'] = str(px)\n        url = self.generate_url(params)\n        # 0 成功 1暂停几秒 2忽略此次交易 3 用户停止策略\n        try:\n            response = self.send(url)\n            if 'code' in response.keys():\n                if int(response['code']) == -2018 or int(response['code']) == -2019:\n                    # 余额不足 直接清仓\n                    return {\"code\": 3, \"msg\": response.get('msg', ''), \"data\": {}}\n                return {\"code\": 1, \"msg\": response.get('msg', ''), \"data\": {}}\n                pass\n            else:\n                return {\n                    'code': 0,\n                    'msg': '',\n                    'data': {\n                        'clOrdId': response['clientOrderId'],\n                        'ordId': response['orderId'],\n                    }\n                }\n        except Exception as e:\n            logger.error('binance error')\n            logger.error(e)\n            return {\"code\": 2, \"msg\": str(e), \"data\": {}}\n\n    # 获取挂单列表\n    def get_open_order(self):\n        self.request_path = '/fapi/v1/openOrders'\n        self.method = 'GET'\n        url = self.generate_url({})\n        response = self.send(url)\n        return response\n\n    def get_kline(self, symbol, limit, interval):\n        self.request_path = '/fapi/v1/klines'\n        self.method = 'GET'\n        params = {\n            'symbol': symbol.upper() + 'USDT',\n            'interval': interval,\n            'limit': limit,\n        }\n        url = self.generate_url(params)\n        response = self.send(url)\n        return response\n\n    # 获取单币种挂单列表\n    def get_symbol_open_order(self, symbol):\n        self.request_path = '/fapi/v1/openOrders'\n        self.method = 'GET'\n        url = self.generate_url({\n            'symbol': symbol.upper() + 'USDT'\n        })\n        response = self.send(url)\n        return response\n\n    # 获取挂单列表\n    def get_positions(self, symbol):\n\n        self.request_path = '/fapi/v2/account'\n        self.method = 'GET'\n        url = self.generate_url({})\n        response = self.send(url)\n        positions = response['positions']\n        return positions\n\n    # 撤单\n    def cancel_order(self, symbol):\n        self.request_path = '/fapi/v1/allOpenOrders'\n        self.method = 'DELETE'\n        params = {\n            'symbol': symbol.upper() + 'USDT',\n        }\n        url = self.generate_url(params)\n        response = self.send(url)\n        if 'code' in response.keys() and int(response.get('code', 0)) != 200:\n            raise Exception(response.get('msg'))\n        return response\n\n    def generate_url(self, params, use_timestamp=True):\n        if use_timestamp:\n            params['timestamp'] = get_timestamp()\n        return '{}{}?{}'.format(self.host, self.request_path, self.generate_sign(params))\n\n    def generate_sign(self, params):\n        query_string = ''\n        for k in params.keys():\n            query_string = query_string + '{}={}&'.format(k, params.get(k))\n        query_string = query_string[:-1]\n        if self.secret_key:\n            signature = hmac.new(self.secret_key.encode(\"utf-8\"),\n                                 query_string.encode(\"utf-8\"), digestmod=sha256).hexdigest()\n            query_string = query_string + '&signature=' + signature\n        return query_string\n\n    def send(self, url, params=None):\n        session = requests.Session()\n        session.headers.update(\n            {\n                \"Content-Type\": \"application/json;charset=utf-8\",\n                \"X-MBX-APIKEY\": self.api_key,\n            }\n        )\n        if self.method == 'GET':\n            response = session.get(url=url, params=params)\n        elif self.method == 'DELETE':\n            response = session.delete(url=url, params=params)\n        else:\n            response = session.post(url=url, params=params)\n        # logger.info('币安请求信息')\n        # logger.info(params)\n        # logger.info(response.text)\n        return json.loads(response.text)"}
{"query": "请生成一个bollmaboll策略代码", "base_model_response": "", "lora_model_response": "```python\nimport numpy as np\nfrom pandas as pd\n\n\n# 假设是BollMABoll风格的\ndef bollmaboll(data, n_samples):\n    \"\"\"\n    返回一个基于BollMABoll风格的随机采样点的列表，每个点的权重为其上一交易日的收盘价与前一日收盘价的差值。\n    \n    参数:\n        data (pandas.DataFrame): 这个DataFrame包含从头到尾的数据点，用于使用BollMABoll进行预测。\n        \n    返回:\n        list: 包含n个点的随机采样点的列表\n    \"\"\"\n    # 如果数据没有数据，则返回一个空列表\n    if not data:\n        return []\n    \n    # 绘制数据点，包括开盘价、最高价、最低价、收盘价和收盘价与昨天的收盘价的差值\n    # 执行bollmann方法\n    def boll(m, m_min, m_max):\n        \"\"\"\n        运算函数，用于计算BollMABoll模型中参数\n        \"\"\"\n        if m < m_min or m > m_max:\n            raise ValueError(\"错误：x坐标范围不能等于X坐标范围\")\n        \n        a,b,c,d,k,l,f = m*100.0*(m_max-m.min),b+50.0*m.max,k-40.0,m_min,\n                        d-c*0.9,b-a,b-a*0.8,b-a*0.6,b-a*0.5,k-l+3.0,n*t,\n                        l-f,f-l-k,k-t-f-d,k-t-f-(d-k)\n        \n        # 填充bollmann公式\n        h=0.0,2.7082902217624775,5244.7724025937889,12.9954784528669574,-0.502010697759940315,-1.71394436722571269,\n        P=4e-05/((a+b+c))/(1-p),f=4e-05/((c+d-b-a)/((a+b+c))),\n        \n        # 使用Haversine公式计算交点和\n        r,s,m=5*16.0,4*16.0,0.22406350468672753\n        N=0\n        while R-s> 1e-15:\n            R,A=(r-s)**2+1/(s-a)*l,S=A-M*0.8*(N.r-N.s-A.N.a)*(p-B-A),\n            \n            # 油管滑行计算并取平均\n            B=(a+R)/S,A-S=-R/B,B=A,\n            \n            L,b,b,M,D,C,c=(D-S-L-M+B-D)/(D-S-C)-N,B,N,A,(C-M/S+C-D),\n            L,S,S,B=(L-S,B,D,C-M/M) + N,N,D,B,\n            \n            # 如果滑行次数超过一天且没有出现过点\n            N>>0,\n            D-S,L-M,S,M,D,C,Y,E=0.001,\n            K=-(-E)/(2*K)*2,\n            H=(E-K-E^2+E+Y-E)^(2/2),\n            Q=(Q+(E-K-E^2+E+Y-E)/E-E+Y)^(2/2),\n            Q=Q+1/(H-Q),\n            C(C-S)-E+(E-K-E^2+E+Y-E)/E+Y,\n            E(E-F-H)+E-E+Y+(E-K-E^2+E+Y-E)/E+Y,\n            C=C-S-(E-K-E^2+E+Y-E)/E+Y,\n            \n            # 向左移动点\n            Q=Q-P*1,\n            Y=(E-P+E^2+E+Y)/E-K,\n            B(M-S)+H-B(K-H),\n            K(L-M)+H-H-H-H,\n            K(S-S)+H-K-K-H-H,\n            E(D-S)-L-S,M-S)+H-K-H-K,\n            Y(H-K)-E-\n            L-S+H-H-H-Y,\n            S(M-S)+H-H-H-H-L,\n            C(Y-S)-E-E+Y+(E-K-E^2+E+Y-E)/E+Y,\n            C(C-M/S)-E+(E-K-E^2+E+Y-E)/E+Y,", "original_response": "python\nimport numpy as np\nimport talib\nimport time\nif period == 1:\n\tper = PERIOD_M1\nif period == 2:\n\tper = PERIOD_M3\nif period == 3:\n\tper = PERIOD_M5\nif period == 4:\n\tper = PERIOD_M15\nif period == 5:\n\tper = PERIOD_M30\nif period == 6:\n\tper = PERIOD_H1\n\t\nstatus=0 #多：1  空：2\n\nposition = 0\n\ndef ontick():\n\tglobal position\n\trecords = exchange.GetRecords(per)\n\t#------------指标计算---------\n\t#rsi = TA.RSI(records,14)\n\t#if rsi[-1] > 65 or rsi[-1] < 35:\n\t#    return\n\tbb = talib.BBANDS(records.Close,timeperiod=bo, nbdevup=2, nbdevdn=2, matype=0) #计算BB\n\trsi = talib.RSI(records.Close,timeperiod=12)\n\tcmi = talib.CMO(records.Close,timeperiod=12)\n\tprint(cmi[-1])\n\tmove = talib.SMA(records.Close,ma2)#收盘价ma\n\tmabt = talib.SMA(bb[0],ma)#上轨ma\n\tmabd = talib.SMA(bb[2],ma)#下跪ma\n\taccount = exchange.GetAccount()\n\n\t\n\n\tif bb[0][-1] > mabt[-1] and bb[0][-2] < mabt[-2] and bb[2][-1] < bb[2][-2] and bb[1][-1] > bb[1][-2] and records.Close[-1] > move[-1] and rsi[-1]>60:\n\t\tposition += 1\n\t\texchange.Buy(-1,account.Balance*0.1)\n\t\t#log('向上突破开多 '+ str(close[-1]))\n\t\n\tif bb[2][-1] < mabd[-1] and bb[2][-2] > mabd[-2] and bb[0][-1] > bb[0][-2] and bb[1][-1] < bb[1][-2] and records.Close[-1] < move[-1] and rsi[-1]<40:\n\t\tposition -= 1\n\t\texchange.Sell(-1,account.Stocks*0.1)\n\t\t#log('向下突破开空 '+ str(close[-1]))\n\t\n\tif bb[0][-1]-bb[2][-1] < bb[0][-2]-bb[2][-2]:\n\t\tif bb[0][-1] < mabt[-1] and bb[0][-2] > mabt[-2] and position> 0:\n\t\t\tposition -= 1\n\t\t\texchange.Sell(-1,account.Stocks*0.1)\n\t\t\t#log('多单平仓 '+ str(close[-1]))\n\n\t\tif bb[2][-1] > mabd[-1] and bb[2][-2] < mabd[-2] and position < 0:\n\t\t\tposition += 1\n\t\t\texchange.Buy(-1,account.Balance*0.1)\n\t\t\t#log('空单平仓 '+ str(close[-1]))\n\ndef main():\n\twhile True:\n\t\tontick()\n\t\tSleep(30000)"}
{"query": "请生成一个grid策略代码", "base_model_response": "这是一个使用Python实现的网格策略：\n\n```python\ndef grid(n, m):\n    def grid_search(k):\n        row = k * m  # 等于行数，列数\n        col = n * m  # 等于列数\n        if (row < 0) or (col < 0):\n            return -1\n        if (row >= m) or (col >= n):\n            return -2\n        return 1\n    def grid_row(x, y):\n        return x + y\n    def grid_col(x, y):\n        return x - y\n    def fill_k(x, y, arr):\n        k += 1\n        grid_search(arr)\n        arr[k] = fill_k(x, y, arr)\n\n    if n == m:\n        return [0]\n    else:\n        if grid_search(0) == 0 or grid_search(m) == 0:\n            return [-1]\n        rows = []\n        for i in range(n):\n            for j in range(m):\n                if i > 0 and j > 0:\n                    x, y = grid(row[i], j), grid_col(i, j)\n                    arr[x][y] = grid_search(0)\n                elif i < 0 and j < 0:\n                    x, y = grid(row[i], j), grid_col(i, j)\n                    arr[x][y] = grid_search(0)\n                elif i >= m or j >= n:\n                    x, y = grid(row[i], j), grid_col(i, j)\n                    arr[x][y] = grid_search(0)\n                elif i % m == j % n == 0 and arr[x][y] != 0:\n                    arr[x][y] = fill_k(x, y, arr)\n                rows.append(arr[rows.index(grid搜索)])\n        return rows\n\n    print(grid_search(0))\n```\n\n这个函数首先定义了一个用于在给定的k值下找到网格中间点的位置。然后它定义了四个函数：grid_search、grid_row和grid_col来遍历网格中的每个元素，并使用它们找到网格中满足条件的位置。最后，函数将所有格子合并到一个列表中。\n\n注意：这个函数假设输入的网格是连续的，并且每个顶点都是唯一的。如果输入的网格不连续或不唯一，该函数可能无法正确找到格子中的位置。", "lora_model_response": "", "original_response": "python\nlast_tick = []\nline = []\ngrid_buy_list = []\n\ndef net(now_price):\n    global line\n    print(now_price)\n    line = [now_price*(1+0.003*i) for i in range(-1000,1000)]\n    Log(line)\n    \ndef ontick():\n    global last_tick\n    global  line\n    global grid_buy_list\n    account = exchange.GetAccount()\n    ticker = exchange.GetTicker()\n    last_tick.append(ticker['Last'])\n    if len(last_tick) == 1:return\n    elif len(last_tick) == 100:del last_tick[0]\n    for i in range(len(line)):\n        if last_tick[-1] > line[i] and last_tick[-2] < line[i] and len(grid_buy_list)!= 0 and i > min(grid_buy_list)  and account['Stocks'] >= 0.001:\n            exchange.Sell(last_tick[-1],0.01)\n            del grid_buy_list[grid_buy_list.index(min(grid_buy_list))]\n            Log(exchange.GetAccount())\n        elif last_tick[-1] < line[i] and last_tick[-2] > line[i] and i not in grid_buy_list:\n            exchange.Buy(last_tick[-1],0.01)\n            grid_buy_list.append(i)\n            Log(exchange.GetAccount())\n\ndef main():\n    net(exchange.GetTicker()['Last'])\n    Log(exchange.GetAccount())\n    while(True):\n        ontick()\n        Sleep(1000)"}
{"query": "请生成一个python-状态栏表格-显示按钮范例策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport json\n\ndef main():\n    tab = {\n        \"type\" : \"table\", \n        \"title\" : \"demo\", \n        \"cols\" : [\"a\", \"b\", \"c\"], \n        \"rows\" : [[\"1\", \"2\", {\"type\" : \"button\", \"cmd\" : \"coverAll\", \"name\" : \"平仓\"}]]    # 在状态栏表格 第一行，第三列上配置一个按钮 名字是平仓\n    }\n    \n    LogStatus(\"`\" + json.dumps(tab) + \"`\")"}
{"query": "请生成一个python策略代码", "base_model_response": "，模拟用户点击按钮然后提交数据\n\n```python\nimport random\n\nclass User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\n@app.route('/submit', methods=['POST'])\ndef submit_data():\n    data = {\n        'name': random.randint(1, 20),\n        'email': random.randint(1, 20)\n    }\n\n    user = User(name=data['name'], email=data['email'])\n\n    if user.submit_data():\n        return 'Form submitted successfully.'\n    else:\n        return 'Error submitting form.'\n\nif __name__ == '__main__':\n    print(submit_data())\n```\n\n这个Python策略代码模拟了一个用户点击`/submit`按钮，并在页面上提交了一段数据。它创建了两个类：User和SubmitData，用于处理请求和返回不同的结果。\n\n在主程序中，我们测试了submit_data方法是否成功提交了表单数据。如果成功，我们将输出\"Form submitted successfully.\"；否则，我们将输出\"Error submitting form.\"。\n\n请注意，此代码只是一个示例，实际使用时可能需要根据你的具体需求进行调整。", "lora_model_response": "```python\n# 该策略会随机选择一定数量的点\ndef choose_random_points(nums, target_size, n):\n    while True:\n        random_point = nums.random() * target_size + 1\n        if random_point % 2 == 0 and target_size > random_point:\n            return []\n        nums.pop(random_point)\n```\n\n测试用例：\n\n```python\nimport random\n\ntarget_size = 100\nnums = [random.randint(100, 99) for _ in range(target_size)]\nprint(chicken_chicken())\nprint(fruit_fruit())\n```\n\n输出结果：[[10, 3], [4, 8]], [5, 7]]", "original_response": "python\n'''backtest\nstart: 2021-06-26 00:00:00\nend: 2022-01-23 00:00:00\nperiod: 1d\nbasePeriod: 1h\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"BTC_USDT\"}]\n'''\ndef main():\n    exchange.SetMarginLevel(7)\n    exchange.SetContractType(\"swap\")\n    exchange.SetDirection(\"buy\")\n    ticker = exchange.GetTicker()\n    Log(ticker)\n    exchange.Buy(ticker[\"Last\"] - 100, 0.001)\n    exchange.Buy(ticker[\"Last\"] - 500, 0.001)\n    exchange.Buy(ticker[\"Last\"] -1000, 0.002)\n    exchange.Buy(ticker[\"Last\"] - 1500, 0.003)\n    exchange.Buy(ticker[\"Last\"] - 2000, 0.005)\n    exchange.Buy(ticker[\"Last\"] - 2500, 0.008)\n    exchange.Buy(ticker[\"Last\"] - 3000, 0.013)\n    exchange.Buy(ticker[\"Last\"] - 3500, 0.021)\n    exchange.Buy(ticker[\"Last\"] - 4000, 0.034)\n    exchange.Buy(ticker[\"Last\"] - 4500, 0.055)\n    exchange.Buy(ticker[\"Last\"] - 5000, 0.089)\n    exchange.Buy(ticker[\"Last\"] - 5500, 0.144)\n    exchange.Buy(ticker[\"Last\"] - 6000, 0.233)\n    exchange.Buy(ticker[\"Last\"] - 6500, 0.377)\n    exchange.Buy(ticker[\"Last\"] - 7000, 0.610)\n    exchange.Buy(ticker[\"Last\"] - 7500, 0.987)\n    exchange.Buy(ticker[\"Last\"] - 8000, 1.597)\n    exchange.Buy(ticker[\"Last\"] - 8500, 2.584)\n    \n    exchange.SetContractType(\"swap\")\n    exchange.SetDirection(\"sell\")\n    ticker = exchange.GetTicker()\n    Log(ticker)\n    exchange.Sell(ticker[\"Last\"] + 100, 0.001)\n    exchange.Sell(ticker[\"Last\"] + 500, 0.001)\n    exchange.Sell(ticker[\"Last\"] + 1000, 0.002)\n    exchange.Sell(ticker[\"Last\"] + 1500, 0.003)\n    exchange.Sell(ticker[\"Last\"] + 2000, 0.005)\n    exchange.Sell(ticker[\"Last\"] + 2500, 0.008)\n    exchange.Sell(ticker[\"Last\"] + 3000, 0.013)\n    exchange.Sell(ticker[\"Last\"] + 3500, 0.021)\n    exchange.Sell(ticker[\"Last\"] + 4000, 0.034)\n    exchange.Sell(ticker[\"Last\"] + 4500, 0.055)\n    exchange.Sell(ticker[\"Last\"] + 5000, 0.089)\n    exchange.Sell(ticker[\"Last\"] + 5500, 0.144)\n    exchange.Sell(ticker[\"Last\"] + 6000, 0.233)\n    exchange.Sell(ticker[\"Last\"] + 6500, 0.377)\n    exchange.Sell(ticker[\"Last\"] + 7000, 0.610)\n    exchange.Sell(ticker[\"Last\"] + 7500, 0.987)\n    exchange.Sell(ticker[\"Last\"] + 8000, 1.597)\n    exchange.Sell(ticker[\"Last\"] + 8500, 2.584)\n    \n    Log(\"orders\", exchange.GetOrders())\n    Sleep(1000)"}
{"query": "请生成一个python利用asyncio-http获取行情数据示范策略代码", "base_model_response": "", "lora_model_response": "```python\nimport asyncio\nfrom asynciohttp import HTTPClient, BaseHTTPRequestHandler\n\nclass NewsItem(BaseHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(json.dumps({'news': '你好', 'time': time.time() + 64 * 1000}))\n\ndef main():\n    url = 'http://example.com/news'\n    client = HTTPClient()\n\n    try:\n        for item in news_item:\n            if item['data'] == '':\n                break\n\n            client.get(url + item['url'], async def get_response(response):\n                response_length = len(response.data) - 8\n                print('Response Length:', response_length)\n                print('Content-type: %s' % response['Content-Type'])\n                data = response_data.decode('utf-8')\n                return json.loads(data)\n                else:\n                    print('Failed to load the data')\n                    continue\n\n            client.send_response(get_response())\n            client.send_header('Connection', 'keep-alive')\n\n        self.end_headers()\n\n    except Exception as e:\n        print('error:', e)\n\nif __name__ == '__main__':\n    main()\n```\n以上是一个简单的例子，展示如何使用asyncio请求和HTTPClient获取行情。在这个例子中，我们创建了一个新闻items，然后从网络获取所有相关的item，并将其发送给客户端。\n如果在生产环境中运行这个程序，你需要处理更多的错误情况（例如错误的URL路径），并确保你的程序可以处理各种不同的HTTP响应格式。\n\n注意：这只是一个非常基础的例子，实际应用中可能需要处理更复杂的错误情况，如网络连接问题、服务器返回的数据格式错误等。\n\n此外，在上面给出的文章中，我将使用asynciohttp库中的fetch方法来获取行情数据，而不是直接使用asynciohttp库中的BaseHTTPRequestHandler。这是一个常见的做法，当需要实时接收网络数据时，可以选择这样做。", "original_response": "python\n'''backtest\nstart: 2021-11-04 00:00:00\nend: 2022-02-01 00:00:00\nperiod: 1h\nbasePeriod: 15m\n'''\n\nimport time\nimport asyncio\nfrom aiohttp import ClientSession\nimport time\nimport datetime\nglobal tasks\ntasks = []\n\nasync def fetch_exchangeinfo():\n    exchangeinfo=\"https://fapi.binance.com//fapi/v1/exchangeInfo\"\n    async with ClientSession() as session:\n        async with session.get(exchangeinfo) as response:\n            result=await response.read()\n            Log(result.text, time.time())\n            return result\n            \n\nasync def fetch_depth(symbol,limit):\n    symbol_depth=\"https://fapi.binance.com//fapi/v1/depth?symbol=\"+str(symbol)+\"&limit=\"+str(limit)\n    async with ClientSession() as session:\n        async with session.get(symbol_depth) as response:\n            result=await response.read()\n            Log(result.text, time.time())\n            return result\n            \n\nasync def fetch_klines(symbol,interval,limit):\n    symbol_kline=\"https://fapi.binance.com//fapi/v1/klines?symbol=\"+str(symbol)+\"&interval=\"+str(interval)+\"&limit=\"+str(limit)\n    async with ClientSession() as session:\n        async with session.get(symbol_kline) as response:\n            result = await response.read()\n            Log(symbol,result, time.time())\n            return result\n           \nasync def fetch_all_ticker():\n    all_symbol_ticker = \"https://fapi.binance.com/fapi/v1/ticker/price\"\n    async with ClientSession() as session:\n        async with session.get(all_symbol_ticker) as response:\n            result = await response.read()\n            Log(result.text, time.time())\n            return result\n            \n\ndef main():\n    while True:\n        Log(datetime.datetime.now(),'开始')\n        symbol_list=['BTCUSDT','ETHUSDT','BNBUSDT','ETCUSDT','EOSUSDT','SANDUSDT','XRPUSDT','ADAUSDT','GALAUSDT','IOTXUSDT','BNBUSDT','MATICUSDT']\n        for i in range(12):\n            task = asyncio.ensure_future(fetch_klines(symbol_list[i],'15m',500))\n            tasks.append(task)\n        loop = asyncio.get_event_loop()\n        result = loop.run_until_complete(asyncio.gather(*tasks))\n        Log(datetime.datetime.now(),'完成')\n        Sleep(1000)"}
{"query": "请生成一个python版-Dual-Thrust-OKCoin-期货策略代码", "base_model_response": "```python\nfrom dhtok coin import DHTok, Token, TradeOrder\nimport pandas as pd\n\n# 假设我们有一个名为\"DHTok合约\"的合约，它接受token和order作为参数\n# 但请注意这个例子中没有进行任何交易。\nDHTok合约 = ...\n\n# 设置单个令牌在合约中的行号为1\ntoken_name_1 = \"token1\"\n\n# 获取所有token对应的行号\ntoken_lines = [c['line_number'] for c in DHTok合约]\n\n# 创建一个列表来存储每个order的行号\norder_lines = [c['order_id'] for c in DHTok合约]\n\n# 初始化空的订单数据字典\norder_data_dict = {k: [] for k in order_lines}\n\n# 添加一个新的Order列到data字典中，记录所有的order数据\norder_data_dict[\"order\"] = []\n\n# 遍历每一行，将每一条order的数据添加到data字典中，并在Order列上创建一个新的order\nfor row in token_lines:\n    for c in row:\n        if c in order_data_dict:\n            c.append({\n                'order_id': order_data_dict[c]['order_id'],\n                'order_value': c[-1]['order_value']\n            })\n        else:\n            c.append({\n                'order_id': None,\n                'order_value': None\n            })\n\n# 将order数据字典保存到CSV文件中，并将其写入Python字典格式的文件中\nwith open(\"orders.csv\", \"w\") as f:\n    df = pd.DataFrame(\n        columns=[token_name_1],\n        data=json.dumps(order_data_dict)\n    )\n    df.to_csv(f, index=False)\n\nprint(\"Orders created successfully.\")\n```\n注意：这个例子只实现了简单的双态交易操作，没有进行任何交易。", "lora_model_response": "", "original_response": "python\nimport time\nclass Error_noSupport(BaseException):\n    def __init__(self):\n        Log(\"只支持OKCoin期货！#FF0000\")\n\nclass Error_AtBeginHasPosition(BaseException):\n    def __init__(self):\n        Log(\"启动时有期货持仓! #FF0000\")\n\nChartCfg = {\n    '__isStock': True,\n    'title': {\n        'text': 'Dual Thrust 上下轨图'\n    },\n    'yAxis': {\n        'plotLines': [{\n            'value': 0,\n            'color': 'red',\n            'width': 2,\n            'label': {\n                'text': '上轨',\n                'align': 'center'\n            },\n        }, {\n            'value': 0,\n            'color': 'green',\n            'width': 2,\n            'label': {\n                'text': '下轨',\n                'align': 'center'\n            },\n        }]\n    },\n    'series': [{\n        'type': 'candlestick',\n        'name': '当前周期',\n        'id': 'primary',\n        'data': []\n    }, {\n        'type': 'flags',\n        'onSeries': 'primary',\n        'data': []\n    }]\n}\n\nSTATE_IDLE = 0\nSTATE_LONG = 1\nSTATE_SHORT = 2\nState = STATE_IDLE\n\nLastBarTime = 0\nUpTrack = 0\nBottomTrack = 0\nchart = None\nInitAccount = None\nLastAccount = None\nCounter = {\n    'w': 0,\n    'l': 0\n}\n\ndef GetPosition(posType):  # if the positions has no this posType ,will return [] ,Another case is return a dict of object\n    positions = exchange.GetPosition()\n    return [{'Price': position['Price'], 'Amount': position['Amount']} for position in positions if position['Type'] == posType]\n\ndef CancelPendingOrders():\n    while True:\n        orders = exchange.GetOrders()\n        [exchange.CancelOrder(order['Id']) for order in orders if not Sleep(500)]\n        if len(orders) == 0:\n            break \n\ndef Trade(currentState,nextState):\n    global InitAccount,LastAccount,OpenPrice,ClosePrice\n    ticker = _C(exchange.GetTicker)\n    slidePrice = 1\n    pfn = exchange.Buy if nextState == STATE_LONG else exchange.Sell \n    if currentState != STATE_IDLE:\n        Log(_C(exchange.GetPosition)) # ceshi \n        exchange.SetDirection(\"closebuy\" if currentState == STATE_LONG else \"closesell\")\n        while True:\n            ID = pfn( (ticker['Last'] - slidePrice) if currentState == STATE_LONG else (ticker['Last'] + slidePrice), AmountOP) # xiugai 限价单\n            # ID = pfn(-1, AmountOP) # xiugai  市价单\n            # ID = pfn(AmountOP) # xiugai  市价单\n            Sleep(Interval)\n            Log(exchange.GetOrder(ID)) # xiugai\n            ClosePrice = (exchange.GetOrder(ID))['AvgPrice'] # \n            CancelPendingOrders()\n            if len(GetPosition(PD_LONG if currentState == STATE_LONG else PD_SHORT)) == 0:\n                break \n        account = exchange.GetAccount()\n        if account['Stocks'] > LastAccount['Stocks']:\n            Counter['w'] += 1\n        else:\n            Counter['l'] += 1\n        # Log(\"ceshi account:\",account,InitAccount) #ceshi\n        Log(account) # xiugai\n        LogProfit((account['Stocks'] - InitAccount['Stocks']),\"收益率:\", ((account['Stocks'] - InitAccount['Stocks']) * 100 / InitAccount['Stocks']),'%')\n        Cal(OpenPrice,ClosePrice)\n        LsatAccount = account \n    \n    exchange.SetDirection(\"buy\" if nextState == STATE_LONG else \"sell\") \n    Log(_C(exchange.GetAccount))\n    while True:\n        ID = pfn( (ticker['Last'] + slidePrice) if nextState == STATE_LONG else (ticker['Last'] - slidePrice), AmountOP) # 限价单\n        # ID = pfn(-1, AmountOP) # 市价单\n        # ID = pfn(AmountOP) # 市价单\n        Sleep(Interval)\n        Log(exchange.GetOrder(ID)) # xiugai\n        CancelPendingOrders()\n        pos = GetPosition(PD_LONG if nextState == STATE_LONG else PD_SHORT)\n        if len(pos) != 0:\n            Log(\"持仓均价\",pos[0]['Price'],\"数量:\",pos[0]['Amount'])\n            OpenPrice = (exchange.GetOrder(ID))['AvgPrice'] # pos[0]['Price']\n            Log(\"now account:\",exchange.GetAccount())\n            break \n\ndef onTick(exchange):\n    global LastBarTime,chart,State,UpTrack,DownTrack,LastAccount\n    records = exchange.GetRecords()\n    if not records or len(records) <= NPeriod:\n        return \n    Bar = records[-1]\n    if LastBarTime != Bar['Time']:\n        HH = TA.Highest(records, NPeriod, 'High')\n        HC = TA.Highest(records, NPeriod, 'Close')\n        LL = TA.Lowest(records, NPeriod, 'Low')\n        LC = TA.Lowest(records, NPeriod, 'Close')\n        \n        Range = max(HH - LC, HC - LL)\n        UpTrack = _N(Bar['Open'] + (Ks * Range))\n        DownTrack = _N(Bar['Open'] - (Kx * Range))\n        if LastBarTime > 0:\n            PreBar = records[-2]\n            chart.add(0, [PreBar['Time'], PreBar['Open'], PreBar['High'], PreBar['Low'], PreBar['Close']], -1)\n        else:\n            for i in range(len(records) - min(len(records), NPeriod * 3), len(records)):\n                b = records[i]\n                chart.add(0,[b['Time'], b['Open'], b['High'], b['Low'], b['Close']])\n                \n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']])\n        ChartCfg['yAxis']['plotLines'][0]['value'] = UpTrack \n        ChartCfg['yAxis']['plotLines'][1]['value'] = DownTrack \n        ChartCfg['subtitle'] = {\n            'text': '上轨' + str(UpTrack) + '下轨' + str(DownTrack)\n        }\n        chart.update(ChartCfg)\n        chart.reset(PeriodShow)\n        \n        LastBarTime = Bar['Time']\n    else:\n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']], -1)\n        \n    LogStatus(\"Price:\", Bar[\"Close\"], \"up:\", UpTrack, \"down:\", DownTrack, \"wins:\", Counter['w'], \"losses:\", Counter['l'], \"Date:\", time.time())\n    msg = \"\"\n    if State == STATE_IDLE or State == STATE_SHORT:\n        if Bar['Close'] >= UpTrack:\n            msg = \"做多，触发价：\" + str(Bar['Close']) + \"上轨\" + str(UpTrack)\n            Log(msg)\n            Trade(State, STATE_LONG)\n            State = STATE_LONG \n            chart.add(1,{'x': Bar['Time'], 'color': 'red', 'shape': 'flag', 'title': '多', 'text': msg})\n    \n    if State == STATE_IDLE or State == STATE_LONG:\n        if Bar['Close'] <= DownTrack:\n            msg = \"做空，触发价：\" + str(Bar['Close']) + \"下轨\" + str(DownTrack)\n            Log(msg)\n            Trade(State, STATE_SHORT)\n            State = STATE_SHORT\n            chart.add(1,{'x': Bar['Time'], 'color': 'green', 'shape': 'circlepin', 'title': '空', 'text': msg})\n\nOpenPrice = 0\nClosePrice = 0\ndef Cal(OpenPrice, ClosePrice):\n    global AmountOP,State\n    if State == STATE_SHORT:\n        Log(AmountOP,OpenPrice,ClosePrice,\"策略盈亏:\", (AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice, \"个币，  手续费：\", - (100 * AmountOP * 0.0003), \"美元,折合：\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \"个币\")\n        Log(((AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\n    if State == STATE_LONG:\n        Log(AmountOP,OpenPrice,ClosePrice,\"策略盈亏:\", (AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePrice, \"个币，  手续费：\", - (100 * AmountOP * 0.0003), \"美元,折合：\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \"个币\")\n        Log(((AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\n\ndef main():\n    global LoopInterval,chart,LastAccount,InitAccount\n    if exchange.GetName() != 'Futures_OKCoin':\n        raise Error_noSupport\n    exchange.SetRate(1)\n    exchange.SetContractType([\"this_week\",\"next_week\",\"quarter\"][ContractTypeIdx]) \n    exchange.SetMarginLevel([10,20][MarginLevelIdx])\n    \n    # Log(\"Fee:\",exchange.GetFee())\n    if len(exchange.GetPosition()) > 0:\n        raise Error_AtBeginHasPosition\n    CancelPendingOrders()\n    InitAccount = LastAccount = exchange.GetAccount()\n    LoopInterval = min(1,LoopInterval)\n    Log(\"交易平台:\",exchange.GetName(), InitAccount)\n    LogStatus(\"Ready...\")\n    \n    LogProfitReset()\n    chart = Chart(ChartCfg)\n    chart.reset()\n    \n    LoopInterval = max(LoopInterval, 1)\n    while True:\n        onTick(exchange)\n        Sleep(LoopInterval * 1000)"}
{"query": "请生成一个python版-画线类库-兼容2-3-Python-Version-Drawing-Class-Library-Compatible-2-3策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# Python 2/3 兼容版本\nimport time\nchart = None\nseries = []\nlabelIdx = {}\npreBarTime = 0\npreFlagTime = 0\npreDotTime = {}\n\ncfg = {\n    \"tooltip\" : {\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\"\n    },\n    \"legend\" : {\n        \"enabled\" : True\n    },\n    \"plotOptions\" : {\n        \"candlestick\" : {\n            \"color\" : \"#d75442\",\n            \"upColor\" : \"#6ba583\"\n        }\n    },\n    \"rangeSelector\" : {\n        \"buttons\" : [{\n            \"type\" : \"hour\",\n            \"count\" : 1,\n            \"text\" : \"1h\",\n        }, {\n            \"type\" : 'hour',\n            \"count\" : 3,\n            \"text\" : \"3h\"\n        }, {\n            \"type\" : \"hour\",\n            \"count\" : 8,\n            \"text\" : \"8h\"\n        }, {\n            \"type\" : \"all\",\n            \"text\" : \"All\"\n        }],\n        \"selected\" : 2,\n        \"inputEnabled\" : True\n    },\n    \"series\" : series,\n}\n\ndef GetCfg():\n    global cfg\n    return cfg\n\n# 画水平线\ndef PlotHLine(value = None, label = None, color = None, style = None):\n    global cfg, chart\n    if (\"yAxis\" in cfg) == False :\n        cfg.setdefault(\"yAxis\", {\"plotLines\" : []})\n    elif (\"plotLines\" in cfg[\"yAxis\"]) == False :\n        cfg[\"yAxis\"].setdefault(\"plotLines\", [])\n    \n    obj = {\n        \"value\" : value,\n        \"color\" : color or \"red\",\n        \"width\" : 2,\n        \"dashStyle\" : style or \"Solid\",\n        \"label\" : {\n            \"text\" : label or \"\",\n            \"align\" : \"center\"\n        }\n    }\n    found = False\n    for i in range(len(cfg[\"yAxis\"][\"plotLines\"])) : \n        if cfg[\"yAxis\"][\"plotLines\"][i][\"label\"][\"text\"] == label : \n            cfg[\"yAxis\"][\"plotLines\"][i] = obj\n            found = True\n    if not found :\n        cfg[\"yAxis\"][\"plotLines\"].append(obj)\n    if not chart :\n        chart = Chart(cfg)\n        chart.update(cfg)    # 更新图表\n    else :\n        chart.update(cfg)\n\n# 画K线\ndef PlotRecords(records, title = None):\n    global labelIdx, series, preBarTime, chart\n    if not chart :\n        chart = Chart(cfg)\n        chart.reset()\n    if (\"candlestick\" in labelIdx) == False : \n        cfg[\"__isStock\"] = True\n        seriesIdx = len(series)\n        series.append({\n            \"type\" : \"candlestick\",\n            \"name\" : \"\" if title == None else title,\n            \"id\" : \"primary\",\n            \"data\" : []\n            })\n        chart.update(cfg)\n        labelIdx.setdefault(\"candlestick\", seriesIdx)\n    else :\n        seriesIdx = labelIdx[\"candlestick\"]\n    if isinstance(records, dict) and (\"Time\" in records) == True :\n        Bar = records\n        if Bar[\"Time\"] == preBarTime :\n            chart.add(seriesIdx, [Bar[\"Time\"], Bar[\"Open\"], Bar[\"High\"], Bar[\"Low\"], Bar[\"Close\"]], -1)\n        elif Bar[\"Time\"] > preBarTime : \n            preBarTime = Bar.Time\n            chart.add(seriesIdx, [Bar[\"Time\"], Bar[\"Open\"], Bar[\"High\"], Bar[\"Low\"], Bar[\"Close\"]])    \n    else :\n        for i in range(len(records)) :\n            if records[i][\"Time\"] == preBarTime :\n                chart.add(seriesIdx, [records[i][\"Time\"], records[i][\"Open\"], records[i][\"High\"], records[i][\"Low\"], records[i][\"Close\"]], -1)\n            elif records[i][\"Time\"] > preBarTime :\n                preBarTime = records[i][\"Time\"]\n                chart.add(seriesIdx, [records[i][\"Time\"], records[i][\"Open\"], records[i][\"High\"], records[i][\"Low\"], records[i][\"Close\"]])\n    return chart\n\n# 画指标线\ndef PlotLine(label, dot, Ntime = None):\n    global labelIdx, chart, series, preDotTime\n    if not chart :\n        cfg.setdefault(\"xAxis\", {\n            \"type\" : \"datetime\"\n            })\n        chart = Chart(cfg)\n        chart.reset()\n    if (label in labelIdx) == False :\n        seriesIdx = len(series)\n        preDotTime.setdefault(str(seriesIdx), 0)\n        labelIdx[label] = seriesIdx\n        series.append({\n            \"type\" : \"line\",\n            \"yAxis\" : 0,\n            \"showInLegend\" : True,\n            \"name\" : label,\n            \"data\" : [],\n            \"tooltip\" : {\"valueDecimals\" : 5}\n            })\n        chart.update(cfg)\n    else :\n        seriesIdx = labelIdx[label]\n    if Ntime == None :\n        Ntime = _N(time.time() * 1000, 0)\n    if preDotTime[str(seriesIdx)] != Ntime :\n        preDotTime[str(seriesIdx)] = Ntime\n        chart.add(seriesIdx, [Ntime, dot])\n    else :\n        chart.add(seriesIdx, [Ntime, dot], -1)\n    return chart\n\n# 画标记\ndef PlotFlag(time, text, title, shape = \"\", color = \"\"):\n    global chart, cfg, labelIdx, preFlagTime\n    if not chart :\n        chart = Chart(cfg)\n        chart.reset()\n    label = \"flag\"\n    if (label in labelIdx) == False : \n        seriesIdx = len(series)\n        labelIdx[label] = seriesIdx\n        series.append({\n            \"type\" : \"flags\",\n            \"onSeries\" : \"primary\",\n            \"data\" : []\n            })\n        chart.update(cfg)\n    else :\n        seriesIdx = labelIdx[label]\n    obj = {\n        \"x\" : time,\n        \"color\" : color,\n        \"shape\" : shape,\n        \"title\" : title,\n        \"text\" : text\n    }\n    if preFlagTime != time : \n        preFlagTime = time\n        chart.add(seriesIdx, obj)\n    else :\n        chart.add(seriesIdx, obj, -1)\n    return chart\n\n# 设置图表标题\ndef PlotTitle(title, chartTitle = None):\n    global cfg\n    if (\"subtitle\" in cfg) == True : \n        cfg[\"subtitle\"] = {\"text\" : title}\n    else :\n        cfg.setdefault(\"subtitle\", {\"text\" : title})\n    if chartTitle != None :\n        if (title in cfg) == True :\n            cfg[\"title\"] = {\"text\" : chartTitle}\n        else :\n            cfg.setdefault(\"title\", {\"text\" : chartTitle})\n    if chart :\n        chart.update(cfg)\n\n# 导出函数\next.GetCfg = GetCfg\next.PlotHLine = PlotHLine\next.PlotRecords = PlotRecords\next.PlotLine = PlotLine\next.PlotFlag = PlotFlag\next.PlotTitle = PlotTitle\n\n# 测试代码\ndef main():\n    isFirst = True\n    while True:\n        records = exchange.GetRecords()\n        if records and len(records) > 0 :\n            ext.PlotRecords(records, \"BTC\")\n            if isFirst :\n                ext.PlotFlag(records[-1][\"Time\"], \"Start\", \"S\")\n                isFirst = False\n                ext.PlotHLine(records[-1][\"Close\"], \"Close\")\n        ticker = exchange.GetTicker()\n        if ticker :\n            ext.PlotLine(\"Last\", ticker.Last)\n            ext.PlotLine(\"buy\", ticker.Buy + 10)\n            ext.PlotTitle(\"Last\" + str(ticker.Last))\n        Sleep(60000)"}
{"query": "请生成一个python版现货数字货币交易类库Python-Version-Spot-Cryptocurrency-Trading-Class-Library策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport types # 导入类型模块\nimport time  # 导入时间模块\nimport platform # 版本信息 \n\nversionMainValue = None\nisFirstCheck = True\ndef typeOfstr(str):\n    if str == \"list\":\n        if versionMainValue == 2:\n            return types.ListType\n        elif versionMainValue == 3:\n            return list\n    elif str == \"int\":\n        if versionMainValue == 2:\n            return types.IntType\n        elif versionMainValue == 3:\n            return int\n    elif str == \"float\":\n        if versionMainValue == 2:\n            return types.FloatType\n        elif versionMainValue == 3:\n            return float\n    else:\n        Log(\"error , typeOfstr used false\")\n            \ndef CheckVersion():\n    global versionMainValue,isFirstCheck\n    platformInfo = platform.python_version()\n    if platformInfo[0] == '2':\n        Log(\"您使用的托管者 python编译环境的python版本是\",platformInfo)\n        versionMainValue = 2\n    elif platformInfo[0] == '3':\n        Log(\"您使用的托管者 python编译环境的python版本是\",platformInfo)\n        versionMainValue = 3\n    else:\n        Log(\"其它版本\")\n    isFirstCheck = False\n\ndef CancelPendingOrders(e, orderType = \"\") : # 取消所有未完成挂单\n    while True: # 循环\n        orders = e.GetOrders()\n        LogStatus(\"orders:\",orders,time.time()) # 测试\n        if(type(orders) != typeOfstr(\"list\")):\n            Sleep(RetryDelay)\n            continue\n        processed = 0\n        for j in range(len(orders)):\n            if (type(orderType) == typeOfstr(\"int\") and orders[j].Type != orderType):\n                continue\n            e.CancelOrder(orders[j].Id,orders[j])\n            processed += 1\n            if (j < (len(orders) - 1)):\n                Sleep(RetryDelay)\n        if(processed == 0):\n            break\n\ndef GetAccount(e, waitFrozen = False):\n    account = null\n    alreadyAlert = False\n    while True:\n        account = _C(e.GetAccount)\n        if(not waitFrozen or (account.FrozenStocks < _GetMinStocks and account.FrozenBalance < 0.01)):\n            break\n        if(not alreadyAlert):\n            alreadyAlert = True\n            Log(\"发现账户有冻结的钱或币\",account)\n        Sleep(RetryDelay)\n    return account\n\ndef StripOrders(e,orderId = null):\n    order = null\n    while True:\n        dropped = 0\n        orders = _C(e.GetOrders)\n        for i in range(len(orders)):\n            if(orders[i].Id == orderId):\n                order = orders[i]\n            else:\n                extra = \"\"\n                if(orders[i].DealAmount > 0):\n                    extra = \"成交：\" + str(orders[i].DealAmount)\n                else:\n                    extra = \"未成交\"\n                e.CancelOrder(orders[i].Id,\"买单\" if orders[i].Type == ORDER_TYPE_BUY else \"卖单\",extra)\n                dropped += 1\n        if(dropped == 0):\n            break\n        Sleep(RetryDelay)\n    return order\n\ndef Trade(e,tradeType,tradeAmount,mode,slidePrice,maxAmount,maxSpace,retryDelay):\n    initAccount = GetAccount(e,True)\n    nowAccount = initAccount\n    orderId = null\n    prePrice = 0.0\n    dealAmount = 0.0\n    diffMoney = 0.0\n    isFirst = True\n    tradeFunc = e.Buy if tradeType == ORDER_TYPE_BUY else e.Sell\n    isBuy = (tradeType == ORDER_TYPE_BUY)\n    while True:\n        ticker = _C(e.GetTicker)\n        tradePrice = 0.0\n        if(isBuy):\n            tradePrice = _N((ticker.Sell if mode == 0 else ticker.Buy) + slidePrice,4)\n        else:\n            tradePrice = _N((ticker.Buy if mode == 0 else ticker.Sell) - slidePrice,4)\n        if(not orderId):\n            if(isFirst):\n                isFirst = False\n            else:\n                nowAccount = GetAccount(e,True)\n            doAmount = 0.0;\n            if(isBuy):\n                diffMoney = _N(initAccount.Balance - nowAccount.Balance,4)\n                dealAmount = _N(nowAccount.Stocks - initAccount.Stocks,4)\n                doAmount = min(maxAmount,tradeAmount - dealAmount,_N((nowAccount.Balance - 10) / tradePrice,4))\n            else:\n                diffMoney = _N(nowAccount.Balance - initAccount.Balance,4)\n                dealAmount = _N(initAccount.Stocks - nowAccount.Stocks,4)\n                doAmount = min(maxAmount,tradeAmount - dealAmount,nowAccount.Stocks)\n            if(doAmount < _GetMinStocks):\n                break\n            prePrice = tradePrice\n            orderId = tradeFunc(tradePrice,doAmount,ticker)\n            if(not orderId):\n                CancelPendingOrders(e,tradeType)\n        else:\n            if(mode == 0 or (abs(tradePrice - prePrice) > maxSpace)):\n                orderId = null\n            order = StripOrders(e,orderId)\n            if(not order):\n                orderId = null\n        Sleep(retryDelay)\n    if(dealAmount <= 0):\n        Log(\"交易失败--TradeType:\",\"buy\" if tradeType == ORDER_TYPE_BUY else \"sell\",\"  ,diffMoney:\",diffMoney,\"  ,dealAmount\",dealAmount,\"  ,doAmount\",doAmount)\n        return null\n    \n    ret = {'price': _N(diffMoney/dealAmount,4),'amount':dealAmount}\n    return ret\n    # 调用时 这样写  ret['price'] 、 ret['amount']\n\ndef _Buy(e = exchange,amount = 0):\n    if isFirstCheck:\n        CheckVersion()\n    if (type(e) == typeOfstr(\"int\") or type(e) == typeOfstr(\"float\")):\n        amount = e\n        e = exchange\n    return Trade(e,ORDER_TYPE_BUY,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\n\ndef _Sell(e = exchange,amount = 0):\n    if isFirstCheck:\n        CheckVersion()\n    if (type(e) == typeOfstr(\"int\") or type(e) == typeOfstr(\"float\")):\n        amount = e\n        e = exchange\n    return Trade(e,ORDER_TYPE_SELL,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\n\ndef _CancelPendingOrders(e = exchange,orderType = \"\"):\n    if isFirstCheck:\n        CheckVersion()\n    return CancelPendingOrders(e,orderType)\n\ndef _GetAccount(e = exchange):\n    if isFirstCheck:\n        CheckVersion()\n    return _C(e.GetAccount)\n\n_MACalcMethod = [TA.EMA,TA.MA][MAType]\nInterval = 200\ndef Cross(a,b):\n    if isFirstCheck:\n        CheckVersion()\n    crossNum = 0\n    arr1 = []\n    arr2 = []\n    if type(a) == typeOfstr(\"list\") and type(b) == typeOfstr(\"list\"):\n        arr1 = a\n        arr2 = b\n    else:\n        records = null\n        while True:\n            records = exchange.GetRecords()\n            if records and len(records) > a and len(records) > b:\n                break\n            Sleep(Interval)\n        arr1 = _MACalcMethod(records,a)\n        arr2 = _MACalcMethod(records,b)\n    if len(arr1) != len(arr2):\n        raise Exception(\"array length not equal\")\n    for i in range(len(arr1) - 1,-1,-1):\n        if (type(arr1[i]) != typeOfstr(\"int\") and type(arr1[i]) != typeOfstr(\"float\")) or (type(arr2[i]) != typeOfstr(\"int\") and type(arr2[i]) != typeOfstr(\"float\")):\n            break\n        if arr1[i] < arr2[i] :\n            if crossNum > 0 :\n                break\n            crossNum -= 1\n        elif arr1[i] > arr2[i] :\n            if crossNum < 0 :\n                break\n            crossNum += 1\n        else:\n            break\n    return crossNum\n\n\n# 导出函数\next.Buy = _Buy\next.Sell = _Sell\next.CancelPendingOrders = _CancelPendingOrders\next.GetAccount = _GetAccount\next.Cross = Cross\n\n# 测试\ndef main():\n    ret = ext.Buy(0.2)\n    exchange.Sell(4500,1)\n    Sleep(10 * 1000)\n    ext.CancelPendingOrders()\n    Log(\"ret:\",ret)\n    avgprice = ret['price']\n    dealamount = ret['amount']\n    Log(\"avgprice:\",avgprice,\"  dealamount:\",dealamount)"}
{"query": "请生成一个robotCtrl教学策略策略代码", "base_model_response": "，该策略包含以下两个部分：一段用于演示如何使用RobotCtrl模块，一段用于展示如何在Python中创建一个机器人Ctrl", "lora_model_response": "下面是一个简单的Python脚本，它可以创建一个新的机器人Ctrl\n\n```python\nclass RobotCtrl:\n    def __init__(self):\n        self.h1 = \"RobotCtrl\"\n        self.mg = {\n            'Ctrl': 0,\n            'Home': 1,\n            'Menu': 2,\n            'Status': 3,\n            'Lock': 4,\n            'Play': 5,\n            'Stop': 6,\n            'PlayAgain': 7,\n            'Delete': 8,\n        }\n        self.mg['Ctrl'] = self.h1\n        for key, value in self.mg.items():\n            if key == \"Ctrl\":\n                self.h1 = key\n```\n\n这是一个非常基础的机器人的概念，实际上你可能需要更复杂的模块来完成所有的操作。这个简单版本只能在Python环境中运行。\n\n当然，这是一个非常基础的版本，没有实现足够的功能，比如在机器人上可以执行操作，或者对机器人进行更多的控制等。\n\n此外，你也可以通过修改机器人程序，增加更多的功能来提高效率。\n\n如果你想要创建一个更高级的功能，你可以考虑创建一个类，然后在这个类中定义所有的函数和方法，这样就可以在编程时直接访问这些函数，而不是通过变量。\n\n这只是一个非常基础的示例，实际开发中的机器人都会使用到很多高级功能，并且会根据具体的需求进行编写代码。", "original_response": "python\n# -*- coding: utf-8 -*-\nimport time\nimport json\n\ntry:\n    import md5\n    import urllib2\n    from urllib import urlencode\nexcept:\n    import hashlib as md5\n    import urllib.request as urllib2\n    from urllib.parse import urlencode\n\ndef api(method, *args):\n    d = {\n        'version': '1.0',\n        'access_key': accessKey,\n        'method': method,\n        'args': json.dumps(list(args)),\n        'nonce': int(time.time() * 1000),\n        }\n\n    d['sign'] = md5.md5(('%s|%s|%s|%d|%s' % (d['version'], d['method'], d['args'], d['nonce'], secretKey)).encode('utf-8')).hexdigest()\n    return json.loads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\n\nRobotParams = json.loads(strRobotParams)\n\ndef main():\n    global RobotParams \n    arrParams = []\n    nowDay = 0\n    strPush = \"\"\n    if isPushMsg:\n        strPush = \"@\"\n\n    for i in range(len(RobotParams)):\n        param = {}\n        arr = RobotParams[i].split(\",\")\n        if len(arr) != 2:\n            raise Exception(\"字符串配置错误：分隔符号,\")\n        param[\"id\"] = arr[0]\n        param[\"isProcessOpenThisDay\"] = False\n        param[\"isProcessCloseThisDay\"] = False\n\n        arr = arr[1].split(\"-\")\n        if len(arr) != 2:\n            raise Exception(\"字符串配置错误：分隔符号-\")\n\n        begin = arr[0]\n        arrBegin = begin.split(\":\")\n        if len(arrBegin) != 3:\n            raise Exception(\"字符串配置错误：起始时间分隔符号:\")\n        \n        param[\"begin\"] = {}\n        param[\"begin\"][\"hour\"] = float(arrBegin[0])\n        param[\"begin\"][\"min\"] = float(arrBegin[1])\n        param[\"begin\"][\"sec\"] = float(arrBegin[2])\n\n        end = arr[1]\n        arrEnd = end.split(\":\")\n        if len(arrEnd) != 3:\n            raise Exception(\"字符串配置错误：结束时间分隔符号:\")            \n        \n        param[\"end\"] = {}\n        param[\"end\"][\"hour\"] = float(arrEnd[0])\n        param[\"end\"][\"min\"] = float(arrEnd[1])\n        param[\"end\"][\"sec\"] = float(arrEnd[2])\n        arrParams.append(param)\n\n    # 测试\n    Log(\"输出参数\", arrParams, \"#FF0000\")  \n\n    while True:\n        nowTime = time.localtime(time.time())\n        nowHour = nowTime.tm_hour \n        nowMin = nowTime.tm_min\n        nowSec = nowTime.tm_sec\n        \n        tbl = {\n            \"type\" : \"table\", \n            \"title\" : \"msg\", \n            \"cols\" : [\"id\", \"begin\", \"end\", \"今天是否执行过启动\", \"今天是否执行过停止\"],\n            \"rows\" : []\n        }\n\n        for i in range(len(arrParams)):\n            tbl[\"rows\"].append([arrParams[i][\"id\"], json.dumps(arrParams[i][\"begin\"]), json.dumps(arrParams[i][\"end\"]), arrParams[i][\"isProcessOpenThisDay\"], arrParams[i][\"isProcessCloseThisDay\"]])\n            if nowDay != nowTime.tm_mday:\n                arrParams[i][\"isProcessOpenThisDay\"] = False\n                arrParams[i][\"isProcessCloseThisDay\"] = False\n\n            if arrParams[i][\"isProcessOpenThisDay\"] == False:\n                if nowTime.tm_hour == arrParams[i][\"begin\"][\"hour\"] and nowTime.tm_min >= arrParams[i][\"begin\"][\"min\"] and nowTime.tm_sec >= arrParams[i][\"begin\"][\"sec\"]:\n                    ret = api('RestartRobot', int(arrParams[i][\"id\"]))                    \n                    arrParams[i][\"isProcessOpenThisDay\"] = True\n                    Log(\"机器人ID:\", arrParams[i][\"id\"], \"执行启动，请登录平台检查是否启动成功\", \"扩展API返回值：\", ret, strPush)\n\n            if arrParams[i][\"isProcessCloseThisDay\"] == False:\n                if nowTime.tm_hour == arrParams[i][\"end\"][\"hour\"] and nowTime.tm_min >= arrParams[i][\"end\"][\"min\"] and nowTime.tm_sec >= arrParams[i][\"end\"][\"sec\"]:\n                    ret = api('StopRobot', int(arrParams[i][\"id\"]))\n                    arrParams[i][\"isProcessCloseThisDay\"] = True\n                    Log(\"机器人ID:\", arrParams[i][\"id\"], \"执行停止，请登录平台检查是否停止成功\", \"扩展API返回值：\", ret, strPush)\n        \n        if nowDay != nowTime.tm_mday:\n            nowDay = nowTime.tm_mday\n\n        LogStatus(_D(), nowTime, \"\\n`\" + json.dumps(tbl) + \"`\")\n        Sleep(500)"}
{"query": "请生成一个三角套利-基础版策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!python2\n# -*- coding:utf-8 -*-\nfrom time import sleep\n\nQ3 = 0.5\ntax = 0.0015   #交易费率，0.15%\n\n\nclass fmz_market():\n\n    # 基础行情数据处理,根据传入的交易对，获取数据，返回行情dict\n    def basic_data_handle(self, pair):\n        pair_depth = {'sale_volume': 0, 'sale_price': 0, 'buy_volume': 0, 'buy_price': 0}\n        depth = exchanges[pair].GetDepth()\n        asks_infor = depth.Asks[0]\n        bids_infor = depth.Bids[0]\n        pair_depth['sale_volume'] = asks_infor.Amount\n        pair_depth['sale_price'] = asks_infor.Price\n        pair_depth['buy_volume'] = bids_infor.Amount\n        pair_depth['buy_price'] = bids_infor.Price\n        #Log(pair_depth)\n        return pair_depth\n\n\n\n    #进行参数计算\n    def profit_calculation(self):\n        profit_obtain = 0\n        #先获取行情数据\n        P1_depth = self.basic_data_handle(0)\n        P2_depth = self.basic_data_handle(1)\n        P3_depth = self.basic_data_handle(2)\n        #买一价格整理\n        p1_sale_price =float(P1_depth['sale_price'])\n        p1_buy_price = float(P1_depth['buy_price'])\n        p2_sale_price = float(P2_depth['sale_price'])\n        p2_buy_price = float(P2_depth['buy_price'])\n        p3_sale_price = float(P3_depth['sale_price'])\n        p3_buy_price = float(P3_depth['buy_price'])\n\n        #深度数据整理\n        p1_sale_volume = float(P1_depth['sale_volume'])\n        p1_buy_volume = float(P1_depth['buy_volume'])\n        p2_sale_volume = float(P2_depth['sale_volume'])\n        p2_buy_volume = float(P2_depth['buy_volume'])\n        p3_sale_volume = float(P3_depth['sale_volume'])\n        p3_buy_volume = float(P3_depth['buy_volume'])\n        # 进行数据分析，正向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_ETH,卖出EOS，买入BTC，买入EOS（卖，买，买）\n        if p1_buy_price / p2_sale_price > p3_sale_price:\n            #总的手续费计算\n            tax_account = (p1_buy_price + p3_sale_price*p2_sale_price + p3_sale_price*p2_sale_price) * Q3 * tax\n            #总的获利计算\n            profit_sum = (p1_buy_price / p2_sale_price - p3_sale_price) * Q3 * p2_buy_price\n            Log('P1;',p1_buy_price,',P2:',p2_sale_price,',P3:',p3_sale_price,',tax_account:',tax_account,',profit_sum:',profit_sum)\n            #如果总的获利 < 手续费，则直接退出\n            if profit_sum < tax_account:\n                return 0\n            p1_accout_receive = p1_buy_price * Q3 * (1 - tax) #卖出EOS得到usdt，同时减去税\n            p3_accout_used = p3_sale_price * Q3 * (1 + tax)  #计算买入Q3 EOS的时候,需要的BTC\n            p2_accout_used =  p2_sale_price *  p3_accout_used * (1 + tax) #计算买入的BTC 需要耗费的USDT数量\n            #获利总量计算\n            profit_obtain = p1_accout_receive - p2_accout_used  #卖EOS得到的usdt - 买入同样数量的EOS需要的USDT\n            return profit_obtain\n\n        # 进行数据分析，逆向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_BTC,卖出EOS->BTC，卖出BTC，买入EOS（卖，卖，买）\n        if p1_buy_price / p2_sale_price < p3_sale_price:\n            # 总的手续费计算\n            tax_account = (p3_buy_price * p2_buy_price + p3_buy_price * p2_buy_price + p1_sale_price) * Q3 * tax\n            # 总的获利计算\n            profit_sum = (p3_sale_price - p1_buy_price / p2_sale_price) * Q3 * p2_buy_price\n            Log('P1;', p1_buy_price, ',P2:', p2_sale_price, ',P3:', p3_sale_price, ',tax_account:', tax_account, ',profit_sum:', profit_sum)\n            # 如果总的获利 < 手续费，则直接退出\n            if profit_sum < tax_account:\n                return 0\n            p3_accout_receive = p3_buy_price * Q3 * (1 - tax)  # 卖出EOS得到BTC，同时减去税\n            p1_accout_used = p1_sale_price * Q3 * (1 + tax)  # 计算买入Q3 EOS的时候,需要的USDT\n            p2_accout_receive = p2_buy_price * p3_accout_receive * (1 - tax)  # 计算卖出的BTC 得到的USDT数量\n            # 获利总量计算\n            profit_obtain = p2_accout_receive - p1_accout_used   #卖出的BTC得到的usdt - 买入EOS锁需要消耗的usdt\n            return profit_obtain\n\n        return 0\n\n    #循环计算\n    def profit_calculation_cycle(self):\n        usdt_remain = 0\n        for i in range(10000):\n            profit_obtain = self.profit_calculation()\n            usdt_remain = usdt_remain + profit_obtain\n            if profit_obtain > 0:\n                Log(u'EOS:',Q3,u'.....USDT:',usdt_remain)\n\n\n\ndef main():\n    Log(exchange.GetAccount())\n    Log(\"测试\")\n    fmz_market_instances = fmz_market()\n    fmz_market_instances.profit_calculation_cycle()\n    # fmz_market_instances.basic_data_handle(0)"}
{"query": "请生成一个三大交易所止盈止损集成类库策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport json\n\n# 对合约进行止盈止损   cangType=0默认逐仓  =1全仓\ndef zhiyingzhisun(ex, amount, directionStr, zhiying, zhisun, cangType = 0):\n    if ex.GetName().find('OK') >= 0 :\n        # okex\n        return okexSwap(ex, amount, directionStr, zhiying, zhisun)\n    elif ex.GetName().find('Huobi') >= 0 :\n        # huobi\n        return huobiSwap(ex, amount, directionStr, zhiying, zhisun, cangType)\n    elif ex.GetName().find('Binance') >= 0 :\n        # bian\n        return bianSwap(ex, amount, directionStr, zhiying, zhisun)\n    else:\n        return False\n\n# 发送请求\ndef AsynIo(ex, paramList):\n        if (len(paramList) == 3):\n            arrRoutine = ex.Go(\"IO\", paramList[0], paramList[1], paramList[2])\n        elif (len(paramList) == 4):\n            arrRoutine = ex.Go(\"IO\", paramList[0], paramList[1], paramList[2], paramList[3])\n        elif (len(paramList) == 5):\n            arrRoutine = ex.Go(\"IO\", paramList[0], paramList[1], paramList[2], paramList[3], paramList[4])\n        data, ok = arrRoutine.wait()\n        return data\n# 火币合约\ndef huobiSwap(ex, amount, directionStr, zhiying, zhisun, cangType):\n    instrument_id = ex.GetCurrency().replace('_',\"-\")\n    # 根据全仓或逐仓 与 U本位或币本位，设置请求url\n    if instrument_id.find('USDT') >= 0 :\n        if cangType == 0:\n            url = \"/linear-swap-api/v1/swap_tpsl_order\"\n        elif cangType == 1:\n            url = '/linear-swap-api/v1/swap_cross_tpsl_order'\n        else:\n            return False\n    elif instrument_id.find('USD') >= 0 :\n        url = \"/swap-api/v1/swap_tpsl_order\"\n    else:\n        return False\n    # 发送请求\n    data = AsynIo(ex, ['api', 'POST', url, '', json.dumps({\n        \"contract_code\": instrument_id,\n        \"direction\": directionStr,\n        \"volume\" : amount,\n        \"tp_order_price\": zhiying,\n        \"tp_trigger_price\": zhiying,\n        \"sl_trigger_price\": zhisun,\n        \"sl_order_price\": zhisun,\n    })])\n    if data[\"status\"] == 'ok':\n        return True\n    else:\n        return False\n\n# 币安合约\ndef bianSwap(ex, amount, directionStr, zhiying, zhisun):\n    instrument_id = ex.GetCurrency().replace('_',\"\")\n    # U本位或币本位，设置请求url\n    if instrument_id.find('USDT') >= 0 :\n        url = \"/fapi/v1/order\"\n    elif instrument_id.find('USD') >= 0 :\n        url = '/dapi/v1/order'\n    else:\n        return False\n    # 止损\n    zhisunData = AsynIo(ex, ['api', 'POST', url , '', json.dumps({\n        \"symbol\": instrument_id,\n        \"side\": directionStr,\n        \"type\": \"STOP\",\n        \"quantity\": amount,\n        \"price\": zhisun,\n        \"stopPrice\": zhisun,\n        \"timestamp\": str(int(round(time.time() * 1000)))\n    })])\n    if int(zhisunData['stopPrice']) != int(zhisun):\n        return False\n    # 止盈\n    zhiyingData = AsynIo(ex, ['api', 'POST', url , '', json.dumps({\n        \"symbol\": instrument_id,\n        \"side\": direction,\n        \"type\": \"TAKE_PROFIT\",\n        \"quantity\": amount,\n        \"price\": zhiying,\n        \"stopPrice\": zhiying,\n        \"timestamp\": str(int(round(time.time() * 1000)))\n    })])\n    if int(zhiyingData['stopPrice']) != int(zhiying):\n        return False\n    return True\n\n\n# 欧易合约\ndef okexSwap(ex, amount, directionStr, zhiying, zhisun):\n    instrument_id = ex.GetCurrency().replace('_',\"-\") + '-SWAP'\n    # 获取仓位方向\n    if directionStr == 'buy':\n        direction = '4'\n    elif directionStr == 'sell':\n        direction = '3'\n    else:\n        return False\n    data =  AsynIo(ex, ['api', 'POST', '/v1/order/orders/place', '', json.dumps({\n        \"instrument_id\": instrument_id,\n        \"type\": direction,\n        \"order_type\": '5',\n        \"size\": amount,\n        \"tp_trigger_price\": zhiying,\n        \"tp_price\": zhiying,\n        \"sl_trigger_price\": zhisun,\n        \"sl_price\": zhisun\n    })])\n    if data[\"error_code\"] == \"0\":\n        return True\n    else:\n        return False\n    \next.zhiyingzhisun = zhiyingzhisun"}
{"query": "请生成一个交易所对倒刷量对敲互刷策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\ndef main():\n    # 设置交易所地址\n    exchanges[0].SetBase(\"\")\n    exchanges[1].SetBase(\"\")\n    Log(\"等待指令\")\n    while True:\n        LogStatus(_D())\n        cmd = GetCommand()\n        if cmd:\n            arr = cmd.split(\":\")\n            # 交易次数\n            for i in range(trade_num):\n                Account0 = exchanges[0].GetAccount()\n                Account1 = exchanges[1].GetAccount()\n                # Log(\"Account0-usdt\", Account0[\"Balance\"], \"Account0-DEC\", Account0[\"Stocks\"])\n                # Log(\"Account 1-usdt\", Account1[\"Balance\"], \"Account1-DEC\", Account1[\"Stocks\"])\n                # 获取A0和A1的币\n                A0_stocks = Account0[\"Stocks\"]\n                A1_stocks = Account1[\"Stocks\"]\n                error = 0\n                if A0_stocks > A1_stocks:\n                    Log(\"Account0有币\")\n                    # 重置索引\n                    ex_chang = [exchanges[0], exchanges[1]]\n                    if abstest(A0_stocks, A1_stocks) == 1:\n                        break\n                    else:\n                        # Log(\"可继续交易\")\n                        pass\n                else:\n                    Log(\"Account1有dec\")\n                    # 重置索引\n                    ex_chang = [exchanges[1], exchanges[0]]\n                    if abstest(A0_stocks, A1_stocks) == 1:\n                        break\n                    else:\n                        # Log(\"可继续交易\")\n                        pass\n                # 0索引永远卖出    \n                ex_chang[0].Sell(pprice, nnum)\n                # 1索引永远卖出  \n                ex_chang[1].Buy(pprice, nnum)\n                Log(\"交易完成\",i)\n                Sleep(5)\n            if abstest(A0_stocks, A1_stocks) == 1:\n                break\n            else:\n                # Log(\"可继续交易\")\n                pass\n    Log(\"运行结束\")\n\ndef abstest(a, b):\n    # 简单判断\n    abs_value = abs(a - b)\n    # Log(\"币种差值:\" + str(abs_value))\n    if abs_value == 0:\n        Log(\"币种不够，请检查\")\n        error = 1\n    else:\n        # Log(\"可继续交易\")\n        error = 0\n    return error"}
{"query": "请生成一个仓位管理配置思路策略代码", "base_model_response": "```python\nclass PositionManager:\n    def __init__(self):\n        self.position = {}\n\n    def add_position(self, position, quantity):\n        if position not in self.position:\n            self.position[position] = {}\n        self.position[position][quantity] += 1\n\n    def remove_position(self, position):\n        for key, value in self.position.items():\n            if key == position:\n                del self.position[key]\n                return True\n\n        return False\n\n    def get_positions(self):\n        positions = []\n        for key in self.position.values():\n            if key == position:\n                positions.append(key)\n        return positions\n\n    def find_position(self, position):\n        return self.position.get(position)\n\n    def update_position(self, position, quantity):\n        if position in self.position:\n            self.position[position].update(quantity)\n        else:\n            self.position[position] = {\"quantity\": quantity}\n\n    def close_position(self, position):\n        for key, value in self.position.items():\n            if key == position:\n                del self.position[key]\n\n    def clear_position(self):\n        for key in self.position.values():\n            del self.position[key]\n\nclass EquityStrategy:\n    def __init__(self):\n        self equity_positions = {}\n\n    def add_equity_position(self, equity_position, quantity):\n        self Equity_positions[equity_position] = {\n            \"position\": equity_position,\n            \"quantity\": quantity,\n        }\n\n    def remove_equity_position(self, equity_position):\n        for key, value in self Equity_positions.items():\n            if key == equity_position:\n                del self.Equity_positions[key]\n\n        return False\n\n    def get_equities(self):\n        equity_positions = []\n\n        for key, value in self.Equity_positions.items():\n            if key == equity_position:\n                equity_positions.append(key)\n        return equity_positions\n\n    def find_equity_position(self, equity_position):\n        return self.Equity_positions.get(equity_position)\n\n    def update_equity_position(self, equity_position, quantity):\n        if key in self.Equity_positions:\n            equity_positions[key][\"position\"] = equity_position\n        else:\n            equity_positions[key] = {\"quantity\": quantity}\n\n    def close_equity_position(self, equity_position):\n        for key, value in self.Equity_positions.items():\n            if key == equity_position:\n                del self.Equity_positions[key]\n\n        return False\n\n    def clear_equity_position(self):\n        for key in self.Equity_positions.values():\n            del self.Equity_positions[key]\n\n```\n\n这个`PositionManager`和`EquityStrategy`类，分别表示基于股票交易的策略。在上面的示例中，我们可以定义一个二维字典来存储不同的操作，以及相应的函数来执行这些操作。这样可以更好地管理和管理我们的策略，以满足市场变化的需求。\n\n注意：以上实现使用了Python中内置的一些函数和类，如`dict`、`list`和`ifelse`等。如果您需要处理更复杂的数据结构或功能（例如数据库连接），可能需要根据具体需求进行修改。", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2017-06-26 00:00:00\nend: 2022-04-6 00:00:00\nperiod: 1d\nbasePeriod: 1h\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"BTC_USDT\"}]\n'''\ndef main():\n    exchange.SetMarginLevel(20)\n    exchange.SetContractType(\"swap\")\n    exchange.SetDirection(\"buy\")\n    exchange.SetDirection(\"sell\")\n    ticker = exchange.GetTicker()\n    Log(ticker)\n    \n    exchange.SetDirection(\"buy\")\n    exchange.Buy(ticker[\"Last\"] /1, 0.001)\n    exchange.Buy(ticker[\"Last\"] /1.1, 0.001)\n    exchange.Buy(ticker[\"Last\"] /1.2, 0.002)\n    exchange.Buy(ticker[\"Last\"] /1.3, 0.002)\n    exchange.Buy(ticker[\"Last\"] /1.4, 0.003)\n    exchange.Buy(ticker[\"Last\"] /1.5, 0.003)\n    exchange.Buy(ticker[\"Last\"] /1.6, 0.003)\n    exchange.Buy(ticker[\"Last\"] /1.7, 0.005)\n    exchange.Buy(ticker[\"Last\"] /1.8, 0.005)\n    exchange.Buy(ticker[\"Last\"] /1.9, 0.005)\n    exchange.Buy(ticker[\"Last\"] /2, 0.005)\n    exchange.Buy(ticker[\"Last\"] /2.1, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.2, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.3, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.4, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.5, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.6, 0.013)\n    exchange.Buy(ticker[\"Last\"] /2.7, 0.013)\n    exchange.Buy(ticker[\"Last\"] /2.8, 0.013)\n    exchange.Buy(ticker[\"Last\"] /2.9, 0.013)\n    exchange.Buy(ticker[\"Last\"] /3, 0.013)\n    exchange.Buy(ticker[\"Last\"] /3.1, 0.013)\n    exchange.Buy(ticker[\"Last\"] /3.2, 0.013)\n    exchange.Buy(ticker[\"Last\"] /3.3, 0.021)\n    exchange.Buy(ticker[\"Last\"] /3.4, 0.021)\n    exchange.Buy(ticker[\"Last\"] /3.5, 0.021) \n    exchange.Buy(ticker[\"Last\"] /3.6, 0.021)\n    exchange.Buy(ticker[\"Last\"] /3.7, 0.021)\n    exchange.Buy(ticker[\"Last\"] /3.8, 0.021) \n    exchange.Buy(ticker[\"Last\"] /3.9, 0.021) \n    exchange.Buy(ticker[\"Last\"] /4.0, 0.034) \n    exchange.Buy(ticker[\"Last\"] /4.1, 0.034) \n    exchange.Buy(ticker[\"Last\"] /4.2, 0.034)\n    exchange.Buy(ticker[\"Last\"] /4.3, 0.034) \n    exchange.Buy(ticker[\"Last\"] /4.4, 0.034)\n    exchange.Buy(ticker[\"Last\"] /4.5, 0.034) \n    exchange.Buy(ticker[\"Last\"] /4.6, 0.034)\n    exchange.Buy(ticker[\"Last\"] /4.7, 0.034)  \n    exchange.SetDirection(\"sell\")\n    exchange.Sell(ticker[\"Last\"] * 1, 0.001)\n    exchange.Sell(ticker[\"Last\"] * 1.1, 0.002)\n    exchange.Sell(ticker[\"Last\"] * 1.2, 0.002)\n    exchange.Sell(ticker[\"Last\"] * 1.3, 0.003)\n    exchange.Sell(ticker[\"Last\"] * 1.4, 0.003)\n    exchange.Sell(ticker[\"Last\"] * 1.5, 0.003)\n    exchange.Sell(ticker[\"Last\"] * 1.6, 0.005)\n    exchange.Sell(ticker[\"Last\"] * 1.7, 0.005)\n    exchange.Sell(ticker[\"Last\"] * 1.8, 0.005)\n    exchange.Sell(ticker[\"Last\"] * 1.9, 0.005)\n    exchange.Sell(ticker[\"Last\"] * 2, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.1, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.2, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.3, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.4, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.5, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 2.6, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 2.7, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 2.8, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 2.9, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 3, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 3.1, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.2, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.3, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.4, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.5, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.6, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.7, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.8, 0.034)\n    exchange.Sell(ticker[\"Last\"] * 3.9, 0.034) \n    exchange.Sell(ticker[\"Last\"] * 4.0, 0.034)\n    exchange.Sell(ticker[\"Last\"] * 4.1, 0.034)\n    exchange.Sell(ticker[\"Last\"] * 4.2, 0.034) \n    exchange.Sell(ticker[\"Last\"] * 4.3, 0.034)  \n    exchange.Sell(ticker[\"Last\"] * 4.4, 0.034)\n    exchange.Sell(ticker[\"Last\"] * 4.5, 0.034)  \n    Log(\"orders\", exchange.GetOrders())\n    Sleep(1000)"}
{"query": "请生成一个企业微信群机器人消息推送策略代码", "base_model_response": "示例\n\n```javascript\nfunction createRobotMessageToGroup群Id, botName, body) {\n    var群Data = [\n        { group_id:群Id },\n        { name: botName }\n    ];\n\n    var message = {\n        content: body,\n        type: 'text/plain'\n    };\n\n    var sendMessage = function(request) {\n        var client = new WebSocket(\"ws://your_server.com\");\n        client.onmessage = function(event) {\n            request文则(this.data);\n        };\n        client.send(message);\n    };\n\n    message = {\"data\":群Data};\n\n    var addRobotMessage = function() {\n        var group = new群群群Id, name = group.name;\n        var message = createRobotMessageToGroup(name, botName, \"group \" + group.id);\n\n        // Send the message to the specified group\n        sendMessage(request文);\n    };\n\n    sendAddRobotMessage();\n}\n\ncreateRobotMessageToGroup(\"your_group_id\", \"yourbot_name\", \"group some_data\");\n\naddRobotMessage();\n```\n\n这个代码示例创建了一个群组聊天机器人，它可以发送文本消息。你可以将`your_group_id`，`yourbot_name`和`group some_data`替换为你的群组ID、机器人名字和数据。\n\n注意：在实际使用中，你需要将`your_server.com`替换为你实际的WebSocket服务器地址，并修改代码中的`message文则`语句以适应你自己的数据内容。", "lora_model_response": "", "original_response": "python\n#!Python3\n\n\"\"\"\n《策略代写》 与 （此程序帮助），致信QQ：35787501\n\n企业微信消息推送，用于群自定义机器人\n同理：修改 data，也可以接入其他软件的 webhook\n\"\"\"\n\nimport requests\n\n\ndef send(text):\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"msgtype\": \"text\",\n        \"text\": {\n            \"content\": text,\n        }\n    }\n    response = requests.post(webhook, headers=headers, json=data)\n    records = response.json()\n    return records\n\n\ndef LogQYWX(*args):\n    text = \" \".join(args)\n    Log(text, send(text))\n\n\next.LogQYWX = LogQYWX"}
{"query": "请生成一个冰山委托买入-Jason策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport random\n\n\ndef main():\n    # 获取账户所有未成交订单\n    Log(\"取消所有未成交订单\")\n    orders = _C(exchange.GetOrders)\n    if len(orders) > 0:\n        for i in range(len(orders)):\n            exchange.CancelOrder(orders[i][\"Id\"])\n            Sleep(priceInterval*1000)\n\n    # 对比账户余额\n    Log(\"获取用户初始化账户\")\n    initAccount = _C(exchange.GetAccount)\n    if initAccount[\"Balance\"] < buyAmount:\n        Log(\"账户余额不足\")\n        return\n    \n    #比较单笔购买数量均值*市场买一价是否大于账户余额\n    ticker = _C(exchange.GetTicker)\n    if (ticker['Last'] * buyNum) > initAccount['Balance']:\n        Log(\"单次购买均值价格大于账户余额，请调整参数\")\n        return\n\n    lastBuyPrice = 0\n\n    while (True):\n        Sleep(priceInterval*1000)\n        #获取账户信息\n        account = _C(exchange.GetAccount)\n        #获取当下行情\n        ticker = _C(exchange.GetTicker)\n        # 上次购买价格不为空，查看订单是否完成，没有完成则取消\n        if lastBuyPrice > 0:\n            orders1 = exchange.GetOrders()\n            if len(orders1) > 0:\n                for j in range(len(orders1)):\n                    #计算实际市场委托深度\n                    if ticker[\"Last\"] > lastBuyPrice and ((ticker[\"Last\"] - lastBuyPrice)/lastBuyPrice) > (2* (depthStatus/100)):\n                        Log(\"委托价格偏离过多，最新成交价:\",ticker[\"Last\"],\"委托价\",lastBuyPrice)\n                        exchange.CancelOrder(orders1[j][\"Id\"])\n                        lastBuyPrice = 0\n                continue\n            else:\n                Log(\"买单完成, 累计花费:\", _N(initAccount[\"Balance\"] - account[\"Balance\"]), \"平均买入价:\", _N((initAccount[\"Balance\"] - account[\"Balance\"]) / (account[\"Stocks\"] - initAccount[\"Stocks\"])))\n                lastBuyPrice = 0\n                continue     \n        else:\n            Log(\"剩余余额:\",account[\"Balance\"])\n            #委托价格 = 最新买一价*（1-委托深度/100）\n            entrustPrice = _N(ticker[\"Buy\"]*(1-depthStatus/100))\n            Log(\"委托价格：\",entrustPrice)\n            #判断委托价格是否大于最高价格限定\n            if entrustPrice > highPrice:\n                continue\n            #随机购买数量 = 单次购买数量均值 * ((100-单次均值浮点数)/100)+(单次均值浮点数*2 /100* 单次购买数量均值 *随机数0~1)  \n            randomBuyNum = (buyNum*((100-buyOncePoint)/100))+(buyOncePoint*2/100 *buyNum*random.random())\n            #可用数量金额 \n            useMoney = min(account[\"Balance\"],randomBuyNum,buyAmount - (initAccount[\"Balance\"] - account[\"Balance\"]))\n            #购买数量\n            orderBuyNum = _N(useMoney/entrustPrice)\n            Log(\"交易数量：\",orderBuyNum)\n            #判断是否小于最小交易量\n            if orderBuyNum < minBuyNum:\n                break\n            #因为要扣手续费，所以大概为账户99.7%\n            if (entrustPrice*orderBuyNum)>(account[\"Balance\"]*0.997):\n                Log(\"金额为\",(entrustPrice*orderBuyNum))\n                Log(\"账户余额为\",(account[\"Balance\"]))\n                continue\n            #更新上次购买价格\n            lastBuyPrice = entrustPrice\n            #下单\n            exchange.Buy(entrustPrice,orderBuyNum)\n            \n    account = _C(exchange.GetAccount)  \n    Log(\"冰山委托买单完成,共计花费：\",_N(initAccount[\"Balance\"]-account[\"Balance\"]),\"平均单价为:\",_N((initAccount[\"Balance\"]-account[\"Balance\"])/(account[\"Stocks\"]-initAccount[\"Stocks\"])))"}
{"query": "请生成一个冲币安新上币开盘策略代码", "base_model_response": "```python\nfrom Crypto.Cipher import AES\nimport hashlib\nimport threading\nimport random\nimport time\n\nclass Token:\n    def __init__(self, token_type):\n        self.token_type = token_type\n\n    def get_token_info(self):\n        # 获取当前时间，用作加密和解密的键\n        now = time.time()\n\n        # 获取前50个非空字符串\n        tokens = [' '.join(random.choices(string.ascii_letters + string.digits, k=50)) for _ in range(50)]\n        # 使用AES对每一串进行加密，生成随机哈希值\n        encrypted_tokens = hashlib.sha256(tokens).hexdigest()\n        return encrypted_tokens\n\nclass TokenService:\n    def __init__(self, account_id, token_type):\n        self.account_id = account_id\n        self.token_type = token_type\n        self.token_service = {}\n\n    def add_token(self, token_data):\n        # 加载当前时长为1秒的加密\n        with AES.new(selfaccount_id, AES.MODE_ECB) as encryptor:\n            # 将加密后的数据解密为原始类型\n            encrypted_data = decryptor.decrypt(token_data)\n            # 提交给TokenService接口，等待TokenService执行操作\n            token_service[token_type] = encrypted_data\n\n    def send_email(self, subject, body, from_account_id, to_account_id):\n        # 在邮件中添加包含Subject、Body和FromAccountID的参数\n        email = f\"Subject: {subject}\\n\\n\\nBody: {body}\\n\\nFrom Account ID: {from_account_id}\\n\\nTo Account ID: {to_account_id}\"\n        # 发送邮件\n        msg = f\"{email} \\n\"\n\n        # 创建一个线程来处理发送邮件的任务\n        thread = threading.Thread(target=self.send_email, args=(subject, body, from_account_id, to_account_id))\n        thread.start()\n\nif __name__ == \"__main__\":\n    token_service = TokenService(\"your_account_id\", \"your_token_type\")\n    token_service.add_token('token_data')\n```\n\n这个代码首先定义了一个`Token`类用于存储各种类型的数据。然后定义了一个`TokenService`类，并使用了一个方法来创建一个新的`TokenService`实例，该实例会自动保存当前时间并获取所有可用的令牌。\n\n在`add_token`方法中，我们首先加载当前时间并将其设置为加密和解密的键。接着，我们将加密后的数据解密为原始类型，最后提交给TokenService接口以等待其执行操作。我们可以使用Thread来多线程地运行这个过程。\n\n在这个例子中，我们假设你的账户ID是`your_account_id`，你的token类型是`your_token_type`，并且你已经设置了`encryptor`作为加密算法并将其名设置为你想要的名称。你需要根据你的具体情况进行修改和配置。\n\n注意：这个代码只是一个基础的示例，实际应用中可能需要更复杂的错误处理和身份验证机制。", "lora_model_response": "", "original_response": "python\ndef main():\n    Log(exchange.GetAccount())\n    Log(exchange.GetCurrency())\n    while True:\n        ticker = exchange.GetTicker()\n        if ticker:\n            Log(\"开盘了，冲啊！！！@\")\n            exchange.SetPrecision(1,0)\n            amount = XX/ticker['Last']\n            exchange.Buy(-1, amount)\n            exchange.Buy(-1, amount/2)\n            exchange.Buy(-1, amount/4)\n            exchange.Buy(-1, amount/8)\n            exchange.Buy(-1, amount/16)\n            Sleep(15*1000)\n            while True:\n                try:\n                    _ticker = exchange.GetTicker()\n                    if _ticker['Last'] > ticker['Last']:\n                        exchange.Sell(-1, amount/3)\n                        Log(\"已经卖出三分之一@\")\n                        return\n                    else:\n                        Sleep(30)\n                        continue\n                except:\n                    Sleep(30)\n                    continue\n        else:\n            Sleep(20)"}
{"query": "请生成一个分享-赌徒策略-马丁策略策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport time\n\n# 初始化策略参数\nsymbol = 'huobip/btc_usdt'\nperiod = '1m'\namount = 0.01\nmartingale_factor = 2\nmax_martingale_times = 5\nstop_loss = 0.05\nstop_profit = 0.1\nlast_buy_price = 0\nmartingale_times = 0\n\n# 连接API\nexchange = Exchange()\nexchange.SetContractType(symbol)\nexchange.SetPeriod(period)\n\n# 主循环\nwhile True:\n    # 获取K线数据\n    klines = exchange.GetRecords()\n    if not klines:\n        continue\n\n    # 获取当前价格\n    current_price = float(klines[-1]['Close'])\n\n    # 判断是否需要加仓\n    if last_buy_price != 0 and current_price < last_buy_price * (1 - stop_loss):\n        # 止损，卖出所有持仓\n        sell_price = current_price\n        sell_amount = exchange.GetPosition()['Amount']\n        exchange.Sell(sell_price, sell_amount)\n        last_buy_price = 0\n        martingale_times = 0\n        print('止损，卖出所有持仓，价格', sell_price)\n    elif last_buy_price != 0 and current_price > last_buy_price * (1 + stop_profit):\n        # 止盈，卖出所有持仓\n        sell_price = current_price\n        sell_amount = exchange.GetPosition()['Amount']\n        exchange.Sell(sell_price, sell_amount)\n        last_buy_price = 0\n        martingale_times = 0\n        print('止盈，卖出所有持仓，价格', sell_price)\n    elif last_buy_price == 0:\n        # 买入一份初始仓位\n        buy_price = current_price\n        buy_amount = amount / buy_price\n        exchange.Buy(buy_price, buy_amount)\n        last_buy_price = buy_price\n        martingale_times = 0\n        print('买入初始仓位，价格', buy_price)\n    elif martingale_times < max_martingale_times:\n        # 加仓\n        buy_price = current_price * martingale_factor\n        buy_amount = amount / buy_price\n        exchange.Buy(buy_price, buy_amount)\n        last_buy_price = (last_buy_price * martingale_times + buy_price) / (martingale_times + 1)\n        martingale_times += 1\n        print('加仓，价格', buy_price)\n\n    # 等待下一次循环\n    time.sleep(60)"}
{"query": "请生成一个分享RSI超买超卖策略策略代码", "base_model_response": "", "lora_model_response": "```java\nimport java.util.*;\n\npublic classRSITeasingStrategy {\n    private static final String lines = \"<br>\\n\";\n    private static final String numbers = \"100.50% \\n\";\n    private static final String words = \"RSI / Bollinger\"\n\n    public static void main(String[] args) throws Exception {\n        List<String> options = new ArrayList<>();\n\n        // Set time range for 5 periods per day with the highest frequency of 3 periods a day\n        Options.set(\"minPeriods\", 2);\n        Options.set(\"maxPeriods\", 6);\n\n        // Set number of periods in a day to 1\n        Options.set(\"numPeriods\", 1);\n\n        // Specify the maximum time period that RSI is trading at (in seconds)\n        Options.set(\"maxTime periods\", 48 * 60 * 60 * 1000);\n\n        // Set the minimum time period at which an order with RSI is valid (in seconds)\n        Options.set(\"minimumTimePeriod\", 18 * 60 * 60);\n\n        // Set the time period (in second) to which order with RSI is valid if it's not currently open\n        Options.set(\"validTimePeriod\", 1 * 3600 * 1000); \n\n        // Set the min signal price\n        Options.set(\"minSignalPrice\", 50 * 1000); \n\n        // Set the max signal price\n        Options.set(\"maxSignalPrice\", 1000 * 1000); \n        Options.set(\"allowMaxVolume\", true);\n\n        // Specify the volume limit size\n        Options.set(\"volumeLimitSize\", 50); \n\n        // Specify the volume limit interval length\n        Options.set(\"volumeLimitIntervalLength\", 5 * 1000); \n        Options.set(\"volumeLimitInterval\", 7 * 1000); \n\n        // Set the volume level\n        Options.set(\"volumeLevel\", 2); \n\n        // Specify the volume rate\n        Options.set(\"volumeRate\", 0); \n\n        // Set the margin size\n        Options.set(\"marginSize\", 1); \n\n        // Set the spread size\n        Options.set(\"spreadSize\", 10); \n\n        // Set the strike size, for example 0.5\n        Options.set(\"shortVolumeSize\", 100);  \n\n        // Set the volume limit\n        Options.set(\"volumeLimit\", 20);\n\n        // Specify the volume limit interval length\n        Options.set(\"volumeLimitInterval\", 20 * 60 * 60); \n        Options.set(\"volumeLimitInterval\", 30; \n\n        // Set the volume limit interval\n        Options.set(\"volumeLimitInterval\", 2;  \n\n        // Set the volatility limit for the last time period to be set\n        Options.set(\"lastVolidityLimit\", 50);  \n\n        // Set the margin\n        Options.set(\"margin\", 100);  \n\n        // Generate a script file named \"main.json\" and add the following content:\n        System.out.println(\"\\n\");\n        System.out.println(lines);\n        System.out.println(\"Options: \");\n        System.out.println(options);\n        System.out.println(\"\\n\");\n        System.out.println(\"Option Type:RSI Sentences Type:RSI Points Type:RSI Indicators Type:RSI Volume Level: 2\");\n        System.out.println(\"Time Range: 0-12X (1:12) Time Period:1-12X (1:12) Volume Limit: 1X(1:12)\";\n        System.out.println();\n```\n\n该示例代码首先设置了RSI的振幅值，然后将不同时间段的时间范围设置在不同的范围内。然后，它使用RSI的振幅值和时间范围来生成两个命令：第一个是创建一个RSI信号，第二个是检查该信号是否已经打开并交易。\n\n最后，如果RSI存在，并且在当前时间点上有一个订单，那么RSI的振幅将是最大的。如果RSI没有在当前时间点上有一个订单，或者之前有RSI指令，那么RSI的振幅将会最小。", "original_response": "python\nimport talib\nimport numpy as np\nimport time\n\n# 初始化策略参数\nsymbol = 'huobip/btc_usdt'\nperiod = '1m'\nrsi_period = 14\nrsi_buy = 30\nrsi_sell = 70\namount = 0.01\nlast_buy_price = 0\n\n# 连接API\nexchange = Exchange()\nexchange.SetContractType(symbol)\nexchange.SetPeriod(period)\n\n# 主循环\nwhile True:\n    # 获取K线数据\n    klines = exchange.GetRecords()\n    if not klines:\n        continue\n\n    # 计算RSI指标\n    close_prices = np.array([float(k['Close']) for k in klines])\n    rsi = talib.RSI(close_prices, rsi_period)\n\n    # 获取当前价格\n    current_price = float(klines[-1]['Close'])\n\n    # 判断是否超买或超卖\n    if rsi[-1] < rsi_buy and last_buy_price == 0:\n        # 超卖，买入\n        buy_price = current_price\n        buy_amount = amount / buy_price\n        exchange.Buy(buy_price, buy_amount)\n        last_buy_price = buy_price\n        print('买入', buy_amount, 'BTC，价格', buy_price)\n    elif rsi[-1] > rsi_sell and last_buy_price != 0:\n        # 超买，卖出\n        sell_price = current_price\n        sell_amount = amount / sell_price\n        exchange.Sell(sell_price, sell_amount)\n        last_buy_price = 0\n        print('卖出', sell_amount, 'BTC，价格', sell_price)\n\n    # 等待下一次循环\n    time.sleep(60)"}
{"query": "请生成一个分享抢新现货策略策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport time\n\n# 初始化策略参数\nsymbol = 'huobip/ht_usdt'\namount = 10\nmax_price = 1.5\nmin_price = 0.5\ninterval = 0.1\n\n# 连接API\nexchange = Exchange()\nexchange.SetContractType(symbol)\n\n# 主循环\nwhile True:\n    # 获取当前市场深度\n    depth = exchange.GetDepth()\n\n    # 获取当前买一和卖一价格\n    buy_price = float(depth['Bids'][0]['Price'])\n    sell_price = float(depth['Asks'][0]['Price'])\n\n    # 判断是否满足条件\n    if buy_price <= max_price and sell_price >= min_price:\n        # 满足条件，进行买入操作\n        buy_amount = amount / buy_price\n        exchange.Buy(buy_price, buy_amount)\n        print('买入', buy_amount, 'HT，价格', buy_price)\n\n        # 等待一段时间后进行卖出操作\n        time.sleep(interval)\n        sell_price = float(depth['Asks'][0]['Price'])\n        sell_amount = amount / sell_price\n        exchange.Sell(sell_price, sell_amount)\n        print('卖出', sell_amount, 'HT，价格', sell_price)\n\n    # 等待下一次循环\n    time.sleep(1)\n\n\n#该策略使用了FMZ平台提供的Exchange API来进行交易。在主循环中，首先获取当前市场深度，然后获取当前买一和卖一价格。如果买一价格小于等于设定的最大价格且卖一价格大于等于设定的最小价格，则进行买入操作。等待一段时间后再获取当前卖一价格进行卖出操作。最后等待下一次循环。需要注意的是，抢新现货策略存在一定的风险，需要谨慎操作。"}
{"query": "请生成一个动态平衡策略-python-版策略代码", "base_model_response": "", "lora_model_response": "在python中用pandas，sqlalchemy", "original_response": "python\n\n# !usr/bin/ python3\n# *_* coding:utf-8 *_*\n#学会python后写的第一个动态平衡策略\n# QQ：5325049 不足之处欢迎指正\n\nimport time\n\n#定义获取行情及账户信息函数\ndef nowinfo(): \n    global NowTicker,NowAsset,NowCoinValue,AssetDiff\n    NowTicker = exchange.GetTicker() #获取行情信息\n    NowAsset = exchange.GetAccount() # 获取账户信息\n    NowCoinValue =NowTicker.Last * NowAsset.Stocks #计算币资产净值\n    AssetDiff = NowCoinValue-NowAsset.Balance #计算币资产与现金差额\n\n# 定义交易执行函数\ndef trade():\n    if AssetDiff > NowAsset.Balance*0.05: # 判断币值是否超过资金5%\n        Log(\"交易将被执行，以\",NowTicker.Buy,\"卖出\",AssetDiff/2/NowTicker.Buy,\"个币\")\n        exchange.SetPrecision(5,5) #设置计价精度\n        exchange.Sell(NowTicker.Buy,AssetDiff/2/NowTicker.Buy) #执行币卖出交易\n    elif AssetDiff < NowAsset.Balance*(-0.05): #判断币值是否低于资金5%\n        Log(\"交易将被执行，以\",NowTicker.Sell,\"买入\",AssetDiff/-2/NowTicker.Sell,\"个币\")\n        exchange.SetPrecision(5,5) #设置计价精度\n        exchange.Buy(NowTicker.Sell,AssetDiff/-2/NowTicker.Sell) #执行币买入交易\n    else:\n        Log(\"未触发交易条件\")\n\n# 入口函数，只要定义了系统就会自动执行该函数，不需要调用啊\ndef main():\n    i = 0\n    while i < 1000: #设置执行总次数\n        nowinfo() # 调用获取行情资产函数\n        Log(NowTicker) # 打印行情信息\n        Log(NowAsset) # 打印账户信息\n        Log(\"当前币余额：\",NowAsset.Stocks)\n        Log(\"当前资金余额：\",NowAsset.Balance)\n        Log(\"当前币市值：\", NowCoinValue)\n        Log(\"币市值与资金差额：\",AssetDiff)\n        trade() #调用 交易执行函数\n        i+=1 # 条件迭代\n        Log(\"第\", i, \"轮循环结束\")\n        time.sleep(60) # 等待60秒"}
{"query": "请生成一个双平台对冲-练习用-求交流求指点策略代码", "base_model_response": "```python\n# 先定义一个函数，返回两个数相加的结果\ndef add_numbers(num1, num2):\n    return num1 + num2\n\n# 在主程序中定义两个函数\ndef addition_and subtraction(num1, num2):\n    result = add_numbers(num1, num2)\n    \n    # 计算求和\n    sum_result = result + subtraction(num2)\n\n    print(f\"两数的和是: {sum_result}\")\n\n# 执行主程序\naddition_and subtraction(\"2\", \"5\")\n```\n\n注意：这个代码需要Python 3.7及更高版本才能运行。", "lora_model_response": "", "original_response": "python\nimport time\nimport numpy as np\n\ndef reject_outliers(arr, m=2):\n    final_list = [x for x in arr if (x > np.mean(arr) - 2 * np.std(arr))]\n    final_list = [x for x in final_list if (x < np.mean(arr) + 2 * np.std(arr))]\n    return final_list\n\ndef main():\n    '''SetErrorFilter(\"canceled\")'''\n     \n    LogReset()\n    LogProfitReset()\n    \n    global sellTrue \n    global buyTrue \n    sellTrue = 0 \n    buyTrue = 0\n    initStocks = 0.0\n    initBalance = 0.0\n    lastTradeTime = 0\n    lastTradeErrExchange = ''\n    accountsCache = []\n    depthCache=[]\n    names = []\n    buyPrice=0\n    sellPrice=0\n    dealtransactioned = False\n\n    for e in exchanges:\n        names.append(e.GetName())\n        account = _C(e.GetAccount)\n        initStocks += account.Stocks\n        initBalance += account.Balance\n        Log(\"Switch\", e.GetLabel(), \"To\", e.IO(\"websocket\"))\n        \n    Log(\"Total Currency:\", _N(initBalance), \"Total Asset\", _N(initStocks), 'Python:', __import__('sys').version)\n    while (True):\n        LogStatus(_D())\n        if not accountsCache:\n            accountsCache = [_C(e.GetAccount) for e in exchanges]\n        Sleep(LoopInterval)\n        depthA = exchanges[0].GetDepth()\n        depthCache.append(depthA)\n        if not depthA:\n            continue\n        depthB = exchanges[1].GetDepth()\n        depthCache.append(depthB)\n        if not depthB:\n            continue\n        \n                \n        '''trade part'''\n        \n        diffA = _N(depthA.Bids[0].Price - depthB.Asks[0].Price, 3)\n        diffB = _N(depthB.Bids[0].Price - depthA.Asks[0].Price, 3)\n        LogStatus(\"A平台币\",exchanges[0].GetAccount().Stocks,\"A平台钱\",exchanges[0].GetAccount().Balance,\"B平台币\",exchanges[1].GetAccount().Stocks,\"B平台钱\",exchanges[1].GetAccount().Balance)\n        \n        if diffA > 0:\n            buytarget = depthB.Asks[0]\n            opAmount=min(depthA.Bids[0].Amount,buytarget.Amount)\n            buyAmount=min(opAmount,exchanges[1].GetAccount().Balance/buytarget.Price)\n            sellAmount=min(buyAmount,exchanges[0].GetAccount().Stocks)\n            \n            if diffA > (buyAmount*depthB.Asks[0].Price*0.2/100+sellAmount*depthA.Bids[0].Price*0.2/100)*p:\n                Log('buy from B sell at A')\n                Log(\"A平台币\",exchanges[0].GetAccount().Stocks,\"A平台钱\",exchanges[0].GetAccount().Balance,\"B平台币\",exchanges[1].GetAccount().Stocks,\"B平台钱\",exchanges[1].GetAccount().Balance)\n                tradeAmount=min(buyAmount,sellAmount)     \n                buyorder =exchanges[1].Buy(buytarget.Price,tradeAmount)\n                sellorder = exchanges[0].Sell(depthA.Bids[0].Price,tradeAmount)\n                canceller = 0\n                    \n                    \n                while True:\n             \n                    \n                    \n                    if (exchanges[1].GetOrder(buyorder).Status == 2) and (exchanges[0].GetOrder(sellorder).Status == 2):\n                        Log('deal transactioned')\n                        buyPrice = exchanges[1].GetOrder(buyorder).Price\n                        sellPrice = exchanges[0].GetOrder(sellorder).Price\n                        LogProfit(exchanges[0].GetOrder(sellorder).Amount*exchanges[0].GetOrder(sellorder).Price-exchanges[1].GetOrder(buyorder).Amount*exchanges[1].GetOrder(buyorder).Price)\n                        dealtransactioned = True\n                        break\n                    elif ((exchanges[1].GetOrder(buyorder).Status == 1) or (exchanges[0].GetOrder(sellorder).Status == 1)):\n                        buyPrice = exchanges[1].GetOrder(buyorder).Price\n                        sellPrice = exchanges[0].GetOrder(sellorder).Price\n                        canceller += 1\n                        dealtransactioned = True\n                        Sleep(200)\n                    elif ((exchanges[1].GetOrder(buyorder).Status == 0) and (exchanges[0].GetOrder(sellorder).Status == 0)):\n                        Sleep(200)\n                        canceller += 1\n                    if canceller == 5:        \n                        exchanges[1].CancelOrder(buyorder)\n                        exchanges[0].CancelOrder(sellorder)\n                        Log('deal cancelled')       \n                        break    \n                \n                    \n\n        elif diffB > 0:\n            \n            opAmount=min(depthB.Bids[0].Amount,depthA.Asks[0].Amount)\n            buyAmount=min(opAmount,exchanges[0].GetAccount().Balance/depthA.Asks[0].Price)\n            sellAmount=min(buyAmount,exchanges[1].GetAccount().Stocks)\n            canceller = 0\n            if diffB > (buyAmount*depthA.Asks[0].Price*0.2/100+sellAmount*depthB.Bids[0].Price*0.2/100)*p:\n                Log('buy from A sell at B')\n                \n                tradeAmount=min(buyAmount,sellAmount)\n                buyorder=exchanges[0].Buy(depthA.Asks[0].Price,tradeAmount)\n                sellorder=exchanges[1].Sell(depthB.Bids[0].Price,tradeAmount)\n                canceller =0\n                \n                while True:\n                       \n                    if (exchanges[0].GetOrder(buyorder).Status == 2) and (exchanges[1].GetOrder(sellorder).Status == 2):\n                        Log('deal transactioned')\n                        buyPrice=exchanges[0].GetOrder(buyorder).Price\n                        sellPrice=exchanges[1].GetOrder(sellorder).Price\n                        LogProfit(exchanges[1].GetOrder(sellorder).Amount*exchanges[1].GetOrder(sellorder).Price-exchanges[0].GetOrder(buyorder).Amount*exchanges[0].GetOrder(buyorder).Price)\n                        dealtransactioned = True\n                        break\n                    elif ((exchanges[0].GetOrder(buyorder).Status == 1) or (exchanges[1].GetOrder(sellorder).Status == 1)):\n                        \n                        buyPrice=exchanges[0].GetOrder(buyorder).Price\n                        sellPrice=exchanges[1].GetOrder(sellorder).Price\n                        canceller += 1\n                        dealtransactioned = True\n                        Sleep(200)\n                    elif ((exchanges[0].GetOrder(buyorder).Status == 0) and (exchanges[1].GetOrder(sellorder).Status == 0)):\n                        Sleep(200)\n                        canceller += 1\n                    if canceller == 5:        \n                        exchanges[0].CancelOrder(buyorder)\n                        exchanges[1].CancelOrder(sellorder)\n                        Log('deal cancelled')       \n                        break \n              \n        '''balance part'''\n        for i in [0,1]:\n            if dealtransactioned:\n                if(exchanges[i].GetAccount().Stocks > (initStocks/2)* q and exchanges[i].GetAccount().Balance < (initBalance/2)*q):           \n                    sellwait = 1\n                    Log('ready to sell')\n                    loopbreaker = 0\n                    while (sellwait):\n                        \n                        if (_N(depthCache[i].Bids[0].Price,3)> buyPrice*r):\n                            sellwait = 0\n\n                            break\n                        else:\n                            Sleep(1000)\n                            Log('sellwait')\n                            loopbreaker += 1\n                        if loopbreaker == 600:\n                            '''break'''\n                        \n                    \n\n                    sellTrue = 1\n\n                    while(sellTrue):\n                        dealprice = depthCache[i].Bids[0].Price\n                        Log('insufficient money, sell some')\n                        idealamount = initBalance/8\n                        availamount = exchanges[i].GetAccount().Stocks/2\n                        dealamount = min(idealamount,availamount)\n                        balancesell = exchanges[i].Sell(depthCache[i].Bids[0].Price, dealamount)\n                        Sleep(200)\n                        while( exchanges[i].GetOrder(balancesell).Status not in [1,2] ):\n                            exchanges[i].CancelOrder(balancesell)\n                            if( dealprice > buyPrice):\n                                dealprice -= 1\n                            balancesell = exchanges[i].Sell(dealprice,dealamount)\n                            Sleep(200)\n                        '''buyPrice=[]'''\n                        Log(\"Sell Balance finished\")\n                        sellTrue=0\n\n\n                if(exchanges[i].GetAccount().Balance > (initBalance/2)*q and exchanges[i].GetAccount().Stocks < (initStocks/2)*q):\n                    buywait = 1\n                    loopbreaker = 0\n                    while (buywait):\n                        \n                        if(_N(depthCache[i].Asks[0].Price,3)< sellPrice*r):\n\n                            buywait=0\n\n                            break\n                        else:\n                            Sleep(1000)\n                            Log(_N(depthCache[i].Asks[0].Price,3),sellPrice*r)\n                            loopbreaker +=1\n                        if loopbreaker == 600:\n                            '''break\n                        break'''\n                            \n\n\n\n                    buyTrue = 1\n                    while(buyTrue):\n                        Log('buyTrue started')\n                        dealprice = depthCache[i].Asks[0].Price\n                        Log('insufficient stocks, buy some')\n                        idealamount = initStocks/8\n                        availamount = exchanges[i].GetAccount().Balance/dealprice/2\n                        dealamount = min(idealamount,availamount)\n                        balancebuy = exchanges[i].Buy(dealprice,dealamount)\n                        Sleep(200)\n                        while(exchanges[i].GetOrder(balancebuy).Status not in [1,2]):\n\n                            exchanges[i].CancelOrder(balancebuy)\n                            if (dealprice < sellPrice):\n                                dealprice += 1\n                            balancebuy = exchanges[i].Buy(dealprice,dealamount)\n                            Sleep(200)\n                        '''sellPrice=[]'''\n                        Log(\"Buy Balance finished\")\n                        buyTrue = 0\n                        break\n                else:         \n                    continue\n                break\n            else:\n                break"}
{"query": "请生成一个双平台对冲平衡策略策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2024-11-19 00:00:00\nend: 2024-12-18 08:00:00\nperiod: 1d\nbasePeriod: 1d\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"TRB_USDT\"},{\"eid\":\"OKX\",\"currency\":\"TRB_USDT\"}]\n'''\n\nimport time\nimport json\n\n# 全局变量定义\ndepthA = depthB = None\ntimeBegin = timeEnd = None\naskPriceA = bidPriceA = askAmountA = bidAmountA = 0\naskPriceB = bidPriceB = askAmountB = bidAmountB = 0\nminAmount = 20  # 最小下单量\nfeeA = 0.0020  # Huobi 手续费   \nfeeB = 0.0010  # Binance 手续费\nfees = None\nminProfit = 0.0002  # 最小利润\nnotDealAmountA = notDealAmountB = None\naccountA = accountB = None\ninitAccountA = initAccountB = None\nmaxDeltaAmount = 100  # 最大可容忍币偏差\ndealAmountA = 0\ndealAmountB = 0\nsafeAmount = 800  # 安全最大成交量\nprofit = None\nmaxTime = 150  # 最大延迟过滤\naccountBNB = None\nreload = False\n\n# 初始化函数\ndef init():\n    global fees, initAccountA, initAccountB, accountA, accountB\n\n    try:\n        fees = feeA + feeB\n\n        initAccountA = _G(\"initAccountA\")\n        initAccountB = _G(\"initAccountB\")\n        \n        if initAccountA is None or initAccountB is None:\n            initAccountA = _C(exchanges[0].GetAccount)\n            initAccountB = _C(exchanges[1].GetAccount)\n            _G(\"initAccountA\", initAccountA)\n            _G(\"initAccountB\", initAccountB)\n            Log(\"账号初值初始化成功\")\n        else:\n            Log(\"继承初值数据成功\")\n        \n        accountA = initAccountA\n        accountB = initAccountB\n\n    except Exception as e:\n        Log(\"初始化失败 请重启:\", e)\n\n# 规范化深度数据\ndef legalize_depth(depthA, depthB):\n    global askPriceA, bidPriceA, askAmountA, bidAmountA\n    global askPriceB, bidPriceB, askAmountB, bidAmountB\n\n    askPriceA = bidPriceA = askAmountA = bidAmountA = 0\n    askPriceB = bidPriceB = askAmountB = bidAmountB = 0\n\n    for ask in depthA[0][\"Asks\"]:\n        askPriceA = ask[\"Price\"]\n        askAmountA += ask[\"Amount\"]\n        if askAmountA >= minAmount:\n            break\n\n    for bid in depthA[0][\"Bids\"]:\n        bidPriceA = bid[\"Price\"]\n        bidAmountA += bid[\"Amount\"]\n        if bidAmountA >= minAmount:\n            break\n\n    for ask in depthB[0][\"Asks\"]:\n        askPriceB = ask[\"Price\"]\n        askAmountB += ask[\"Amount\"]\n        if askAmountB >= minAmount:\n            break\n\n    for bid in depthB[0][\"Bids\"]:\n        bidPriceB = bid[\"Price\"]\n        bidAmountB += bid[\"Amount\"]\n        if bidAmountB >= minAmount:\n            break\n\n# 取消所有挂单\ndef cancel_all_orders():\n    global dealAmountA, dealAmountB\n\n    orders = _C(exchanges[0].GetOrders)\n    for order in orders:\n        exchanges[0].CancelOrder(order[\"Id\"])\n        Log(\"成交:\", order[\"DealAmount\"], \"未成交:\", order[\"Amount\"] - order[\"DealAmount\"])\n        dealAmountA -= order[\"Amount\"] - order[\"DealAmount\"]\n\n    orders = _C(exchanges[1].GetOrders)\n    for order in orders:\n        exchanges[1].CancelOrder(order[\"Id\"])\n        Log(\"成交:\", order[\"DealAmount\"], \"未成交:\", order[\"Amount\"] - order[\"DealAmount\"])\n        dealAmountB -= order[\"Amount\"] - order[\"DealAmount\"]\n\n# 检查余额\ndef check_balance():\n    global accountA, accountB, dealAmountA, dealAmountB\n\n    cancel_all_orders()\n    deltaStocks = (initAccountA[\"Stocks\"] + initAccountA[\"FrozenStocks\"] + initAccountB[\"Stocks\"] + initAccountB[\"FrozenStocks\"]\n        - accountA[\"Stocks\"] - accountA[\"FrozenStocks\"] - accountB[\"Stocks\"] - accountB[\"FrozenStocks\"])\n\n    deltaStocks = round(deltaStocks, 0)\n\n    if deltaStocks < -maxDeltaAmount:  # 仓位过重\n        if askPriceA > askPriceB and accountA[\"Stocks\"] > -deltaStocks:\n            exchanges[0].Sell(askPriceA, -deltaStocks)\n            dealAmountA += -deltaStocks\n        else:\n            exchanges[1].Sell(askPriceB, -deltaStocks)\n            dealAmountB += -deltaStocks\n        return True\n\n    if deltaStocks > maxDeltaAmount:  # 仓位过轻\n        if bidPriceA < bidPriceB and accountA[\"Balance\"] * 0.999 / bidPriceA > deltaStocks:\n            exchanges[0].Buy(bidPriceA, deltaStocks)\n            dealAmountA += deltaStocks\n        else:\n            exchanges[1].Buy(bidPriceB, deltaStocks)\n            dealAmountB += deltaStocks\n        return True\n\n    return False\n\n# 更新利润\ndef update_profit():\n    global profit\n\n    profit = (\n        accountA[\"Balance\"] + accountB[\"Balance\"] + accountA[\"FrozenBalance\"] + accountB[\"FrozenBalance\"]\n        + (accountA[\"Stocks\"] + accountA[\"FrozenStocks\"] + accountB[\"Stocks\"] + accountB[\"FrozenStocks\"]\n        - initAccountA[\"Stocks\"] - initAccountA[\"FrozenStocks\"] - initAccountB[\"Stocks\"] - initAccountB[\"FrozenStocks\"]) * askPriceA\n        - (initAccountA[\"Balance\"] + initAccountA[\"FrozenBalance\"] + initAccountB[\"Balance\"] + initAccountB[\"FrozenBalance\"]))\n\n    return profit\n\n# 检查套利机会\ndef check_opportunity():\n    global dealAmountA, dealAmountB, accountA, accountB, diff_A, diff_B \n\n    diff_A = bidPriceB - askPriceA  # A交易所买 -> B交易所卖\n    diff_B = bidPriceA - askPriceB  # B交易所买 -> A交易所卖\n\n    if diff_A > 0 and diff_A > (minProfit + fees) * askPriceA:\n        maxBuyAmount = min(accountA[\"Balance\"] / askPriceA * 0.98, askAmountA)\n        maxSellAmount = min(accountB[\"Stocks\"], bidAmountB)\n        amount = min(maxBuyAmount, maxSellAmount, safeAmount)\n        amount = round(amount, 0)\n\n        if amount >= minAmount:\n            Log(\"huobi -> binance\", amount)\n            exchanges[0].Buy(askPriceA, amount)\n            exchanges[1].Sell(bidPriceB, amount)\n            time.sleep(3)\n            dealAmountA += amount\n            dealAmountB += amount\n            accountA = _C(exchanges[0].GetAccount)\n            accountB = _C(exchanges[1].GetAccount)\n            Log(\"利润更新:\", update_profit())\n\n    if diff_B > 0 and diff_B > (minProfit + fees) * askPriceB:\n        maxBuyAmount = min(accountB[\"Balance\"] / askPriceB * 0.98, askAmountB)\n        maxSellAmount = min(accountA[\"Stocks\"], bidAmountA)\n        amount = min(maxBuyAmount, maxSellAmount, safeAmount)\n        amount = round(amount, 0)\n\n        if amount >= minAmount:\n            Log(\"binance -> huobi\", amount)\n            exchanges[1].Buy(askPriceB, amount)\n            exchanges[0].Sell(bidPriceA, amount)\n            time.sleep(3)\n            dealAmountA += amount\n            dealAmountB += amount\n            accountA = _C(exchanges[0].GetAccount)\n            accountB = _C(exchanges[1].GetAccount)\n            Log(\"利润更新:\", update_profit())\n\ndef main():\n    global initAccountA, initAccountB\n    if reload == True:\n        initAccountA = _C(exchanges[0].GetAccount)\n        initAccountB = _C(exchanges[1].GetAccount)\n        _G(\"initAccountA\", initAccountA)\n        _G(\"initAccountB\", initAccountB)\n\n    init()\n\n    checkBalanceCount = 60\n    \n    while True:\n        accountA = exchanges[0].GetAccount()\n        accountB = exchanges[1].GetAccount()\n        timeBegin = int(time.time() * 1000)\n        depthA = exchanges[0].Go(\"GetDepth\")\n        depthB = exchanges[1].Go(\"GetDepth\")\n        depthA = depthA.wait()\n        depthB = depthB.wait()\n        \n        timeEnd = int(time.time() * 1000)\n        # 真实交易，去除205-208注释\n        #if timeEnd - timeBegin > maxTime:\n        #    continue  # 延迟超过 maxTime 毫秒就放弃当组数据\n        #if depthA is None or depthB is None or accountA is None or accountB is None:\n        #    continue\n\n        legalize_depth(depthA, depthB)\n\n        if checkBalanceCount >= 60:\n            checkBalanceCount = 0\n            if check_balance():\n                continue\n        else:\n            checkBalanceCount += 1\n        \n        check_opportunity()\n        \n        # 数据可视化操作\n        table = {\n            'type': 'table',\n            'title': '持仓操作',\n            'cols': ['交易所', '初始余额', '初始币数', '当前余额', '当前币数', '成交量'],\n            'rows': [\n                ['huobi', initAccountA.Balance + initAccountA.FrozenBalance, initAccountA.Stocks + initAccountA.FrozenStocks,\n                    accountA.Balance + accountA.FrozenBalance, accountA.Stocks + accountA.FrozenStocks, dealAmountA],\n                ['binance', initAccountB.Balance + initAccountB.FrozenBalance, initAccountB.Stocks + initAccountB.FrozenStocks,\n                    accountB.Balance + accountB.FrozenBalance, accountB.Stocks + accountB.FrozenStocks, dealAmountB],\n                ['合计', initAccountA.Balance + initAccountB.Balance, initAccountA.Stocks + initAccountB.Stocks,\n                    accountA.Balance + accountA.FrozenBalance + accountB.Balance + accountB.FrozenBalance,\n                    accountA.Stocks + accountA.FrozenStocks + accountB.Stocks + accountB.FrozenStocks, dealAmountA + dealAmountB],\n                ['huobi盘口', askPriceA, askAmountA, bidPriceA, bidAmountA, ''],\n                ['binance盘口', askPriceB, askAmountB, bidPriceB, bidAmountB, ''],\n                ['收益:', str(_N(update_profit(), 8)) + '#FF0000',  '', '', ''],\n                ['收益率', str(_N(100 * profit / (initAccountA.Balance + initAccountA.FrozenBalance + initAccountB.Balance + initAccountB.FrozenBalance), 6)) + '%' + '#FF0000', '', '', '', ''],\n                ['总延迟', timeEnd - timeBegin, '', '', '', ''],\n                ['最后更新时间', _D(), '', '', '', ''],\n            ]\n        }\n        LogStatus('`' + json.dumps(table) + '`')\n\n        time.sleep(10)"}
{"query": "请生成一个可变图表示例策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nPS = ext.PersistentStorage()\nALPHA = 0.0008\nclass GraphManager:\n\n    diffs_chart = {\n        '__isStock': False,\n        'extension': {\n            'layout': 'single',\n            'height': 300,\n            'col': 6\n        },\n        'chart': {\n            'zoomType': 'x'\n        },\n        'title': {\n            'text': '各币种价格与指数的偏离值'\n        },\n        'subtitle': {\n            'text': 'Alpha: %s' % ALPHA\n        },\n        'xAxis': {\n            'type': 'datetime'\n        },\n        'series': []\n    }\n    index_chart = {\n        '__isStock': False,\n        'extension': {\n            'layout': 'single',\n            'height': 300,\n            'col': 6\n        },\n        'chart': {\n            'zoomType': 'x'\n        },\n        'title': {\n            'text': '基准指数值'\n        },\n        'xAxis': {\n            'type': 'datetime'\n        },\n        'series': [{\n            'type': 'line',\n            'name': 'INDEX',\n            'data': []\n        }]\n    }\n    pos_chart = {\n        '__isStock': False,\n        'extension': {\n            'layout': 'single',\n            'height': 300,\n            'col': 6\n        },\n        'chart': {\n            'zoomType': 'x'\n        },\n        'title': {\n            'text': '各币种当前持仓价值'\n        },\n        'subtitle': {\n            'text': '以USDT计算'\n        },\n        'xAxis': {\n            'type': 'datetime'\n        },\n        'series': []\n    }\n    upnl_chart = {\n        '__isStock': False,\n        'extension': {\n            'layout': 'single',\n            'height': 300,\n            'col': 6\n        },\n        'chart': {\n            'zoomType': 'x'\n        },\n        'title': {\n            'text': '各币种当前未实现盈亏'\n        },\n        'subtitle': {\n            'text': '以USDT计算'\n        },\n        'xAxis': {\n            'type': 'datetime'\n        },\n        'series': []\n    }\n\n    def __init__(self, reset: bool):\n        self.indices = {}\n        self.diffs_data = {}\n        self.pos_data = {}\n        self.upnl_data = {}\n        self.index = 1\n        self.not_manual_reset = True\n        if PS['symbols'] is None or reset:\n            echo('图表管理器第一次初始化')\n            if reset:\n                PS['symbols'] = None\n                self.not_manual_reset = False\n\n    def initialize(self, symbols):\n        self.symbols = symbols\n        self.create_chart()\n        if self.symbols != PS['symbols']:\n            if self.not_manual_reset:\n                echo('币种出现更改，图表重新初始化')\n            self.reset_graph()\n        PS['symbols'] = self.symbols\n\n    def reset_graph(self):\n        self.chart.reset(0)\n\n    def create_chart(self):\n        i = 0\n        for symbol in self.symbols:\n            # DIFF Chart\n            self.diffs_chart['series'].append({\n                'type': 'line',\n                'name': symbol,\n                'data': []\n            })\n            self.indices[symbol+'_diff'] = i\n            i+=1\n        # INDEX Chart\n        self.indices['INDEX_CHART'] = i\n        i+=1\n        for symbol in self.symbols:\n            # POS Chart\n            self.pos_chart['series'].append({\n                'type': 'line',\n                'name': symbol,\n                'data': []\n            })\n            self.indices[symbol+'_pos'] = i\n            i+=1\n        for symbol in self.symbols:\n            # UPNL Chart\n            self.upnl_chart['series'].append({\n                'type': 'line',\n                'name': symbol,\n                'data': []\n            })\n            self.indices[symbol+'_upnl'] = i\n            i+=1\n        self.chart = Chart([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])\n\n    def add_diff_data(self, symbol, diff):\n        self.diffs_data[symbol] = diff\n\n    def add_pos_data(self, symbol, pos):\n        self.pos_data[symbol] = pos\n\n    def add_upnl_data(self, symbol, upnl):\n        self.upnl_data[symbol] = upnl\n\n    def add_index_data(self, index):\n        self.index = index\n\n    def update_chart(self, timestamp):\n        for symbol in self.diffs_data.keys():\n            index = self.indices[symbol+'_diff']\n            data = self.diffs_data[symbol]\n            self.chart.add(index, [timestamp, data])\n\n        for symbol in self.pos_data.keys():\n            index = self.indices[symbol+'_pos']\n            data = self.pos_data[symbol]\n            self.chart.add(index, [timestamp, data])\n\n        for symbol in self.upnl_data.keys():\n            index = self.indices[symbol+'_upnl']\n            data = self.upnl_data[symbol]\n            self.chart.add(index, [timestamp, data])\n\n        index = self.indices['INDEX_CHART']\n        self.chart.add(index, [timestamp, self.index])\n        self.chart.update([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])"}
{"query": "请生成一个各平台策略代写区块链5年专业经验低价高质量-薇芯bov1107策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\ndef main():\n    Log(exchange.GetAccount())"}
{"query": "请生成一个各平台策略代写区块链5年专业经验低价高质量薇芯bov1107策略代码", "base_model_response": "", "lora_model_response": "薇芯bov是2020年11月23日推出的一款投资数字货币的社区智能合约", "original_response": "python\ndef main():\n    Log(exchange.GetAccount())"}
{"query": "请生成一个合成任意周期K线-使用请看源码最下面策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n# \n# Candlestick merger.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\nfrom math import *\nfrom datetime import datetime\n\ndef timeFilter(records, since, to=1000000000000000):\n    bars = []\n    for i in records:\n        if i['Time'] >= since and i['Time'] <= to:\n            bars.append(i)\n\n    return bars\n\ndef calcRecords(records, period=30, start=None):\n    try:\n        records[0]\n    except IndexError:\n        return []\n    \n    period_ms = period * 60000  # 以毫秒记的K线周期\n    end_in = records[len(records)-1]['Time']  # K线的结束时间\n    start_at = records[0]['Time']  # K线的开始时间\n    \n    # 获得可以用于计算目标K线的开始时间\n    r_offest = start_at % period_ms\n    start_at = start_at - r_offest + period_ms\n    if start is not None:\n        start_at = start\n    \n    target_count = ceil((end_in-start_at)/period_ms) # 目标K线的数量\n    \n    n_records = []\n    \n    for i in range(0, target_count):\n        bars = timeFilter(records, start_at+i*period_ms, start_at+(i+1)*period_ms-1000)\n        try:\n            bars[0]\n        except IndexError:\n            continue\n        # 初始化新的Bar\n        Time = bars[0]['Time']\n        Open = bars[0]['Open']\n        High = bars[0]['High']\n        Low = bars[0]['Low']\n        Close = bars[0]['Close']\n        Volume = 0\n        for item in bars:\n            High = max(High, item['High'])\n            Low = min(Low, item['Low'])\n            Close = item['Close']\n            Volume+=item['Volume']\n            \n        # 将Bar添加添加到新的K线中\n        n_records.append(dict({\n            'Time' : Time,\n            'Open' : Open,\n            'High' : High,\n            'Low' : Low,\n            'Close' : Close,\n            'Volume' : Volume\n        }))\n        \n    return n_records\n\ndef getRecords(exchange, period=30):\n    records = exchange.GetRecords(PERIOD_M1)\n        \n    return calcRecords(records, period)\n\ndef calcRecordsWithOldRecords(records, old_records, period=30):\n    try:\n        start = old_records[len(old_records)-1]['Time']\n        del old_records[len(old_records)-1]\n    except IndexError:\n        old_records = []\n        start = None\n        \n    return old_records + calcRecords(records=records, period=period, start=start)\n        \next.calcRecords = calcRecords\next.getRecords = getRecords\next.calcRecordsWithOldRecords = calcRecordsWithOldRecords\n\n# Function Test\ndef main():\n    LogReset()\n    M1 = exchange.GetRecords(PERIOD_M1)\n    M15 = exchange.GetRecords(PERIOD_M15)\n    M15_GEN = ext.calcRecords(M1, 15) # 使用ext.calcRecords函数 按照1分钟K线 计算出15分钟K线\n    Log(M15[len(M15)-50:])\n    Log(M15_GEN[len(M15_GEN)-50:])"}
{"query": "请生成一个回测保存K线到本地CSV策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''\n/*backtest\nstart: 2017-10-01        \nend: 2017-11-16          \nperiod: 1440\nperiodBase: 15\nmode: 0                 \n*/\n'''\n\n#需要用的pandas库，并且用自己的托管回测才能保存到本地\n#import numpy as np\nimport pandas as pd\n\n#保存路径\npath = 'C:\\\\Users\\\\Public\\\\Documents\\\\'\n\ndef main():\n    df=pd.DataFrame()\n    while True:\n        records = _C(exchange.GetRecords)\n        df_new = pd.DataFrame(records)  #把records转为dataframe\n        df_new['Time'] = pd.to_datetime(df_new['Time'],unit='ms')+pd.Timedelta('8 h')\n        df_new.index = df_new['Time']\n        if df.empty or df_new['Time'].min() >= df['Time'].max():\n            df=df.combine_first(df_new)\n            Log(df['Time'].max())\n        #确定最后一次时间，用于保存数据\n        if df_new['Time'].max() == pd.Timestamp('2017-11-15 23:45:00'):\n            Log('保存数据')\n            df=df.combine_first(df_new)\n            df.to_csv(path+'records15.csv',index=False)\n            break\n        #休眠时间是选择周期\n        Sleep(15*60*1000)"}
{"query": "请生成一个回测系统随机行情生成器策略代码", "base_model_response": "```python\nimport random\nimport string\nfrom Crypto.Random import Crypto\nimport re\n\n# 生成函数\ndef generate_random_weather(city_name, temperature):\n    # 模拟温度波动\n    temp_range = {\n        \"lower\": range(-1500, -3500),\n        \"upper\": range(3500, 4600)\n    }\n    \n    # 随机取一定区间内的天气数据，包括城市名\n    city_data = random.choice(temp_range.keys())\n    \n    # 将天气数据转换为数字格式，以便于计算\n    weather_data = int(city_data.replace(\".\",\".\"))\n    \n    return weather_data\n    \n# 主函数\ndef main():\n    # 设置参数\n    city_name = input(\"Enter city name: \")\n    \n    # 获取天气数据\n    city_data = generate_random_weather(city_name, 20)\n    \n    # 计算平均值和标准差\n    avg_temp = calculate_average气温(city_data)\n    std_dev_temp = calculate_std_dev_temperature(city_data)\n    \n    # 打印结果\n    print(f\"Average weather in {city_name}: {avg_temp}C\")\n    print(f\"Standard deviation of temperature in {city_name}: {std_dev_temp}C\")\n\n    # 函数实现\n    def calculate_average气温(data):\n        # 这里假设数据是标准化的，并且每个单元格的数据都具有相同的单位。如果不同，请替换此函数。\n        \n        total = sum(data.values())\n        mean = total / len(data)\n        var = total - mean\n        \n        return mean\n        \n    def calculate_std_dev_temperature(data):\n        # 这里假设数据是标准化的，并且每个单元格的数据都具有不同的单位。如果不同，请替换此函数。\n        \n        total = sum(data.values())\n        std = math.sqrt(total - mean)\n        variance = sum((x - mean)**2 for x in data)\n        \n        return variance\n        \n    # 主函数调用\nif __name__ == \"__main__\":\n    main()\n```\n\n这个回测系统使用了Python的`random`模块，`string`模块来模拟温度的波动，`Crypto`模块用于安全地存储和处理加密的数据。\n\n在主函数中，我们设置了输入的参数（城市名称和20℃），然后获取并计算了这些城市的天气数据。最后，我们计算了平均温度、标准差和平均值，并打印出了结果。\n\n这个程序可以用来随机生成气候数据，比如雨天、晴天等。通过调整参数（如city_name和temp_range）和更新函数（如calculate_average气温和calculate_std_dev_temperature），你可以创建自己的随机天气系统。", "lora_model_response": "", "original_response": "python\nimport _thread\nimport json\nimport math\nimport csv\nimport random\nimport os\nimport datetime as dt\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse\n\narrTrendType = [\"down\", \"slow_up\", \"sharp_down\", \"sharp_up\", \"narrow_range\", \"wide_range\", \"neutral_random\"]\n\ndef url2Dict(url):\n    query = urlparse(url).query  \n    params = parse_qs(query)  \n    result = {key: params[key][0] for key in params}  \n    return result\n\nclass Provider(BaseHTTPRequestHandler):\n    def do_GET(self):\n        global filePathForCSV, pround, vround, ct\n        try:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"application/json\")\n            self.end_headers()\n\n            dictParam = url2Dict(self.path)\n            Log(\"自定义数据源服务接收到请求，self.path:\", self.path, \"query 参数：\", dictParam)            \n            \n            eid = dictParam[\"eid\"]\n            symbol = dictParam[\"symbol\"]\n            arrCurrency = symbol.split(\".\")[0].split(\"_\")\n            baseCurrency = arrCurrency[0]\n            quoteCurrency = arrCurrency[1]\n            fromTS = int(dictParam[\"from\"]) * int(1000)\n            toTS = int(dictParam[\"to\"]) * int(1000)\n            priceRatio = math.pow(10, int(pround))\n            amountRatio = math.pow(10, int(vround))\n\n            data = {\n                \"detail\": {\n                    \"eid\": eid,\n                    \"symbol\": symbol,\n                    \"alias\": symbol,\n                    \"baseCurrency\": baseCurrency,\n                    \"quoteCurrency\": quoteCurrency,\n                    \"marginCurrency\": quoteCurrency,\n                    \"basePrecision\": vround,\n                    \"quotePrecision\": pround,\n                    \"minQty\": 0.00001,\n                    \"maxQty\": 9000,\n                    \"minNotional\": 5,\n                    \"maxNotional\": 9000000,\n                    \"priceTick\": 10 ** -pround,\n                    \"volumeTick\": 10 ** -vround,\n                    \"marginLevel\": 10,\n                    \"contractType\": ct\n                },\n                \"schema\" : [\"time\", \"open\", \"high\", \"low\", \"close\", \"vol\"],\n                \"data\" : []\n            }\n            \n            listDataSequence = []\n            with open(filePathForCSV, \"r\") as f:\n                reader = csv.reader(f)\n                header = next(reader)\n                headerIsNoneCount = 0\n                if len(header) != len(data[\"schema\"]):\n                    Log(\"CSV文件格式有误，列数不同，请检查！\", \"#FF0000\")\n                    return \n                for ele in header:\n                    for i in range(len(data[\"schema\"])):\n                        if data[\"schema\"][i] == ele or ele == \"\":\n                            if ele == \"\":\n                                headerIsNoneCount += 1\n                            if headerIsNoneCount > 1:\n                                Log(\"CSV文件格式有误，请检查！\", \"#FF0000\")\n                                return \n                            listDataSequence.append(i)\n                            break\n                \n                while True:\n                    record = next(reader, -1)\n                    if record == -1:\n                        break\n                    index = 0\n                    arr = [0, 0, 0, 0, 0, 0]\n                    for ele in record:\n                        arr[listDataSequence[index]] = int(ele) if listDataSequence[index] == 0 else (int(float(ele) * amountRatio) if listDataSequence[index] == 5 else int(float(ele) * priceRatio))\n                        index += 1\n                    data[\"data\"].append(arr)            \n            Log(\"数据data.detail：\", data[\"detail\"], \"响应回测系统请求。\")\n            self.wfile.write(json.dumps(data).encode())\n        except BaseException as e:\n            Log(\"Provider do_GET error, e:\", e)\n        return \n\ndef createServer(host):\n    try:\n        server = HTTPServer(host, Provider)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except BaseException as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\nclass KlineGenerator:\n    def __init__(self, start_time, end_time, interval):\n        self.start_time = dt.datetime.strptime(start_time, \"%Y-%m-%d %H:%M:%S\")\n        self.end_time = dt.datetime.strptime(end_time, \"%Y-%m-%d %H:%M:%S\")\n        self.interval = self._parse_interval(interval)\n        self.timestamps = self._generate_time_series()\n\n    def _parse_interval(self, interval):\n        unit = interval[-1]\n        value = int(interval[:-1])\n\n        if unit == \"m\":\n            return value * 60\n        elif unit == \"h\":\n            return value * 3600\n        elif unit == \"d\":\n            return value * 86400\n        else:\n            raise ValueError(\"不支持的K线周期，请使用 'm', 'h', 或 'd'.\")\n\n    def _generate_time_series(self):\n        timestamps = []\n        current_time = self.start_time\n        while current_time <= self.end_time:\n            timestamps.append(int(current_time.timestamp() * 1000))\n            current_time += dt.timedelta(seconds=self.interval)\n        return timestamps\n\n    def generate(self, initPrice, trend_type=\"neutral\", volatility=1):\n        data = []\n        current_price = initPrice\n        angle = 0\n        for timestamp in self.timestamps:\n            angle_radians = math.radians((angle + random.uniform(0, 360)) % 360)\n            cos_value = math.cos(angle_radians)   #  -1 ~ 1\n\n            if trend_type == \"down\":\n                change = random.uniform(-0.5, 0.4) * volatility * abs(cos_value) \n            elif trend_type == \"slow_up\":\n                change = random.uniform(-0.4, 0.5) * volatility * abs(cos_value) \n            elif trend_type == \"sharp_down\":\n                change = random.uniform(-10, 7) * volatility * abs(cos_value) \n            elif trend_type == \"sharp_up\":\n                change = random.uniform(-7, 10) * volatility * abs(cos_value) \n            elif trend_type == \"narrow_range\":\n                change = random.uniform(-0.2, 0.2) * volatility * abs(cos_value) \n            elif trend_type == \"wide_range\":\n                change = random.uniform(-20, 20) * volatility * abs(cos_value) \n            else:\n                change = random.uniform(-1, 1) * volatility * abs(cos_value) \n            \n            open_price = current_price\n            close_price = open_price + change\n            high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price + random.uniform(0, abs(change))\n            low_price = close_price - random.uniform(0, abs(change)) if open_price > close_price else open_price - random.uniform(0, abs(change))\n\n            if low_price <= 0:\n                change = random.uniform(1, 5) * volatility * abs(cos_value) \n                close_price = open_price + change\n                high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price + random.uniform(0, abs(change))\n                low_price = open_price * random.uniform(0.8, 1)\n\n\n            if (high_price >= open_price and open_price >= close_price and close_price >= low_price) or (high_price >= close_price and close_price >= open_price and open_price >= low_price):\n                pass\n            else:\n                Log(\"异常数据：\", high_price, open_price, low_price, close_price, \"#FF0000\")\n\n            base_volume = random.uniform(1000, 5000)\n            volume = base_volume * (1 + abs(change) * 0.2)\n\n            kline = {\n                \"Time\": timestamp,\n                \"Open\": round(open_price, 2),\n                \"High\": round(high_price, 2),\n                \"Low\": round(low_price, 2),\n                \"Close\": round(close_price, 2),\n                \"Volume\": round(volume, 2),\n            }\n            data.append(kline)\n            current_price = close_price\n            angle += 1\n        return data\n\n    def save_to_csv(self, filename, data):\n        with open(filename, mode=\"w\", newline=\"\") as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow([\"\", \"open\", \"high\", \"low\", \"close\", \"vol\"])\n            for idx, kline in enumerate(data):\n                writer.writerow(\n                    [kline[\"Time\"], kline[\"Open\"], kline[\"High\"], kline[\"Low\"], kline[\"Close\"], kline[\"Volume\"]]\n                )\n        \n        Log(\"当前路径：\", os.getcwd())\n        with open(\"data.csv\", \"r\") as file:\n            lines = file.readlines()\n            if len(lines) > 1:\n                Log(\"文件写入成功，以下是文件内容的一部分：\")\n                Log(\"\".join(lines[:5]))\n            else:\n                Log(\"文件写入失败，文件为空！\")\n\ndef main():\n    Chart({})\n    LogReset(1)\n    \n    try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))\n        Log(\"开启自定义数据源服务线程，数据由CSV文件提供。\", \", 地址/端口：0.0.0.0:9090\", \"#FF0000\")\n    except BaseException as e:\n        Log(\"启动自定义数据源服务失败！\")\n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")\n    \n    while True:\n        cmd = GetCommand()\n        if cmd:\n            if cmd == \"createRecords\":\n                Log(\"生成器参数：\", \"起始时间：\", startTime, \"结束时间：\", endTime, \"K线周期：\", KLinePeriod, \"初始价格：\", firstPrice, \"波动类型：\", arrTrendType[trendType], \"波动性系数：\", ratio)\n                generator = KlineGenerator(\n                    start_time=startTime,\n                    end_time=endTime,\n                    interval=KLinePeriod,\n                )\n                kline_data = generator.generate(firstPrice, trend_type=arrTrendType[trendType], volatility=ratio)\n                generator.save_to_csv(\"data.csv\", kline_data)\n                ext.PlotRecords(kline_data, \"%s_%s\" % (\"records\", KLinePeriod))\n        LogStatus(_D())\n        Sleep(2000)"}
{"query": "请生成一个均仓策略策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2020-04-03 00:00:00\nend: 2021-04-02 23:59:00\nperiod: 1h\nbasePeriod: 15m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\",\"stocks\":0}]\n'''\n\nimport time\nclass juncang_strategy():  \n    def __init__(self,exchange):\n        self.p = 0.5\n        self.account = None\n        self.cny = 0\n        self.btc = 0\n        self.exchange =exchange\n        #以上都是self对象的属性\n\n    def cancelAllOrders(self):\n        orders = _C(self.exchange.GetOrders)\n        for order in orders:\n            exchange.CancelOrder(order['Id'], order)\n        return True\n\n\n    def balanceAccount(self):\n        self.cancelAllOrders()\n\n        kr =  _C(self.exchange.GetRecords,PERIOD_M1)\n        account = _C(self.exchange.GetAccount)\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n\n        #赋值\n        self.btc = account.Stocks+account.FrozenStocks\n        self.cny = account.Balance+account.FrozenBalance\n        \n        accountmoney=self.btc * kr[-1].Close + self.cny\n        self.p = self.btc * kr[-1].Close / accountmoney\n        # Log(self.p)\n        tradenum=accountmoney/kr[-1].Close/100\n        if tradenum<0.001:\n            tradenum=0.001\n        #判断self.p的值是否小于0.48\n        Log(self.p)\n        if (0.45<self.p < 0.49):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #判断self.p的值是否大于0.52\n        elif (0.55 > self.p > 0.51):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            #调用Sell函数并传入相应的参数\n            self.exchange.Sell(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p >= 0.55):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡,快速平仓\", self.p)\n\n            self.exchange.Sell(kr[-1].Close, tradenum*10)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p <= 0.45):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡，快速建仓\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, tradenum*10)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n\n\n\n#函数main\ndef main():\n    #reaper 是构造函数的实例\n    reaper = juncang_strategy(exchange)\n    while (True):\n        #通过实例调用poll方法\n        reaper.balanceAccount()\n        Sleep(1000*10)"}
{"query": "请生成一个均线-趋势_数字货币策略V02策略代码", "base_model_response": "，包含以下功能：\n\n1. 收集数据：接收一系列的期货市场信号，包括开盘价、收盘价、最高价、最低价、时间戳等。\n2. 计算收盘价和最高价的平均数，并显示在图表上。\n3. 分类买入价格：根据历史交易记录进行分类，并计算卖出价格。\n4. 识别异常行为：使用移动平均线和K线来识别可能的异常行为。\n5. 按照日志日期对交易数据进行排序。\n\n以下是实现这些功能的Python代码：\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\nfrom statsmodels.tsa.stattools import maes, smaes, ssim\n\n# 假设你有一个包含每天买卖的订单的历史数据集，每个订单的数据如下：\norders = [' compra', '卖出', '未知']\n\n# 获取当前日期\nnow = datetime.now()\n\n# 将数据集分为三个部分：\ndate_time = pd.date_range(now, orders)\ndates = date_time.index\n\n# 提取开盘价、收盘价和最高价：\norder_data = [orders[i] for i in orders if i in dates]\ndata = pd.DataFrame(order_data)\n\n# 计算收盘价和最高价的平均数：\naverage_values = data.mean()\nprint(\"收盘价: \", average_values)\nprint(\"\\n最高价: \", data.max())\n\n# 按日期进行分类买入和卖出：\nclass Buyer:\n    def __init__(self, start_date):\n        self.start_date = start_date\n        self.data = []\n        self.current_date = now\n\n    def add_order(self, order):\n        if order['type'] == 'buy':\n            self.data.append(order)\n            return self.current_date + datetime.timedelta(days=order[' timeframe'])\n        elif order['type'] == 'sell':\n            self.data.remove(order)\n            return self.current_date - datetime.timedelta(days=order[' timeframe'])\n\n    def get_price(self, current_date):\n        return self.data[current_date]\n\n# 按照日志日期对交易数据进行排序：\nsorted_orders = sorted(data, key=lambda x: x['current_date'], reverse=True)\nprint(\"\\n有序交易数据:\\n\", sorted_orders)\n\n# 分析数据\nmaes_data = maes(sorted_orders)\nprint(\"\\nMAE: \", maes_data)\n\n# 判断趋势：使用移动平均线和K线分析趋势\nsmaes_data = smaes(sorted_orders)\nprint(\"\\nMoving average: \", smaes_data)\nprint(\"\\nK线图:\\n\", smaes_data.plot(kind='bar', title='SMAE')\n\n# 划分购买和卖出区域\n卖家_list = []\n买家_list = []\n\nfor order in sorted_orders:\n    if order['type'] == 'buy':\n       卖家_list.append(order['order_num'])\n        break\n    else:\n       买家_list.append(order['order_num'])\n\n# 绘制趋势线\nplt.figure(figsize=(10,6))\nplt.plot(dates,卖家_list, label=\"卖家\")\nplt.plot(dates, buyers_list, label=\"买家\")\nplt.xlabel('Date')\nplt.ylabel('Volume')\nplt.legend(loc='upper left')\nplt.show()\n```\n\n这段代码首先收集数据，然后计算收盘价和最高价的平均数。接着，它按照日期对交易数据进行分类买入和卖出。最后，它根据日志日期对交易数据进行排序，并分析数据并判断趋势。", "lora_model_response": "", "original_response": "python\n#!/usr/local/bin/python\n#-*- coding: UTF-8 -*-\n#均线/趋势  策略\n#通过判断  在死叉下底后回弹多少买入\n#在金叉上扬至顶后下降多少卖出\n\n\n# FastPeriod=3 #开仓快线周期\n# SlowPeriod=7 #开仓慢线周期\n# EnterPeriod=1       #开仓观察期\n# ExitFastPeriod=3 #平仓线周期\n# ExitSlowPeriod=7 #平仓慢线周期\n# ExitPeriod=2        #平仓观察期\n# PositionRatio=0.5 #仓位比例\n# Interval=10 #轮询周期\n# MAType=0 #均线类型 TA.EMA|TA.MA\n\n\nimport types\narray = [TA.EMA,TA.MA]\n_MACalcMethod = array[MAType]\ndef Cross(a,b):   #计算均线方法\n    crossNum = 0\n    arr1 = []\n    arr2 = []\n    if(type(a) == types.ListType and type(b) == types.ListType):\n        arr1 = a\n        arr2 = b\n    else:\n        records = null\n        while True:\n            records = exchange.GetRecords()\n            if(records and len(records) > a and len(records) > b):\n                break\n            Sleep(Interval)\n        arr1 = _MACalcMethod(records,a)\n        arr2 = _MACalcMethod(records,b)\n    if(len(arr1) != len(arr2)):\n        raise Exception(\"array length not equal\")\n    for i in range(len(arr1) - 1,-1,-1):\n        if((type(arr1[i]) != types.IntType and type(arr1[i]) != types.FloatType) or (type(arr2[i]) != types.IntType and type(arr2[i]) != types.FloatType) ):\n            break\n        if(arr1[i] < arr2[i]):\n            if(crossNum > 0):\n                break\n            crossNum -= 1\n        elif(arr1[i] > arr2[i]):\n            if(crossNum < 0):\n                break\n            crossNum += 1\n        else:\n            break\n    return crossNum\n\nimport datetime\ndef Caltime(date1,date2):\n    try:\n        date1=time.strptime(date1,\"%Y-%m-%d %H:%M:%S\")\n        date2=time.strptime(date2,\"%Y-%m-%d %H:%M:%S\")\n        date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])\n        date2=datetime.datetime(date2[0],date2[1],date2[2],date2[3],date2[4],date2[5])\n        return date2-date1\n    except Exception,ex:\n        Log('except Exception Caltime:',ex)\n        return \"except Exception\"\n\nimport time\nstart_timexx =time.localtime(time.time()) #time.clock()\nstart_time=time.strftime(\"%Y-%m-%d %H:%M:%S\",start_timexx)\nbuy_price=0 #买入价格\nbuy_qty=0  #买入数量\ngains=0  #盈利\n\ndef my_buy(): #开仓\n    try:\n        global buy_price,buy_qty\n        initAccount = ext.GetAccount()  #交易模板的导出函数， 获得账户状态，保存策略运行前账户初始状态\n        opAmount=1\n        #开仓之前判断有币没有没有先进行买入\n        if int(initAccount.Stocks)>1:\n            if buy_price<1:\n                buy_price=_C(exchange.GetTicker).Last\n                buy_qty=initAccount.Stocks\n            Log('开仓信息1 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\n            return 1\n        if int(initAccount.Stocks)<1:\n            if int(str(initAccount.Stocks).replace('0.',''))>=1:\n                if buy_price<1:\n                    buy_price=_C(exchange.GetTicker).Last\n                    buy_qty=initAccount.Stocks\n                Log('开仓信息2 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\n                return 1\n\n        #if int(initAccount.Stocks)<1:\n        if int(str(initAccount.Stocks).replace('0.',''))==0:\n            #opAmount=1\n            opAmount = _N(initAccount.Balance*PositionRatio,3)  #买入数量\n            Log(\"开仓没有币先进行 开仓买入%s元\"%(str(opAmount)))   #生成LOG日志\n        #     else:\n        #         opAmount = _N(initAccount.Stocks * PositionRatio,3)  #获取交易数量\n        # else:\n        #     opAmount = _N(initAccount.Stocks * PositionRatio,3)  #获取交易数量\n        Dict = ext.Buy(opAmount)  #买入ext.Buy\n        if(Dict):#确认开仓成功\n            buy_price=Dict['price'] #买入价格   #{'price': 4046.446, 'amount': 1.5}\n            buy_qty=Dict['amount']  #买入数量\n            print_log(1,initAccount,Dict)\n            return 1\n        return 0\n\n    except Exception,ex:\n        Log('except Exception my_buy:',ex)\n        return 0\n\noutAccount = ext.GetAccount()  #初始化信息\ndef print_log(k_p,Account,Dict):\n    try:\n        global outAccount\n        name=\"\"\n        if k_p:\n            LogProfit(_N(gains,4),'开仓信息 钱:',Account.Balance,'--币:',Account.Stocks,'--开仓详情:',Dict)\n            name=\"开仓\"\n        else:\n            LogProfit(_N(gains,4),'平仓信息 钱:',Account.Balance,'--币:',Account.Stocks,'--平仓详情:',Dict)\n            name=\"平仓\"\n        endAccount = ext.GetAccount()  #初始化信息\n        date1=time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime(time.time()))\n        LogStatus(\"初始化投入2016/9/16  投入资金2000元\\r\\n\",\n                  \"本次初始化状态:\",outAccount,\n                  \"\\r\\n当前运  行状态:\",endAccount,\n                  \"\\r\\n本次开始运行时间:%s  已运行:%s\\r\\n\"%(start_time,Caltime(start_time,date1)),\n                  \"本次盈利:%s\\r\\n\"%(str(gains)),\n                  \"当前状态:%s--钱:%s--币:%s\\r\\n\"%(str(name),str(Account.Balance),str(Account.Stocks)),\n                  \"更新时间:%s\"%(date1)\n                  ) # 测试\n    except Exception,ex:\n        Log('except Exception print_log:',ex)\n\n\ndef my_sell(): #平仓\n    try:\n        global buy_price,buy_qty,gains,start_time\n        nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\n        if _C(exchange.GetTicker).Last>buy_price+4:   #当前价格一定要大于  开仓价格\n            Dict = ext.Sell(nowAccount.Stocks)\n            if(Dict):\n                sell_gains=(Dict['price']-buy_price)*Dict['amount']\n                gains=gains+sell_gains\n                buy_price=0 #买入价格\n                buy_qty=0  #买入数量\n                print_log(0,nowAccount,Dict)\n                return 1\n        return 0\n    except Exception,ex:\n        Log('except Exception my_sell:',ex)\n        return 0\n\ndef main():\n    global outAccount\n    STATE_IDLE = -1  #空闲状态\n    state = STATE_IDLE  #初始化  状态 为 空闲\n\n    Log(\"run  \",outAccount)  #输出初始账户信息\n    SetErrorFilter(\"GetAccount|GetRecords|GetTicker\")  #屏蔽错误内容\n\n    b=0  #开仓\n    b1=0  #检测次数\n    a=0  #平仓\n    a1=0  #检测次数\n    while True:\n        if(state == STATE_IDLE):   #判断状态是否 为空闲 触发开仓\n            #开仓\n            n = Cross(FastPeriod,SlowPeriod) #模板函数获取EMA指标快线、慢线交叉结果\n            if n<0:  #确定当前为死叉\n                b1+=1\n                if b>=int(n): #说明现在还是在下跌涨趋势\n                    b=int(n)\n                else: #开始下跌  开仓\n                    if(int(n)>=int(b)+int(EnterPeriod)):  #确认上行走势 至自己定义的点\n                        if my_buy():  #开仓\n                            b=0\n                            b1=0\n                            state = PD_SHORT\n                            # if(b1>=10):#小波动操作开仓\n                            #     b1=0\n                            #     if my_buy():\n                            #         b=0\n                            #         state = PD_SHORT\n        else:#平仓\n            n = Cross(ExitFastPeriod,ExitSlowPeriod) #模板函数获取EMA指标快线、慢线交叉结果\n            if n>0:  #确定当前为金叉\n                a1+=1\n                if a<=int(n): #说明现在还是在上涨趋势\n                    a=int(n)\n                else: #开始下跌  平仓\n                    if(int(n)<=int(a)-int(ExitPeriod)):  #确认下行走势 至自己定义的点\n                        if my_sell(): #平仓\n                            a=0\n                            a1=0\n                            state = STATE_IDLE   #更改状态  为空闲 触发开仓\n                            # if(a1>=10): #小波动操作平仓\n                            #     a1=0\n                            #     if my_sell():\n                            #         a=0\n                            #         state = STATE_IDLE   #更改状态  为空闲 触发开仓\n        Sleep(Interval * 1000)"}
{"query": "请生成一个均线策略python版策略代码", "base_model_response": "```python\nimport pandas as pd\nfrom matplotlib.pyplot as plt\nfrom numpy import array, sin, cos, exp, log\nfrom sklearn.metrics import mean_squared_error\n\n# 假设这是一个股票数据集，可以使用pandas的read_csv函数读取\ndf = pd.read_csv('stock_data.csv')\n\n# 使用matplotlib和numpy来绘制线图\nplt.plot(df['Close'], df['Close'])\nplt.xlabel('日期')\nplt.ylabel('Close价格')\nplt.title('股票日交易额分布图')\n\n# 绘制平均值（平均日交易额）和标准差（标准差日交易额）\nmean_close = df.mean()\nstd_close = df.std()\n\n# 计算MAE和σE\nmae = mean_close - std_close\nstdae = abs(mean_close - std_close)\n\nprint(f'Mean MAE: {mae:.2f}, Standard deviation MAE: {stdae:.2f}')\n```\n\n这个代码只是一个基础的均线策略，需要根据实际数据进行优化。例如，你可能需要处理更复杂的趋势或更频繁的交易行为；你可能需要考虑更多的输入参数；你可能需要使用更强大的计算库。\n\n注意，这只是一个非常基础的示例，实际情况下可能需要处理更复杂的情况，比如随机变动的市场环境、异常的交易数据等。", "lora_model_response": "```python\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport random\n\ndef get_next():\n    if get_next() == 1:\n        return 0\n    elif get_next() == 2:\n        return 1\n    else:\n        return -1\n    \ndef add_to_board(board, row):\n    i = random.randint(3)\n    j = random.randint(3)\n    if (i == row - 1) and (j == col - 1):\n        board[row][col] = 0\n    elif (i == row + 1) and (j == col):\n        board[row][col] = 0\n    elif (i == row - 1) and (j == col + 1):\n        board[row][col] = 0\n    else:\n        print('Invalid row or column')\n        exit()\n    \ndef add_to_board_max(board, max_row):\n    while True:\n        row_num = random.randint(0, len(board))\n        column_num = random.randint(0, len(board))\n        \n        x = board[row_num].values[0]\n        y = board[column_num].values[0]\n        \n        if x < 0 or y < 0 or x > board.shape[0]:\n            return -1\n        \n        if max_row >= x:\n            max_x = max(x, max_row)\n            \n        if max_y >= y:\n            max_y = max(y, max_y)\n            \n        if x >= 0 and y >= 0 and x <= max_x and y <= max_y:\n            board[row_num][column_num] += 1\n            break\n            \n        time.sleep(0.01)\n    \nadd_to_board(board, -1)\nadd_to_board_max(board, -1)\n\ndef get_next_min():\n    if get_next() == 1:\n        return -1\n    elif get_next() == 2:\n        return 1\n    else:\n        return None\n\ndef get_next_max():\n    if get_next() == 1:\n        return 1\n    elif get_next() == 2:\n        return 3\n    else:\n        return None\n\n\ndef main():\n    start_time = time.time()\n    for _ in range(40000):\n        board = random.rand(3, 6)\n        if is_random Board):\n            get_next_from_board(board)\n        else:\n            add_to_board_max(board, 1)\n        total_time = (time.time() - start_time) * 60\n        print(\"Total: \", total_time, \" sec\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n运行后，会提示你输入下个交易的股票代码。", "original_response": "python\nimport types\ndef main():\n    STATE_IDLE = -1\n    state = STATE_IDLE\n    initAccount = ext.GetAccount()\n    while True:\n        if state == STATE_IDLE :\n            n = ext.Cross(FastPeriod,SlowPeriod) # 指标交叉函数\n            if abs(n) >= EnterPeriod :\n                opAmount = _N(initAccount.Stocks * PositionRatio,3)\n                Dict = ext.Buy(opAmount) if n > 0 else ext.Sell(opAmount)\n                if Dict :\n                    opAmount = Dict['amount']\n                    state = PD_LONG if n > 0 else PD_SHORT\n                    Log(\"开仓详情\",Dict,\"交叉周期\",n)\n        else:\n            n = ext.Cross(ExitFastPeriod,ExitSlowPeriod) # 指标交叉函数\n            if abs(n) >= ExitPeriod and ((state == PD_LONG and n < 0) or (state == PD_SHORT and n > 0)) :\n                nowAccount = ext.GetAccount()\n                Dict2 = ext.Sell(nowAccount.Stocks - initAccount.Stocks) if state == PD_LONG else ext.Buy(initAccount.Stocks - nowAccount.Stocks)\n                state = STATE_IDLE\n                nowAccount = ext.GetAccount()\n                LogProfit(nowAccount.Balance - initAccount.Balance,'钱：',nowAccount.Balance,'币：',nowAccount.Stocks,'平仓详情：',Dict2,'交叉周期：',n)\n        Sleep(Interval * 1000)"}
{"query": "请生成一个基于随机森林的趋势策略策略代码", "base_model_response": "```python\nimport numpy as np\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n# 假设你有一个数据集，其中包含了1000个特征，每个特征都有10个标签\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8],\n               [9, 10], [11, 12], [13, 14], [15, 16]])\ny = np.array([0, 1, 2, 3, 4, 5])\n\n# 创建随机森林模型并训练它\nmodel = RandomForestClassifier(n_estimators=100)\n\n# 使用训练好的模型预测新的数据集上的标签\npredictions = model.predict(X)\n\n# 计算预测的准确率\naccuracy = np.sum(predictions == y)\nprint(\"Accuracy: \", accuracy)\n```\n\n这个代码首先导入了所需的库，包括numpy、scikit-learn和matplotlib。然后，它定义了一个数据集X和一个对应的标签y。接着，它创建了一个随机森林模型，并使用该模型进行预测。最后，它计算了预测的准确性。\n\n请注意，这只是一个基本的例子，实际的情况可能需要更复杂的逻辑来处理数据和优化模型。在实际的应用中，你可能还需要考虑更多的因素，例如噪声、异常值、模型的复杂性等。", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2019-02-09 00:00:00\nend: 2019-03-11 00:00:00\nperiod: 1h\nbasePeriod: 15m\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport itertools\nfrom collections import deque\n\nimport numpy as np\nfrom sklearn.ensemble import RandomForestClassifier\n\ndef main():\n    initAccount = _C(exchange.GetAccount)\n    position = 0\n    classifier = RandomForestClassifier()\n    win_len = 8\n    input = deque(maxlen=300)\n    output = deque(maxlen=300)\n    recent_prices = deque(maxlen=win_len + 2)\n    interval = 3600000 # 一小时采样一次\n    \n    while True:\n        ticker = _C(exchange.GetTicker)\n        recent_prices.append(ticker.Last)\n        \n        if len(recent_prices) > 0:\n            Sleep(interval)\n            \n        if len(recent_prices) < recent_prices.maxlen:\n            continue\n        # 计算波动率\n        price_list = list(itertools.islice(recent_prices, 0, recent_prices.maxlen - 1))\n        volt_list = np.divide(np.diff(recent_prices), price_list)\n        # 根据波动范围，将其分类标记为: 上涨(>+0.5%)、下跌(<-0.5%)、平稳(-0.5%~+0.5%)\n        trend_list = []\n        for volt in volt_list:\n            if 0.005 > volt > -0.005:\n                trend_list.append(0)\n            elif volt >= 0.005:\n                trend_list.append(1)\n            else:\n                trend_list.append(-1)\n\n        # 添加波动数据到训练集\n        input.append(trend_list[:-1])\n        output.append(trend_list[-1])\n\n        # 当训练集个数包含 200 组数据时，认为可以拟合随机森林\n        if len(input) < 200:\n            continue\n        classifier.fit(input, output)            # 拟合\n        prediction = classifier.predict([trend_list[1:]])  # 预测\n        if position == 0:\n            if prediction == 1:\n                exchange.Buy(-1, _C(exchange.GetAccount).Balance)\n                position = 1\n        else:\n            if prediction == -1:\n                exchange.Sell(-1, _C(exchange.GetAccount).Stocks - initAccount.Stocks)\n                position = 0"}
{"query": "请生成一个基础网格交易策略策略代码", "base_model_response": "", "lora_model_response": "```python\ndef mygrid():\n    try:\n        g = nx.greedy_grid(16, 3)\n        print(g)\n    except Exception as e:\n        print(str(e))\n```\n\n在本例中，我将使用Pandas库中的`greedy_grid()`函数来计算网格（实际的大小可能比这个值更小）。然后，我将在控制台打印出结果。\n\n请注意，本示例假设数据分布在3x3的格子里。如果数据分布更复杂，请根据需要调整网格参数。", "original_response": "python\n'''backtest\nstart: 2021-08-01 00:00:00\nend: 2021-09-01 00:00:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\",\"balance\":1000000,\"stocks\":0,\"fee\":[0.06,0.075]}]\nargs: [[\"lower_price\",30000],[\"upper_price\",50000],[\"grid_num\",200],[\"trading_per_grid\",0.1]]\n'''\n\ngrid = dict()\ninterval = 0\n\n\nclass GridItem:\n    def __init__(self, order_id, status, price):\n        self.order_id = order_id\n        self.status = status  # -1：此点为空白点; -2：此点未下过单\n        self.side = 0  # 1：买入；2：卖出；0：未知\n        self.price = price\n\n\ndef create_grid(ticker_price):\n    global grid\n    global interval\n\n    exchange.SetCurrency(trading_pair)\n    exchange.SetPrecision(price_precision, amount_precision)\n\n    interval = _N((upper_price - lower_price) / grid_num, price_precision)\n    \n    grid[lower_price] = GridItem(-1, -2, lower_price)\n    grid[upper_price] = GridItem(-1, -2, upper_price)\n    for i in range(1, grid_num):\n        price = lower_price + interval * i\n        grid[price] = GridItem(-1, -2, price)\n        \n    buy_stocks = (grid_num - int((ticker_price - lower_price) / interval) - 1) * trading_per_grid\n    buy_2_sell(buy_stocks)\n    \n    \ndef buy_2_sell(buy_stocks):\n    while True:\n        account = exchange.GetAccount()\n        stocks = _N(account['Stocks'], amount_precision)\n        if stocks < buy_stocks:\n            depth = exchange.GetDepth()\n            price = depth['Asks'][0]['Price']\n            vol = _N(price * trading_per_grid, price_precision)\n            min_vol = 1.0 / (10 ** price_precision)\n            exchange.Buy(-1, vol if vol > min_vol else min_vol)\n        else:\n            break\n        Sleep(1000)\n\n\ndef set_blank(price):\n    grid[price].order_id = -1\n    grid[price].status = -1\n    grid[price].side = 0\n\n\ndef update_order():\n    last_blank_price = -1\n    close_price_list = set()\n\n    for grid_item in grid.values():\n        if grid_item.status == -1:\n            last_blank_price = grid_item.price\n        elif grid_item.status == -2:\n            close_price_list.add(grid_item.price)\n        else:\n            order = exchange.GetOrder(grid_item.order_id)\n            grid_item.status = order[\"Status\"]\n            if grid_item.status == 1:\n                close_price_list.add(grid_item.price)\n    return close_price_list, last_blank_price\n\n\ndef remove_blank(close_price_list, last_blank_price):\n    if last_blank_price != -1:\n        close_price_list.discard(last_blank_price)\n\n\ndef set_left_blank(close_price_list, left_side_grid, last_blank_price):\n    set_blank(left_side_grid)\n    close_price_list.discard(left_side_grid)\n    if last_blank_price != -1:\n        close_price_list.add(last_blank_price)\n    \n    \ndef set_right_blank(close_price_list, right_side_grid, last_blank_price):\n    set_blank(right_side_grid)\n    close_price_list.discard(right_side_grid)\n    if last_blank_price != -1:\n        close_price_list.add(last_blank_price)\n\n\ndef trace():\n    close_price_list, last_blank_price = update_order()\n    \n    has_buy_order = False\n    for price in close_price_list:\n        if grid[price].side == 1:\n            has_buy_order = True\n            break\n    \n    if has_buy_order:\n        ticker_price = min(close_price_list) - interval / 2.0\n    else:\n        ticker = exchange.GetTicker()\n        ticker_price = ticker['Last']\n    \n    if not grid:\n        create_grid(ticker_price)\n\n    left_side_grid = int((ticker_price - lower_price) / interval) * interval + lower_price\n    right_side_grid = left_side_grid + interval\n\n    # 设置空白点\n    # 当前价格左侧未成交，当前价格右侧未成交，不存在\n    # 当前价格左侧空白点，当前价格右侧空白点，不存在\n    # 左侧和右侧任何一个为空白点，不需要更新空白点\n    if left_side_grid >= upper_price or right_side_grid <= lower_price:\n        # 在区间外，不需要空白点\n        remove_blank(close_price_list, last_blank_price)\n    elif grid[left_side_grid].status == 0 and grid[right_side_grid].status == 1:\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 0:\n        set_left_blank(close_price_list, left_side_grid, last_blank_price)\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 1:\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\n    elif grid[left_side_grid].status == -2 and grid[right_side_grid].status == -2:\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\n\n    # 重新下单\n    for price in close_price_list:            \n        if price <= ticker_price:\n            order_id = exchange.Buy(price, trading_per_grid)\n            side = 1\n        else:\n            buy_2_sell(trading_per_grid)\n            order_id = exchange.Sell(price, trading_per_grid)\n            side = 2\n\n        if order_id:\n            grid[price].order_id = order_id\n            grid[price].status = 0\n            grid[price].side = side\n\n\ndef main():\n    while True:\n        trace()\n        Sleep(1000)"}
{"query": "请生成一个复杂看盘图表测试版策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n\n'''backtest\nstart: 2020-03-11 00:00:00\nend: 2020-04-09 23:59:00\nperiod: 1d\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\"}]\n'''\nimport pandas as pd\nimport numpy as np\nimport re\npreBarTime_1=0\n'''\nshortChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\",  #single不参于分组，单独显示, 默认为分组 'group'\n        \"height\" : 300, \n    },\n    \"title\" : {\"text\": 'rb888' + '__15M交易信号图'},\n    \"xAxis\" : {\"type\" : \"datetime\"}, # 时间序列轴\n    \"yAxis\" : [{\"labels\": {\n        \"align\": 'right',\n        \"x\": -3\n    },\n                \"title\": {\n                    \"text\": '盘口'\n                },\n                \"height\": \"45%\",  # 相对宽度大小\n                \"resize\": {\n                    \"enabled\": True  # 是否启用重置宽度  \n                },\n                \"opposite\": True,  # 是否将轴显示在对面 默认左\n                \"offset\": 0,  # 坐标轴偏移 正右 负左\n                \"lineWidth\": 2  # 线宽\n               }, {\"labels\": {\n        \"align\": 'right',\n        \"x\": -3\n    },\n                   \"title\": {\n                       \"text\": 'RSI'\n                   },\n                   \"top\": '45%',\n                   \"height\": '25%',\n                   \"opposite\": True,\n                   \"offset\": 0,\n                   \"lineWidth\": 2\n                  }, {\"labels\": {\n        \"align\": 'right',\n        \"x\": -3\n    },\n                      \"title\": {\n                          \"text\": 'MACD_5'\n                      },\n                      \"top\": '70%',\n                      \"height\": '30%',\n                      \"opposite\": True,\n                      \"offset\": 0,\n                      \"lineWidth\": 2\n                     }    \n              ],\n    \"tooltip\":{\n        \"split\": False,  # 原生js？？\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\"\n    },\n    \"series\" : [{'type': 'candlestick',\n                 'name': 'k线',\n                 #'color': 'green',\n                 #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\n                 #'upColor': 'red',\n                 #'upLineColor': 'red',\n                 \"data\" : [],\n                }, {\n            \"type\" : \"line\",\n            \"name\" : \"rsi\",\n            \"data\" : [],\n            \"yAxis\": 1  # 相对位置\n        }\n        , {\n            \"type\" : \"line\",\n            \"name\" : \"diff\",\n            \"data\" : [],\n            \"yAxis\": 2  # 相对位置\n        }, {\n            \"type\" : \"line\",\n            \"name\" : \"dea\",\n            \"data\" : [],\n            \"yAxis\": 2  # 相对位置\n        }, {\n            \"type\" : \"column\",\n            \"name\" : \"macd\",\n            \"data\" : [],\n            \"yAxis\": 2  # 相对位置\n        }\n    ]\n}\n'''\n\"\"\"\nshortChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"single\",  #single不参于分组，单独显示, 默认为分组 'group'\n        \"height\" : 300, \n    },\n    \"title\" : {\"text\": 'rb888' + '__15M交易信号图'},\n    \"xAxis\" : {\"type\" : \"datetime\"}, # 时间序列轴\n    \"yAxis\" : {\"labels\": {\n                    \"align\": 'right',\n                    \"x\": -3\n                },\n                \"title\": {\n                    \"text\": '盘口'\n                },\n                #\"height\": \"45%\",  # 相对宽度大小\n                #\"resize\": {\n                #    \"enabled\": True  # 是否启用重置宽度  \n                \"opposite\": True,  # 是否将轴显示在对面 默认左\n                \"offset\": 0,  # 坐标轴偏移 正右 负左\n                \"lineWidth\": 2  # 线宽\n    },\n    \"tooltip\" : {\n        \"split\": false,  # 原生js？？\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\"\n    },\n    \"series\" : {'type': 'candlestick',\n                'name': 'k线',\n                #'color': 'green',\n                #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\n                #'upColor': 'red',\n                #'upLineColor': 'red',\n                \"data\" : [],\n            }\n}\n\"\"\"\nshortChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n    \"layout\" : \"single\",  #single不参于分组，单独显示, 默认为分组 'group'\n    #\"height\" : 500, \n    },\n    'legend': {\n        'enabled': true  # 图例 true开启\n    },\n    'title' : {\n        'text' : '柱形K线'\n    },\n    \"xAxis\" : {\n        \"type\" : \"datetime\",\n        #'dashStyle': 'dash'  # 准心线样式 虚线\n    }, # 时间序列轴\n    'yAxis' : [{\n        'labels':{\n            'align':'right',\n            'x':-3\n        },\n        'height':\"40%\",\n        'lineWidth':2,\n        #'crosshair': true,  # 准心线\n        'resize':{\n            'enabled':true\n        }\n    },{\n        'labels':{\n            'align':'right',\n            'x':-3\n        },\n        'title':{\n            'text' : 'Volume'\n        },\n        'top':'40%',\n        'height':'15%',\n        'offset':0,\n        #'crosshair': true,\n        'lineWidth':2\n    },{\"labels\": {\n            \"align\": 'right',\n            \"x\":-3\n        },\n        \"title\": {\n            \"text\": 'RSI'\n        },\n        \"top\": '55%',\n        \"height\": '20%',\n        \"opposite\": True,\n        \"offset\": 0,\n        #'crosshair': true,\n        \"lineWidth\": 2,\n        'plotLines': [{\n                'value': 75,  # 值大小\n                'color': 'green',  # 颜色\n                'dashStyle': 'shortdash', # 线条样式\n                'width': 0.5,\n                #'label': {\n                #    'text': '多头止盈线'\n                #}\n        },{\n                'value': 25,\n                'color': 'red',\n                'dashStyle': 'shortdash',\n                'width': 0.5,\n                #'label': {\n                #    'text': '空头止盈线'\n                #}\n        }\n        ]\n    }, {\"labels\": {\n            \"align\": 'right',\n            \"x\":-3\n    },\n        \"title\": {\n            \"text\": 'MACD'\n        },\n        \"top\": '75%',\n        \"height\": '25%',\n        \"opposite\": True,\n        \"offset\": 0,\n        \"lineWidth\": 2\n    }\n    ],\n    'tooltip':{\n        #'shared': true,  # 是否开启提示标签共享,多图下效果基本等同split\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\",\n        'shared': true,\n\t\t'crosshairs': true,\n        'valueDecimals':2, # 保留小数\n        #'split':true, # 提示框分开\n        #'distance': 30,\n\t\t#'padding': 5\n        #'positioner': {\n        #    'x':150,\n        #    'y':150\n        #},\n        #'shadow': false,\n        #'borderWidth': 0,\n        #'backgroundColor': 'rgba(255,255,255,0.8)'\n    },\n    'series':[{\n        'type':'candlestick',\n        'animationLimit':'Infinity',\n        'color': 'green',\n        'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\n        'upColor': 'red',\n        'upLineColor': 'red',\n        'name':'appl',\n        'data':[]\n    },{\n        'type':'column',\n        'name':'Volume',\n        'data':[],\n        'yAxis':1\n    },{\n        \"type\" : \"line\",\n        \"name\" : \"rsi\",\n        \"data\" : [],\n        \"yAxis\": 2  # 相对位置\n    },{\n        \"type\" : \"line\",\n        \"name\" : \"diff\",\n        \"data\" : [],\n        \"yAxis\": 3  # 相对位置\n    },{\n        \"type\" : \"line\",\n        \"name\" : \"dea\",\n        \"data\" : [],\n        \"yAxis\": 3  # 相对位置\n    },{\n        \"type\" : \"column\",\n        \"name\" : \"macd\",\n        \"data\" : [],\n        'maxPointWidth':2,  # 量柱最大宽度\n        \"yAxis\": 3  # 相对位置\n    }\n\n    ]\n}\n    \n\nlongChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n    'rangeSelector':{\n        'selected' : 0 \n    },\n    'chart': {  # 主配置项\n        #'height': 630,  # 高度，平台不支持配置\n        'type': 'line',\n        'zoomType': 'x',  # 缩放\n        #'selectionMarkerFill':'rgba(51,92,223,0.25)',  # 缩放框背景色\n        #'panning': true,  # 开启平移\n        #'panKey': 'shift'  # 平移\n        'borderColor': '#EBBA95', # 外框配置项\n        'borderWidth': 2,  ##\n        'borderRadius': 10, ##\n    },\n    \"rangeSelector\" : {\n        \"buttons\" : [{\n            \"type\" : \"hour\",\n            \"count\" : 1,\n            \"text\" : \"1h\",\n        }, {\n            \"type\" : 'hour',\n            \"count\" : 3,\n            \"text\" : \"3h\"\n        }, {\n            \"type\" : \"day\",\n            \"count\" : 1,\n            \"text\" : \"1d\"\n        }, {\n            \"type\" : \"week\",\n            \"count\" : 1,\n            \"text\" : \"1w\"\n        }, {\n            \"type\" : \"year\",\n            \"count\" : 1,\n            \"text\" : \"1Y\"\n        }, {\n            \"type\" : \"all\",\n            \"text\" : \"All\"\n        }],\n        \"selected\" : 1,\n        \"inputEnabled\" : True\n    },\n    'legend': {\n        'enabled': true  # 图例 true开启\n    },\n    'title' : {\n        'text' : '15'\n    },\n    'subtitle': {\n        'text': '湘水看盘图表',  #'当前价格:'+str(records_5[-1]['Close'] if records_5[-1]['Close'] is not None else **)+' || '+'当前时间:'+str(Time_5 if Time_5 is not None else **)\n    },\n    \"xAxis\" : {\n        \"type\" : \"datetime\",\n        #'dashStyle': 'dash'  # 准心线样式 虚线\n    }, # 时间序列轴\n    \"xAxis\" : {\"type\" : \"datetime\"},\n    \"yAxis\" : [{\n            \"title\": {\n                \"text\": 'Kline'\n            },\n            \"height\": \"60%\",  # 相对宽度大小\n            \"offset\": 0,  # 坐标轴偏移 正右 负左\n            \"lineWidth\": 2  # 线宽\n        },{\n            \"title\": {\n                \"text\": 'MACD'\n            },\n            \"top\": '62%',\n            \"height\": '38%',\n            \"offset\": 0,\n            \"lineWidth\": 2\n        }    \n    ],\n    \"series\" : [\n        {\n            \"type\" : \"candlestick\", \n            \"name\" : \"k_15\",\n            \"id\" : \"k\",\n            \"data\" : [],\n            \"yAxis\": 0  # 相对位置\n        },{\n            \"type\" : \"column\",\n            \"name\" : \"macd_15\",\n            \"data\" : [],  \n            \"yAxis\": 1  # 相对位置\n        }\n    ]\n}\n\nchart0 = {                                        \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n\n    'title' : { 'text' : '日K线图'},                       \n    'xAxis': { 'type': 'datetime'},            \n    'series' : [                                          \n        {                                      \n            'type': 'candlestick',                         \n            'name': 'r',   \n            'id': 'r',                                     \n            'data': []                                           \n        }, {                                      \n            'type': 'column',           \n            'name': 'vol',          \n            'data': [],               \n        }\n    ]\n}\n\nchart1 = {  \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n                                      \n    'title' : { 'text' : 'ris'},                       \n    'xAxis': { 'type': 'datetime'},                       \n    'yAxis' : {                                           \n            'title': {'text': 'rsi'},                           \n            'opposite': false                                 \n    },\n    'series' :                                      \n        { \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'rsi',\n            'data': []\n    },\n}\n\n\nchart2 = {  \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n                                      \n    'title' : { 'text' : 'macd'},                       \n    'xAxis': { 'type': 'datetime'},                       \n    'yAxis' : {                                           \n            'title': {'text': 'macd'},                           \n            'opposite': false                                 \n    },\n    'series' :  [           \n        { \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'dif',\n            'data': []\n    },{ \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'eda',\n            'data': []\n    },{ \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'macd',\n            'data': []\n    },\n    ]\n}\n\n\nhart1 = {                                        \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n\n    'title' : { 'text' : 'MACD_5'},                       \n    'xAxis': { 'type': 'datetime'},             \n    'series' : [                                          \n        {                                      \n            'type': 'candlestick',                             \n            'name': 'k',   \n            'id': 'r1',                                     \n            'data': []                                           \n        }, {                                      \n            'type': 'column',           \n            'name': 'macd_15',          \n            'data': [],               \n        }\n    ]\n}\n\n\n\n\nmacd_15 = []\nrunTime = {}\nrunTime['preBarTime_1'] = [0,0]\nrunTime['arrKIndex'] = []\n_5_lengh = 50\n_15_lengh = 50\ndef ticks_(records, k):\n    if len(records) == 0:\n        return []\n    if isinstance(records[0], int) or isinstance(records[0], float):\n        return records\n\n    ticks = [None] * len(records)\n    for i in range(len(records)):\n        ticks[i] = records[i][k]\n        return ticks\n\n\ndef plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart):\n    for x,symbol in enumerate(arr):\n        #Log(symbol,_D(),)\n        runTime['arrKIndex'] = [index_2[x],index_2[x]+7]   # [0,7] [8,15]\n        #Log(symbol)\n        exchange.SetContractType(symbol)\n        #Log(symbol,_D())\n        records_5 = _C(exchange.GetRecords,PERIOD_M5)  # 返回列表型字典\n        records_15 = _C(exchange.GetRecords,PERIOD_M15)\n        r = records_5\n        m = records_15\n        Time_5 = records_5[-1]['Time']\n        Time_5_list = pd.Series(ticks_(records_5,'Time'))  # 小周期开盘时间数组\n        #Open_5 = records_5['Open']\n        #High_5 = records_5['High']\n        #Low_5 = records_5['Low']\n        Close_5 = pd.Series(ticks_(records_5,'Close'))  # 小周期收盘价数组\n\n        Time_15 = records_15[-1]['Time']\n        Time_15_list = pd.Series(ticks_(records_15,'Time'))  # 小周期开盘时间数组\n        #Open_5 = records_5['Open']\n        #High_5 = records_5['High']\n        #Low_5 = records_5['Low']\n        Close_15 = pd.Series(ticks_(records_15,'Close'))  # 小周期收盘价数组\n\n        #Log(2)\n        '''\n        nowdea_15 = dea_15[-1]\n        nowdiff_15 = diff_15[-1]\n        nowmacd_15 = macd_15[-1]\n        '''\n\n        '''\n        predea_15 = dea_15[-2]\n        prediff_15 = diff_15[-2]\n        premacd_15 = macd_15[-2]\n        '''\n        #index_1 += 5\n        if not r or not m:\n            return\n        #Log(3,len(r))\n\n        if len(r) < _5_lengh:  # 过滤K线过短情况\n            return\n\n        #Log(4)\n        Macd_5 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\n        diff_5 = Macd_5[0]\n        dea_5 = Macd_5[1]\n        macd_5 = pd.Series(Macd_5[2]).fillna(0)\n        macd_5 = macd_5.values*2  # TA的macd算法未乘以2\n\n        Macd_15 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\n        diff_15 = Macd_15[0]\n        dea_15 = Macd_15[1]\n        macd_15 = pd.Series(Macd_15[2]).fillna(0)\n        macd_15 = macd_15.values*2  # TA的macd算法未乘以2\n\n        RSI = TA.RSI(records_5, period = rsi_period)\n        nowdea_5 = dea_5[-1]\n        nowdiff_5 = diff_5[-1]\n        nowmacd_5 = macd_5[-1]\n        if len(macd_15) > 2:\n            nowmacd_15 = macd_15[-1]\n        nowrsi = RSI[-1]\n        \n        predea_5 = dea_5[-2]\n        prediff_5 = diff_5[-2]\n        premacd_5 = macd_5[-2]\n        if len(macd_15) > 2:\n            premacd_15 = macd_15[-2]\n        prersi = RSI[-2]\n        #Log('K线长度',len(r),'dea_5',len(dea_5),'rsi',len(RSI),preBarTime_1)\n            \n            \n\n        if len(macd_15)>0:        \n            #Log(time.strftime(\"%Y-%m-%d %H:%M:%S\",  time.localtime(int(records_5[-1]['Time'])/1000)),_D(),macd_15[-1])\n            pass\n        \n        #r = records_5\n        #m = records_15\n        arr_ = [r,m]        \n\n        #Log(index_2)\n        index_2 = index_2.copy()\n        #index_2 = index_2.tolist()\n        for i in range(len(arr_)):  # i 是k线周期循环\n\n            #Log(runTime['arrKIndex'])\n            for j in range(len(arr_[i])):  # 时间周期循环\n                #Log(arr_[i][j][\"Time\"],runTime['preBarTime_1'][i])\n                if arr_[i][j][\"Time\"] == runTime['preBarTime_1'][i]:  # preBarTime初始为0\n                    if i == 0:  #5分钟 #index_2 0 8\n                        chart.add(int(index_2[x]), [arr_[i][j][\"Time\"], arr_[i][j][\"Open\"], arr_[i][j][\"High\"], arr_[i][j][\"Low\"], arr_[i][j][\"Close\"]], -1)  # 选出不同周期K线的index\n                        #Log(1,int(index_2[i]))\n                    if i == 0 and len(arr_[i]) > _5_lengh:\n                        #Log(2)\n                        if j == len(arr_[i]) - 2:\n                            #Log(3)\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\"Time\"], arr_[i][j][\"Volume\"]],-1)  \n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\"Time\"], prersi], -1)    # 快线\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\"Time\"], prediff_5], -1)    # 慢线\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\"Time\"], predea_5], -1)\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\"Time\"], premacd_5], -1)\n                        elif j == len(arr_[i]) - 1:\n                            #Log(4,int(index_2[i]))\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\"Time\"], arr_[i][j][\"Volume\"]],-1)  \n                            #Log(4.1)\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\"Time\"], nowrsi], -1)    # 快线\n                            #Log(4.2)\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\"Time\"], nowdiff_5], -1)    # 慢线\n                            #Log(4.3)\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\"Time\"], nowdea_5], -1)\n                            #Log(4.4)\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\"Time\"], nowmacd_5], -1)\n                            #Log(4.5)\n                    '''\n                    if i == 1 and len(arr_[i]) > _15_lengh:\n                        if j == len(arr_[i]) - 2:\n                            chart.add(index_2 + 8, [arr_[i][j][\"Time\"], premacd_15], -1)    # 快线\n                        elif j == len(arr_[i]) - 2:\n                            chart.add(index_2 + 8, [arr_[i][j][\"Time\"], nowmacd_15], -1)    # 快线\n                    '''\n                elif arr_[i][j][\"Time\"] > runTime['preBarTime_1'][i]:  # 初始运行此处  每个5，15分钟运行两次\n                    \n                    if i ==1:\n                        pass\n                        \n                        #Log(time.strftime(\"%Y-%m-%d %H:%M:%S\",  time.localtime(int(arr_[i][j][\"Time\"])/1000)),time.strftime(\"%Y-%m-%d %H:%M:%S\",  time.localtime(int(runTime['preBarTime_1'][i])/1000)),'//',i)\n                    runTime['preBarTime_1'][i] = arr_[i][j][\"Time\"]  # K线时间赋值给preBarTime\n                    Log(runTime['preBarTime_1'][0],runTime['preBarTime_1'][1])\n                    # 0 7 8 15\n                    chart.add(int(runTime['arrKIndex'][x]), [arr_[i][j][\"Time\"], arr_[i][j][\"Open\"], arr_[i][j][\"High\"], arr_[i][j][\"Low\"], arr_[i][j][\"Close\"]])\n                    if i ==0 and len(arr_[i]) > _5_lengh:\n                        #Log('i=0',int(runTime['arrKIndex'][x]))\n                        if j == len(arr_[i]) - 1:\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\"Time\"], arr_[i][j][\"Volume\"]])\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\"Time\"], nowrsi])\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\"Time\"], nowdiff_5])\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\"Time\"], nowdea_5])\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\"Time\"], nowmacd_5])\n                    \n                    if i == 1 and len(arr_[i]) > _15_lengh:\n                        Log('i=1',int(index_2[x]) + 7)\n                        if j == len(arr_[i]) - 1:\n                            chart.add(int(index_2[x]) + 7, [arr_[i][j][\"Time\"], nowmacd_5])\n\ndef main():\n    \"\"\"\n    \"\"\"\n    global preBarTime_1,macd_15,runTime,_5_lengh,_15_lengh,shortChart,longChart,chart0,chart1,chart2,hart1\n    if exchange.GetName().find(\"CTP\") == -1:\n        raise Exception(\"只支持商品期货CTP\")\n    SetErrorFilter(\"login|ready|流控|连接失败|初始|Timeout\")\n    mode = exchange.IO(\"mode\", 0)\n    if mode is None:\n        raise Exception(\"切换模式失败，请更新到最新托管者！\")\n    while not exchange.IO(\"status\"):\n        Sleep(3000)\n        LogStatus(\"正在等待与交易服务器连接，\" + _D())\n    positions = _C(exchange.GetPosition)  # 获取当前持仓信息字典\n    if len(positions) > 0:\n        Log(\"检测到当前持有仓位，系统将开始尝试恢复进度...\")\n        Log(\"持仓信息：\", positions)\n\n\n    tts = []  # \n    arrChart_1 = []  # 图表数组\n    arrChart_2 = []\n    index_ = 0  # \n    index_2 = []\n    arrKIndex = []\n    a = []\n    b = []\n    c = []\n    d = []\n\n    #while True:\n    #Log(1)\n    symbolFilter = {}  # 过滤用数组\n    arr = Instruments.split(\",\")  # 合约列表\n    for i in range(len(arr)):  # 遍历合约列表\n        symbol = re.sub(r'/\\s+$/g', \"\", re.sub(r'/^\\s+/g', \"\", arr[i]))  # 规整合约字符串\n        if symbol in symbolFilter.keys():  # 如果 在过滤数组中 存在 名为 symbol的属性，则显示信息 并跳过。\n            raise Exception(symbol + \"已经存在，请检查参数！\")\n        symbolFilter[symbol] = True  # 给过滤数组 添加 名为 symbol 的 keys，下次 同样的 合约代码 会被过滤 保证每个合约只对Manager类方法传入一次参数\n        hasPosition = False  # 初始化 hasPosition 变量 false 代表没有持仓 \n        for j in range(len(positions)):  # 遍历 获取到的持仓信息\n            if positions[j][\"ContractType\"] == symbol:  # 如果持仓中有合约名等于symbol\n                Log('cc')\n                hasPosition = True  # 标记 True 持仓\n                break  # 跳出\n        #fastPeriod = int(arrFastPeriod[i])  # 规整为数值型\n        #slowPeriod = int(arrSlowPeriod[i])\n        Log(123)\n        obj_1 = shortChart #  实例化Manager类\n        obj_2 = longChart\n        index_2.append(index_)  # 0 8\n        index_ += 8 # 长周期的图表index\n        \n        #tts.append(obj)  # tts列表传入 最终根据合约列表 ，生成了若干个品种的 控制对象储存在tts数组 \n        #Log(obj)\n        arrChart_1.append(obj_1)   # 在for循环中 依次把图表信息字典传入图表数组\n        #arrChart_2.append(obj_2)\n        a.append(chart0)\n        b.append(chart1)\n        c.append(chart2)\n        d.append(hart1)\n        Log(len(arrChart_1))\n        Log(111 if arrChart_1[0]==shortChart else 000)\n        #arrChart_2.append(obj.longChart)\n    # 创建图表对象\n    #chart = Chart([arrChart_1, arrChart_2])  # __isStock\" : True表示是highstock图，False表示是highcharts图 使用多图表对象，转为二维数组\n    #chart = Chart([arrChart_1,arrChart_2])\n    chart = Chart([a,b,c,d])\n    #Log(len(arrChart_1),len(arrChart_2))\n    index_2 = np.array(index_2)\n    chart.reset()  # 清空上次轮询的图表数据\n\n    while True:\n        #c = Chart(shortChart)\n        preTicker = None\n        #while True:\n        #Log(1)\n        if exchange.IO('status'):\n            LogStatus(_D(),'已经连接')\n            #t = exchange.GetTicker()\n            plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart)\n        Sleep(1000)                      \n        ''' \n        if i ==0:\n            if signals['buy_sell_sig'+str(trueSymbol)] ==1:\n                Log(1)\n                #ext.PlotFlag(r[-2]['Time'],'开多','L','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'L','text':'开多'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n            if signals['buy_sell_sig'+str(trueSymbol)] ==2:\n                Log(2)\n                #ext.PlotFlag(r[-2]['Time'],'开空','S','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'S','text':'开空'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n            if signals['buy_sell_sig'+str(trueSymbol)] ==3:\n                Log(3)\n                #ext.PlotFlag(r[-2]['Time'],'平多','UL','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'UL','text':'平多'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n            if signals['buy_sell_sig'+str(trueSymbol)] ==4:\n                Log(4)\n                #ext.PlotFlag(r[-2]['Time'],'平空','US','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'US','text':'平空'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n\n        '''\n\n                    #index_1 += 9  # 短周期的图表index"}
{"query": "请生成一个定投策略策略代码", "base_model_response": "，其中包含5个投资工具：股票、债券、商品等\n\n```python\nimport pandas as pd\n\nclass StockStrategy:\n    def __init__(self):\n        self.products = [\"AAPL\", \"GOOG\"]\n        self.bonds = [\"MTC\", \"BABA\"]\n        self.cryptocurrencies = [\"RUB\", \"ETH\"]\n\n    def add_investments(self, product):\n        df = pd.DataFrame({\n            \"Product\": product,\n            \"Date\": pd.to_datetime(f\"{self.product}.{self.Date}\")\n        })\n        self products.append(df)\n\n    def calculate_return(self, date):\n        df = pd.DataFrame的历史 returns)\n        return df[\"Return\"].sum()\n\n# Create an instance of the stock strategy class\nstock_strategy = StockStrategy()\n\n# Add some investments to the portfolio using a mix of stocks and bonds\nstock_strategy.add_investments(\"Apple\")\nstock_strategy.add_investments(\"Google\")\n\n# Calculate the percentage returned for the end date (in 2023 based on current market conditions)\nreturn_date = pd.to_datetime('2023-06-30')\nfor date in self.calculate_return(date):\n    print(date.strftime('%Y-%m-%d'))  # Output: 2023-06-30\n\n# Close the portfolio\nstock_strategy.close()\n```\n\n这个 `StockStrategy` 类定义了三个投资工具：股票、债券和商品。每个工具都有自己的历史表现和相应的收益率指标。当添加新的投资到 Portfolio后，它会自动计算并返回投资的百分比回报。\n\n你可以通过调用 `add_investments` 方法将新的投资加入到您的投资组合中。例如：\n\n```python\nstock_strategy.add_investments(\"Amazon\")\nstock_strategy.add_investments(\"Netflix\")\n```\n\n输出：\n\n```\n12.00%\n```\n\n请注意，这只是一个基本的定投策略，实际的投资活动可能会受到多种因素的影响，如市场变化、行业趋势、投资目标等因素。", "lora_model_response": "", "original_response": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport json\nimport time\n\nfrom kumex.client import Trade\n\n\nclass Aip(object):\n\n    def __init__(self):\n        # read configuration from json file\n        with open('config.json', 'r') as file:\n            config = json.load(file)\n\n        self.api_key = config['api_key']\n        self.api_secret = config['api_secret']\n        self.api_passphrase = config['api_passphrase']\n        self.sandbox = config['is_sandbox']\n        self.symbol = config['symbol']\n        self.timer = int(config['timer'])\n        self.size = int(config['size'])\n        self.side = config['side']\n        self.leverage = config['leverage']\n        self.rate = float(config['rate'])\n        self.trade = Trade(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\n        if self.side == 'sell':\n            self.close = 'buy'\n        else:\n            self.close = 'sell'\n\n    def get_position_pcnt(self):\n        position = self.trade.get_position_details(self.symbol)\n        return float(position['unrealisedPnlPcnt'])\n\n\nif __name__ == '__main__':\n    aip = Aip()\n    market_order = aip.trade.create_market_order(aip.symbol, aip.side, aip.leverage, type='market', size=aip.size)\n    print('create a market %s order, order id = %s' % (aip.side, market_order['orderId']))\n    while 1:\n        time.sleep(aip.timer * 60)\n        pcnt = aip.get_position_pcnt()\n        if pcnt < 0 and abs(pcnt) > aip.rate:\n            market_order = aip.trade.create_market_order(aip.symbol, aip.side, aip.leverage,\n                                                         type='market', size=aip.size)\n            print('create a market %s order, order id = %s' % (aip.side, market_order['orderId']))\n        elif pcnt > 0 and pcnt > aip.rate:\n            market_order = aip.trade.create_market_order(aip.symbol, aip.close, aip.leverage,\n                                                         type='market', size=(aip.size*2))\n            print('create a market %s order, order id = %s' % (aip.close, market_order['orderId']))"}
{"query": "请生成一个子辰量化无限网格交易策略策略代码", "base_model_response": "", "lora_model_response": "```python\nimport time\nfrom datetime import timedelta, timedelta, getdate, strdate\nfrom ipygame import *\nimport random\n\ndef start(time):\n    global _start\n    _start = time.time()\n    global _client\n    client = None\n    return True\nfrom IPython.display import display\ndisplay('Welcome to the无限网格交易策略！')\n\nclass Client:\n    def __init__(self, name, maxsize=None, nlines=0, c=1):\n        self.client = client\n        self.name = name\n        self.maxsize = maxsize\n        self.nlines = nlines\n        self.c = c\n        self.client = _client()\n\n    def onexit(self):\n        # 事件处理程序\n        if not _client:\n            raise Exception('Client is not registered. No more events will be generated.')\n        # 打印数据到控制台\n        if not _client:\n            display('Client is unregistered. No more events will be generated.')\n        # 关闭连接到服务器\n        self.client.close()\n\n    def ondata(self, data):\n        # 防止无限网格游戏，防止用户退出\n        if self.onexit():\n            return\n        # 对所有状态进行操作，并将其写入到文件中\n        for item in data:\n            self.client.senditem(item)\n\ndef print_info(self, items):\n    # 打印每个状态的详细信息，例如线数、颜色、时间等\n    for item in items:\n        print(f'Line: {item['line']}, Color: {item['color']} Time: {item[\"time\"]}')\n\ndef main():\n    while True:\n        # 获取当前时间\n        now_str = getdate()\n        now = str(now_str)\n        # 获取开始和结束日期\n        start_date = now.split('.')[1]\n        end_date = now.split('.')[2]\n        # 如果没有记录，就创建一个新的记录\n        if self.client or self.client.get('client'):\n            self.client.set('client', now)\n        # 如果有记录，获取所有的状态\n        if now_data:\n            items = []\n            lines = {}\n            for line in now_data:\n                if isinstance(line, str) and len(line) >= 4:\n                    # 合并状态信息\n                    if line.startswith(\"Total (\") or line.startswith(\"Lines:\") or line.startswith(\"Lanes)\"):\n                        total_lines, total_lines_count = [line.strip() for line in line.split(')]].split(' ', 2).map(int)\n                        if not total_lines and total_lines_count > 0:\n                            lines[code] = total_lines\n                            total_lines = 0\n                            if not lines[code]:\n                                lines[code] = [total_lines_count]\n                            if total_lines_count == 0:\n                                total_lines_count = 0\n                            else:\n                                total_lines = total_lines_count + 1\n                        elif total_lines <= 2:\n                            lines[code] = total_lines\n                            total_lines = 0\n                        else:\n                            total_lines = 3\n                # 检查是否已经到达上限\n                if 72 * (now - start_date) > total_lines * 56:\n                    print_info(items) # 这里是错误提示，因为超过上限了\n                    return\n                # 输出全部状态信息\n                print_info(lines[code])\n                # 记录记录\n                total_lines_count += 1\n                if total_lines_count == 3:\n                    lines[code][total_lines_count] = 3\n                    if 'Total (') in lines[code]:\n                        for i in lines[code]['Total (')]:\n                            lines[code][\"Total (\")].append(str(i) + \" (\" + str(i) + \")\")\n                    else:\n                        lines[code][\"Total (\")].append(str(i))\n                    total_lines_count = 0", "original_response": "python\n##\n# 无限网格交易策略（公开版）\n# Author: 子辰量化\n# Last Modified: 2024-1-4\n##\n\nimport time\n\nassetRatio = 0.5 # 资产投资比例\n\noriginalTotalMoney = totalInvestment # 基准投资额，总投资额+盈亏后的全部权益\noriginalAssetMoney = totalInvestment * assetRatio # 基准资产价值\noriginalCashMoney = totalInvestment * (1 - assetRatio) # 基准现金\n\nremainCashMoney = originalTotalMoney # 当前剩余现金\ninvestAssetMoney = 0 # 当前资产价值\ninverstAssetAmount = 0 # 当前资产数量\n\nboolInited = False # 是否完成了首次建仓\n\ni = 0 # tick计算\n\ndef num_cut(num, c):\n    str_num = str(num)\n    return float(str_num[:str_num.index('.') + 1 + c])\n\ndef onTick():\n    global assetRatio\n    global originalTotalMoney\n    global originalAssetMoney\n    global originalCashMoney\n    global remainCashMoney\n    global investAssetMoney\n    global inverstAssetAmount\n    global boolInited\n    global i\n\n    ticker = exchange.GetTicker()\n    # Log(ticker)\n    openTime = time.localtime(ticker.Time / 1000) # ticker time\n    openTimeStr = time.strftime(\"%Y-%m-%dT%H:%M:%S\", openTime) \n    price = ticker.Last\n\n    # 初始建仓\n    if not boolInited:\n        money = originalAssetMoney\n        id = exchange.Buy(-1, money) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"buy money:\", money)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        money = order[\"Amount\"] # 成交的money\n        dealAmount = order[\"DealAmount\"] # 已扣除手续费的资产数量\n        price = order[\"AvgPrice\"] # 成交均价\n        remainCashMoney = originalCashMoney\n        investAssetMoney = originalAssetMoney\n        inverstAssetAmount = dealAmount        \n        boolInited = True\n        Log(f\"use ${investAssetMoney} buy {inverstAssetAmount} asset at price ${price} at time {openTimeStr}\")\n\n        Log(f\"{i} summary:\")\n        originalTotalMoney = originalAssetMoney + originalCashMoney\n        investAssetMoney = inverstAssetAmount * price\n        currentTotalMoney = investAssetMoney + remainCashMoney\n        Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n        Log(f\"originalCashMoney: ${originalCashMoney}\")\n        Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n        Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n        Log(f\"investAssetMoney: ${investAssetMoney}\")\n        Log(f\"remainCashMoney: ${remainCashMoney}\")\n        Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n        # account = exchange.GetAccount()\n        # Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # 买入\n    money = inverstAssetAmount * price # pirce\n    if money < originalAssetMoney * (1 - buyRatio):\n        money = originalAssetMoney * buyRatio # 买入金额\n        account = exchange.GetAccount()\n        if remainCashMoney > money and account[\"Balance\"] > money: # 判断是否还有足够的现金，双重检查 \n            # amount = money / price\n            id = exchange.Buy(-1, money) # 市价单\n            # Log(\"order id:\", id)\n            order = exchange.GetOrder(id)\n            Log(\"buy money:\", money)\n            Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n            money = order[\"Amount\"] # 成交的money\n            dealAmount = order[\"DealAmount\"] # 已扣除手续费的资产数量\n            price = order[\"AvgPrice\"] # 成交均价  \n            remainCashMoney -= money\n            inverstAssetAmount = inverstAssetAmount + dealAmount\n            Log(f\"bull/bear buy {dealAmount} asset at ${price} at time {openTimeStr}\")\n\n            Log(f\"{i} summary:\")\n            originalTotalMoney = originalAssetMoney + originalCashMoney\n            investAssetMoney = inverstAssetAmount * price\n            currentTotalMoney = investAssetMoney + remainCashMoney\n            Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n            Log(f\"originalCashMoney: ${originalCashMoney}\")\n            Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n            Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n            Log(f\"investAssetMoney: ${investAssetMoney}\")\n            Log(f\"remainCashMoney: ${remainCashMoney}\")\n            Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n            # account = exchange.GetAccount()\n            #Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # 卖出\n    money = inverstAssetAmount * price # pirce\n    if money > (originalAssetMoney * (1 + sellRatio)):\n        money = originalAssetMoney * sellRatio # 卖出金额\n        amount = money / price\n        id = exchange.Sell(-1, amount) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"sell money:\", money)\n        Log(\"sell amount:\", amount) \n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        amount = order[\"Amount\"] # 计划卖出资产数量\n        dealAmount = order[\"DealAmount\"] # 成交资产数量，这里好像是从balance扣除的手续费吗?\n        # 从日志来看amount == dealAmount,所以手续费是从balance扣除的\n        price = order[\"AvgPrice\"] # 成交均价\n        dealMoney = dealAmount * price # 未扣除手续费\n        remainCashMoney += dealMoney # 这里需要减去手续费\n        inverstAssetAmount = inverstAssetAmount - dealAmount\n        Log(f\"bull/bear sell {amount} asset at ${price} at time {openTimeStr}\")\n\n        Log(f\"{i} summary:\")\n        originalTotalMoney = originalAssetMoney + originalCashMoney\n        investAssetMoney = inverstAssetAmount * price\n        currentTotalMoney = investAssetMoney + remainCashMoney\n        Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n        Log(f\"originalCashMoney: ${originalCashMoney}\")\n        Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n        Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n        Log(f\"investAssetMoney: ${investAssetMoney}\")\n        Log(f\"remainCashMoney: ${remainCashMoney}\")\n        Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n        # account = exchange.GetAccount()\n        # Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    ##\n    # 仓位调整\n    ##\n    # 当remainCashMoney超过originalCashMoney的10%时，加大投资基准\n    if remainCashMoney >= originalCashMoney * 1.1:\n        money = (remainCashMoney - originalCashMoney) / 2 # 买入金额\n        # amount = money / price\n        id = exchange.Buy(-1, money) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"buy money:\", money)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        money = order[\"Amount\"] # 成交的money\n        dealAmount = order[\"DealAmount\"] # 已扣除手续费\n        price = order[\"AvgPrice\"] # 成交均价  \n        remainCashMoney -= money\n        inverstAssetAmount = inverstAssetAmount + dealAmount\n        originalAssetMoney += money # 增加投资基准\n        originalCashMoney += money # 增加投资基准\n        Log(f\"bull/bear add original invest at time {openTimeStr}\")\n\n    # 当remainCashMoney低于originalCashMoney的90%时，减少投资基准\n    if remainCashMoney <= originalCashMoney * 0.9:\n        money = (originalCashMoney - remainCashMoney) / 2 # 卖出金额\n        amount = money / price\n        id = exchange.Sell(-1, amount) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"sell money:\", money)\n        Log(\"sell amount:\", amount)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        amount = order[\"Amount\"] # 计划卖出资产数量\n        dealAmount = order[\"DealAmount\"] # 成交资产数量，这里好像是从balance扣除的手续费吗?\n        # 从日志来看amount == dealAmount,所以手续费是从balance扣除的\n        price = order[\"AvgPrice\"] # 成交均价\n        dealMoney = dealAmount * price # 未扣除手续费\n        dealMoney = dealAmount * price # 未扣除手续费\n        remainCashMoney += dealMoney # 这里需要减去手续费\n        inverstAssetAmount = inverstAssetAmount - dealAmount\n        originalAssetMoney -= money # 减少投资基准\n        originalCashMoney -= money # 减少投资基准\n        Log(f\"bull/bear reduce original invest at time {openTimeStr}\")\n\n    # tick计算\n    i = i + 1\n\ndef main():\n    Log(totalInvestment, buyRatio, sellRatio)\n\n    while True:\n        onTick()\n        Sleep(1000) # 1秒\n\ndef onexit():\n    global inverstAssetAmount\n\n    # 清仓\n    Log(\"清仓\")\n    if inverstAssetAmount > 0:\n        amount = num_cut(inverstAssetAmount * (1-0.0001), 8) # 留0.01%一丢丢，小数位控制\n        id = exchange.Sell(-1, amount) # 市价单\n        Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])        \n    # 倒计时\n    beginTime = time.time() * 1000\n    while True:\n        ts = time.time() * 1000\n        Log(\"程序停止倒计时...，已经过去：\", (ts - beginTime) / 1000, \"秒！\")\n        Sleep(1000) # 1秒"}
{"query": "请生成一个子辰量化香农网格交易策略策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n##\n# 香农网格交易策略（公开版）\n# Author: 子辰量化\n# Last Modified: 2024-1-4\n##\n\nimport time\n\nassetRatio = 0.5 # 资产投资比例\n\noriginalTotalMoney = totalInvestment # 基准投资额，总投资额+盈亏后的全部权益\noriginalAssetMoney = totalInvestment * assetRatio # 基准资产价值\noriginalCashMoney = totalInvestment * (1 - assetRatio) # 基准现金\n\nremainCashMoney = originalCashMoney # 当前剩余现金\ninvestAssetMoney = 0 # 当前资产价值\ninverstAssetAmount = 0 # 当前资产数量\n\nboolInited = False # 是否完成了首次建仓\n\ni = 0 # tick计算\n\ndef num_cut(num, c):\n    str_num = str(num)\n    return float(str_num[:str_num.index('.') + 1 + c])\n\ndef onTick():\n    global assetRatio\n    global originalTotalMoney\n    global originalAssetMoney\n    global originalCashMoney\n    global remainCashMoney\n    global investAssetMoney\n    global inverstAssetAmount\n    global boolInited\n    global i\n\n    ticker = exchange.GetTicker()\n    # Log(ticker)\n    openTime = time.localtime(ticker.Time / 1000) # ticker time\n    openTimeStr = time.strftime(\"%Y-%m-%dT%H:%M:%S\", openTime) \n    price = ticker.Last\n\n    # 初始建仓\n    if not boolInited:\n        money = originalAssetMoney\n        id = exchange.Buy(-1, money) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"buy money:\", money)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        money = order[\"Amount\"] # 成交的money\n        dealAmount = order[\"DealAmount\"] # 已扣除手续费的资产数量\n        price = order[\"AvgPrice\"] # 成交均价\n        investAssetMoney = originalAssetMoney\n        remainCashMoney = originalCashMoney\n        inverstAssetAmount = dealAmount       \n        boolInited = True\n        Log(f\"use ${investAssetMoney} buy {inverstAssetAmount} asset at price ${price} at time {openTimeStr}\")\n\n        Log(f\"{i} summary:\")\n        originalTotalMoney = originalAssetMoney + originalCashMoney\n        investAssetMoney = inverstAssetAmount * price\n        currentTotalMoney = investAssetMoney + remainCashMoney\n        Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n        Log(f\"originalCashMoney: ${originalCashMoney}\")\n        Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n        Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n        Log(f\"investAssetMoney: ${investAssetMoney}\")\n        Log(f\"remainCashMoney: ${remainCashMoney}\")\n        Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n        # account = exchange.GetAccount()\n        # Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # 买入\n    money = inverstAssetAmount * price # pirce\n    if money < originalAssetMoney * (1 - buyRatio):\n        money = originalAssetMoney * buyRatio / 2 # 买入金额\n        account = exchange.GetAccount()\n        if remainCashMoney > money and account[\"Balance\"] > money: # 判断是否还有足够的现金，双重检查\n            # amount = money / price\n            id = exchange.Buy(-1, money) # 市价单\n            # Log(\"order id:\", id)\n            order = exchange.GetOrder(id)\n            Log(\"buy money:\", money)\n            Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n            money = order[\"Amount\"] # 成交的money\n            dealAmount = order[\"DealAmount\"] # 已扣除手续费的资产数量\n            price = order[\"AvgPrice\"] # 成交均价  \n            originalAssetMoney -= money #\n            originalCashMoney -= money #\n            remainCashMoney -= money\n            inverstAssetAmount = inverstAssetAmount + dealAmount\n            Log(f\"bull/bear buy {dealAmount} asset at ${price} at time {openTimeStr}\")\n\n            Log(f\"{i} summary:\")\n            originalTotalMoney = originalAssetMoney + originalCashMoney\n            investAssetMoney = inverstAssetAmount * price\n            currentTotalMoney = investAssetMoney + remainCashMoney\n            Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n            Log(f\"originalCashMoney: ${originalCashMoney}\")\n            Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n            Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n            Log(f\"investAssetMoney: ${investAssetMoney}\")\n            Log(f\"remainCashMoney: ${remainCashMoney}\")\n            Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n            # account = exchange.GetAccount()\n            #Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # 卖出\n    money = inverstAssetAmount * price # pirce\n    if money > (originalAssetMoney * (1 + sellRatio)):\n        money = originalAssetMoney * sellRatio / 2 # 卖出金额\n        amount = money / price\n        id = exchange.Sell(-1, amount) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"sell money:\", money)\n        Log(\"sell amount:\", amount)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        amount = order[\"Amount\"] # 计划卖出资产数量\n        dealAmount = order[\"DealAmount\"] # 成交资产数量，这里好像是从balance扣除的手续费吗?\n        # 从日志来看amount == dealAmount,所以手续费是从balance扣除的\n        price = order[\"AvgPrice\"] # 成交均价\n        dealMoney = dealAmount * price # 未扣除手续费\n        remainCashMoney += dealMoney # 这里需要减去手续费\n        originalAssetMoney += money #\n        originalCashMoney += money #\n        inverstAssetAmount = inverstAssetAmount - dealAmount\n        Log(f\"bull/bear sell {amount} asset at ${price} at time {openTimeStr}\")\n\n        Log(f\"{i} summary:\")\n        originalTotalMoney = originalAssetMoney + originalCashMoney\n        investAssetMoney = inverstAssetAmount * price\n        currentTotalMoney = investAssetMoney + remainCashMoney\n        Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n        Log(f\"originalCashMoney: ${originalCashMoney}\")\n        Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n        Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n        Log(f\"investAssetMoney: ${investAssetMoney}\")\n        Log(f\"remainCashMoney: ${remainCashMoney}\")\n        Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n        # account = exchange.GetAccount()\n        # Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # tick计数\n    i = i + 1\n\ndef main():\n    Log(totalInvestment, buyRatio, sellRatio)\n\n    while True:\n        onTick()\n        Sleep(1000) # 1秒\n\ndef onexit():\n    global inverstAssetAmount\n\n    # 清仓\n    Log(\"清仓\")\n    if inverstAssetAmount > 0:\n        amount = num_cut(inverstAssetAmount * (1-0.0001), 8) # 留0.01%一丢丢，小数位控制\n        id = exchange.Sell(-1, amount) # 市价单\n        Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])        \n    # 倒计时\n    beginTime = time.time() * 1000\n    while True:\n        ts = time.time() * 1000\n        Log(\"程序停止倒计时...，已经过去：\", (ts - beginTime) / 1000, \"秒！\")\n        Sleep(1000) # 1秒"}
{"query": "请生成一个定投新手入门每周100USDT-定期定额-100USDT-Invested-Every-Week-Regular-Fixed-Investment策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\ndef main():\n    amountAll = 0                                              #持有总量\n    cost = 0                                                   #成本\n    marketValueCurrent = 0                                     #当前持有总市值\n    rateOfReturn = 0                                           #收益率\n    while True:\n        ticker = exchange.GetTicker()\n        price = ticker['Last']                                 #获得当前价格\n        amount = 100 / price                                   #计算本次买入量\n        exchange.Buy(price,amount)                             #买入\n        amountAll = amountAll + amount                         #计算持有总量\n        cost = cost + 100                                      #计算总成本\n        marketValueCurrent = amountAll * price                 #计算当前持有总市值\n        rateOfReturn = (marketValueCurrent - cost) / cost      #计算收益率        \n        Log(\"此次投入金额：\", 100, \"本金：\", cost, \"当前总市值：\", marketValueCurrent, \"收益率:\", rateOfReturn * 100,\"%\",\"当前价格\",price)\n        Sleep(7 * 24 * 60 * 60 * 1000)                         #等待一周"}
{"query": "请生成一个定投新手入门每周100USDT左右-定期不定额-100USDT-Invested-Every-Week-Regular-Variable-Investment策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\ndef main():\n    amountAll = 0                                              #持有总量\n    cost = 0                                                   #成本\n    marketValueCurrent = 0                                     #当前持有总市值\n    marketValueExpected = 0                                    #当前期望总市值\n    rateOfReturn = 0                                           #收益率\n    eachBuy = 100\n    while True:\n        marketValueExpected = marketValueExpected + eachBuy        #计算当前期望总市值\n        ticker = exchange.GetTicker()\n        price = ticker['Last']                                 #获得当前价格\n        amount = marketValueExpected / price - amountAll       #计算本次买入量\n        if amount > 0:\n            exchange.Buy(price,amount)                         #买入         \n        else:\n            amount = 0\n        amountAll = amountAll + amount                         #计算持有总量\n        cost = cost + amount * price                           #计算总成本\n        marketValueCurrent = amountAll * price                 #计算当前持有总市值\n        rateOfReturn = (marketValueCurrent - cost) / cost      #计算收益率\n        Log(\"此次投入金额：\", amount * price, \"本金：\", cost,\"当前总持有量\", amountAll,\"当前总市值：\", marketValueCurrent, \"收益率:\", rateOfReturn * 100,\"%\" ,\"当前价格:\", price, )\n        Sleep(7 * 24 * 60 * 60 * 1000)                         #等待一周"}
{"query": "请生成一个山寨币指数20180222基点1000策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-coding\nimport time\nimport urllib2\nimport json\nimport pickle\n            \ndef updateTicker():\n    global index,initPrice\n    ticker = json.loads(urllib2.urlopen('https://api.binance.com/api/v3/ticker/price',timeout=10).read())\n    change = []\n    for t in ticker:\n        if t['symbol'][-3:] == 'BTC':\n            if t['symbol'][:-3] in initPrice.keys():\n                change.append(float(t['price'])/initPrice[t['symbol'][:-3]])\n            else:\n                initPrice[t['symbol'][:-3]] = float(t['price'])\n                f=open('price.pkl','w')\n                pickle.dump(initPrice,f,0)\n                f.close()\n                Log(t['symbol'][:-3],' added')\n    if len(change)>0:\n        index = 1000*sum(change)/len(change)\n    \n\n\ninitPrice = {}\nprice = {}\nindex = 1000\ntry:\n    f=open('price.pkl','r')  \n    initPrice=pickle.load(f)  \n    f.close()\nexcept:\n    initPrice = {}\nLog('共计入山寨币:', len(initPrice))\ndef main():\n    while True:\n        try:\n            updateTicker()\n            LogProfit(round(index,4))\n        except Exception as e:\n            pass\n        Sleep(3600000)"}
{"query": "请生成一个币安websocket订阅永续合约行情信息策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport json\ndef main():\n    LogStatus(\"正在连接...\")\n    # client = Dial(\"wss://stream.binance.com:9443/stream?streams=btcusdt@aggTrade/ethusdt@aggTrade|reconnect=true\")    #多个交易对\n    # client = Dial(\"wss://stream.binance.com:9443/ws/btcusdt@aggTrade|reconnect=true\")    #单个交易对\n    # client = Dial(\"wss://dstream.binance.com/ws/btcusd_perp@aggTrade|reconnect=true\")    #币本位，ticker\n    client = Dial(\"wss://fstream.binance.com/ws/btcusdt@aggTrade|reconnect=true\")\n    if not client:    \n        Log(\"连接失败, 程序退出\")\n        return\n    while True:\n        buf = client.read(-2)\n        Log('tt',buf)\n        if buf:\n            obj = json.loads(buf)\n            # Log(obj)\n            # Log('交易对',obj['data']['s'], ' 价格', obj['data']['p'])    #多个交易对 \n            Log(obj['p'])    #测试\n        Sleep(5000)\n    client.close()"}
{"query": "请生成一个币安合约BNB手续费抵扣-自动购买自动划转策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# Contact : ck@xueqiubot.com / WeChat@stay37\n\nimport time\n\n\ndef supply_bnb(transfer_usdt,i):\n    Log(\"当前BNB不足，补充BNB作为手续费抵扣\")\n    #获取当前BNB_USDT价格\n    depth = _C(exchanges[i].GetDepth)\n    #转出transfer_usdt个USDT\n    timestamp = time.time() * 1000\n    transfer = exchanges[i].IO(\"api\",\"POST\",\"/sapi/v1/futures/transfer\",\"asset=USDT&amount=\"+str(transfer_usdt)+\"&type=2&timestamp=+\"+str(timestamp))\n    time.sleep(1)\n    #获取BNB深度 下单购买\n    depth = _C(exchanges[i].GetDepth)\n    buyamount = round(transfer_usdt / (depth.Asks[0].Price + 0.2) , 2)\n    buyid = exchanges[i].Buy(round(depth.Asks[0].Price + 0.1 , 4) , buyamount)\n    time.sleep(1)\n    #查询购买结果 将购买后的BNB以及剩余的USDT转入合约账户\n    acc = _C(exchanges[i].GetAccount)\n    transfer_usdt = acc.Balance\n    transfer_bnb = acc.Stocks\n    timestamp = time.time() * 1000\n    transfer = exchanges[i].IO(\"api\",\"POST\",\"/sapi/v1/futures/transfer\",\"asset=USDT&amount=\"+str(transfer_usdt)+\"&type=1&timestamp=+\"+str(timestamp))\n    transfer = exchanges[i].IO(\"api\",\"POST\",\"/sapi/v1/futures/transfer\",\"asset=BNB&amount=\"+str(transfer_bnb)+\"&type=1&timestamp=+\"+str(timestamp))\n    Log(\"BNB补充完成\")\n\n\n\n\ndef main():\n    if '合约账户内BNB不足':\n        #transfer_usdt: 需要购买的usdt金额\n        #i: bnb_usdt现货交易对的序号\n        supply_bnb(transfer_usdt,i)"}
{"query": "请生成一个币安合约网格-002v策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n\nimport time\nimport requests\nimport math\n# import pandas as pd\n\nInitPrice = 0\nupdateProfitTime = 0\nassets = {}\ntradeInfo = {}\naccountAssets = {}\nruntimeData = {}\nFunding = 0   #账户资金  为0的时候自动获取\nsymbol = ''\nVersion = '0.0.1'\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\n\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所！')\n    exit()\n\ndef init():\n    initData()\n    CancelOrder()\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()\n    for i in range(len(exchangeInfo['symbols'])):\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\n            assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\n\ndef CancelOrder():\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    for x in range(len(orders)):\n        if orders[x]['Info']['symbol'] == symbol :\n            exchange.CancelOrder(orders[x]['Id'])\n\ndef UpdateStatus():\n    global Funding,updateProfitTime\n    if Funding == 0 :\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\n\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\",  \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数][持仓模式]', '币种信息', '开仓方向','初始价格', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\n        'rows': []\n    }\n\n    profitColors = DangerColor\n    totalProfit = assets['USDT']['total_balance'] - Funding\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday\n    \n    #Log('dayProfit:',dayProfit,'Funding:',Funding)\n    dayRate = dayProfit / Funding * 100\n\n\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n\n    i = 1\n    for x in list(symbol.split(',')):\n        typestr = '多空持仓'\n        if type == 1:\n            typestr = '只持多仓'\n        if type == 2:\n            typestr = '只持空仓'\n        direction = '空仓'\n        margin = direction\n        if assets[x]['amount'] != 0:\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\n        unrealised_profit_color = '#000000'\n        if assets[symbol]['unrealised_profit'] > 0:\n            unrealised_profit_color = SuccessColor\n        if assets[symbol]['unrealised_profit'] < 0:\n            unrealised_profit_color = DangerColor\n\n        infoList = [\n        i,\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']'+'['+typestr+']',\n        x,\n        direction,\n        InitPrice,\n        assets[x]['amount'],\n        assets[x]['hold_price'],\n        assets[x]['price'],\n        assets[x]['liquidationPrice'],\n        float(assets[x]['amount']) * float(assets[x]['price']),\n        assets[x]['positionInitialMargin'],\n        assets[x]['unrealised_profit'],\n        ]\n        table['rows'].append(infoList)\n\n        retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n'\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = assets['USDT']['total_balance']\n        key = \"initialAccount_\" + exchange.GetLabel()\n        initialAccount = _G(key)\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\n        if Show:\n            balance = assets['USDT']['total_balance'] - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n        Profit = _N(balance,0)\n\n\ndef UpdateAccount():\n    # Log('UpdateAccount()')\n    global accountAssets\n    account = exchange.GetAccount()\n    position = exchange.GetPosition()\n    if account is None and position is None :\n        Log('更新账户超时！！！')\n        return\n    accountAssets = account['Info']['assets']\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\n    for  i in range(len(account['Info']['positions'])) :\n        if account['Info']['positions'][i]['symbol'] == symbol :\n            #计算持仓保证金                                           初始保证金                +            维持保证金\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\n            #未实现收益\n            assets[symbol]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\n            assets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\n\n    #计算持仓保证金总额\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\n\n    ps = json.loads(exchange.GetRawJSON())\n    if len(ps) > 0 :\n        for x in range(len(ps)):\n            if ps[x]['symbol'] == symbol:\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProfit'])\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\n                assets[symbol]['marginType'] = ps[x]['marginType']\n\ndef UpdateTick():\n    global InitPrice\n    res = _C(exchange.GetTicker)\n    if res is None:\n        Log(\"行情更新异常！！！\")\n\n    if target:\n        InitPrice = target_price\n        _G('InitPrice',InitPrice)\n    else:\n        if  _G('InitPrice') is None :\n            InitPrice = res.Last\n            _G('InitPrice',InitPrice)\n        else:\n            InitPrice = _G('InitPrice')\n\n    assets[symbol]['price'] = res.Last\n\ndef Trade(direction,price,amount):\n    if amount < 0:\n        amount = -amount\n    Log('amount:',amount,'minQty:',tradeInfo[symbol]['minQty'])\n    if amount < tradeInfo[symbol]['minQty']:\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n    else:\n        para = ''\n        url = '/fapi/v1/order'\n        para += 'symbol='+ symbol\n        para += '&side='+ direction\n        para += '&type=LIMIT&timeInForce=GTC'\n        para += '&quantity='+ str(amount)\n        para += '&price='+ str(price)\n        para += \"&timestamp=\"+str(time.time() * 1000);\n        go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n        ret = go.wait()\n        if ret  is not None:\n            logType = LOG_TYPE_SELL\n            if direction == 'BUY':\n                logType =LOG_TYPE_BUY\n            exchange.Log(logType,price,amount,symbol)\n\ndef batch(buy_price,sell_price):\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    if len(orders) < 2 :\n        return True\n    return False\n\ndef Process():\n    amount = (1 - float(assets[symbol]['price']) / float(InitPrice)) / float(pct) * float(value) / float(assets[symbol]['price'])\n    if abs(amount - assets[symbol]['amount']) > _N(value / float(assets[symbol]['price']), tradeInfo[symbol]['amountSize']):\n        if amount > 0:\n            if assets[symbol]['amount'] < amount:\n                CancelOrder()\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n            if assets[symbol]['amount'] > amount:\n                CancelOrder()\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n        if amount < 0:\n            if assets[symbol]['amount'] < amount:\n                CancelOrder()\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n            if assets[symbol]['amount'] > amount:\n                CancelOrder()\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n\n\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n    sell_price = (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\n        CancelOrder()\n        Trade('BUY', _N(buy_price, tradeInfo[symbol]['priceSize']), _N(value / buy_price, tradeInfo[symbol]['amountSize']))\n        Trade('SELL', _N(sell_price, tradeInfo[symbol]['priceSize']), (_N(value / sell_price, tradeInfo[symbol]['amountSize'])))\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)\n    return initialAccount\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef initData():\n    global symbol\n    if _G('symbol') is None:\n        symbol = exchange.GetCurrency().replace('_','')\n        _G('symbol',symbol)\n        Log('初始化币种：',symbol)\n    else:\n        symbol = _G('symbol')\n        Log('交易币种：',symbol)\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(10)\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n\n        Sleep(1000 * Interval)"}
{"query": "请生成一个币安合约网格-基础版本-001策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# 刚开始学python，有不不合理的地方，见谅！！！\nimport time\nimport requests\nimport math\nimport pandas as pd\n\nInitPrice = 0\nupdateProfitTime = 0\nassets = {}\ntradeInfo = {}\naccountAssets = {}\nruntimeData = {}\nFunding = 0   #账户资金  为0的时候自动获取\nsymbol = ''\nVersion = '0.0.1'\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\n\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所！')\n    exit()\n\ndef init():\n    initData()\n    CancelOrder()\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()\n    for i in range(len(exchangeInfo['symbols'])):\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\n            assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\n\ndef CancelOrder():\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    for x in range(len(orders)):\n        if orders[x]['Info']['symbol'] == symbol :\n            exchange.CancelOrder(orders[x]['Id'])\n\ndef UpdateStatus():\n    global Funding,updateProfitTime\n    if Funding == 0 :\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\n\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\",  \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\n        'rows': []\n    }\n\n    profitColors = DangerColor\n    totalProfit = assets['USDT']['total_balance'] - Funding\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday\n    dayRate = dayProfit / Funding * 100\n\n\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n\n    i = 1\n    for x in list(symbol.split(',')):\n        \n        direction = '空仓'\n        margin = direction\n        if assets[x]['amount'] != 0:\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\n        unrealised_profit_color = '#000000'\n        if assets[symbol]['unrealised_profit'] > 0:\n            unrealised_profit_color = SuccessColor\n        if assets[symbol]['unrealised_profit'] < 0:\n            unrealised_profit_color = DangerColor\n\n        infoList = [\n        i,\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']',\n        x,\n        direction,\n        assets[x]['amount'],\n        assets[x]['hold_price'],\n        assets[x]['price'],\n        assets[x]['liquidationPrice'],\n        float(assets[x]['amount']) * float(assets[x]['price']),\n        assets[x]['positionInitialMargin'],\n        assets[x]['unrealised_profit'],\n        ]\n        table['rows'].append(infoList)\n\n        retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n'\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = assets['USDT']['total_balance']\n        key = \"initialAccount_\" + exchange.GetLabel()\n        initialAccount = _G(key)\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\n        if Show:\n            balance = assets['USDT']['total_balance'] - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n        Profit = _N(balance,0)\n\n\ndef UpdateAccount():\n    # Log('UpdateAccount()')\n    global accountAssets\n    account = exchange.GetAccount()\n    position = exchange.GetPosition()\n    if account is None and position is None :\n        Log('更新账户超时！！！')\n        return\n    accountAssets = account['Info']['assets']\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\n    for  i in range(len(account['Info']['positions'])) :\n        if account['Info']['positions'][i]['symbol'] == symbol :\n            #计算持仓保证金                                           初始保证金                +            维持保证金\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\n            #未实现收益\n            assets[symbol]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\n            assets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\n\n    #计算持仓保证金总额\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\n\n    ps = json.loads(exchange.GetRawJSON())\n    if len(ps) > 0 :\n        for x in range(len(ps)):\n            if ps[x]['symbol'] == symbol:\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProfit'])\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\n                assets[symbol]['marginType'] = ps[x]['marginType']\n\ndef UpdateTick():\n    global InitPrice\n    try:\n        res = requests.get(f'https://fapi.binance.com/fapi/v1/ticker/price?symbol={symbol}').json()\n    except:\n        Log('get ticker time out !')\n        return\n\n    if target:\n        InitPrice = target_price\n        _G('InitPrice',InitPrice)\n    else:\n        if  _G('InitPrice') is None :\n            InitPrice = res['price']\n            _G('InitPrice',InitPrice)\n        else:\n            InitPrice = _G('InitPrice')\n\n    assets[symbol]['price'] = res['price']\n\ndef Trade(direction,price,amount):\n    if amount < tradeInfo[symbol]['minQty']:\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n    else:\n        para = ''\n        url = '/fapi/v1/order'\n        para += 'symbol='+ symbol\n        para += '&side='+ direction\n        para += '&type=LIMIT&timeInForce=GTC'\n        para += '&quantity='+ str(amount)\n        para += '&price='+ str(price)\n        para += \"&timestamp=\"+str(time.time() * 1000);\n        go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n        ret = go.wait()\n        if ret  is not None:\n            logType = LOG_TYPE_SELL\n            if direction == 'BUY':\n                logType =LOG_TYPE_BUY\n            exchange.Log(logType,price,amount,symbol)\n\ndef batch(buy_price,sell_price):\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    if len(orders) < 2 :\n        return True\n    return False\n\ndef Process():\n\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n    sell_price = (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\n        CancelOrder()\n        Trade('BUY', _N(buy_price, 5), _N(value / buy_price, 0))\n        Trade('SELL', _N(sell_price, 5), _N(value / sell_price, 0))\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)\n    return initialAccount\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef initData():\n    global symbol\n    if _G('symbol') is None:\n        symbol = exchange.GetCurrency().replace('_','')\n        _G('symbol',symbol)\n        Log('初始化币种：',symbol)\n    else:\n        symbol = _G('symbol')\n        Log('交易币种：',symbol)\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(10)\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n\n        Sleep(1000 * Interval)"}
{"query": "请生成一个币安永续多币种对冲策略做多超跌做空超涨-张总python版策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#刚学python，希望指正！共同学习！\nimport time\nimport requests\nimport math\nAlpha = 0.001 #指数移动平均的Alpha参数，设置的越大，基准价格跟踪越敏感，最终持仓也会越低，降低了杠杆，但会降低收益，具体需要根据回测结果自己权衡\nUpdate_base_price_time_interval = 60 #多久更新一次基准价格, 单位秒，和Alpha参数相关,Alpha 设置的越小，这个间隔也可以设置的更小\n#Stop_loss设置为0.8表示当资金达到低于初始资金的80%时，止损，清空所有仓位，停止策略。\n#随着策略运行，Stop_loss可以设置大于1（重启生效），比如从1000赚到1500，Stop_loss设置为1.3，则回撤到1300元止损。不想止损可以把这个参数设置的很小。\n#风险是大家都用这种止损会形成踩踏，加大亏损。\n#初始资金在状态栏的init_balance字段，注意提现等操作会影响，别不小心止损了。\n#如果还是怕黑天鹅事件，比如某个币归0等，可以手动提现出来。\n\nStop_loss = 0.8\nMax_diff = 0.03 #当偏差diff大于0.4时，不继续加空仓, 自行设置\nMin_diff = -0.03 #当diff小于-0.3时，不继续加多仓, 自行设置\nVersion = '0.1.3'\nShow = false #默认为false累计收益显示是账户余额,改为true累计收益显示为收益,如果之前是显示的账户余额,你使用LogProfitReset()来清空图表\nFunding = 0 #账户初始金额,为0的时候,自动获取,非0为自定义\nsuccess = '#5cb85c' #成功颜色\ndanger = '#ff0000' #危险颜色\nwarning = '#f0ad4e' #警告颜色\nRunTime = {} #运行时间\nSelfFee = 0.04 #https:#www.binance.com/cn/fee/futureFee\nTotalLong = 0\nTotalShort = 0\nUpProfit = 0\naccountAssets = [] #保存资产\nWinRateData = {} #保存所有币种的胜率及开仓次数\n\nif IsVirtual():\n    Log('不能回测，回测参考 https://www.fmz.com/digest-topic/5294 ')\n    exit()\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所，和现货交易所不同，需要单独添加，名称为Futures_Binance')\n    exit()\ntrade_symbols = Trade_symbols.split(',')\nsymbols = trade_symbols + ['BTC']\nindex = 1 #指数\nupdate_profit_time = 0\nupdate_base_price_time = int(time.time()*1000)\nassets = {}\ninit_prices = {}\ntrade_info = {}\n\ndef init():\n    InitRateData()\n    exchange_info = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchange_info is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()    \n    for i in range(len(exchange_info['symbols'])):\n        if exchange_info['symbols'][i]['baseAsset'] in symbols:            \n            assets[exchange_info['symbols'][i]['baseAsset']] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'btc_price': 0, 'btc_change': 1,'btc_diff': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n            trade_info[exchange_info['symbols'][i]['baseAsset']] = {'minQty': float(exchange_info['symbols'][i]['filters'][1]['minQty']) , 'priceSize': int((math.log10(1.1/float(exchange_info['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchange_info['symbols'][i]['filters'][1]['stepSize']))))}\n\nassets['USDT'] = {\n    'unrealised_profit': 0,\n    'margin': 0,\n    'margin_balance': 0,\n    'total_balance': 0,\n    'leverage': 0,\n    'update_time': 0,\n    'margin_ratio': 0,\n    'init_balance': 0,\n    'stop_balance': 0,\n    'short_value': 0,\n    'long_value': 0,\n    'profit': 0\n}\n\ndef updateAccount() : #更新账户和持仓\n    global accountAssets\n    account = exchange.GetAccount()\n    pos = exchange.GetPosition()\n    if account is None or pos is None:\n        Log('update account time out')\n        return    \n    accountAssets = account['Info']['assets']\n    assets['USDT']['update_time'] = int(time.time()*1000)\n    for i in range(len(trade_symbols)):\n        assets[trade_symbols[i]]['margin'] = 0\n        assets[trade_symbols[i]]['unrealised_profit'] = 0\n        assets[trade_symbols[i]]['hold_price'] = 0\n        assets[trade_symbols[i]]['amount'] = 0\n    \n    for j in range(len(account['Info']['positions'])):        \n        if account['Info']['positions'][j]['positionSide'] == 'BOTH':\n            pair = account['Info']['positions'][j]['symbol']\n            coin = pair[0:len(pair)-4]\n            if coin not in trade_symbols:\n                continue\n            assets[coin]['margin'] = float(account['Info']['positions'][j]['initialMargin']) + float(account['Info']['positions'][j]['maintMargin'])\n            assets[coin]['unrealised_profit'] = float(account['Info']['positions'][j]['unrealizedProfit'])\n            assets[coin]['positionInitialMargin'] = float(account['Info']['positions'][j]['positionInitialMargin'])\n            assets[coin]['leverage'] = account['Info']['positions'][j]['leverage']\n\n    assets['USDT']['margin'] = _N(float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin']), 2)\n    assets['USDT']['margin_balance'] = _N(float(account['Info']['totalMarginBalance']), 2)\n    assets['USDT']['total_balance'] = _N(float(account['Info']['totalWalletBalance']), 2)\n    if assets['USDT']['init_balance'] == 0:\n        if _G('init_balance'):\n            assets['USDT']['init_balance'] = _N(_G('init_balance'), 2)\n        else:\n            assets['USDT']['init_balance'] = assets['USDT']['total_balance']\n            _G('init_balance', assets['USDT']['init_balance'])\n    assets['USDT']['profit'] = _N(assets['USDT']['margin_balance'] - assets['USDT']['init_balance'], 2)\n    assets['USDT']['stop_balance'] = _N(Stop_loss * assets['USDT']['init_balance'], 2)\n    assets['USDT']['total_balance'] = _N(float(account['Info']['totalWalletBalance']), 2)\n    assets['USDT']['unrealised_profit'] = _N(float(account['Info']['totalUnrealizedProfit']), 2)\n    assets['USDT']['leverage'] = _N(assets['USDT']['margin'] / assets['USDT']['total_balance'], 2)\n    assets['USDT']['margin_ratio'] = float(account['Info']['totalMaintMargin']) / float(account['Info']['totalMarginBalance']) * 100\n    pos = json.loads(exchange.GetRawJSON())\n    if len(pos) > 0:\n        for k in range(len(pos)):\n            pair = pos[k]['symbol']\n            coin = pair[0:len(pair)-4]\n            if coin not in trade_symbols:\n                continue            \n            if pos[k]['positionSide'] != 'BOTH':\n                continue       \n            assets[coin]['hold_price'] = float(pos[k]['entryPrice'])\n            assets[coin]['amount'] = float(pos[k]['positionAmt'])\n            assets[coin]['unrealised_profit'] = float(pos[k]['unRealizedProfit'])\n            assets[coin]['liquidationPrice'] = float(pos[k]['liquidationPrice'])\n            assets[coin]['marginType'] = pos[k]['marginType']\n\ndef updateIndex(): #更新指数\n    global update_base_price_time,index,init_prices,Reset\n    if _G('init_prices') is None or Reset:\n        Reset = False\n        for i in range(len(trade_symbols)):\n            init_prices[trade_symbols[i]] = (assets[trade_symbols[i]]['ask_price'] + assets[trade_symbols[i]]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n        Log('保存启动时的价格')\n        _G('init_prices', init_prices)\n        _G(\"StartTime\", None) #重置开始时间\n        _G(\"initialAccount_\" + exchange.GetLabel(), None) #重置开始资金\n        _G('tradeNumber', 0) #重置交易次数\n        _G('tradeVolume', 0) #重置交易量\n        _G('buyNumber', 0) #重置做多次数\n        _G('sellNumber', 0) #重置做空次数\n        _G('totalProfit', 0) #重置打印次数\n        _G('profitNumber', 0) #重置盈利次数\n    else:\n        init_prices = _G('init_prices')\n        if (int(time.time()*1000) - update_base_price_time > Update_base_price_time_interval * 1000):\n            update_base_price_time = int(time.time()*1000)\n            for i in range(len(trade_symbols)): #更新初始价格\n                init_prices[trade_symbols[i]] = init_prices[trade_symbols[i]] * (1 - Alpha) + Alpha * (assets[trade_symbols[i]]['ask_price'] + assets[trade_symbols[i]]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n            _G('init_prices', init_prices)\n        temp = 0\n        for i in range(len(trade_symbols)):\n            assets[trade_symbols[i]]['btc_price'] = (assets[trade_symbols[i]]['ask_price'] + assets[trade_symbols[i]]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n            if trade_symbols[i] not in init_prices:\n                Log('添加新的币种', trade_symbols[i])\n                init_prices[trade_symbols[i]] = assets[trade_symbols[i]]['btc_price']\n                _G('init_prices', init_prices)\n            assets[trade_symbols[i]]['btc_change'] = _N(assets[trade_symbols[i]]['btc_price'] / init_prices[trade_symbols[i]], 4)\n            temp += assets[trade_symbols[i]]['btc_change']        \n        index = _N(temp / len(trade_symbols), 4)\n\ndef updateTick() : #更新行情\n    try:\n        ticker = requests.get('https://fapi.binance.com/fapi/v1/ticker/bookTicker').json()\n    except Exception as e:\n        Log('get ticker time out:',e)\n        return\n    assets['USDT']['short_value'] = 0\n    assets['USDT']['long_value'] = 0\n    for i in range(len(ticker)):\n        pair = ticker[i]['symbol']\n        coin = pair[0:len(pair)-4]\n        if coin not in symbols:\n            continue\n        assets[coin]['ask_price'] = float(ticker[i]['askPrice'])\n        assets[coin]['bid_price'] = float(ticker[i]['bidPrice'])\n        assets[coin]['ask_value'] = _N(assets[coin]['amount'] * assets[coin]['ask_price'], 2)\n        assets[coin]['bid_value'] = _N(assets[coin]['amount'] * assets[coin]['bid_price'], 2)\n        if coin not in trade_symbols:\n            continue\n        if assets[coin]['amount'] < 0 :\n            assets['USDT']['short_value'] += abs((assets[coin]['ask_value'] + assets[coin]['bid_value']) / 2)\n        else:\n            assets['USDT']['long_value'] += abs((assets[coin]['ask_value'] + assets[coin]['bid_value']) / 2)        \n        assets['USDT']['short_value'] = _N(assets['USDT']['short_value'], 0)\n        assets['USDT']['long_value'] = _N(assets['USDT']['long_value'], 0)    \n    updateIndex()\n    for i in range(len(trade_symbols)):\n        assets[trade_symbols[i]]['btc_diff'] = _N(assets[trade_symbols[i]]['btc_change'] - index, 4)\n\ndef trade(symbol, dirction, value) : #交易\n    if (int(time.time()*1000) - assets['USDT']['update_time'] > 10 * 1000):\n        Log('更新账户延时，不交易')\n    else:\n        price = assets[symbol]['bid_price'] if dirction == 'sell' else assets[symbol]['ask_price']\n        amount = _N(min(value, Ice_value) / price, trade_info[symbol]['amountSize'])\n        if amount < trade_info[symbol]['minQty']:\n            Log(symbol, '合约价值偏离或冰山委托订单的大小设置过小，达不到最小成交, 至少需要: ', _N(trade_info[symbol]['minQty'] * price, 0) + 1)\n        else:\n            exchange.IO(\"currency\", symbol + '_' + 'USDT')\n            exchange.SetContractType('swap')\n            exchange.SetDirection(dirction)\n            #f = 'Buy' if dirction == 'buy' else 'Sell'\n            place_order = getattr(exchange,'Buy' if dirction == 'buy' else 'Sell')\n            id = place_order(price, amount, symbol)\n            if id:\n                exchange.CancelOrder(id) #订单会立即撤销\n            tradingCounter('tradeVolume', price * amount) #保存交易量\n            tradingCounter('tradeNumber', 1) #保存交易次数\n            WinRateData[symbol]['tradeNumber'] += 1\n            if dirction == 'buy':\n                tradingCounter('buyNumber', 1)\n                WinRateData[symbol].buyNumber += 1\n            else:\n                tradingCounter('sellNumber', 1)\n                WinRateData[symbol].sellNumber += 1            \n            _G(\"WinRateData\", WinRateData) #保存各币种的交易数据\n            return id\n\ndef InitRateData():\n    global WinRateData\n    if Reset :\n        _G(\"WinRateData\", None)    \n    if _G(\"WinRateData\"):\n        WinRateData = _G(\"WinRateData\")    \n    for i in range(len(symbols)):        \n        if symbols[i] not in WinRateData:\n            WinRateData[symbols[i]] = {'totalProfit': 0, 'profitNumber': 0,'tradeNumber': 0,'buyNumber': 0, 'sellNumber': 0}\n                                            #统计次数        #盈利次数          #交易次数       #做多次数        #做空次数\n    _G(\"WinRateData\", WinRateData)\n\ndef RunCommand():\n    str_cmd = GetCommand()\n    if str_cmd:\n        arrCmd = str_cmd.split(':')\n        symbol = arrCmd[1]\n        amount = float(arrCmd[2])\n        if amount == 0:\n            Log('亲,你还记得大明湖畔的乔碧萝吗?' + danger)\n        else:\n            #f = 'Buy' if amount < 0 else 'Sell'\n            dirction = 'buy' if amount < 0 else 'sell'\n            exchange.IO(\"currency\", symbol + '_' + 'USDT')\n            exchange.SetContractType('swap')\n            exchange.SetDirection(dirction)\n            place_order = getattr(exchange,'Buy' if dirction == 'buy' else 'Sell')\n            id = place_order(-1, abs(amount), symbol)\n            #exchange[f](-1, abs(amount), symbol)\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)    \n    return initialAccount\n\ndef StartTime():\n    StartTime = _G(\"StartTime\")\n    if StartTime is None:\n        StartTime = _D()\n        _G(\"StartTime\", StartTime)    \n    return StartTime\n\ndef RuningTime():\n    ret = {}    \n    dateBegin = StartTime()\n    dateEnd = _D()\n    dateDiff = (time.mktime(time.strptime(dateEnd, '%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(dateBegin, '%Y-%m-%d %H:%M:%S'))) * 1000\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    leave1 = dateDiff % (24 * 3600 * 1000)\n    hours = math.floor(leave1 / (3600 * 1000))\n    leave2 = leave1 % (3600 * 1000)\n    minutes = math.floor(leave2 / (60 * 1000))\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = \"运行时间: \" + str(dayDiff) + \" 天 \" + str(hours) + \" 小时 \" + str(minutes) + \" 分钟\"\n    return ret\n\ndef AppendedStatus():\n    global TotalLong , TotalShort,RunTime,Funding, accountAssets\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\", \"止损\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    feeTable = {\n        'type': 'table',\n        'title': '交易统计',\n        'cols': [\"策略指数\", '交易次数', '做多次数', '做空次数', '预估胜率', '预估成交额', '预估手续费', \"未实现盈利\", '持仓总值', '做多总值', '做空总值'],\n        'rows': []\n    }\n    runday = RunTime['dayDiff']\n    if runday == 0:\n        runday = 1\n    if Funding == 0:\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])\n    profitColors = danger\n    totalProfit = assets['USDT']['total_balance'] - Funding #总盈利\n    if totalProfit > 0:\n        profitColors = success\n    dayProfit = totalProfit / runday #天盈利\n    dayRate = dayProfit / Funding * 100\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(assets['USDT']['stop_balance'], 2)) + danger,\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n    vloume = _G('tradeVolume') if _G('tradeVolume') is not None else 0\n    feeTable['rows'].append([\n        index, #指数\n        _G('tradeNumber') if _G('tradeNumber') is not None else 0, #交易次数\n        _G('buyNumber') if _G('buyNumber') is not None else 0, #做多次数\n        _G('sellNumber') if _G('sellNumber') is not None else 0, #做空次数\n        str(_N(_G('profitNumber') / _G('totalProfit') * 100, 2) if _G('totalProfit') > 0 else 0) + '%', #胜率\n        '$' + str(_N(vloume, 2)) + ' ≈ ฿' + str(_N(vloume / ((assets['BTC']['bid_price'] + assets['BTC']['ask_price']) / 2), 6)), #成交金额\n        '$' + str(_N(vloume * (SelfFee / 100), 4)), #手续费\n        '$' + str(_N(assets['USDT']['unrealised_profit'], 2)) + (success if assets['USDT']['unrealised_profit'] >= 0 else danger),\n        '$' + str(_N(TotalLong + abs(TotalShort), 2)), #持仓总价值\n        '$' + str(_N(TotalLong, 2)) + success, #做多总值\n        '$' + str(_N(abs(TotalShort), 2)) + danger, #做空总值\n    ])\n    assetTable = {\n        'type': 'table',\n        'title': '账户资产信息',\n        'cols': ['编号', '资产名', '起始保证金', '维持保证金', '保证金余额', '最大可提款金额', '挂单起始保证金', '持仓起始保证金', '持仓未实现盈亏', '账户余额'],\n        'rows': []\n    }\n    for i in range(len(accountAssets)):\n        acc = accountAssets[i]\n        assetTable['rows'].append([\n            i + 1,\n            acc['asset'], acc['initialMargin'], acc['maintMargin'], acc['marginBalance'],\n            acc['maxWithdrawAmount'], acc['openOrderInitialMargin'], acc['positionInitialMargin'],\n            acc['unrealizedProfit'], acc['walletBalance']\n        ])\n    indexTable = {\n        'type': 'table',\n        'title': '币指数信息',\n        'cols': ['编号', '币种信息', '当前价格', 'BTC计价', 'BTC计价变化(%)', '偏离平均', '交易次数', '做空次数', '做多次数', '预估胜率'],\n        'rows': []\n    }\n    for i in range(len(symbols)) :\n        price = _N((assets[symbols[i]]['ask_price'] + assets[symbols[i]]['bid_price']) / 2, trade_info[symbols[i]]['priceSize'])\n        if symbols[i] not in symbols:\n            indexTable['rows'].append([i + 1, symbols[i], price, assets[symbols[i]]['btc_price'], _N((1 - assets[symbols[i]]['btc_change']) * 100), assets[symbols[i]]['btc_diff']], 0, 0, 0, '0%')\n        else:\n            rateData = _G(\"WinRateData\")\n            winRate = _N(rateData[symbols[i]]['profitNumber'] / rateData[symbols[i]]['totalProfit'] * 100, 2) if rateData[symbols[i]]['totalProfit'] > 0 else 0\n            indexTable['rows'].append([\n                (i + 1),\n                symbols[i] + warning,\n                price,\n                _N(assets[symbols[i]]['btc_price'], 6),\n                _N((1 - assets[symbols[i]]['btc_change']) * 100),\n                str(assets[symbols[i]]['btc_diff']) + (success if assets[symbols[i]]['btc_diff'] >= 0 else danger),\n                rateData[symbols[i]]['tradeNumber'],\n                rateData[symbols[i]]['sellNumber'],\n                rateData[symbols[i]]['buyNumber'],\n                (str(winRate) if rateData[symbols[i]]['profitNumber'] > 0 and rateData[symbols[i]]['totalProfit'] > 0 else '0') + '%' + (success if winRate >= 50 else danger), #胜率\n            ])    \n    retData = {}\n    retData['upTable'] = RunTime['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version + '\\n' + '`' + json.dumps([accountTable, assetTable]) + '`\\n' + '`' + json.dumps(feeTable) + '`\\n'\n    retData['indexTable'] = indexTable\n    return retData\n\n\ndef WinRate():\n    global WinRateData\n    for i in range(len(symbols)) :\n        unrealised = assets[symbols[i]]['unrealised_profit']\n        WinRateData[symbols[i]]['totalProfit'] += 1\n        if unrealised != 0:\n            if unrealised > 0:\n                WinRateData[symbols[i]]['profitNumber'] += 1    \n    _G(\"WinRateData\", WinRateData)\n\ndef tradingCounter(key, newValue):\n    value = _G(key)\n    if value is None:\n        _G(key, newValue)\n    else:\n        _G(key, value + newValue)\n\ndef updateStatus() : #状态栏信息\n    global TotalLong , TotalShort,Funding,update_profit_time,UpProfit\n    TotalLong = 0\n    TotalShort = 0\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '强平差价', '持仓价值', '保证金', '未实现盈亏', '投降'],\n        'rows': []\n    }\n    \n    for i in range(len(symbols)):        \n        direction = '空仓'\n        margin = direction\n        if assets[symbols[i]]['amount'] != 0:\n            direction = '做多' + success if assets[symbols[i]]['amount'] > 0 else '做空' + danger\n            margin = '全仓' if assets[symbols[i]]['marginType'] == 'cross' else '逐仓'\n        price = _N((assets[symbols[i]]['ask_price'] + assets[symbols[i]]['bid_price']) / 2, trade_info[symbols[i]]['priceSize'])\n        value = _N((assets[symbols[i]]['ask_value'] + assets[symbols[i]]['bid_value']) / 2, 2)\n        if value != 0:\n            if value > 0:\n                TotalLong += value\n            else:\n                TotalShort += value\n        # rateData = _G(\"WinRateData\")\n        infoList = [\n            i + 1,\n            \"[\" + margin + \"] [\" + str(assets[symbols[i]]['leverage']) + 'x] ',\n            symbols[i],\n            direction,\n            abs(assets[symbols[i]]['amount']),\n            assets[symbols[i]]['hold_price'],\n            price,\n            assets[symbols[i]]['liquidationPrice'], #强平价格\n            '0' if assets[symbols[i]]['liquidationPrice'] == 0 else '$' + str(_N(assets[symbols[i]]['liquidationPrice'] - price, 5)) + ' ≈ ' + str(_N(assets[symbols[i]]['liquidationPrice'] / price * 100, 2)) + '%' + warning, #强平价格\n            abs(value),\n            _N(assets[symbols[i]]['positionInitialMargin'], 2),\n            # assets[symbols[i]]['btc_diff'],\n            str(_N(assets[symbols[i]]['unrealised_profit'], 3)) + (success if assets[symbols[i]]['unrealised_profit'] >= 0 else danger),\n            # (rateData[symbols[i]]['profit']Number > 0 and rateData[symbols[i]].totalProfit > 0 ? _N(rateData[symbols[i]]['profit']Number / rateData[symbols[i]].totalProfit * 100, 2) : '0') + '%', #胜率\n            {\n                'type': 'button',\n                'cmd': '说好的没有撤退可言呢？？?:' + symbols[i] + ':' + str(assets[symbols[i]]['amount']) + ':',\n                'name': symbols[i] + ' 投降'\n            }\n        ]\n        table['rows'].append(infoList)\n    #del assets['USDT']['update_time'] #时间戳没什么用,不要了\n    logString = json.dumps(assets['USDT']) + '\\n'\n    StatusData = AppendedStatus()\n    LogStatus(StatusData['upTable'] + '`' + json.dumps([table, StatusData['indexTable']]) + '`\\n' + logString)\n\n    if int(time.time()*1000) - update_profit_time > Log_profit_interval * 1000:\n        balance = assets['USDT']['margin_balance']\n        if Show:\n            balance = assets['USDT']['margin_balance'] - Funding\n        LogProfit(_N(balance, 3), '&')\n        update_profit_time = int(time.time()*1000)\n        if UpProfit != 0 and (_N(balance, 0) != UpProfit): #第一次不计算,并且小数点面的不进行胜率计算\n            tradingCounter(\"totalProfit\", 1) #统计打印次数, 胜率=盈利次数/打印次数*100\n            if _N(balance, 0) > UpProfit:\n                tradingCounter('profitNumber', 1) #盈利次数\n            WinRate()\n        UpProfit = _N(balance, 0)\n\ndef stopLoss() : #止损函数\n    while True:\n        if assets['USDT']['margin_balance'] < Stop_loss * assets['USDT']['init_balance'] and assets['USDT']['init_balance'] > 0:\n            Log('触发止损，当前资金：', assets['USDT']['margin_balance'], '初始资金：', assets['USDT']['init_balance'])\n            Ice_value = 200 #止损的快一些，可修改\n            updateAccount()\n            updateTick()\n            trading = False #是否正在交易\n            for i in range(len(trade_symbols)):\n                symbol = trade_symbols[i]\n                if assets[symbol]['ask_price'] == 0:\n                    continue                \n                if assets[symbol]['bid_value'] >= trade_info[symbol]['minQty'] * assets[symbol]['bid_price']:\n                    trade(symbol, 'sell', assets[symbol]['bid_value'])\n                    trading = True\n                if assets[symbol]['ask_value'] <= -trade_info[symbol]['minQty'] * assets[symbol]['ask_price']:\n                    trade(symbol, 'buy', -assets[symbol]['ask_value'])\n                    trading = True\n            Sleep(1000)\n            if not trading :\n                Log('止损结束,如果需要重新运行策略，需要调低止损') \n                exit()\n        else : #不用止损\n            return None\n\ndef onTick() : #策略逻辑部分\n    for i in range(len(trade_symbols)) :\n        symbol = trade_symbols[i]\n        if assets[symbol]['ask_price'] == 0:\n            continue        \n        aim_value = -Trade_value * _N(assets[symbol]['btc_diff'] / 0.01, 3)        \n        if aim_value - assets[symbol]['ask_value'] >= Adjust_value and assets[symbol]['btc_diff'] > Min_diff and assets['USDT']['long_value'] - assets['USDT']['short_value'] <= 1.1 * Trade_value:\n            Log('做多',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \n            trade(symbol, 'buy', aim_value - assets[symbol]['ask_value'])\n        if aim_value - assets[symbol]['bid_value'] <= -Adjust_value and assets[symbol]['btc_diff'] < Max_diff and assets['USDT']['short_value'] - assets['USDT']['long_value'] <= 1.1 * Trade_value:\n            Log('做空',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \n            trade(symbol, 'sell', -(aim_value - assets[symbol]['bid_value']))\n\ndef main():\n    global RunTime\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    while True:\n        RunTime = RuningTime()\n        RunCommand() #捕获交互命令\n        updateAccount() #更新账户和持仓\n        updateTick() #行情\n        stopLoss() #止损\n        onTick() #策略逻辑部分\n        updateStatus() #输出状态栏信息\n        Sleep(Interval * 1000)"}
{"query": "请生成一个布林均线突破_vnpy_botvs实现版策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''\n策略名称: BollingBreaker趋势策略\n策略作者: ipqhjjybj\n策略描述:  \n           这是将 botvs的接口用 Vnpy 的写法 方式简单封装掉，便于后期的调用！\n           这本来是期货的 策略， 直接改参数套在 比特币上。\n           期货上要切换到分钟级别， 比特币期货则用小时级别的\n           实盘时需要调整参数。\n           如有策略改进，请多多与本人交流   250657661\n\n           bar.minute.hour  代表是小时级别 \n           bar.minute.minute  代表是分钟级别\n\n           \n------------------------------------------------------------------\n\n          当前只支持 比特币OKCOIN 期货， 如果要弄到 CTP期货，需要微调\n\n趋势跟踪策略\n'''\nimport time\nfrom datetime import datetime\nimport numpy as np\nimport talib\n\nEMPTY_STRING = \"\"\nEMPTY_INT = 0\nEMPTY_FLOAT = 0.0\nEMPTY_UNICODE = u''\n\nDIRECTION_LONG = u'long'\nDIRECTION_SHORT = u'short'\n\nOFFSET_OPEN = u'kaicang'\nOFFSET_CLOSE = u'pingcang'\n\n# CTA引擎中涉及到的交易方向类型\nCTAORDER_BUY = \"buy\"\nCTAORDER_SELL = \"closebuy\"\nCTAORDER_SHORT = \"sell\"\nCTAORDER_COVER = \"closesell\"\n\n\n# 本地停止单状态\nSTOPORDER_WAITING = u'waiting'\nSTOPORDER_CANCELLED = u'canceled'\nSTOPORDER_TRIGGERED = u'touched'\n\n# 本地停止单前缀\nSTOPORDERPREFIX = 'CtaStopOrder'\n\n\n\n########################################################################\nclass VtBarData:\n    \"\"\"K线数据\"\"\"\n\n    #----------------------------------------------------------------------\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        \n        self.vtSymbol = EMPTY_STRING        # vt系统代码\n        self.symbol = EMPTY_STRING          # 代码\n        self.exchange = EMPTY_STRING        # 交易所\n    \n        self.open = EMPTY_FLOAT             # OHLC\n        self.high = EMPTY_FLOAT\n        self.low = EMPTY_FLOAT\n        self.close = EMPTY_FLOAT\n        \n        self.date = EMPTY_STRING            # bar开始的时间，日期\n        self.time = EMPTY_STRING            # 时间\n        self.datetime = None                # python的datetime时间对象\n        \n        self.volume = EMPTY_INT             # 成交量\n        self.openInterest = EMPTY_INT       # 持仓量    \n\n########################################################################\nclass VtTickData:\n    \"\"\"Tick行情数据类\"\"\"\n\n    #----------------------------------------------------------------------\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        \n        # 代码相关\n        self.exchange = EMPTY_STRING            # 交易所代码\n        self.vtSymbol = EMPTY_STRING            # 合约在vt系统中的唯一代码，通常是 合约代码.交易所代码\n        \n        # 成交数据\n        self.lastPrice = EMPTY_FLOAT            # 最新成交价\n        self.lastVolume = EMPTY_INT             # 最新成交量\n        self.volume = EMPTY_INT                 # 今天总成交量\n        self.openInterest = EMPTY_INT           # 持仓量\n        self.time = EMPTY_STRING                # 时间 11:20:56.5\n        self.date = EMPTY_STRING                # 日期 20151009\n        self.datetime = None                    # python的datetime时间对象\n        \n        # 常规行情\n        self.openPrice = EMPTY_FLOAT            # 今日开盘价\n        self.highPrice = EMPTY_FLOAT            # 今日最高价\n        self.lowPrice = EMPTY_FLOAT             # 今日最低价\n        self.preClosePrice = EMPTY_FLOAT\n        \n        self.upperLimit = EMPTY_FLOAT           # 涨停价\n        self.lowerLimit = EMPTY_FLOAT           # 跌停价\n        \n        # 五档行情\n        self.bidPrice1 = EMPTY_FLOAT\n        self.bidPrice2 = EMPTY_FLOAT\n        self.bidPrice3 = EMPTY_FLOAT\n        self.bidPrice4 = EMPTY_FLOAT\n        self.bidPrice5 = EMPTY_FLOAT\n        \n        self.askPrice1 = EMPTY_FLOAT\n        self.askPrice2 = EMPTY_FLOAT\n        self.askPrice3 = EMPTY_FLOAT\n        self.askPrice4 = EMPTY_FLOAT\n        self.askPrice5 = EMPTY_FLOAT        \n        \n        self.bidVolume1 = EMPTY_INT\n        self.bidVolume2 = EMPTY_INT\n        self.bidVolume3 = EMPTY_INT\n        self.bidVolume4 = EMPTY_INT\n        self.bidVolume5 = EMPTY_INT\n        \n        self.askVolume1 = EMPTY_INT\n        self.askVolume2 = EMPTY_INT\n        self.askVolume3 = EMPTY_INT\n        self.askVolume4 = EMPTY_INT\n        self.askVolume5 = EMPTY_INT         \n\n\n########################################################################\nclass StopOrder(object):\n    \"\"\"本地停止单\"\"\"\n\n    #----------------------------------------------------------------------\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        self.vtSymbol = EMPTY_STRING\n        self.orderType = EMPTY_UNICODE\n        self.direction = EMPTY_UNICODE\n        self.offset = EMPTY_UNICODE\n        self.price = EMPTY_FLOAT\n        self.volume = EMPTY_INT\n        \n        self.strategy = None             # 下停止单的策略对象\n        self.stopOrderID = EMPTY_STRING  # 停止单的本地编号 \n        self.status = EMPTY_STRING       # 停止单状态\n\n\nclass BollingerBreakerStrategy:\n    #品种属性\n    vtSymbol = EMPTY_STRING # 是什么品种\n\n    # 策略参数\n    minute_use = 6              # 多少分钟级别的K线\n\n    bar = None                  # 1分钟K线对象\n    fiveBar = None              # 1分钟K线对象\n\n    # 策略参数\n    bollLength = 20         # 通道窗口数\n    topDev = 1.3            # 开仓偏差\n    trailingPrcnt = 2       # 移动止损百分比\n    use_range = 10          # use_range天内有突破最高价\n    N = 10                  # 多少天突破\n\n    bufferSize = 40                     # 需要缓存的数据的大小\n    bufferCount = 0                     # 目前已经缓存了的数据的计数\n\n\n    realBuyCond = 0                     # 买卖的状态\n    realSellCond = 0                    # 买卖的状态\n    \n    bollMid = 0                         # 布林带中轨\n    bollStd = 0                         # 布林带宽度\n    entryUp = 0                         # 开仓上轨\n\n    barMinute = EMPTY_STRING            # K线当前的分钟\n\n    fixedSize = 1\n\n    stopOrderCount = 0                  # 记录停止单的数量\n\n    pos = 0                             # 仓位\n\n    LastBarTime = None                  # python 上一根Tick\n\n    currency = EMPTY_STRING\n\n    def __init__(self, _exchange , setting ):\n        self.exchange = _exchange\n        for key in setting.keys():\n            if key == \"vtSymbol\":\n                self.vtSymbol = setting[key]\n            if key == \"currency\":\n                self.currency = setting[key]\n            if key == 'minute_use':\n                self.minute_use = setting[key]\n            if key == \"bollLength\":\n                self.bollLength = setting[key]\n            if key == \"topDev\":\n                self.topDev = setting[key]\n            if key == \"trailingPrcnt\":\n                self.trailingPrcnt = setting[key]\n            if key == \"use_range\":\n                self.use_range = setting[key]\n            if key == \"N\":\n                self.N = setting[key]\n        Log(setting)\n\n        self.pos = 0\n        self.order_PreUse = {}            # vtPreID , pushDealAmount  已经推送过的成交数据\n        self.workingStopOrderDict = {}\n        self.stopOrderDict = {}\n        self.orderList = []               # 保存委托代码的列表\n        self.fixedSize = 1\n        ##################\n        self.bufferSize = 40\n        #################\n        self.highArray = np.zeros(self.bufferSize) \n        self.lowArray = np.zeros(self.bufferSize)\n        self.closeArray = np.zeros(self.bufferSize)\n        \n        self.buyValue = np.zeros(self.bufferSize)\n\n\n    def onCall(self):\n        try:\n            #self.exchange.IO(\"currency\" , self.currency)\n            need_remove = []\n            for orderId in self.orderList:\n                # 订单状态, 参考常量里的订单状态，以下是此键值的常量。\n                # ORDER_STATE_PENDING  :未完成\n                # ORDER_STATE_CLOSED   :已关闭   已完成\n                # ORDER_STATE_CANCELED :已取消\n                # STOPORDERPREFIX 是否是 系统内部的 停止单\n                if orderId != None and type(orderId) != type(1) and STOPORDERPREFIX in orderId:\n                    continue\n                botvsOrder = self.exchange.GetOrder(orderId)\n                preAmount = 0.0\n                if botvsOrder != None:\n                    if botvsOrder[\"Status\"] in [ORDER_STATE_CLOSED,ORDER_STATE_CANCELED]:\n                        try:\n                            preAmount = self.order_PreUse[orderId]\n                        except Exception,ex:\n                            Log(\"Error in preAmount\",ex)\n                            preAmount = 0.0\n                        Log(\"preAmount:\" , preAmount)\n                        incAmount = botvsOrder[\"DealAmount\"] - preAmount\n                        if incAmount > 0:\n                            self.order_PreUse[orderId] = botvsOrder[\"DealAmount\"]\n                            botvsOrder[\"preAmount\"] = preAmount\n                            botvsOrder[\"incAmount\"] = incAmount\n                            self.onTrade( botvsOrder )\n\n\n                    if botvsOrder[\"Status\"] == ORDER_STATE_CLOSED:\n                        need_remove.append(orderId)\n                else:\n                    Log(\"None order!\")\n\n            for orderId in need_remove:\n                Log(\"remove order:\" , orderId)\n                self.orderList.remove(orderId)\n\n            \n            # Log(\"currency\",self.currency)\n            botvsTick = self.exchange.GetTicker()\n\n\n            if self.LastBarTime != botvsTick[\"Time\"]:\n                newTick = VtTickData()\n                newTick.datetime = datetime.fromtimestamp(botvsTick[\"Time\"] / 1000.0)\n                newTick.vtSymbol = self.vtSymbol\n                newTick.lastPrice = float(botvsTick[\"Last\"])\n                newTick.lastVolume = float(botvsTick[\"Volume\"])\n                newTick.volume = float(botvsTick[\"Volume\"])\n                newTick.highPrice = float(botvsTick[\"High\"])\n                newTick.lowPrice = float(botvsTick[\"Low\"])\n\n                newTick.upperLimit = newTick.highPrice * 1.03\n                newTick.lowerLimit = newTick.lowPrice * 0.97\n\n                newTick.exchange = self.exchange.GetName()\n\n                newTick.date = newTick.datetime.strftime(\"%Y%m%d\")\n                newTick.time = newTick.datetime.strftime(\"%Y:%m:%d\")\n\n                self.onTick(newTick)\n\n                self.processStopOrder(newTick)\n        except Exception,ex:\n            Log(ex , \"error in onCall , maybe getTicker wrong!\")\n\n    #----------------------------------------------------------------------\n    def onTrade(self, trade):\n        # 发出状态更新事件\n        #'Type': 0           # 订单类型, 参考常量里的订单类型，以下是此键值的常量。\n                             # ORDER_TYPE_BUY   :买单\n                             # ORDER_TYPE_SELL  :卖单\n        try:\n            Log(\"trade:\",trade)\n            newPos = 0.0\n            if trade[\"Type\"] == ORDER_TYPE_BUY:\n                newPos += trade[\"incAmount\"]\n            elif trade[\"Type\"] == ORDER_TYPE_SELL:\n                newPos -= trade[\"incAmount\"]\n            else:\n                Log(\"What ? trade Type error!\")\n            self.pos += newPos\n        except Exception,ex:\n            print ex\n    #----------------------------------------------------------------------\n    def processStopOrder(self, tick):\n        \"\"\"收到行情后处理本地停止单（检查是否要立即发出）\"\"\"\n        vtSymbol = tick.vtSymbol\n        \n        # 遍历等待中的停止单，检查是否会被触发\n        for so in self.workingStopOrderDict.values():\n            if so.vtSymbol == vtSymbol:\n                longTriggered = so.direction==DIRECTION_LONG and tick.lastPrice>=so.price        # 多头停止单被触发\n                shortTriggered = so.direction==DIRECTION_SHORT and tick.lastPrice<=so.price     # 空头停止单被触发\n                \n                if longTriggered or shortTriggered:\n                    # 买入和卖出分别以涨停跌停价发单（模拟市价单）\n                    if so.direction==DIRECTION_LONG:\n                        price = tick.upperLimit\n                    else:\n                        price = tick.lowerLimit\n                    \n                    so.status = STOPORDER_TRIGGERED\n                    orderIDList = self.sendOrder(so.vtSymbol, so.orderType, price, so.volume, False ,so.strategy)\n                    for orderID in orderIDList:\n                        self.orderList.append(orderID)\n                    del self.workingStopOrderDict[so.stopOrderID]\n                    so.strategy.onStopOrder(so)\n\n    def onStopOrder(self, vtStopOrder):\n        Log(\"stopOrder Deal ID:\", vtStopOrder.stopOrderID , vtStopOrder.status )\n\n    def sendStopOrder(self, vtSymbol, orderType, price, volume, strategy ):\n        \"\"\"发停止单（本地实现）\"\"\"\n        self.stopOrderCount += 1\n        stopOrderID = STOPORDERPREFIX + str(self.vtSymbol) + str(self.stopOrderCount)\n\n        so = StopOrder()\n        so.vtSymbol = vtSymbol\n        so.orderType = orderType\n        so.price = price\n        so.volume = volume\n        so.strategy = strategy\n        so.stopOrderID = stopOrderID\n        so.status = STOPORDER_WAITING\n\n        if orderType == CTAORDER_BUY:\n            so.direction = DIRECTION_LONG\n            so.offset = OFFSET_OPEN\n        elif orderType == CTAORDER_SELL:\n            so.direction = DIRECTION_SHORT\n            so.offset = OFFSET_CLOSE\n        elif orderType == CTAORDER_SHORT:\n            so.direction = DIRECTION_SHORT\n            so.offset = OFFSET_OPEN\n        elif orderType == CTAORDER_COVER:\n            so.direction = DIRECTION_LONG\n            so.offset = OFFSET_CLOSE      \n\n        # 保存stopOrder对象到字典中\n        self.stopOrderDict[stopOrderID] = so\n        self.workingStopOrderDict[stopOrderID] = so\n        \n        # 推送停止单状态\n        strategy.onStopOrder(so)\n        return stopOrderID\n\n    def sendOrder(self , vtSymbol , orderType , price, volume , stop , strategy ):\n        #   id1 = exchange.Buy(4300,1)     # 日期                  平台    类型  价格     数量   信息\n        #                                  # 2016-10-21 00:00:00  OKCoin  买入  4300     1\n        #   id2 = exchange.Buy(-1, 8000)   # 市价单 的第二个参数的意义是  购买8000金额的 币数。\n        #   id1 = exchange.Sell(4300,1)    #     日期                     平台        类型      价格      数量     信息\n        #                                  #     2016-10-21 00:00:00     OKCoin      卖出      市价单     1    \n        # id2 = exchange.Sell(-1, 1)       #     日期                     平台        类型      价格      数量     信息\n                                           #     2016-10-21 00:00:00     OKCoin      卖出      4300      1\n                                           # 一般错误提示： 小于允许的最小交易单位，大部分是这个原因（参数1是1块钱而不是1个币）。\n        if stop == True:\n            vtOrderID = self.sendStopOrder(self.vtSymbol, orderType, price, volume, self)\n            return vtOrderID\n        else:\n            ret_order_list = []\n            self.exchange.SetDirection( orderType )\n            if orderType in [ CTAORDER_BUY , CTAORDER_COVER]:\n                ret_order_list.append( self.exchange.Buy( price , volume ))\n            elif orderType in [CTAORDER_SELL , CTAORDER_SHORT]:\n                ret_order_list.append( self.exchange.Sell( price , volume ))\n            return ret_order_list\n\n    def buy(self , price , volume , stop = False):\n        Log(CTAORDER_BUY,price,volume)\n        return self.sendOrder( self.vtSymbol , CTAORDER_BUY , price , volume , stop , self)\n    def sell(self , price , volume , stop = False):\n        Log(CTAORDER_SELL,price,volume)\n        return self.sendOrder( self.vtSymbol , CTAORDER_SELL , price , volume , stop , self)\n    def short(self , price , volume , stop = False):\n        Log(CTAORDER_SELL,price,volume)\n        return self.sendOrder( self.vtSymbol , CTAORDER_SHORT , price , volume , stop , self)\n    def cover(self , price , volume , stop = False):\n        Log(\"cover\",price,volume)\n        return self.sendOrder( self.vtSymbol , CTAORDER_COVER , price , volume , stop , self)\n\n    #----------------------------------------------------------------------\n    def cancelStopOrder(self, stopOrderID):\n        \"\"\"撤销停止单\"\"\"\n        # 检查停止单是否存在\n        if stopOrderID in self.workingStopOrderDict:\n            so = self.workingStopOrderDict[stopOrderID]\n            so.status = STOPORDER_CANCELLED\n            del self.workingStopOrderDict[stopOrderID]\n            so.strategy.onStopOrder(so)\n\n        if stopOrderID in self.orderList:\n            self.orderList.remove(stopOrderID)\n\n    def cancelOrder(self , vtOrderId):\n        Log(\"cancelOrder:\",vtOrderId)\n        if STOPORDERPREFIX in vtOrderId:\n            self.cancelStopOrder(vtOrderId)\n        else:\n            self.exchange.CancelOrder(vtOrderId)\n\n    def onTick(self, tick):\n\n        # self.orderList = []\n        # orderIDList = self.buy(tick.lastPrice , abs(self.fixedSize))\n        # #Log( str(self.vtSymbol) + \" cover 0 1 \" + str(self.fixedSize) +\" \" +str(','.join(orderIDList))  + \"\\n\")\n        # #print str(self.vtSymbol) , \"cover 0 1\" , self.fixedSize , orderID\n        # for orderID in orderIDList:\n        #     self.orderList.append(orderID)\n\n        # 聚合为1分钟K线\n        tickMinute = tick.datetime.hour\n\n        if tickMinute != self.barMinute:  \n            if self.bar:\n                self.onBar(self.bar)\n\n            bar = VtBarData()              \n            bar.vtSymbol = tick.vtSymbol\n            bar.exchange = tick.exchange\n\n            bar.open = tick.lastPrice\n            bar.high = tick.lastPrice\n            bar.low = tick.lastPrice\n            bar.close = tick.lastPrice\n\n            bar.date = tick.date\n            bar.time = tick.time\n            bar.datetime = tick.datetime    # K线的时间设为第一个Tick的时间\n\n            self.bar = bar                  # 这种写法为了减少一层访问，加快速度\n            self.barMinute = tickMinute     # 更新当前的分钟\n        else:                               # 否则继续累加新的K线\n            bar = self.bar                  # 写法同样为了加快速度\n\n            bar.high = max(bar.high, tick.lastPrice)\n            bar.low = min(bar.low, tick.lastPrice)\n            bar.close = tick.lastPrice\n\n    def onBar(self , bar):\n        \n        if bar.datetime.hour  % self.minute_use == 0:         # bar.datetime.minute 则切换成分钟级别\n            # 如果已经有聚合5分钟K线\n            if self.fiveBar:\n                # 将最新分钟的数据更新到目前5分钟线中\n                fiveBar = self.fiveBar\n                fiveBar.high = max(fiveBar.high, bar.high)\n                fiveBar.low = min(fiveBar.low, bar.low)\n                fiveBar.close = bar.close\n                \n                # 推送5分钟线数据\n                self.onFiveBar(fiveBar)\n                \n                # 清空5分钟线数据缓存\n                self.fiveBar = None\n        else:\n            # 如果没有缓存则新建\n            if not self.fiveBar:\n                fiveBar = VtBarData()\n                \n                fiveBar.vtSymbol = bar.vtSymbol\n                fiveBar.symbol = bar.symbol\n                fiveBar.exchange = bar.exchange\n            \n                fiveBar.open = bar.open\n                fiveBar.high = bar.high\n                fiveBar.low = bar.low\n                fiveBar.close = bar.close\n            \n                fiveBar.date = bar.date\n                fiveBar.time = bar.time\n                fiveBar.datetime = bar.datetime \n                \n                self.fiveBar = fiveBar\n            else:\n                fiveBar = self.fiveBar\n                fiveBar.high = max(fiveBar.high, bar.high)\n                fiveBar.low = min(fiveBar.low, bar.low)\n                fiveBar.close = bar.close\n\n\n    def onFiveBar(self , bar):\n        #Log( self.currency , bar.close , self.pos , self.orderList)\n\n        for orderID in self.orderList:\n            self.cancelOrder(orderID)\n        self.orderList = []\n    \n        # 保存K线数据\n        self.closeArray[0:self.bufferSize-1] = self.closeArray[1:self.bufferSize]\n        self.highArray[0:self.bufferSize-1] = self.highArray[1:self.bufferSize]\n        self.lowArray[0:self.bufferSize-1] = self.lowArray[1:self.bufferSize]\n        self.buyValue[0:self.bufferSize-1] = self.buyValue[1:self.bufferSize]\n\n        self.closeArray[-1] = bar.close\n        self.highArray[-1] = bar.high\n        self.lowArray[-1] = bar.low\n    \n        # 计算指标数值\n        self.bollMid = talib.MA(self.closeArray, self.bollLength)[-1]\n        self.bollStd = talib.STDDEV(self.closeArray, self.bollLength)[-1]\n        self.entryUp = self.bollMid + self.bollStd * self.topDev\n\n        self.buyValue[-1] = self.entryUp\n\n        self.bufferCount += 1\n        if self.bufferCount < self.bufferSize:\n            return\n\n        # 判断是否要进行交易\n        cond1 = 0\n        for i in range(1 , self.use_range + 1):\n            if self.highArray[-i] > self.buyValue[-i]:\n                cond1 = 1\n        cond2 = 0\n\n        # newHigh = [float(x) for x in self.highArray]\n        # if bar.high >= max(newHigh[-self.N : ]) and self.highArray[-2] >= max(newHigh[-self.N-1 : -1]):\n        #     cond2 = 1\n        if self.pos == 0 and cond1 > 0:\n            self.intraTradeHigh = bar.high\n            newHigh = [float(x) for x in self.highArray]\n            entryBuyPrice = max(newHigh[-self.N:])\n            orderID = self.buy( entryBuyPrice, self.fixedSize , stop=True)\n            self.orderList.append(orderID)\n\n        elif self.pos > 0:\n            self.intraTradeHigh = max(bar.high , self.intraTradeHigh)\n            exitPrice = self.intraTradeHigh * (1 - self.trailingPrcnt / 100.0) \n            orderID = self.sell( exitPrice , self.fixedSize , stop=True)\n            self.orderList.append(orderID)\n\n'''\nbollLength = 20         # 通道窗口数\ntopDev = 1.3            # 开仓偏差\ntrailingPrcnt = 2       # 移动止损百分比\nuse_range = 10          # use_range天内有突破最高价\nN = 10                  # 多少天突破\n'''\nrunning_key = {\n    \"BTC\":{ \"bollLength\":20 , \"topDev\":1.3 , \"trailingPrcnt\": 2 , \"use_range\": 10 , \"N\":10 , \"minute_use\": 6},\n    \"LTC\":{ \"bollLength\":20 , \"topDev\":1.3 , \"trailingPrcnt\": 2 , \"use_range\": 10 , \"N\":10 , \"minute_use\": 6}\n}\n\ndef main():\n    global LoopInterval \n\n    objs = []\n    for e in exchanges:\n        if e.GetName() != 'Futures_OKCoin':\n            raise Error_noSupport\n        e.SetRate(1)\n        use_symbol = [\"this_week\",\"next_week\",\"quarter\"][ContractTypeIdx]\n        e.SetContractType(use_symbol) \n        e.SetMarginLevel([10,20][MarginLevelIdx])\n\n        e_currency = e.GetCurrency().upper()\n        Log(e_currency)\n        st = BollingerBreakerStrategy(e , {\n        \"vtSymbol\":e.GetName() + \"_\" + use_symbol + \"_\" + e.GetCurrency(), \n        \"currency\":e_currency,\n        \"minute_use\":running_key[e_currency][\"minute_use\"],\n        \"bollLength\":running_key[e_currency][\"bollLength\"],\n        \"topDev\": running_key[e_currency][\"topDev\"],\n        \"trailingPrcnt\": running_key[e_currency][\"trailingPrcnt\"],\n        \"use_range\": running_key[e_currency][\"use_range\"],\n        \"N\": running_key[e_currency][\"N\"]\n        })\n\n        objs.append(st)\n\n    while True:\n        for st in objs:\n            st.onCall()\n        Sleep(LoopInterval * 1000)"}
{"query": "请生成一个干货-下单量精度和价格精度-适用各个交易所策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nfrom collections import Counter\ndef GetAmountPrecision():\n    depth = _C(exchange.GetDepth)    \n    amountPrecisions = []\n    for ask in depth[\"Asks\"]:\n        i = ask[\"Amount\"]\n        amountPrecision = 0\n        if str(i).count('.') == 1:\n            amountPrecision = len(str(i).split(\".\")[1])\n        amountPrecisions.append(amountPrecision)\n    amountPrecision = max(amountPrecisions)    \n    return amountPrecision\n\ndef GetPricePrecision():\n    depth = _C(exchange.GetDepth)    \n    pricePrecisions = []\n    for ask in depth[\"Asks\"]:\n        j = ask[\"Price\"]\n        pricePrecision = 0\n        if str(j).count('.') == 1:\n            pricePrecision = len(str(j).split(\".\")[1])\n        pricePrecisions.append(pricePrecision)\n    pricePrecision = Counter(pricePrecisions).most_common(1)[0][0]\n    return pricePrecision"}
{"query": "请生成一个干货-选币系统-选币因子策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport numpy as np\nfrom scipy.stats import norm\nfrom sklearn import preprocessing\nimport json\n\n#计算波动率因子值\ndef GetAtrFactorService(records):\n    atrlength = 14\n    atrs = TA.ATR(records, atrlength)\n    acs = sorted(range(len(atrs)), key=lambda k: atrs[k])\n    ac = acs[-1]\n    arr_mean = np.mean(acs)\n    arr_std = np.std(acs,ddof=1)\n    p = norm.cdf(x=ac, loc=arr_mean, scale = arr_std)\n    #P值越大，波动性越大\n    atrFactor = _N(p,3)\n    return atrFactor \n\n#计算机构的行为痕迹因子值        \ndef GetITFactorService(records):\n    #本福特定律分布频数\n    PN = [301, 176, 125, 97, 79, 67, 58, 51, 46]\n    FN = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n    for i in range(len(records)):\n        valume = records[i]['Volume']*10000\n        strValume = str(valume)\n        num = strValume[0]\n        for j in range(len(FN)):\n            key = j + 1\n            if int(num) == key:\n                FN[j] += 1\n    if sum(FN) == 0:\n        FN = PN\n    X = 0\n    for i in range(len(PN)):\n        X += (FN[i] - PN[i])**2\n    ITFactor = X\n    #X 的数值越大，则成交量数据与本福特理想分布的偏离越大，机构的行为痕迹也越大\n    return ITFactor\n\n#计算价格因子值\ndef GetPriceFactorService(records):\n    record = records[-1]\n    price = record[\"Close\"]\n    PFactor = 1/price \n    #PFactor数值越大，则价格越小 \n    return PFactor \n\n#标准化处理   --计算出来的因子值因为数量级不同，要进行标准化处理。暂不处理空值、异常值\ndef StandardizedService(factor):\n    # 标准化处理\n    factorArray = np.asarray(factor)\n    factorArray = preprocessing.scale(factorArray)\n    factor = factorArray.tolist()\n\next.GetAtrFactorService = GetArtFactorService \next.GetITFactorService = GetITFactorService \next.GetPriceFactorService = GetPriceFactorService \next.StandardizedService = StandardizedService"}
{"query": "请生成一个幽灵趋势跟踪策略策略代码", "base_model_response": "这个策略要以日历表的形式展示每个月的活动，并将每个事件分类为不同的类型\n\n例如，每周一，周五的活动是“活动”，周六和周日的活动是“活动”，周一到周六的活动是“其他”\n\n以下是一个使用Python和Tkinter库的简单例子：\n\n```python\nimport tkinter as tk\nfrom datetime import datetime, timedelta\n\nclass幽灵Track:\n    def __init__(self, root):\n        self.root = root\n\n    def add_event(self, event):\n        # 将事件添加到时间轴中\n        self.root历历().addEvent(event)\n\n    def categorize_event(self, event):\n        # 将事件划分为活动、活动和其他类别\n        categories = {\"活动\": [event], \"活动及其他\": []}\n        for category in categories:\n            if event.category == category:\n                self categorize_event(category)\n        return categories\n\ndef track幽灵Events(root):\n    while True:\n        events = []\n        today = datetime.now()\n        total_days = len(days_to要看)\n        for i in range(total_days):\n            event_date = today.replace(day=1)\n            for event_category in categorized events.get(event_date, []):\n                event = {\n                    'category': event_category,\n                    'date': event_date,\n                }\n                events.append(event)\n\n        new_root = tk.Tk(root)\n        new_root.title(\"幽灵趋势跟踪\")\n\n        current_events = [(event for event, category in events.items()) for event in newroot历历()]\n        date_range = [[int(f\"{i+1}/{total_days})}{int(d-1)}\"] for i in range(len(current_events)) + timedelta(days=365)\n        events_per_month = [current_events[i][0] for i in range(1, len(current_events) + 2)]\n        start_date = start_date for i in range(1, len(current_events) + 2)\n\n        for start_date, end_date in date_range:\n            start_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n            end_date = datetime.strptime(end_date, \"%Y-%m-%d\")\n            start_date_index = random.randint(1, len(current_events))\n            end_date_index = random.randint(1, len(current_events))\n\n            total_day = (end_date_index - start_date_index).days\n\n            new_date = start_date + timedelta(days=int((total_day/365) - 72.5))\n            new_events = [(new_date for event, category in events.items()) for event in newroot历历()]\n\n        print(\"\\n当前日期前一周的活动：\", new_events)\n        print(\"\\n每个月的活动：\", new_events_per_month)\n        print(\"\\n总计天数：\", len(new_events))\n\nif __name__ == \"__main__\":\n    track幽灵Events(tk.Tk())\n```\n\n这个程序会创建一个日历表格，并记录每个月的活动。每个事件都有两个可能分类（\"活动\"或\"活动及其他\")。每个月的活动会被包含在一个列表中。\n\n请注意，这只是一个基本的方案，实际的项目可能会更复杂，包括处理更多的事件，更灵活的时间范围等。", "lora_model_response": "```python\n# 贝林顿模式\ndef python_bern顿(n, p):\n    if p is None:\n        return 0.5 * (1 + log(2) - n / float(p))\n    elif p == 0:\n        return 0.5 * log(2) - 3\n    else:\n        return 0.6 * ((n / float(p)) * ((log(2) - 0.5) * log(2) - n / float(p)) + log(2) - 0.4)\n\n# 针对Python的贝林顿模式，我们创建了一个新函数：pymPyBern顿。\ndef pympy bern顿(p, n):\n    if p < 0:\n        return 0.5 * (1 + log(2) - n / float(p))\n    elif p > 0:\n        return 0.6 * ((n / float(p)) * ((log(2) - 0.5) * log(2) - n / float(p)) + log(2) - 0.3)\n\ndef main():\n    # 输入参数：\n    # n：目标值（使用字符串形式表示）\n    # p：目标值（使用字符串形式表示）\n    n = int(input(\"请输入n值：\"))\n    # 计算贝林顿模式的计算结果\n    b = pympy bern顿(n, p)\n    \n    # 检查结果是否为Python贝林顿模式\n    if p < 0:\n        print('输入错误，请输入正数。')\n        return\n    \n    # 如果输入的是Python贝林顿模式，输出结果\n    if b == pynpy bern顿(b, n):\n        print(f'计算的结果是：{b}')\n    else:\n        print(f'输入错误，请输入正数。')\n\nif __name__ == \"__main__\":\n    main()\n```\n\n这个策略代码首先定义了贝林顿模式的基本函数`python_bern顿`和一个新函数`mympy bern顿`。然后在主函数中，程序根据用户输入的参数计算贝林顿模式并输出计算结果。如果用户输入的不是正数，则会提示错误。", "original_response": "python\nimport json\nimport traceback\n#SYMBOLS = ['1INCH_USDT','ADA_USDT','ALGO_USDT','ATOM_USDT','AVAX_USDT','AAVE_USDT','AXS_USDT',\n#           'BAND_USDT','BCH_USDT','BTC_USDT','COMP_USDT','CHZ_USDT','CRV_USDT','CVC_USDT','DOGE_USDT'\n#           ,'DOT_USDT','DYDX_USDT','DASH_USDT','EGLD_USDT','ENJ_USDT','ENS_USDT','EOS_USDT','ETH_USDT',\n#           'ETC_USDT','FIL_USDT','FTM_USDT','GALA_USDT','GRT_USDT','IOTA_USDT','ICP_USDT','KSM_USDT',\n#           'LINK_USDT','LRC_USDT','LTC_USDT','MANA_USDT','MATIC_USDT','NEAR_USDT','OMG_USDT','SAND_USDT',\n #          'SC_USDT','1000SHIB_USDT','SOL_USDT','SRM_USDT','STORJ_USDT','SUSHI_USDT','THETA_USDT','TRX_USDT',\n  #         'UNI_USDT','XRP_USDT','XLM_USDT','XMR_USDT','XTZ_USDT','YFI_USDT','ZEC_USDT','PEOPLE_USDT',\n  #         'APE_USDT','GMT_USDT','ZIL_USDT','KNC_USDT']\nSYMBOLS = ['1INCH_USDT','ALGO_USDT','ATOM_USDT','AVAX_USDT','AAVE_USDT','AXS_USDT',\n           'BAND_USDT','BCH_USDT','BTC_USDT','COMP_USDT','CVC_USDT','DOGE_USDT'\n           ,'DOT_USDT','DYDX_USDT','DASH_USDT','EGLD_USDT','ENJ_USDT','ENS_USDT','EOS_USDT','ETH_USDT',\n           'ETC_USDT','FTM_USDT','GALA_USDT','GRT_USDT','IOTA_USDT','KSM_USDT',\n           'LINK_USDT','LRC_USDT','LTC_USDT','MANA_USDT','MATIC_USDT','NEAR_USDT','OMG_USDT','SAND_USDT',\n           'SC_USDT','SOL_USDT','SRM_USDT','SUSHI_USDT','THETA_USDT','TRX_USDT',\n           'UNI_USDT','XRP_USDT','XLM_USDT','XMR_USDT','XTZ_USDT','YFI_USDT','ZEC_USDT','PEOPLE_USDT',\n           'APE_USDT','ZIL_USDT','KNC_USDT']\n#主函数\ndef main():\n    try:\n        while True:\n            flage = ext.GetStopService()\n            if flage == 1:\n                break\n            #策略交互\n            ext.GetCommandService()\n            #选币功能\n            ext.GetSymbolService()\n            #下单信号 \n            ext.FirstSignalService()\n            #减仓信号\n            ext.StopSurplusService()\n            #展示数据\n            ext.UpdateLogStatusService()\n            Sleep(tickInterval)\n    except Exception as e:\n        Log(traceback.format_exc())\n        Log(\"策略已停止，请及时查看@\")\n    \n#初始化函数        \ndef init():\n    Log(\"策略开始\")\n    #设置合约永续\n    if len(exchanges) != 2:\n        Log(\"需要设置两组交易对\")\n        return\n    symbolRecord = _G(\"symbolRecord\")\n    Log(\"symbolRecord:\",symbolRecord)\n    if symbolRecord is not None:\n        symbol = symbolRecord['symbol']\n        exchange.SetCurrency(symbol) \n    _G(\"symbolRecord\",None)\n    exchange.SetContractType(\"swap\")\n    exchange.SetMarginLevel(leverage)\n    exchanges[1].SetContractType(\"swap\")\n    exchanges[1].SetMarginLevel(leverage)\n    _G(\"orderValue\",orderValue)\n    _G(\"leverage\",leverage)\n    _G(\"bfCount\",bfCount)\n    _G(\"symbols\",SYMBOLS)\n    _G(\"isFlag\",isFlag)\n    _G(\"isUpdate\",0)\n    _G(\"stopSurplus\",stopSurplus)\n    _G(\"stopSurplusCount\",stopSurplusCount)\n    Log(\"所有交易标的：\",SYMBOLS)\n    if _G(\"initialTotalMarginBalance\") is None:\n        info = exchange.GetAccount().Info\n        if info is None or info == {}:\n            Log(\"获取不到期货数据，无法运行\")\n            return\n        _G(\"initialTotalMarginBalance\", round(float(info.totalMarginBalance),2))#初始金额\n    if _G(\"drawIn\") is None:\n        _G(\"drawIn\",0)\n    if _G(\"drawOut\") is None:\n        _G(\"drawOut\",0)\n    ext.ClearAllService()\n    \n    \n#扫尾函数   \ndef onexit():\n     #平仓\n    #ext.ClearanceService()\n    ext.UpdateLogStatusService()\n    #Log(\"已全部平仓\")\n    Log(\"策略已停止\")"}
{"query": "请生成一个幽灵趋势跟踪策略业务库策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport time,datetime\nimport json\nimport math\nimport urllib.request\nRECORDS = None\nFLAGE = 0\n#账户信息表格化，用于展示在状态信息上\ndef TableAccountService(account):\n    \n    clos = [] #表头\n    clos.append(\"初始余额\")\n    clos.append(\"钱包余额\")\n    clos.append(\"保证金余额\")\n    clos.append(\"可用余额\")\n    clos.append(\"已用保证金\")\n    clos.append(\"当前杠杆\")\n    clos.append(\"总收益(收益率)\")\n    \n    initialTotalMarginBalance = \"$\" + str(_G(\"initialTotalMarginBalance\")) #初始余额\n    totalWalletBalance = \"$\" + str(account.totalWalletBalance) #钱包余额\n    totalMarginBalance = \"$\" + str(account.totalMarginBalance) #保证金余额\n    availableBalance = \"$\" + str(account.availableBalance) #可用余额\n    totalPositionInitialMargin = account.totalPositionInitialMargin#持仓保证金\n    totalOpenOrderInitialMargin = account.totalOpenOrderInitialMargin#当前挂单保证金\n    #_C(FilterHandlService)\n    drawOut = _N(_G(\"drawOut\"),2) #已划转资金\n    if account.totalMarginBalance==0 :\n        marginRate = \"0\"\n        lever = 0\n        Revenue = \"$0\"\n    else :\n        marginRate = (totalPositionInitialMargin+totalOpenOrderInitialMargin)/account.totalMarginBalance\n        marginRate = \"(\"+str(_N(marginRate,2)) + \")\"#保证金率\n        leverage = _G(\"leverage\")#杠杆 \n        lever = _N(totalPositionInitialMargin*leverage/account.totalMarginBalance,2)#当前杠杆\n        drawIn = _G(\"drawIn\")\n        drawOut = _G(\"drawOut\")\n        totalRevenue = account.totalMarginBalance-_G(\"initialTotalMarginBalance\") + drawOut - drawIn#总收益\n        initialTotalMarginBalance = _G(\"initialTotalMarginBalance\")\n        totalYield = 0\n        if initialTotalMarginBalance != 0:\n            totalYield = totalRevenue/initialTotalMarginBalance\n        totalYield = \"(\" + str(_N(totalYield,2)) + \")\"#总收益率\n        Revenue = \"$\" + str(_N(totalRevenue,2)) + totalYield\n        #记录当前总收益\n        _G(\"totalRevenue\",totalRevenue)\n    totalInitialMargin = \"$\" + str(_N(totalPositionInitialMargin+totalOpenOrderInitialMargin,2))#已用保证金\n    \n    rows = [] #表内容\n    row =[]\n    row.append(initialTotalMarginBalance)\n    row.append(totalWalletBalance)\n    row.append(totalMarginBalance)\n    row.append(availableBalance)\n    row.append(totalInitialMargin+marginRate)\n    row.append(lever)\n    row.append(Revenue)\n    rows.append(row)\n    \n    table = {\n        \"type\" : \"table\",\n        \"title\" : \"账户信息\",\n        \"cols\" : clos,\n        \"rows\" : rows\n    }\n    \n    \n    return table\n    \n#交易对表格化，用于展示在状态信息上    \ndef TablePositionsService(positions):\n    clos = [] #表头\n    clos.append(\"币种\")\n    clos.append(\"方向\")\n    clos.append(\"数量\")\n    clos.append(\"开仓价格\")\n    clos.append(\"强平价格\")\n    clos.append(\"现价\")\n    clos.append(\"未实现盈亏\")\n    rows = [] #表内容\n    for position in positions:\n        row = []\n        symbol = position.symbol\n        leverage = position.leverage\n        row.append(symbol + \"[\" + leverage + \"X]\")\n        \n        positionAmt = position.positionAmt\n        if float(positionAmt)>0:\n            row.append(\"做多\")\n        else:\n            row.append(\"做空\")\n        row.append(math.fabs(float(positionAmt)))\n        row.append(position.entryPrice)\n        row.append(position.liquidationPrice)\n        row.append(position.markPrice)\n        row.append(position.unRealizedProfit)\n        rows.append(row)  \n    table = {\n        \"type\" : \"table\",\n        \"title\" : \"交易对信息\",\n        \"cols\" : clos,\n        \"rows\" : rows\n    }\n    return table \n\n\n\n#跟新状态信息\ndef UpdateLogStatusService():\n    account = ext.GetAccountDao()\n    positions = ext.GetPositionsDao()\n    LogStatus(\"`\" + json.dumps(TableAccountService(account)) + \"`\\n\" +  \"`\" + json.dumps(TablePositionsService(positions)) +  \"`\")\n\n            \n#根据当前价格和下单价值换算成合约数            \ndef GetAmountByOrderValueService(price):\n    ext.GetNumByAmountService()\n    num = _G(\"num\")\n    orderValue = _G(\"orderValue\")\n    leverage = _G(\"leverage\")\n    account = ext.GetAccountDao()\n    totalMarginBalance = account.totalMarginBalance\n    orderValue = orderValue*totalMarginBalance*leverage*0.99/100\n    amount = orderValue/price\n    if orderValue < 5:\n        amount = 5/price + 1\n    amount = _N(amount,num)\n    if price*amount > orderValue:\n        amount = orderValue*0.99/price\n        amount = _N(amount,num)\n    exchange.SetMarginLevel(leverage)\n    return amount   \n\n#平仓\ndef ClearanceService():\n    positions = ext.GetPositionsDao()\n    for position in positions:\n        positionAmt = position.positionAmt\n        amt = math.fabs(float(positionAmt))\n        totalRevenue = _G(\"totalRevenue\")\n        ticker = ext.GetTickerDao(0)\n        price = ticker.last\n        symbol = position.symbol\n        symbol = symbol.replace(\"USDT\",\"_USDT\")\n        if float(positionAmt)>0:\n            #持多仓，--卖出平仓\n            ext.CreateOrderDao2(amt,3,\"{}币种平多单的当前成交价格：{}\".format(symbol,price))\n            LogProfit(_N(totalRevenue,2))\n        else:\n            #持空仓，--买入平仓\n            ext.CreateOrderDao2(amt,1,\"{}币种平空单的当前成交价格：{}\".format(symbol,price))\n            LogProfit(_N(totalRevenue,2))\n            \n#获取合约数位数\ndef GetNumByAmountService():\n    ext.GetNumByAmountDao()            \n\n#计算出交易对最小下单量\ndef GetMinOrderCountService():\n    minCount = 1\n    num = _G(\"num\")\n    if num != 0:\n        minCount = 1/(10**num)\n    return minCount\n \n#获取标志 \ndef GetStopService():\n    return ext.GetStopDao()\n\n#获取交易对信息    \ndef GetPositionsService():\n    return ext.GetPositionsDao()\n\n#获取tick价格\ndef GetPriceService(i):\n    ticker = ext.GetTickerDao(i)\n    price = ticker.last\n    return price \n\n#选出涨跌幅最大的币种\ndef GetSymbolService():\n    global RECORDS \n    #第一次获取所有币种的record数据，缓存起来 \n    R = _G(\"RECORDS\")\n    r = RECORDS\n    if r is None:\n        if R is None:\n            SetSymbolsRecordsService()\n        else:\n            RECORDS = R\n        return\n    #定期获取其中一个币种的最新record数据，和缓存数据比较，如果一样则，将数据更新标识记录为0并跳过\n    #如果不同，则更新缓存中所有币种的record数据,并将数据更新标识记录为1\n    isUpdate = UpdateRecordService()\n    if isUpdate:\n        return \n    #计算所有币种涨跌幅的绝对值，选出数值最大的币种\n    #根据选出来的币种的最新价格和bfCount的k线开盘价对比，判断出下单方向并记录起来\n    GetMaxSymbolService()\n    _G(\"RECORDS\",RECORDS)\n\n#下单信号\ndef FirstSignalService():\n    global FLAGE\n    symbolRecord = _G(\"symbolRecord\")\n    #检测是否已经筛选出币种，如果没有则跳出 \n    if symbolRecord is None:\n        return\n    #检测数据更新标识是否为1，如果不是则跳出 \n    isUpdate = _G(\"isUpdate\")\n    if isUpdate == 0:\n        return\n    symbol = symbolRecord[\"symbol\"] \n    #检测当前是否有持仓 \n    positions = ext.GetPositionsDao()\n    if len(positions) == 0:\n        #如果没有则用筛选出的币种进行下单\n        ext.SetCurrencyDao(symbol,0)\n        leverage = _G(\"leverage\")\n        exchange.SetMarginLevel(leverage)\n        side = symbolRecord[\"side\"]  \n        if side == 1:#做多 \n            price = symbolRecord[\"close\"]\n            amount = GetAmountByOrderValueService(price)\n            ext.CreateOrderDao2(amount,0,\"{}币种下多单的当前成交价格：{}\".format(symbol,price))\n            _G(\"initPrice\",price)\n            _G(\"initSide\",side)\n        else:#做空\n            price = symbolRecord[\"close\"]                      \n            amount = GetAmountByOrderValueService(price)\n            ext.CreateOrderDao2(amount,2,\"{}币种下空单的当前成交价格：{}\".format(symbol,price))\n            _G(\"initPrice\",price)\n            _G(\"initSide\",side)\n    elif len(positions) == 1:\n        position = positions[0]\n        positionAmt = float(position.positionAmt)\n        nSymbol = position.symbol\n        nSymbol = nSymbol.replace(\"USDT\",\"_USDT\")\n        #判断筛选出来的币种和当前下单的币种是否一样\n        if symbol == nSymbol:\n            #判断当前币种是否有浮亏，如果有则清仓，并反向下单\n            isFlag = _G(\"isFlag\")\n            if isFlag == 0:#使用反转信号,如果isFlag=0则不使用反转信号，则不处理当前的持仓\n                firstPrice = _G(\"initPrice\")\n                side = _G(\"initSide\")\n                price = symbolRecord[\"close\"]\n                if side == 1 and price <= firstPrice:#换币后首次下单方向是多，但是当前价格低于首次下单价格（浮亏），所以需要反转下单\n                    Log(\"换币后当前持仓方向是多，但是当前价格{}低于等于首次下单价格{}（浮亏），所以需要反转下单\".format(price,firstPrice))\n                    ClearanceService()\n                    amount = GetAmountByOrderValueService(price)\n                    if positionAmt > 0:#持有多单则清多单再下空单\n                        ext.CreateOrderDao2(amount,2,\"{}币种下空单的当前成交价格：{}\".format(symbol,price))\n                    else:\n                        ext.CreateOrderDao2(amount,0,\"{}币种下多单的当前成交价格：{}\".format(symbol,price))\n                    _G(\"initSide\",0)\n                    FLAGE = 0\n                elif side == 0 and price >= firstPrice:#换币后首次下单方向是空，但是当前价格高于首次下单价格（浮亏），所以需要反转下单\n                    Log(\"换币后当前持仓方向是空，但是当前价格{}高于等于首次下单价格{}（浮亏），所以需要反转下单\".format(price,firstPrice))\n                    #清空仓，再下多单\n                    ClearanceService()\n                    amount = GetAmountByOrderValueService(price)\n                    if positionAmt < 0:\n                        ext.CreateOrderDao2(amount,0,\"{}币种下多单的当前成交价格：{}\".format(symbol,price))\n                    else:\n                        ext.CreateOrderDao2(amount,2,\"{}币种下空单的当前成交价格：{}\".format(symbol,price))\n                    _G(\"initSide\",1)\n                    FLAGE = 0\n                else:\n                    Log(\"当前价格{}，首次下单价格{}，不需要反转下单\".format(price,firstPrice))\n            else:\n                Log(\"策略参数已屏蔽反转信号功能\")\n        else:\n            #将当前持仓清仓，并更换为筛选出的币种进行下单\n            ClearanceService()\n            ext.SetCurrencyDao(symbol,0)\n            side = symbolRecord[\"side\"]  \n            if side == 1:#做多 \n                ticker = ext.GetTickerDao(0)\n                price = ticker.last                          \n                amount = GetAmountByOrderValueService(price)\n                ext.CreateOrderDao2(amount,0,\"{}币种下多单的当前成交价格：{}\".format(symbol,price))\n                _G(\"initPrice\",price)\n                _G(\"initSide\",side)\n                FLAGE = 0\n            else:#做空\n                ticker = ext.GetTickerDao(0)\n                price = ticker.last                          \n                amount = GetAmountByOrderValueService(price)\n                ext.CreateOrderDao2(amount,2,\"{}币种下空单的当前成交价格：{}\".format(symbol,price))\n                _G(\"initPrice\",price)\n                _G(\"initSide\",side)\n                FLAGE = 0\n        \n    \n    \n#缓存record\ndef SetSymbolsRecordsService():\n    global RECORDS \n    symbols = _G(\"symbols\")\n    recordss = {}\n    for symbol in symbols:\n        #Log(\"symbol:\",symbol)\n        ext.SetCurrencyDao(symbol,1)\n        if RECORDS is None:\n            records =  ext.GetRecordsDao(-1,1)\n            recordss[symbol] = records\n        else:\n            oldRecords = RECORDS[symbol]\n            _CDelay(250)\n            records = _C(CheckRecordService,oldRecords)\n            recordss[symbol] = records\n    RECORDS = recordss\n\n#检查记录record数据是否更新\ndef CheckRecordService(oldRecords):\n    oldTime = oldRecords[-1][\"Time\"]\n    records = ext.GetRecordsDao(-1,1)\n    newTime = records[-1][\"Time\"]\n    if oldTime == newTime:\n        #Sleep(100)\n        return False\n    else:\n        return records\n\n#更新所有symbol的record    \ndef UpdateRecordService():\n    global RECORDS \n    symbols = _G(\"symbols\")\n    symbol = symbols[0]\n    ext.SetCurrencyDao(symbol,1)\n    newRecords = ext.GetRecordsDao(-1,1)\n    newTime = newRecords[-1][\"Time\"]\n    oldRecords = RECORDS[symbol]\n    oldTime = oldRecords[-1][\"Time\"]\n    if newTime == oldTime:\n        _G(\"isUpdate\",0)\n        return True\n    else:\n        Sleep(500)\n        SetSymbolsRecordsService()\n        _G(\"isUpdate\",1)\n        Log(\"行情数据已更新\")\n        return False\n\n#计算涨跌幅最大的币种\ndef GetMaxSymbolService():\n    symbols = _G(\"symbols\")\n    bfCount = _G(\"bfCount\") + 1\n    chgs = []\n    symbolList = []\n    tests = []\n    tests2 = []\n    for symbol in symbols:\n        records = RECORDS[symbol]\n        record = records[-1]\n        close = record[\"Open\"]\n        bfRecord = []\n        if len(records) < bfCount:\n            bfRecord = records[-len(records)]\n            Log(\"{}数据过少{}\".format(symbol,len(records)))\n        else:\n            bfRecord = records[-bfCount]\n        bfOpen = bfRecord[\"Open\"]\n        chg = 0\n        if close >= bfOpen:\n            chg = (close - bfOpen)/bfOpen \n        else:\n            chg = (bfOpen - close)/bfOpen\n        chgs.append(chg)\n        symbolList.append(symbol)\n        tests.append([symbol,chg])\n        tests2.append([symbol,bfOpen,close])\n    Log(tests)\n    Log(tests2)\n    maxChg = max(chgs)\n    maxSymbol = symbolList[chgs.index(maxChg)]\n    maxRecords = RECORDS[maxSymbol]\n    maxRecord = maxRecords[-1]\n    maxClose = maxRecord[\"Open\"]\n    maxBfRecord = maxRecords[-bfCount]\n    maxBfOpen = maxBfRecord[\"Open\"] \n    maxSide = GetSideService(maxSymbol,maxClose,maxBfOpen)\n    symbolRecord = {}\n    symbolRecord[\"symbol\"] = maxSymbol \n    symbolRecord[\"initPrice\"] = maxBfOpen \n    #symbolRecord[\"firstPrice\"] = price \n    symbolRecord[\"close\"] = maxClose \n    symbolRecord[\"side\"] = maxSide \n    symbolRecord[\"chg\"] = maxChg\n    _G(\"symbolRecord\",symbolRecord)\n    Log(\"新symbolRecord:\",symbolRecord)\n    #Log(\"最大涨跌幅的币种是：{}，涨跌幅为：{}\".format(maxSymbol,maxChg))\n\n#计算下单方向    \ndef GetSideService(maxSymbol,maxClose,maxBfOpen):\n    symbol = ext.GetCurrencyDao()\n    records = RECORDS[symbol]\n    price = records[-1][\"Open\"]\n    #检测当前是否有持仓 \n    positions = ext.GetPositionsDao()\n    if len(positions) == 0:#没有持仓，则不使用继承模块 \n        Log(\"首次下单，不使用继承模块\")\n        _G(\"oldClose\",maxClose)\n        _G(\"oldBfOpen\",maxBfOpen)\n        if maxClose > maxBfOpen:\n            return 1 #做多方向\n        else:\n            return 0 #做空方向\n    else:\n        position = positions[0]\n        nSymbol = position.symbol\n        nSymbol = nSymbol.replace(\"USDT\",\"_USDT\")\n        initPrice = _G(\"initPrice\")\n        if nSymbol == maxSymbol:#相同币种不需要换币\n            Log(\"筛选出来的币种和当前持仓的币种一样,不需要更换币种\")\n            if price >= initPrice:\n                return 1 #做多方向\n            else:\n                return 0 #做空方向\n        #使用继承模块\n        Log(\"筛选出来的币种和当前持仓的币种不一样,需要更换币种，{}币种更换为{}币种\".format(nSymbol,maxSymbol))\n        oldClose = _G(\"oldClose\")\n        oldBfOpen =_G(\"oldBfOpen\")\n        if (maxClose >= maxBfOpen and oldClose > oldBfOpen) or (maxClose <= maxBfOpen and oldClose < oldBfOpen):#继承上一个币的下单方向 \n            _G(\"oldClose\",maxClose)\n            _G(\"oldBfOpen\",maxBfOpen)\n            Log(\"{}币种继承{}币种的下单方向\".format(maxSymbol,nSymbol))\n            position =  positions[0]\n            positionAmt = float(position.positionAmt)\n            if positionAmt < 0:\n                return 0\n            else:\n                return 1\n        else:#不用使用继承\n            Log(\"不使用继承模块\")\n            _G(\"oldClose\",maxClose)\n            _G(\"oldBfOpen\",maxBfOpen)\n            if maxClose >= maxBfOpen:\n                return 1 #做多方向\n            else:\n                return 0 #做空方向 \n#清仓\ndef ClearAllService():\n    symbols = _G(\"symbols\")\n    for symbol in symbols:\n        ext.SetCurrencyDao(symbol,0)\n        positions = ext.GetPositionsDao()\n        if len(positions) != 0:\n            Log(\"清理已有仓位\")\n            ClearanceService()\n    \n        \n#策略交互\ndef GetCommandService():\n    cmd = GetCommand()\n    if cmd: \n        arr = cmd.split(\":\")\n        if arr[0] == \"一键清仓\": #清空所有交易对持仓\n            ClearanceService()\n            Log(\"全部清仓\")\n        elif arr[0] == \"现货==》合约\": #从现货账户划转USDT到合约账户\n            accountFunds = float(arr[1])\n            ret = ext.SetTransferDao(accountFunds,\"MAIN_UMFUTURE\",\"USDT\")\n            if ret is None:\n                Log(\"现货==》合约,划转资金出错\")  \n        elif arr[0] == \"合约==》现货\": #从合约账户划转USDT到现货账户\n            accountFunds = float(arr[1])\n            ret = ext.SetTransferDao(accountFunds,\"UMFUTURE_MAIN\",\"USDT\")\n            if ret is None:\n                Log(\"合约==》现货,划转资金出错\")\n            drawOut = _G(\"drawOut\")\n            _G(\"drawOut\",accountFunds + drawOut)\n\n#减仓信号\ndef StopSurplusService():\n    global FLAGE\n    if FLAGE == 1:\n        return \n    positions = ext.GetPositionsDao() \n    if len(positions) == 0:\n        return \n    position = positions[0]\n    positionAmt = float(position.positionAmt)\n    entryPrice = float(position.entryPrice)\n    ticker = ext.GetTickerDao(0)\n    price = ticker.last\n    stopSurplus = _G(\"stopSurplus\")/100\n    stopSurplusCount = _G(\"stopSurplusCount\")\n    stopSurplusCount = float(stopSurplusCount)/100\n    if positionAmt > 0:\n        if (price - entryPrice)/entryPrice < stopSurplus:\n            return \n        positionAmt = stopSurplusCount*positionAmt\n        num = _G(\"num\")\n        positionAmt = _N(positionAmt,num)\n        Log(\"减多仓\")\n        ext.CreateOrderDao2(positionAmt,3,\"当前成交价格：{}\".format(price))\n        totalRevenue = _G(\"totalRevenue\")\n        LogProfit(_N(totalRevenue,2))\n        FLAGE = 1\n    else:\n        if (entryPrice - price)/entryPrice  < stopSurplus:\n            return \n        positionAmt = -positionAmt \n        positionAmt = stopSurplusCount*positionAmt\n        num = _G(\"num\")\n        positionAmt = _N(positionAmt,num)\n        Log(\"减空仓\")\n        ext.CreateOrderDao2(positionAmt,1,\"当前成交价格：{}\".format(price))\n        totalRevenue = _G(\"totalRevenue\")\n        LogProfit(_N(totalRevenue,2))\n        FLAGE = 1\n    \n#设置双向持仓           \ndef SetDualService():\n    ext.SetDualDao()\n            \next.TableAccountService = TableAccountService\next.TablePositionsService = TablePositionsService\next.UpdateLogStatusService = UpdateLogStatusService\next.ClearanceService = ClearanceService\next.GetNumByAmountService = GetNumByAmountService\next.GetAmountByOrderValueService = GetAmountByOrderValueService\next.GetStopService = GetStopService\next.GetPositionsService = GetPositionsService\next.GetPriceService = GetPriceService \next.GetSymbolService = GetSymbolService\next.FirstSignalService = FirstSignalService\next.GetCommandService = GetCommandService\next.SetDualService = SetDualService\next.GetSymbolService = GetSymbolService\next.ClearAllService = ClearAllService\next.StopSurplusService = StopSurplusService"}
{"query": "请生成一个幽灵趋势跟踪策略数据库策略代码", "base_model_response": "", "lora_model_response": "```python\n    # Import modules necessary for the database\n\n\n    import sqlite3\n\n    class Table:\n        def __init__(self, name):\n            self.__table_name = name\n            self.__name = \"Table\"\n            self.cursor = None\n\n            self.__data = {}\n            \n        def add(self, key, value):\n            if key in self.data and self.data[key] != value:\n                self.data[key] = value\n            else:\n                if key in (self.__table_name, table_name):\n                    print(\"Error\", file=\"pytpgit\", file=self.file)\n                    raise \n                conn = sqlite3.connect(self.__table_name)\n                cursor = conn.cursor()\n                cursor.execute(\"INSERT INTO {0} VALUES (%s)\", (self.__table_name, key))\n                db.commit()\n                \n        def get(self, key):\n            try:\n                return self.data[key]\n            except sqlite3.OperationalError as e:\n                print(e)\n                db.rollback()\n                raise\n\n        def del(self, key):\n            try:\n                self.data[key] = float('inf')\n            exceptsqlite3.OperationalError as e:\n                print(e)\n                db.rollback()\n                raise", "original_response": "python\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport time,datetime\nimport json\nfrom collections import Counter\nIFLAGE = 0\nclass Account(object):\n    #币安账户信息实体，封装了常用的账户信息\n    #totalWalletBalance：钱包余额\n    #totalMarginBalance：保证金余额\n    #totalPositionInitialMargin：持仓保证金\n    #totalOpenOrderInitialMargin：当前挂单保证金\n    #availableBalance: 可用余额（仅计算usdt资产）\n    def __init__(self, totalWalletBalance, totalMarginBalance, totalPositionInitialMargin, totalOpenOrderInitialMargin, availableBalance):\n        self.totalWalletBalance = totalWalletBalance\n        self.totalMarginBalance = totalMarginBalance\n        self.totalPositionInitialMargin = totalPositionInitialMargin\n        self.totalOpenOrderInitialMargin = totalOpenOrderInitialMargin \n        self.availableBalance = availableBalance\n        \nclass Position(object):\n    #币安交易对实体，封装了常用的交易对信息\n    #entryPrice：持仓成本价\n    #leverage：杠杆倍率\n    #liquidationPrice：强平价格\n    #marginType：逐仓模式或全仓模式\n    #markPrice：标记价格\n    #positionAmt：头寸数量\n    #symbol：交易对\n    #unRealizedProfit：持仓未实现盈亏\n    #positionSide：持仓方向\n    def __init__(self, entryPrice, leverage, liquidationPrice, marginType, markPrice, positionAmt, symbol, unRealizedProfit, positionSide):\n        self.entryPrice = entryPrice\n        self.leverage = leverage\n        self.liquidationPrice = liquidationPrice\n        self.marginType = marginType \n        self.markPrice = markPrice\n        self.positionAmt = positionAmt\n        self.symbol = symbol\n        self.unRealizedProfit = unRealizedProfit\n        self.positionSide = positionSide\n\nclass Ticker(object):\n    #sell: 卖一价\n    #buy: 买一价\n    #last: 最后成交价格\n    def __init__(self, sell, buy, last):\n        self.sell = sell \n        self.buy = buy \n        self.last = last \n        \n        \n        \nclass Order(object):\n    #id:订单唯一标识 \n    #price:下单价格 \n    #amount:下单数量 \n    #status:订单状态--0：未完成；1：已完成；2：已经取消；3：未知状态\n    def __init__(self, id, price, amount, status):\n        self.id = id \n        self.price = price \n        self.amount = amount \n        self.status = status \n        \n        \n#获取账户信息        \ndef GetAccountDao():\n    account = _C(exchange.GetAccount)\n    assets = account.Info.assets\n    busd = {}\n    usdt = {}\n    for asset in assets:\n        symbol = asset[\"asset\"]\n        if symbol == \"BUSD\":\n            busd = asset \n        if symbol == \"USDT\":\n            usdt = asset\n            \n    bTotalWalletBalance = float(busd[\"walletBalance\"])\n    bTotalMarginBalance = float(busd[\"marginBalance\"])\n    bTotalPositionInitialMargin = float(busd[\"positionInitialMargin\"])\n    bTotalOpenOrderInitialMargin = float(busd[\"openOrderInitialMargin\"])\n    bAvailableBalance = float(busd[\"availableBalance\"])\n    uTotalWalletBalance = float(usdt[\"walletBalance\"])\n    uTotalMarginBalance = float(usdt[\"marginBalance\"])\n    uTotalPositionInitialMargin = float(usdt[\"positionInitialMargin\"])\n    uTotalOpenOrderInitialMargin = float(usdt[\"openOrderInitialMargin\"])\n    uAvailableBalance = float(usdt[\"availableBalance\"])\n    totalWalletBalance = _N(uTotalWalletBalance+bTotalWalletBalance,2)\n    totalMarginBalance = _N(uTotalMarginBalance+bTotalMarginBalance,2)\n    totalPositionInitialMargin = _N(uTotalPositionInitialMargin+bTotalPositionInitialMargin,2)\n    totalOpenOrderInitialMargin = _N(uTotalOpenOrderInitialMargin+bTotalOpenOrderInitialMargin,2)\n    availableBalance = _N(uAvailableBalance+bAvailableBalance,2)\n    account = Account(totalWalletBalance, totalMarginBalance, totalPositionInitialMargin, totalOpenOrderInitialMargin, availableBalance)\n    return account\n\n#获取账户所有交易对\ndef GetPositionsDao():\n    positions = [] \n    num2 = _G(\"num2\")\n    for i in _C(exchange.GetPosition):\n        entryPrice = _N(float(i.Info.entryPrice),num2)\n        leverage = i.Info.leverage \n        liquidationPrice = _N(float(i.Info.liquidationPrice),num2)\n        marginType = i.Info.marginType \n        markPrice = _N(float(i.Info.markPrice),num2) \n        positionAmt = i.Info.positionAmt \n        symbol = i.Info.symbol \n        unRealizedProfit = _N(float(i.Info.unRealizedProfit),3)  \n        positionSide = i.Info.positionSide \n        \n        position = Position(entryPrice, leverage, liquidationPrice, marginType, markPrice,\n                            positionAmt, symbol, unRealizedProfit, positionSide)\n        positions.append(position)\n    return positions\n\n#获取tick级别的行情数据\ndef GetTickerDao(i):\n    ticker = _C(exchanges[i].GetTicker)\n    sell = ticker.Sell \n    buy = ticker.Buy \n    last = ticker.Last\n    newTicker = Ticker(sell,buy,last)\n    return newTicker\n\n#创建订单\ndef CreateOrderDao(price,amount,flag):\n    #price: 价格\n    #amount: 合约数\n    #flag: 0(买入开多仓);1(买入平空仓);2(卖出开空仓);3(卖出平多仓)\n    num2 = _G(\"num2\")\n    price = _N(price,num2)\n    id = 0\n    if flag == 0:\n        exchange.SetDirection(\"buy\")\n        id = exchange.Buy(price,amount)\n    elif  flag == 1:\n        exchange.SetDirection(\"closesell\")\n        id = exchange.Buy(price,amount)\n    elif  flag == 2:\n        exchange.SetDirection(\"sell\")\n        id = exchange.Sell(price,amount) \n    elif  flag == 3:\n        exchange.SetDirection(\"closebuy\")\n        id = exchange.Sell(price,amount)\n    return id\n\n#市价平仓\ndef CreateOrderDao2(amount,flag,message):\n    id = 0\n    #flag: 0(买入开多仓);1(买入平空仓);2(卖出开空仓);3(卖出平多仓)\n    if flag == 0:\n        exchange.SetDirection(\"buy\")\n        id = exchange.Buy(-1,amount,message)\n    elif  flag == 1:\n        exchange.SetDirection(\"closesell\")\n        id = exchange.Buy(-1,amount,message)\n    elif  flag == 2:\n        exchange.SetDirection(\"sell\")\n        id = exchange.Sell(-1,amount,message)\n    elif flag == 3:\n        exchange.SetDirection(\"closebuy\")\n        id = exchange.Sell(-1,amount,message)\n    return id \n\n\n#获取合约数位数\ndef GetNumByAmountDao():\n    depth = _C(exchange.GetDepth)\n    nums = []\n    num2s = []\n    for ask in depth[\"Asks\"]:\n        i = ask[\"Amount\"]\n        num = 0\n        if str(i).count('.') == 1:\n            num = len(str(i).split(\".\")[1])\n        nums.append(num)\n        \n        j = ask[\"Price\"]\n        num2 = 0\n        if str(j).count('.') == 1:\n            num2 = len(str(j).split(\".\")[1])\n        num2s.append(num2)\n    num = max(nums)    \n    _G(\"num\",num)\n    num2 = Counter(num2s).most_common(1)[0][0]\n    _G(\"num2\",num2)\n    \n    \n    \n#返回一个K线历史\ndef GetRecordsDao(period,i):\n    if period == -1:\n        return _C(exchanges[i].GetRecords)\n    else:\n        return _C(exchanges[i].GetRecords,period)\n\n#设置币种\ndef SetCurrencyDao(symbol,i):\n    exchanges[i].SetCurrency(symbol)\n\n#划转资金\ndef SetTransferDao(amount, typeEnum, symbol):\n    exchange.SetBase(\"https://api.binance.com\")\n    params = \"amount=\" + str(amount) + \"&type=\" + typeEnum + \"&asset=\" + symbol\n    ret = exchange.IO(\"api\", \"POST\", \"/sapi/v1/asset/transfer\", params)\n    Log(\"资金划转：划转数量为{}\".format(amount))\n    exchange.SetBase(\"https://fapi.binance.com\")\n    return ret\n\n\n#获取当前未完成的所有订单\ndef GetPendingOrdersDao():\n    orders = []\n    for order in _C(exchange.GetOrders):\n        id = order.Id\n        price = order.Price\n        amount = order.Amount\n        status = order.Status\n        newOrder = Order(id, price, amount, status)\n        orders.append(newOrder)\n    return orders \n\n#根据订单ID获取订单详情\ndef GetOrderByIdDao(id):\n    order = _C(exchange.GetOrder,id)\n    id = order.Id\n    price = order.Price\n    amount = order.Amount\n    status = order.Status\n    newOrder = Order(id, price, amount, status)\n    return newOrder    \n\n#取消某个订单\ndef CancelOrderDao(id):\n    if id == 0:\n        return True\n    flag = exchange.CancelOrder(id)\n    if flag == True:\n        return flag \n    else:\n        order =_C(exchange.GetOrder,id)\n        if order[\"Status\"] == 0:\n            flag = exchange.CancelOrder(id)\n        else:\n            flag = True\n        return flag    \n\n#取消所有未完成的订单\ndef AllCanelOrderDao():\n    orders = GetPendingOrdersDao()\n    for order in orders:\n        _C(CancelOrderDao,order.id)\n\n#定时器\ndef TimerDao(m,key):\n    value = _G(key)\n    if value is None:\n        value = time.time()\n        _G(key,value)\n        return True\n    now = time.time()\n    dnow = datetime.datetime.fromtimestamp(now)\n    dvalue = datetime.datetime.fromtimestamp(int(value))\n    c = (dnow - dvalue).total_seconds()\n    if c - m > 0:\n        _G(key,now)\n        return True\n    return False    \n\n#获取Period\ndef GetPeriodDao():\n    return exchange.GetPeriod()\n\n#获取Currency \ndef GetCurrencyDao():\n    return exchange.GetCurrency()\n\n#获取标志 \ndef GetStopDao():\n    i = IFLAGE\n    return i\n\n#设置标志1\ndef SetIFlageDao():\n    global IFLAGE \n    IFLAGE = 1  \n\n#定时器\ndef TimerDao(m,key):\n    value = _G(key)\n    if value is None:\n        value = time.time()\n        _G(key,value)\n        return True\n    now = time.time()\n    dnow = datetime.datetime.fromtimestamp(now)\n    dvalue = datetime.datetime.fromtimestamp(int(value))\n    c = (dnow - dvalue).total_seconds()\n    if c - m > 0:\n        _G(key,now)\n        return True\n    return False        \n#设置双向持仓\ndef SetDualDao():\n    dual = _C(exchange.IO,\"api\", \"GET\", \"/fapi/v1/positionSide/dual\", \"\")\n    if dual.dualSidePosition:\n        Log(\"当前账户为双向持仓模式，不需要转换持仓模式\")\n    else:\n        Log(\"当前账户为单向持仓模式，准备转双向持仓模式\")\n        _C(exchange.IO,\"api\", \"POST\", \"/fapi/v1/positionSide/dual\", \"dualSidePosition=true\")\n        Log(\"已转为双向持仓模式\")    \n\next.GetAccountDao = GetAccountDao\next.GetPositionsDao = GetPositionsDao\next.GetTickerDao = GetTickerDao\next.CreateOrderDao = CreateOrderDao\next.CreateOrderDao2 = CreateOrderDao2\next.GetNumByAmountDao = GetNumByAmountDao\next.GetRecordsDao = GetRecordsDao\next.SetTransferDao = SetTransferDao\next.GetPendingOrdersDao = GetPendingOrdersDao\next.GetOrderByIdDao = GetOrderByIdDao\next.CancelOrderDao = CancelOrderDao\next.TimerDao = TimerDao\next.AllCanelOrderDao = AllCanelOrderDao\next.GetPeriodDao = GetPeriodDao\next.GetCurrencyDao = GetCurrencyDao\next.GetStopDao = GetStopDao\next.SetIFlageDao = SetIFlageDao\next.TimerDao = TimerDao\next.SetDualDao = SetDualDao\next.SetCurrencyDao = SetCurrencyDao"}
{"query": "请生成一个指数对冲修罗场-001策略代码", "base_model_response": "，该策略包括投资组合的创建、市场动态分析、风险控制等环节。", "lora_model_response": "", "original_response": "python\n\nimport time\nimport requests\nimport math\nimport pandas as pd\n\nAlpha = 0.001  #指数移动平均的MA参数，设置的越大基准价格跟踪越敏感，最终持仓也会越低降低了杠杆，但会降低收益，具体根据自己需求权衡\nUpdateBasePriceInterval = 60 #多久更新一次基准价格，单位位秒，跟Alpha相关，Alpha设置的越小，这个间隔也可以设置的更小\nStopLossRate = 0.8 #表示当资金达到初始资金的80%时触发止损，停止策略，可以随着策略的盈利，动态设置止损位置\nMaxDiff = 0.5  #当偏差diff大于这个值时停止加仓\nMinDiff = -0.5  #当StopLossRate偏差Diff小于这个值时停止加仓\nVersion = '0.0.1'\nShow = True   #默认false 显示账户余额，true显示累计收益\nFunding = 0    #账户资金，为0的时候自动获取，非0的时候自行设置\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\nSelfFee = 0.04   #手续费率   https:#www.binance.com/cn/fee/futureFee\nTotalLong = 0    #做多总价值\nTotalShort = 0   #做空总价值\nProfit = 0       #收益\nAccount = {}     #保存账户信息\nWinRateData = {}  # 存储胜率信息\nassets = {}\ntradeInfo = {}\naccountAssets = {}\nruntimeData = {}\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\ntradeSymbols = list(TradeSymbols.replace(' ','').split(','))\nIndex = 1   #指数\nUpdateBasePriceTime = 0\nInitPrice = {}\nupdateProfitTime = 0\n\n\n#\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'stop_balance':0,'short_value':0,'long_value':0,'profit':0}\n\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所！')\n    exit()\n\ndef init():\n    InitRateData()\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()\n    #Log(exchangeInfo)\n    for i in range(len(exchangeInfo['symbols'])):\n        if len(exchangeInfo['symbols'][i]['symbol'].split('_')) > 1 :continue\n        sp = exchangeInfo['symbols'][i]['symbol'].split('_')[0]\n        symbol = sp.replace('USDT','')\n        #Log(sp)\n        BUSD = sp[-4:len(sp)]\n        if 'BUSD' != BUSD or symbol not in exchangeInfo['symbols'][i]['symbol']:   #排除BUSD交易对\n            if symbol in tradeSymbols:\n                assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'btc_price': 0, 'btc_change': 1,'btc_diff': 0,\n                'realised_profit': 0,'margin': 0,'unrealised_profit': 0,'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n                tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\n                'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\n\n\ndef UpdateAccount():\n    global accountAssets ,StopLoss\n    #判断当前是模拟交易还是实盘交易\n    if MockTrading:\n        Log('模拟交易更新账户')\n\n    else:\n        #Log('实盘交易更新账户')\n        account = exchange.GetAccount()\n        ps = exchange.GetPosition()\n        if account is None:\n            Log('更新账户超时！')\n            return\n        accountAssets = account['Info']['assets']\n        assets['USDT']['update_time'] = int(time.time() * 1000)\n        #Log(account['Info']['positions'])\n        for i in range(len(account['Info']['positions'])):\n            symbol = account['Info']['positions'][i]['symbol']\n            if len(symbol.split('_')) > 1: continue   #过滤掉 例：symbol:ETHUSDT_211231  合约\n            sp = symbol.split('_')[0]\n            #排除掉BUSD交易对 和不在交易列表的交易对\n            coin = sp.replace('USDT','')\n            BUSD = sp[-4:len(sp)]\n            if 'BUSD' == BUSD or coin not in tradeSymbols: continue\n            #筛选单向持仓币种\n            if account['Info']['positions'][i]['positionSide'] == 'BOTH':\n                # if coin == 'ETH':\n                #     Log(coin,account['Info']['positions'][i])\n                #Log('symbol:',symbol)\n                assets[coin]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\n                assets[coin]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\n                assets[coin]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\n                assets[coin]['leverage'] = account['Info']['positions'][i]['leverage']\n        #Log(assets)\n        #计算持仓保证金总额\n        assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\n        assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\n        assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\n        if assets['USDT']['init_balance'] == 0:\n            if _G('init_balance'):\n                assets['USDT']['init_balance'] = _N(_G('init_balance'),2)\n            else:\n                assets['USDT']['init_balance'] = assets['USDT']['total_balance']\n                _G('init_balance',assets['USDT']['init_balance'])\n        #计算收益\n        assets['USDT']['profit'] = _N(float(assets['USDT']['margin_balance']) - float(assets['USDT']['init_balance']),2)\n        #计算止损位置\n        assets['USDT']['stop_balance'] = _N(StopLossRate * assets['USDT']['init_balance'], 2)\n        #计算未实现收益\n        assets['USDT']['unrealised_profit'] = _N(float(account['Info']['totalUnrealizedProfit']),2)\n        #计算杠杆\n        assets['USDT']['leverage'] = _N(assets['USDT']['margin'] / float(assets['USDT']['total_balance']))\n        #计算保证金率\n        assets['USDT']['margin_ratio'] = _N(float(account['Info']['totalMaintMargin']) / float(account['Info']['totalMarginBalance'])) * 100\n        exchange.SetContractType('swap')\n        ps = json.loads(exchange.GetRawJSON())\n        # 更新持仓\n        #Log('position:',ps)\n        if len(ps) > 0:\n            j = 1\n            for i in range(len(ps)):\n                #Log(ps[i])\n                if len(ps[i]['symbol'].split('_')) > 1: continue   #过滤掉 例：symbol:ETHUSDT_211231  合约\n                sp = ps[i]['symbol'].split('_')[0]\n                BUSD = sp[-4:len(sp)]\n                symbol = sp.replace('USDT','')\n\n\n                if 'BUSD' == BUSD or symbol not in tradeSymbols : continue\n                if ps[i]['positionSide'] != 'BOTH': continue\n                assets[symbol]['hold_price'] = float(ps[i]['entryPrice'])\n                assets[symbol]['amount'] = float(ps[i]['positionAmt'])\n                assets[symbol]['unrealised_profit'] = float(ps[i]['unRealizedProfit'])\n                assets[symbol]['liquidationPrice'] = float(ps[i]['liquidationPrice'])\n                assets[symbol]['marginType'] = ps[i]['marginType']\n                #Log(j,assets[symbol])\n                #j+=1\n        #Log('实盘账户更新完毕！')\n\n\ndef UpdateTick():\n    try:\n        ticker = requests.get('https://fapi.binance.com/fapi/v1/ticker/bookTicker').json()\n    except Exception as e:\n        Log('get ticker time out !')\n        return\n    assets['USDT']['long_value'] = 0\n    assets['USDT']['short_value'] = 0\n    for i in range(len(ticker)):\n        sp = ticker[i]['symbol'].split('_')[0]\n        if len(ticker[i]['symbol'].split('_')) > 1: continue   #过滤掉 例：symbol:ETHUSDT_211231  合约\n        BUSD = sp[-4:len(sp)]\n        symbol = sp.replace('USDT','')\n        if 'BUSD' == BUSD or symbol not in tradeSymbols: continue\n        # if symbol == 'BTCDOM':\n        #     Log(symbol,ticker[i])\n        #Log(ticker[i])\n        assets[symbol]['ask_price'] = float(ticker[i]['askPrice'])\n        assets[symbol]['bid_price'] = float(ticker[i]['bidPrice'])\n        assets[symbol]['ask_value'] = _N(assets[symbol]['amount'] * assets[symbol]['ask_price'], 2)\n        assets[symbol]['bid_value'] = _N(assets[symbol]['amount'] * assets[symbol]['bid_price'], 2)\n\n        # if symbol == 'BTCDOM':\n        #     Log(symbol,assets[symbol])\n        value = (assets[symbol]['ask_value'] + assets[symbol]['bid_value']) / 2\n        if value != 0:\n            if value > 0:\n                assets['USDT']['long_value'] += value\n            else:\n                assets['USDT']['short_value'] += value\n\n        # if assets[symbol]['amount'] < 0:\n        #     assets['USDT']['short_value'] += abs((assets[symbol]['ask_value'] + assets[symbol]['bid_price']) / 2)\n        # else:\n        #     assets['USDT']['long_value'] += abs((assets[symbol]['ask_value'] + assets[symbol]['bid_value']) / 2)\n\n        assets['USDT']['short_value']    = _N(assets['USDT']['short_value'], 2)\n        assets['USDT']['long_value']     = _N(assets['USDT']['long_value'], 2)\n\n        #Log('UpdateTick:',symbol,assets[symbol])\n    #更新指数\n    UpdateIndex()\n    for symbol in  tradeSymbols:\n        assets[symbol]['btc_diff'] = _N((assets[symbol]['btc_change'] - Index), 4)\n\n\ndef UpdateIndex():\n    global UpdateBasePriceTime,InitPrice,Index,Reset\n\n    if MockTrading:\n        Log('模拟交易模式更新指数')\n    else:\n        #Log('实盘交易模式更新指数')\n        if _G('InitPrice') is None or Reset:\n            Reset = False\n            for symbol in tradeSymbols:\n                InitPrice[symbol] = (assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n            Log('保存启动时的价格')\n            _G('InitPrice',InitPrice)\n            _G('StartTime',None)\n            _G('InitAccount_'+exchange.GetLabel(), None)\n            _G('tradeNumber', 0) #重置交易次数\n            _G('tradeVolume', 0) #重置交易量\n            _G('buyNumber', 0) #重置做多次数\n            _G('sellNumber', 0) #重置做空次数\n            _G('totalProfit', 0) #重置打印次数\n            _G('profitNumber', 0) #重置盈利次数\n        else:\n            InitPrice = _G('InitPrice')\n            if int(time.time()*1000) - UpdateBasePriceTime > UpdateBasePriceInterval:\n                UpdateBasePriceTime = int(time.time() * 1000)\n                for symbol in tradeSymbols:\n                    if symbol not in InitPrice: continue\n                    InitPrice[symbol] = InitPrice[symbol] * (1 - Alpha) + Alpha * (assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n                    _G('InitPrice',InitPrice)\n            temp = 0\n            for symbol in tradeSymbols:\n                assets[symbol]['btc_price'] = (assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n                if symbol not in InitPrice:\n                    Log('添加新的币种：',symbol)\n                    InitPrice[symbol] = assets[symbol]['btc_price']\n                    _G('InitPrice',InitPrice)\n                #Log(symbol,assets[symbol]['btc_price'],InitPrice[symbol])\n                assets[symbol]['btc_change'] = _N(assets[symbol]['btc_price'] / InitPrice[symbol], 4)\n                temp += assets[symbol]['btc_change']\n            Index = _N(temp / len(tradeSymbols), 4)\n            #Log('最新指数：',Index)\n\n\n#止损模块\ndef StopLoss():\n    if assets['USDT']['margin_balance'] < StopLossRate * assets['USDT']['init_balance'] and assets['USDT']['init_balance'] != 0:\n        Log('出发止损！ 当前资金：',assets['USDT']['margin_balance'],'初始资金：',assets['USDT']['init_balance'])\n        UpdateAccount()\n        UpdateTick()\n        Ice_value = 200 #止损的快一些，可修改\n        trading = False\n        for symbol in tradeSymbols:\n            if assets[symbol]['bid_price'] == 0 : continue\n            if assets[symbol]['bid_value'] >= tradeInfo[symbol]['minQty'] * assets[symbol]['bid_price']:\n                ## TODO: 卖出止损\n                trading = True\n                pass\n            if assets[symbol]['ask_value'] <= tradeInfo[symbol]['minQty'] * assets[symbol]['ask_price']:\n                # TODO: 买入止损\n                trading = True\n                pass\n            Sleep(1000)\n            if not trading:\n                Log('止损结束，如果需要重新运行策略，请调低止损参数！')\n                exit()\n    else:  # 不用止损\n        return None\n\ndef Trade(symbol,direction,value):\n    if int(time.time()) - assets['USDT']['update_time'] > 10 * 1000:\n        Log('更新账户延迟，不进行交易！！！')\n    else:\n        price = assets[symbol]['bid_price'] if direction =='SELL' else assets[symbol]['ask_price']\n        amount = _N(min(IceValue,value) / price,tradeInfo[symbol]['amountSize'])\n        if amount < tradeInfo[symbol]['minQty']:\n            Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n        else:\n            # exchange.SetCurrency(symbol+'_USDT')\n            # Log(direction)\n            # exchange.SetDirection(direction)\n            # f = 'Buy' if direction == 'Buy' else 'Sell'\n            # Log(f)\n            # place_order = getattr(exchange,direction) #获取交易对象\n            # id = place_order(price,amount,symbol)\n            para = ''\n            url = '/fapi/v1/order'\n            para += 'symbol='+ symbol + 'USDT'\n            para += '&side='+ direction\n            para += '&type=LIMIT&timeInForce=IOC'\n            para += '&quantity='+ str(amount)\n            para += '&price='+ str(price)\n            para += \"&timestamp=\"+str(time.time() * 1000);\n            go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n            ret = go.wait()\n            if ret  is not None:\n                logType = LOG_TYPE_SELL\n                if direction == 'BUY':\n                    logType =LOG_TYPE_BUY\n                exchange.Log(logType,price,amount,symbol)\n\n            TradingCounter('tradeVolume',amount * price)\n            TradingCounter('tradeNumber',1)\n            WinRateData[symbol]['tradeNumber'] += 1\n            if direction == 'Buy':\n                TradingCounter('buyNumber',1)\n                WinRateData[symbol]['buyNumber'] += 1\n            else:\n                TradingCounter('sellNumber',1)\n                WinRateData[symbol]['sellNumber'] += 1\n            _G('WinRateData',WinRateData)\n            return id\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)\n    return initialAccount\n\ndef AppendedStatus():\n    global TotalLong,TotalShort,RunTime,Funding,Account\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\", \"止损\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    feeTable = {\n        'type': 'table',\n        'title': '交易统计',\n        'cols': [\"策略指数\", '交易次数', '做多次数', '做空次数', '预估胜率', '预估成交额', '预估手续费', \"未实现盈利\", '持仓总值', '做多总值', '做空总值'],\n        'rows': []\n    }\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if Funding == 0:\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])\n    profitColors = DangerColor\n    totalProfit = assets['USDT']['total_balance'] - Funding\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday\n    dayRate = dayProfit / Funding * 100\n\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(assets['USDT']['stop_balance'], 2)) + DangerColor,\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n    vloume = _G('tradeVolume') if _G('tradeVolume') is not None else 0\n\n    feeTable['rows'].append([\n        Index, #指数\n        _G('tradeNumber') if _G('tradeNumber') is not None else 0, #交易次数\n        _G('buyNumber') if _G('buyNumber') is not None else 0, #做多次数\n        _G('sellNumber') if _G('sellNumber') is not None else 0, #做空次数\n        str(_N(_G('profitNumber') / _G('totalProfit') * 100, 2) if _G('totalProfit') > 0 else 0) + '%', #胜率\n        '$' + str(_N(vloume, 2)) + ' ≈ ฿' + str(_N(vloume / ((assets['BTC']['bid_price'] + assets['BTC']['ask_price']) / 2), 6)), #成交金额\n        '$' + str(_N(vloume * (SelfFee / 100), 4)), #手续费\n        '$' + str(_N(assets['USDT']['unrealised_profit'], 2)) + (SuccessColor if assets['USDT']['unrealised_profit'] >= 0 else DangerColor),\n        '$' + str(_N(TotalLong + abs(TotalShort), 2)), #持仓总价值\n        '$' + str(_N(TotalLong, 2)) + SuccessColor, #做多总值\n        '$' + str(_N(abs(TotalShort), 2)) + DangerColor, #做空总值\n    ])\n\n    assetTable = {\n        'type': 'table',\n        'title': '账户资产信息',\n        'cols': ['编号', '资产名', '起始保证金', '维持保证金', '保证金余额', '最大可提款金额', '挂单起始保证金', '持仓起始保证金', '持仓未实现盈亏', '账户余额'],\n        'rows': []\n    }\n    for i in range(len(accountAssets)):\n        acc = accountAssets[i]\n        assetTable['rows'].append([\n            i + 1,\n            acc['asset'], acc['initialMargin'], acc['maintMargin'], acc['marginBalance'],\n            acc['maxWithdrawAmount'], acc['openOrderInitialMargin'], acc['positionInitialMargin'],\n            acc['unrealizedProfit'], acc['walletBalance']\n        ])\n    indexTable = {\n        'type': 'table',\n        'title': '币指数信息',\n        'cols': ['编号', '币种信息', '当前价格', 'BTC计价', 'BTC计价变化(%)', '偏离平均', '交易次数', '做空次数', '做多次数', '预估胜率'],\n        'rows': []\n    }\n\n    i = 0\n    for symbol in tradeSymbols :\n        price = _N((assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / 2, tradeInfo[symbol]['priceSize'])\n        if symbol not in tradeSymbols:\n            indexTable['rows'].append([i + 1, symbol, price, assets[symbol]['btc_price'], _N((1 - assets[symbol]['btc_change']) * 100), assets[symbol]['btc_diff']], 0, 0, 0, '0%')\n        else:\n            i += 1\n            WinRateData = _G(\"WinRateData\")\n            winRated = _N(WinRateData[symbol]['profitNumber'] / WinRateData[symbol]['totalProfit'] * 100, 2) if WinRateData[symbol]['totalProfit'] > 0 else 0\n            indexTable['rows'].append([\n                i,\n                symbol + WrningColor,\n                price,\n                _N(assets[symbol]['btc_price'], 6),\n                _N((1 - assets[symbol]['btc_change']) * 100),\n                str(assets[symbol]['btc_diff']) + (SuccessColor if assets[symbol]['btc_diff'] >= 0 else DangerColor),\n                WinRateData[symbol]['tradeNumber'],\n                WinRateData[symbol]['sellNumber'],\n                WinRateData[symbol]['buyNumber'],\n                (str(winRated) if WinRateData[symbol]['profitNumber'] > 0 and WinRateData[symbol]['totalProfit'] > 0 else '0') + '%' + (SuccessColor if winRated >= 50 else DangerColor), #胜率\n            ])\n    retData = {}\n    #Log(runtimeData['str'])\n    #retData['upTable'] = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version + '\\n' + '`' + json.dumps([accountTable, assetTable]) + '`\\n' + '`' + json.dumps(feeTable) + '`\\n'\n    retData['upTable'] = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n' + '`' + json.dumps([accountTable, assetTable]) + '`\\n' + '`' + json.dumps(feeTable) + '`\\n'\n    retData['indexTable'] = indexTable\n    return retData\n\n\n\ndef UpdateStatus():\n    global TotalLong,TotalShort,updateProfitTime,Funding,Profit\n    TotalLong = 0\n    TotalShort = 0\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '强平差价', '持仓价值', '保证金', '未实现盈亏', '投降'],\n        'rows': []\n    }\n    i = 0\n    for symbol in tradeSymbols:\n        i += 1\n        direction = '空仓'\n        margin = direction\n        if assets[symbol]['amount'] != 0:\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\n        price = _N((assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / 2 ,tradeInfo[symbol]['priceSize'])\n        value = _N((assets[symbol]['ask_value'] + assets[symbol]['bid_value'])/2 , 2)\n        if value != 0:\n            if value > 0:\n                TotalLong += value\n            else:\n                TotalShort += value\n        unrealised_profit_color = '#000000'\n        if assets[symbol]['unrealised_profit'] > 0:\n            unrealised_profit_color = SuccessColor\n        if assets[symbol]['unrealised_profit'] < 0:\n            unrealised_profit_color = DangerColor\n        infoList = [\n            i,\n            '['+ margin +']' +'[' + str(assets[symbol]['leverage']) +'X]',\n            symbol,\n            direction,\n            abs(assets[symbol]['amount']),\n            assets[symbol]['hold_price'],\n            price,\n            assets[symbol]['liquidationPrice'],\n            '0' if assets[symbol]['liquidationPrice'] == 0 else '$' + str(_N(assets[symbol]['liquidationPrice'] - price, 5)) + ' ≈ ' + str(_N(assets[symbol]['liquidationPrice'] / price * 100, 2)) + '%' + WrningColor, #强平价格\n            abs(value),\n            _N(assets[symbol]['positionInitialMargin'],2),\n            str(_N(assets[symbol]['unrealised_profit'], 3)) + unrealised_profit_color,\n            {\n                'type': 'button',\n                'cmd': '说好的没有撤退可言呢？？?:' + symbol + ':' + str(assets[symbol]['amount']) + ':',\n                'name': symbol + ' 投降'\n            }\n\n        ]\n        table['rows'].append(infoList)\n        logString = json.dumps(assets['USDT'])\n\n        StatusData = AppendedStatus()\n        LogStatus(StatusData['upTable'] + '`' + json.dumps([table, StatusData['indexTable']]) + '`\\n' + logString)\n        # LogStatus('`' + json.dumps([table, StatusData['indexTable']]) + '`\\n' + logString)\n\n        if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n            balance = assets['USDT']['total_balance']\n            if Show:\n                balance = assets['USDT']['total_balance'] - Funding\n            LogProfit(_N(balance, 3), '&')\n            updateProfitTime = int(time.time()*1000)\n            if Profit != 0 and (_N(balance, 0) != Profit): #第一次不计算,并且小数点面的不进行胜率计算\n                TradingCounter(\"totalProfit\", 1) #统计打印次数, 胜率=盈利次数/打印次数*100\n                if _N(balance, 0) > Profit:\n                    TradingCounter('profitNumber', 1) #盈利次数\n                WinRate()\n            Profit = _N(balance,0)\n\n\n# 策略主逻辑\ndef Process():\n    # UpdateTick()\n    for symbol in tradeSymbols:\n        if assets[symbol]['ask_price'] == 0 : continue\n        aim_value = -TradeValue * _N(assets[symbol]['btc_diff'] / 0.01 ,3)  #计算偏离1%需要加的仓位\n        #偏移仓位 - 持有仓位 > 偏离加仓阈值 并且 diff > 预设最小加仓值 并且 多方仓位 - 空方仓位 小于等于 1.1倍的 偏离加仓  则进行开多仓\n        # if symbol == 'IOTA':\n        #     Log(symbol,aim_value - assets[symbol]['ask_value'])\n        if (aim_value - assets[symbol]['ask_value']) >= DeviateValue and assets[symbol]['btc_diff'] > MinDiff :\n            Log('做多',symbol,'   aim_value:',aim_value,'   ask_value:',assets[symbol]['ask_value'],'amount:',(aim_value - assets[symbol]['ask_value']), '   偏离平均:',assets[symbol]['btc_diff'])\n            Trade(symbol,'BUY',aim_value - assets[symbol]['ask_value'])\n        if (aim_value - assets[symbol]['bid_value']) <= -DeviateValue and assets[symbol]['btc_diff'] < MaxDiff:\n            Log('做空',symbol,'   aim_value:',aim_value,'   ask_value:',assets[symbol]['ask_value'],'amount:',(aim_value - assets[symbol]['bid_value']),  '   偏离平均:',assets[symbol]['btc_diff'])\n            Trade(symbol,'SELL',-(aim_value - assets[symbol]['bid_value']) )\n\n\n# 保存交易量\ndef TradingCounter(key,newValue):\n    value = _G(key)\n    if value is None:\n        _G(key,newValue)\n    else:\n        _G(key,value + newValue)\n\n\ndef WinRate():\n    global WinRateData\n    for symbol in tradeSymbols:\n        unrealised = assets[symbol]['unrealised_profit']\n        WinRateData[symbol]['totalProfit'] += 1\n        if unrealised != 0:\n            if unrealised > 0:\n                WinRateData[symbol]['profitNumber'] += 1\n    _G(\"WinRateData\", WinRateData)\n\n#更新胜率信息\ndef InitRateData():\n    global WinRateData\n    if Reset:\n        _G('WinRateData',None)\n    if _G('WinRateData'):\n        WinRateData = _G('WinRateData')\n    for symbols in tradeSymbols:\n        if symbols not in WinRateData:\n                                 #统计次数        #盈利次数          #交易次数       #做多次数        #做空次数\n            WinRateData[symbols] = {'totalProfit': 0, 'profitNumber': 0,'tradeNumber': 0,'buyNumber': 0, 'sellNumber': 0}\n    _G('WinRateData',WinRateData)\n #获取或创建策略第一次启动时间\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\n\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(20)\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #止损模块\n        StopLoss()\n        #策略逻辑\n        Process()\n        #输出状态栏信息\n        UpdateStatus()\n\n        Sleep(Interval * 1000)"}
{"query": "请生成一个指标库python版策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# 0级：核心工具函数\n# 1级：应用层函数(通过0级核心函数实现）\n# 2级：技术指标函数(全部通过0级，1级函数实现）\n\nimport math\nimport numpy as np\nimport pandas as pd\n\n\n#------------------ 0级：核心工具函数 --------------------------------------------      \ndef RD(N,D=3):   return np.round(N,D)        #四舍五入取3位小数 \ndef RET(S,N=1):  return np.array(S)[-N]      #返回序列倒数第N个值,默认返回最后一个\ndef ABS(S):      return np.abs(S)            #返回N的绝对值\ndef MAX(S1,S2):  return np.maximum(S1,S2)    #序列max\ndef MIN(S1,S2):  return np.minimum(S1,S2)    #序列min\n         \ndef MA(S,N):              #求序列的N日平均值，返回序列                    \n    return pd.Series(S).rolling(N).mean().values    \n\n#引用X在N个周期前的值\n#例如：REF(CLOSE,5)  #表示引用当前周期的前第5个周期的收盘价，如果是日线周期，即为第5个交易日前的收盘价\ndef REF(S, N=1):          #对序列整体下移动N,返回序列(shift后会产生NAN)    \n    return pd.Series(S).shift(N).values  \n\ndef DIFF(S, N=1):         #前一个值减后一个值,前面会产生nan \n    return pd.Series(S).diff(N)  #np.diff(S)直接删除nan，会少一行\n\ndef STD(S,N):             #求序列的N日标准差，返回序列    \n    return  pd.Series(S).rolling(N).std(ddof=0).values     \n\ndef IF(S_BOOL,S_TRUE,S_FALSE):   #序列布尔判断 return=S_TRUE if S_BOOL==True  else  S_FALSE\n    return np.where(S_BOOL, S_TRUE, S_FALSE)\n\ndef SUM(S, N):            #对序列求N天累计和，返回序列    N=0对序列所有依次求和         \n    return pd.Series(S).rolling(N).sum().values if N>0 else pd.Series(S).cumsum()  \n\ndef HHV(S,N):             # HHV(C, 5)  # 最近5天收盘最高价        \n    return pd.Series(S).rolling(N).max().values     \n\ndef LLV(S,N):             # LLV(C, 5)  # 最近5天收盘最低价     \n    return pd.Series(S).rolling(N).min().values    \n\ndef EMA(S,N):             #指数移动平均,为了精度 S>4*N  EMA至少需要120周期     alpha=2/(span+1)    \n    return pd.Series(S).ewm(span=N, adjust=False).mean().values     \n\ndef SMA(S, N, M=1):        #中国式的SMA,至少需要120周期才精确 (雪球180周期)    alpha=1/(1+com)\n    return pd.Series(S).ewm(com=N-M, adjust=True).mean().values     \n\ndef AVEDEV(S,N):           #平均绝对偏差  (序列与其平均值的绝对差的平均值)   \n    return pd.Series(S).rolling(N).apply(lambda x: (np.abs(x - x.mean())).mean()).values \n\ndef SLOPE(S,N,RS=False):    #返S序列N周期回线性回归斜率 (默认只返回斜率,不返回整个直线序列)\n    M=pd.Series(S[-N:]);   poly = np.polyfit(M.index, M.values,deg=1);    Y=np.polyval(poly, M.index); \n    if RS: return Y[1]-Y[0],Y\n    return Y[1]-Y[0]\n\n  \n#------------------   1级：应用层函数(通过0级核心函数实现） ----------------------------------\ndef COUNT(S_BOOL, N):                  # COUNT(CLOSE>O, N):  最近N天满足S_BOO的天数  True的天数\n    return SUM(S_BOOL,N)    \n\ndef EVERY(S_BOOL, N):                  # EVERY(CLOSE>O, 5)   最近N天是否都是True\n    R=SUM(S_BOOL, N)\n    return  IF(R==N, True, False)\n  \ndef LAST(S_BOOL, A, B):                #从前A日到前B日一直满足S_BOOL条件   \n    if A<B: A=B                        #要求A>B    例：LAST(CLOSE>OPEN,5,3)  5天前到3天前是否都收阳线     \n    return S_BOOL[-A:-B].sum()==(A-B)  #返回单个布尔值    \n\ndef EXIST(S_BOOL, N=5):                # EXIST(CLOSE>3010, N=5)  n日内是否存在一天大于3000点\n    R=SUM(S_BOOL,N)    \n    return IF(R>0, True ,False)\n\ndef BARSLAST(S_BOOL):                  #上一次条件成立到当前的周期  \n    M=np.argwhere(S_BOOL);             # BARSLAST(CLOSE/REF(CLOSE)>=1.1) 上一次涨停到今天的天数\n    return len(S_BOOL)-int(M[-1])-1  if M.size>0 else -1\n\ndef FORCAST(S,N):                      #返S序列N周期回线性回归后的预测值\n    K,Y=SLOPE(S,N,RS=True)\n    return Y[-1]+K\n  \ndef CROSS(S1,S2):                      #判断穿越 CROSS(MA(C,5),MA(C,10))               \n    CROSS_BOOL=IF(S1>S2, True ,False)   \n    return COUNT(CROSS_BOOL>0,2)==1    #上穿：昨天0 今天1   下穿：昨天1 今天0\n\n\n\n#------------------   2级：技术指标函数(全部通过0级，1级函数实现） ------------------------------\ndef MACD(CLOSE,SHORT=12,LONG=26,M=9):            # EMA的关系，S取120日，和雪球小数点2位相同\n    DIF = EMA(CLOSE,SHORT)-EMA(CLOSE,LONG);  \n    DEA = EMA(DIF,M);      MACD=(DIF-DEA)*2\n    return RD(DIF),RD(DEA),RD(MACD)\n\ndef KDJ(CLOSE,HIGH,LOW, N=9,M1=3,M2=3):         # KDJ指标\n    RSV = (CLOSE - LLV(LOW, N)) / (HHV(HIGH, N) - LLV(LOW, N)) * 100\n    K = EMA(RSV, (M1*2-1));    D = EMA(K,(M2*2-1));        J=K*3-D*2\n    return K, D, J\n\ndef RSI(CLOSE, N=24):                           # RSI指标,和通达信小数点2位相同\n    DIF = CLOSE-REF(CLOSE,1) \n    return RD(SMA(MAX(DIF,0), N) / SMA(ABS(DIF), N) * 100)  \n\ndef WR(CLOSE, HIGH, LOW, N=10, N1=6):            #W&R 威廉指标\n    WR = (HHV(HIGH, N) - CLOSE) / (HHV(HIGH, N) - LLV(LOW, N)) * 100\n    WR1 = (HHV(HIGH, N1) - CLOSE) / (HHV(HIGH, N1) - LLV(LOW, N1)) * 100\n    return RD(WR), RD(WR1)\n\ndef BIAS(CLOSE,L1=6, L2=12, L3=24):              # BIAS乖离率\n    BIAS1 = (CLOSE - MA(CLOSE, L1)) / MA(CLOSE, L1) * 100\n    BIAS2 = (CLOSE - MA(CLOSE, L2)) / MA(CLOSE, L2) * 100\n    BIAS3 = (CLOSE - MA(CLOSE, L3)) / MA(CLOSE, L3) * 100\n    return RD(BIAS1), RD(BIAS2), RD(BIAS3)\n\ndef BOLL(CLOSE,N=20, P=2):                       #BOLL指标，布林带    \n    MID = MA(CLOSE, N); \n    UPPER = MID + STD(CLOSE, N) * P\n    LOWER = MID - STD(CLOSE, N) * P\n    return RD(UPPER), RD(MID), RD(LOWER)    \n\ndef PSY(CLOSE,N=12, M=6):  \n    PSY=COUNT(CLOSE>REF(CLOSE,1),N)/N*100\n    PSYMA=MA(PSY,M)\n    return RD(PSY),RD(PSYMA)\n\ndef CCI(CLOSE,HIGH,LOW,N=20):  \n    TP=(HIGH+LOW+CLOSE)/3\n    return (TP-MA(TP,N))/(0.015*AVEDEV(TP,N))\n        \ndef ATR(CLOSE,HIGH,LOW, N=20):                    #真实波动N日平均值\n    TR = MAX(MAX((HIGH - LOW), ABS(REF(CLOSE, 1) - HIGH)), ABS(REF(CLOSE, 1) - LOW))\n    return MA(TR, N)\n\ndef BBI(CLOSE,M1=3,M2=6,M3=12,M4=20):             #BBI多空指标   \n    return (MA(CLOSE,M1)+MA(CLOSE,M2)+MA(CLOSE,M3)+MA(CLOSE,M4))/4    \n\ndef DMI(CLOSE,HIGH,LOW,M1=14,M2=6):               #动向指标：结果和同花顺，通达信完全一致\n    TR = SUM(MAX(MAX(HIGH - LOW, ABS(HIGH - REF(CLOSE, 1))), ABS(LOW - REF(CLOSE, 1))), M1)\n    HD = HIGH - REF(HIGH, 1);     LD = REF(LOW, 1) - LOW\n    DMP = SUM(IF((HD > 0) & (HD > LD), HD, 0), M1)\n    DMM = SUM(IF((LD > 0) & (LD > HD), LD, 0), M1)\n    PDI = DMP * 100 / TR;         MDI = DMM * 100 / TR\n    ADX = MA(ABS(MDI - PDI) / (PDI + MDI) * 100, M2)\n    ADXR = (ADX + REF(ADX, M2)) / 2\n    return PDI, MDI, ADX, ADXR  \n\ndef TAQ(HIGH,LOW,N):                               #唐安奇通道(海龟)交易指标，大道至简，能穿越牛熊\n    UP=HHV(HIGH,N);    DOWN=LLV(LOW,N);    MID=(UP+DOWN)/2\n    return UP,MID,DOWN\n\ndef KTN(CLOSE,HIGH,LOW,N=20,M=10):                 #肯特纳交易通道, N选20日，ATR选10日\n    MID=EMA((HIGH+LOW+CLOSE)/3,N)\n    ATRN=ATR(CLOSE,HIGH,LOW,M)\n    UPPER=MID+2*ATRN;   LOWER=MID-2*ATRN\n    return UPPER,MID,LOWER       \n  \ndef TRIX(CLOSE,M1=12, M2=20):                      #三重指数平滑平均线\n    TR = EMA(EMA(EMA(CLOSE, M1), M1), M1)\n    TRIX = (TR - REF(TR, 1)) / REF(TR, 1) * 100\n    TRMA = MA(TRIX, M2)\n    return TRIX, TRMA\n\ndef VR(CLOSE,VOL,M1=26):                            #VR容量比率\n    LC = REF(CLOSE, 1)\n    return SUM(IF(CLOSE > LC, VOL, 0), M1) / SUM(IF(CLOSE <= LC, VOL, 0), M1) * 100\n\ndef EMV(HIGH,LOW,VOL,N=14,M=9):                     #简易波动指标 \n    VOLUME=MA(VOL,N)/VOL;       MID=100*(HIGH+LOW-REF(HIGH+LOW,1))/(HIGH+LOW)\n    EMV=MA(MID*VOLUME*(HIGH-LOW)/MA(HIGH-LOW,N),N);    MAEMV=MA(EMV,M)\n    return EMV,MAEMV\n\n\ndef DPO(CLOSE,M1=20, M2=10, M3=6):                  #区间震荡线\n    DPO = CLOSE - REF(MA(CLOSE, M1), M2);    MADPO = MA(DPO, M3)\n    return DPO, MADPO\n\ndef BRAR(OPEN,CLOSE,HIGH,LOW,M1=26):                 #BRAR-ARBR 情绪指标  \n    AR = SUM(HIGH - OPEN, M1) / SUM(OPEN - LOW, M1) * 100\n    BR = SUM(MAX(0, HIGH - REF(CLOSE, 1)), M1) / SUM(MAX(0, REF(CLOSE, 1) - LOW), M1) * 100\n    return AR, BR\n\ndef DMA(CLOSE,N1=10,N2=50,M=10):                     #平行线差指标  \n    DIF=MA(CLOSE,N1)-MA(CLOSE,N2);    DIFMA=MA(DIF,M)\n    return DIF,DIFMA\n\ndef MTM(CLOSE,N=12,M=6):                             #动量指标\n    MTM=CLOSE-REF(CLOSE,N);         MTMMA=MA(MTM,M)\n    return MTM,MTMMA\n\ndef MASS(HIGH,LOW,N1=9,N2=25,M=6):                   # 梅斯线\n    MASS=SUM(MA(HIGH-LOW,N1)/MA(MA(HIGH-LOW,N1),N1),N2)\n    MA_MASS=MA(MASS,M)\n    return MASS,MA_MASS\n  \ndef ROC(CLOSE,N=12,M=6):                             #变动率指标\n    ROC=100*(CLOSE-REF(CLOSE,N))/REF(CLOSE,N);    MAROC=MA(ROC,M)\n    return ROC,MAROC  \n\ndef EXPMA(CLOSE,N1=12,N2=50):                        #EMA指数平均数指标\n    return EMA(CLOSE,N1),EMA(CLOSE,N2);\n\ndef OBV(CLOSE,VOL):                                  #能量潮指标\n    return SUM(IF(CLOSE>REF(CLOSE,1),VOL,IF(CLOSE<REF(CLOSE,1),-VOL,0)),0)/10000\n\ndef MFI(CLOSE,HIGH,LOW,VOL,N=14):                    #MFI指标是成交量的RSI指标\n    TYP = (HIGH + LOW + CLOSE)/3\n    V1=SUM(IF(TYP>REF(TYP,1),TYP*VOL,0),N)/SUM(IF(TYP<REF(TYP,1),TYP*VOL,0),N)  \n    return 100-(100/(1+V1))     \n  \ndef ASI(OPEN,CLOSE,HIGH,LOW,M1=26,M2=10):            #振动升降指标\n    LC=REF(CLOSE,1);      AA=ABS(HIGH-LC);     BB=ABS(LOW-LC);\n    CC=ABS(HIGH-REF(LOW,1));   DD=ABS(LC-REF(OPEN,1));\n    R=IF( (AA>BB) & (AA>CC),AA+BB/2+DD/4,IF( (BB>CC) & (BB>AA),BB+AA/2+DD/4,CC+DD/4));\n    X=(CLOSE-LC+(CLOSE-OPEN)/2+LC-REF(OPEN,1));\n    SI=16*X/R*MAX(AA,BB);   ASI=SUM(SI,M1);   ASIT=MA(ASI,M2);\n    return ASI,ASIT  \n\ndef VWAP(CLOSE,VOL,HIGH,LOW,N=14):                    #交易量加权平均价格\n    TYP = (HIGH + LOW + CLOSE)/3\n    VWAP = SUM(VOL*TYP, N) / SUM(VOL, N)\n    return VWAP\n\n\next.MACD = MACD \next.KDJ = KDJ\next.RSI = RSI\next.WR = WR\next.BIAS = BIAS\next.BOLL = BOLL\next.PSY = PSY\next.CCI = CCI    \next.ATR = ATR\next.BBI = BBI\next.DMI = DMI\next.TAQ = TAQ\next.KTN = KTN\next.TRIX = TRIX\next.VR = VR\next.EMV = EMV\next.DPO = DPO\next.BRAR = BRAR\next.DMA = DMA\next.MTM = MTM\next.MASS = MASS\next.ROC = ROC\next.EXPMA = EXPMA\next.OBV = OBV\next.MFI = MFI\next.ASI = ASI\next.VWAP = VWAP"}
{"query": "请生成一个数字货币定投策略代码", "base_model_response": "", "lora_model_response": "在Python中，我们可以使用Py胆和Pandas库来创建投资组合的图表，然后使用pandas的DataFrame数据结构对股票数据进行排序、筛选和可视化。\n\n下面是一个简单的例子：\n\n```python\nimport pandas as pd\nimport py胆 as ptc\nfrom matplotlib.pyplot as plt\n\ndef smart_4d():\n    # 创建投资组合的图表\n    chart = ptc.SmartConductor()\n    chart.set_value_date('1/01/2023', '2023-12-31')\n    chart.set_amount(100)\n    chart.set_currency('USD')\n\n    # 将投资组合分为两部分：指数部分，以及特定指数组的部分\n    index_group = 3\n    index_group_size = len(index_group)\n\n    # 根据指数组大小将投资分为不同的股票\n    for i in range(index_group_size):\n        c = ptc.Candlestick candlestick_type=py胆.Ticks(value=chart.values,\n                                                                                        _currency='USD',\n                                                                                        _unit=py胆.Days(),\n                                                                                        _size=(index_group_size + 1, index_group_size),\n                                                                                        _color=ptc.Color.paleen_r,\n                                                                                        _title='Index Group %s' % (i+1),\n                                                                                        start='1/2023', end='12/31',\n                                                                                        chart=xtzt(i*1.5, 5))\n        if i == index_group_size:\n            c.start='%s', c.end='%s'\n        else:\n            c.start='%s', c.end='%s' % (index_group-size-i+1, index_group-size+i+1))\n\n    # 把指数部分画成图\n    chart.draw()\n\nsmart_4d()\n```\n\n这段代码定义了一个智能货币（Smart Conductor）的图表，它可以自动计算股票价格，并且可以显示在图表上。它会根据交易量来划分投资组合的不同部分。\n\n注意，这个例子中的投资组合只是一些基本的数学计算，实际投资可能会更复杂，需要考虑更多的因素，比如市场波动率、时间成本等。", "original_response": "python\ndef onTick():\n\t\n\texchange_count = len(exchanges)\n\tfor i in range(exchange_count):\n\t\taccount = exchanges[i].GetAccount()\n\n\t\tmarketName = exchanges[i].GetName()\n\t\tdepth = exchanges[i].GetDepth()\n\t\tLog(\"Market \",marketName,exchanges[i].GetCurrency(),\"Account Balance [\",account[\"Balance\"],\"] Stocks[\",account[\"Stocks\"],\"]\")\n\t\tif account and depth and account[\"Balance\"] > accountLimitMoney :\n\t\t\tbidPrice = depth[\"Asks\"][0][\"Price\"] \n\t\t\tif bidPrice <  maxBidPrice :\n\t\t\t\tamount = orderAmount\n\t\t\t\tif amount <= account[\"Balance\"]:\n\t\t\t\t\texchanges[i].Buy(amount)\n\t\t\t\telse:\n\t\t\t\t\tLog(\"Account Balance is less than bid Amount\")\n\t\t\telse:\n\t\t\t\tLog(\"Bid Price >= maxBidPrice, not process\")\n\t\telse:\n\t\t\tLog(\"Account Balance <= accountLimitMoney\")\ndef main() :\n\twhile 1:\n\t\t\n\t\tonTick()\n\t\ttime.sleep(orderTimeInterval)"}
{"query": "请生成一个暴雪网格-724小时交易机器人每日更新实盘效果策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!python2\n# -*- coding:utf-8 -*-\n'''\n主要是使用发明者量化API进行网格买卖，当前只支持单品网格买卖\n'''\nfrom time import sleep\nimport datetime,copy\n\nsale_price_list = [] #卖出的价格列表\nbuy_price_list = []  #买入的价格列表\n\nclass fmz_market():\n    def get_data_depth(self):\n        data_depth = exchange.GetDepth()\n        return data_depth\n\n\n\n    #检查当前是否可以进行买卖操作\n    def make_trade_check(self,symbol):\n        trade_infor = {'price':0,'trade_type':''}\n        #进行买卖列表判断，先更新交易记录列表\n        trade_price_list = self.get_trade_price_list(symbol)\n        sale_price_list = trade_price_list[0]\n        buy_price_list = trade_price_list[1]\n        #获取深度数据\n        data_depth = self.get_data_depth()\n        #买单列表：\n        data_depth_bids = data_depth.Bids[0]\n        #卖单列表：\n        data_depth_asks = data_depth.Asks[0]\n        #如果买入记录不为空\n        sale_buy_diff_now = two_distance*len(sale_price_list) if len(sale_price_list) >0 else sale_buy_diff\n        sale_buy_diff_sale = two_distance if len(sale_price_list) > 0 else sale_buy_diff\n        # sale_price_last = float(sale_price_list[len(sale_price_list)-1]) if len(sale_price_list) >0 else base_price\n        # buy_price_last = float(buy_price_list[len(buy_price_list)-1]) if len(buy_price_list) >0 else base_price\n        sale_price_last = float(sale_price_list[0]) if len(sale_price_list) > 0 and float(sale_price_list[0]) > base_price else base_price\n        buy_price_last = float(buy_price_list[0]) if len(buy_price_list) > 0 and float(buy_price_list[0]) < base_price else base_price\n        #判断当前价格是否满足 卖出的价格请求\n        if float(data_depth_bids.Price) - sale_price_last > sale_buy_diff_sale and float(data_depth_bids.Amount) > trade_amount * 1.5:\n            Log(\"当前卖价：\",str(data_depth_bids.Price),\"订单中最高卖价：\",str(sale_price_last),\"生成卖单\")\n            trade_infor['price'] = float(data_depth_bids.Price)\n            trade_infor['trade_type'] = 'sale'\n        #判断当前价格是否满足 买入的价格请求\n        if  buy_price_last - float(data_depth_asks.Price) > sale_buy_diff_now and float(data_depth_bids.Amount) > trade_amount * 1.5:\n            #Log(\"当前买价：\", str(data_depth_asks.Price), \"订单中最高买价：\", str(sale_price_last),\"生成买单\")\n            trade_infor['price'] = float(data_depth_bids.Price)\n            trade_infor['trade_type'] = 'buy'\n        #判断当前价格是否破格，破格则置空买卖信息\n        if float(data_depth_bids.Price) - sale_price_max > 0 or buy_price_min - float(data_depth_asks.Price) > 0:\n            trade_infor['price'] = 0\n            trade_infor['trade_type'] = ''\n        timestr = (datetime.datetime.now()).strftime('%Y-%m-%d %H:%M:%S')\n        Log(trade_infor,\"...time：\",timestr)\n        if trade_infor['price'] != 0:\n            #Log(trade_infor,\"...time：\",timestr)\n            pass\n        return trade_infor\n\n    #根据委托信息生成买卖价格列表\n    def get_trade_price_list(self,symbol):\n        sale_list = []\n        buy_list = []\n        #获取所有的交易记录，根据不同的类型 分配到 买卖列表中\n        orders = exchange.GetOrders()\n        for i in range(len(orders)):\n            if orders[i].Type == 1:\n                sale_price = float(orders[i].Price)\n                sale_price_bak = copy.deepcopy(sale_price)\n                sale_list.append(sale_price_bak)\n            if orders[i].Type == 0:\n                buy_price = float(orders[i].Price)\n                buy_price_bak = copy.deepcopy(buy_price)\n                buy_list.append(buy_price_bak)\n        #判断为0的数组进处理\n        if len(sale_list) == 0:\n            for i in range(len(buy_list)):\n                sale_list.append(float('%.6f' % (buy_list[i] + sale_buy_diff)))\n        if len(buy_list) == 0:\n            for i in range(len(sale_list)):\n                buy_list.append(float('%.6f' % (sale_list[i] - sale_buy_diff)))\n        trade_price_list = [sale_list,buy_list]\n        return trade_price_list\n\n    #网格交易入口：\n    def grid_trade_start(self,symbol):\n        #进行状态获取，上涨/下跌\n        # trend_status = self.kline_trend_check(symbol)\n        \n        #获取可否进行交易\n        trade_infor = self.make_trade_check(symbol)\n        #进行判断是否交易，判断是否可以卖出\n        # if trend_status == 'is_up' and trade_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\n            buy_price = float('%.6f' % (trade_infor['price'] - sale_buy_diff))\n            #调用下单功能,先调用卖，再调用买\n            order_id = exchange.Sell(trade_infor['price'], trade_amount)\n            #Log('order_id:',order_id)\n            #检查下单是否成功，不成功，则直接返回\n            if order_id is None:\n                Log(\"下单失败，等待600s继续.........\")\n                sleep(600)\n                return 0\n            #检查主交易是否成功：判断卖单单是否交易成功,交易成功则进行买单下单\n            for i in range(100):\n                sale_orders = exchange.GetOrder(order_id)\n                #Log('sale_orders:',sale_orders)\n                if sale_orders.Status == 1:\n                    #如果卖单已成交，则进行买单提交\n                    exchange.Buy(buy_price, trade_amount)\n                    return 0\n                sleep(10)\n            #如果循环1000次还未成交，则取消订单\n            exchange.CancelOrder(order_id)\n        # 进行判断是否交易，判断是否可以买入\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'buy':\n            sale_price = float('%.6f' % (trade_infor['price'] + sale_buy_diff))\n            # 调用下单功能，先调用买入，再调用卖出\n            order_id = exchange.Buy(trade_infor['price'], trade_amount)\n            # 检查下单是否成功，不成功，则直接返回\n            if order_id is None:\n                #Log(\"下单失败，等待600s继续.........\")\n                sleep(600)\n                return 0\n            # 检查主交易是否成功：判断买单是否交易成功,交易成功则进行卖单下单\n            for i in range(100):\n                buy_orders = exchange.GetOrder(order_id)\n                if buy_orders.Status == 1:\n                    # 如果买单已成交，则进行卖单提交\n                    exchange.Sell(sale_price, trade_amount)\n                    return 0\n                sleep(10)\n            # 如果循环1000次还未成交，则取消订单\n            exchange.CancelOrder(order_id)\n\n    #进行循环调用\n    def grid_trade_cycle(self,symbol):\n        cycle_num = 0\n        while(True):\n            timestr = (datetime.datetime.now()).strftime('%H%M%S')\n            self.grid_trade_start(symbol)\n            sleep(10)\n            cycle_num = cycle_num + 1\n            if cycle_num % 100 == 0:\n                account_infor = exchange.GetAccount()\n                Log(\"当前用户的账号信息：%s,....当前已循环检查次数：%s\"%(account_infor,str(cycle_num)))\n\ndef main():\n    Log(exchange.GetAccount())\n    Log(\"测试\")\n    fmz_market_instances = fmz_market()\n    fmz_market_instances.grid_trade_cycle(100)\n    #order_id = exchange.Sell(10000,1)"}
{"query": "请生成一个期现成对下单_Public策略代码", "base_model_response": "```javascript\n// 定义一个函数，用于获取用户的支付金额和单笔交易的总价\nfunction getTransactionTotal(input) {\n    const { amount, transactionAmount } = input;\n    return transactionAmount * amount; // 10元整\n}\n\n// 定义一个函数，用于计算用户所购买商品的总价值\nfunction calculateProductValue(input) {\n    const { items } = input;\n    const totalValue = items.reduce((total, item) => total + item.price); // 每个商品200元\n    return totalValue;\n}\n\n// 定义一个函数，用于创建一个新的账户并进行转账\nfunction createAccountWith转账(input) {\n    if (!input.startsWith('https')) {\n        throw new Error(`Invalid account type: ${input}`);\n    }\n    let account = prompt(`Enter your account details:`);\n    let transactionAmount = getTransactionTotal(input);\n    let productValue = calculateProductValue(input);\n\n    // 创建一个新密码哈希，用于存储每个账户的密码\n    let passwordHash = new Date().getTime();\n    account.split('').forEach(password => passwordHash += password);\n\n    // 运行转账操作，并保存哈希值到数据库中\n    db.run(`INSERT INTO accounts (account_name, transaction_amount, product_value)\n        VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)`, account);\n    database.run(`UPDATE transactions SET transaction_amount = ? WHERE id = ?`, transactionAmount, account.id);\n}\n\n// 定义一个函数，用于处理用户的订单\nfunction processOrder(input) {\n    const order = prompt(`Enter the order ID and order name:`);\n    const customerId = prompt(`Enter the customer ID:`);\n    const orderNumber = prompt(`Enter the order number:`);\n    const product = prompt(`Enter the product you want to purchase:`);\n\n    // 提交订单请求\n    db.run(`INSERT INTO orders (customer_id, order_number, product) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)`).then((result) => {\n        console.log(result);\n        history.push(`已完成订单 ${orderNumber}`);\n        window.location.href = `http://localhost:5306/historic-order?order=${orderNumber}`;\n    });\n}\n```\n\n上述代码定义了三个函数：`getTransactionTotal()`、`calculateProductValue()` 和 `createAccountWith转账()`。这些函数分别实现了一个获取用户的支付金额和单笔交易的总价的功能，以及计算用户所购买商品的总价值的功能。此外，还有一个名为 `processOrder()` 的函数，用于处理用户的订单。", "lora_model_response": "", "original_response": "python\ndef main():\n\texchange.SetContractType(ContractSwap)\n\tTickerSwap = exchange.GetTicker()\n\tTickerSwap['BuyAmount'] = TickerSwap['Info']['result']['best_bid_amount']\n\tTickerSwap['SellAmount'] = TickerSwap['Info']['result']['best_ask_amount']\n\texchange.SetContractType(ContractFuture)\n\tTickerFuture = exchange.GetTicker()\n\tTickerFuture['BuyAmount'] = TickerFuture['Info']['result']['best_bid_amount']\n\tTickerFuture['SellAmount'] = TickerFuture['Info']['result']['best_ask_amount']\n\n\tDiff = _N(TickerFuture['Buy'] - TickerSwap['Sell'],2)\n\n\tMsg = ''\n\tMsg += str(ContractSwap) +' '+ str(TickerSwap['Sell']) +' '+ str(TickerSwap['SellAmount'])+ '\\n'\n\tMsg += str(ContractFuture) +' '+ str(TickerFuture['Buy']) +' '+ str(TickerFuture['BuyAmount']) + '\\n'\n\tMsg += '差价: ' + str(Diff) + '\\n'\n\n\tif Diff <= DiffMin:\n\t\treturn '差价为 ' + str(_N(Diff,2)) + ' 小于设定价差 '+str(DiffMin)+'，不下单' + '\\n\\n附加信息\\n' +Msg\n\n\tif TickerFuture['BuyAmount'] < Amount or TickerFuture['SellAmount'] < Amount:\n\t\treturn '某方向挂单量小于设定下单量 '+str(Amount)+'，不下单' + '\\n\\n附加信息\\n' +Msg\n\n\tif not RealTrade:\n\t\treturn '非真实交易' + '\\n' + Msg\n\n\texchange.SetContractType(ContractSwap)\n\texchange.SetDirection(\"buy\")\n\tBuyOrderId = exchange.Buy(TickerSwap['Sell'] + 0.2, Amount)\n\n\texchange.SetContractType(ContractFuture)\n\texchange.SetDirection(\"sell\")\n\tSellOrderId = exchange.Sell(TickerFuture['Buy'] - 0.2, Amount)\n\n\tBuyOrder = exchange.GetOrder(BuyOrderId)\n\tSellOrder = exchange.GetOrder(SellOrderId)\n\n\tTradeMsg = '交易完成\\n'\n\tTradeMsg += '买单 ' + str(BuyOrder['ContractType']) + ' ' + str(BuyOrder['Price']) + ' ' + str(BuyOrder['DealAmount']) + '/' + str(BuyOrder['Amount']) + '\\n'\n\tTradeMsg += '卖单 ' + str(SellOrder['ContractType']) + ' ' + str(SellOrder['Price']) + ' ' + str(SellOrder['DealAmount']) + '/' + str(SellOrder['Amount']) + '\\n'\n\tTradeMsg += '\\n\\n附加信息\\n' +Msg\n\treturn TradeMsg"}
{"query": "请生成一个本地存储策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n#  Persistent Storage for FMZ\n#\n# Copyright 2020 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE \n#                    Version 2, December 2004 \n#\n# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net> \n#\n# Everyone is permitted to copy and distribute verbatim or modified \n# copies of this license document, and changing it is allowed as long \n# as the name is changed. \n#\n#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE \n#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION \n#\n#  0. You just DO WHAT THE FUCK YOU WANT TO.\n#\n\nclass PersistentStorage:\n    \n    def __init__(self):\n        keys = _G('__keys__')\n        if isinstance(keys, list):\n            self.__keys__ = keys\n        else:\n            self.__keys__ = []\n            self.__setitem__('__keys__', self.__keys__)\n        return\n    \n    def _add_key(self, key):\n        if key == '__keys__':\n            return\n        self.__keys__.append(key)\n        self.__setitem__('__keys__', self.__keys__)\n        return\n        \n    def _del_key(self, key):\n        if key == '__keys__':\n            return\n        if key in self.__keys__:\n            del self.__keys__[self.__keys__.index(key)]\n        self.__setitem__('__keys__', self.__keys__)\n        return\n    \n    def __setitem__(self, key, value):\n        _G(key, value)\n        self._add_key(key)\n        return\n    \n    def __delitem__(self, key):\n        _G(key, None)\n        self._del_key(key)\n        return\n    \n    def __getitem__(self, key):\n        return _G(key)\n\n    def keys(self):\n        return self.__keys__\n        \n\next.PersistentStorage = PersistentStorage"}
{"query": "请生成一个检查https-quantla-Argus-是否正常策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport urllib2\ndef main():\n    Log(\"开始检查@\")\n    while True:\n        try:\n            urllib2.urlopen(\"https://quant.la/API/Argus/predict\", timeout=15)\n            Log(\"服务正常\")\n        except:\n            Log(_D(),\" 服务异常@\")\n        Sleep(10*60*1000)"}
{"query": "请生成一个测试多图表展示Python版策略代码", "base_model_response": "", "lora_model_response": "```\n# 创建多个图\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\ndef func():\n    pass\n\nfig.canvas.draw_idle()\n\nfig.legend(loc='upper right')\nplt.show()\n```\n\n请根据您的实际需求，修改参数为：`func() -> None`", "original_response": "python\nimport random\nimport time\ndef main():\n    cfgA = {\n        \"title\" : {\"text\" : \"盘口图表\"},\n        \"xAxis\" : {\n            \"type\" : \"datetime\"\n        }, \n        \"series\" : [{\n            \"name\" : \"买一\", \n            \"data\" : [],        \n        },{\n            \"name\" : \"卖一\",\n            \"data\" : [],\n        }]\n    }\n\n    cfgB = {\n        \"title\" : {\"text\" : \"差价图\"},\n        \"xAxis\" : {\n            \"type\" : \"datetime\"\n        },\n        \"series\" : [{\n            \"name\" : \"差价\",\n            \"type\" : \"column\",\n            \"data\" : [],\n        }]\n    }\n\n    cfgC = {\n        \"__isStock\" : False,\n        \"title\" : {\n            \"text\" : \"饼图\"\n        },\n        \"series\" : [{\n            \"type\" : \"pie\",\n            \"name\" : \"one\",\n            \"data\" : [\n                [\"A\", 25],\n                [\"B\", 25],\n                [\"C\", 25],\n                [\"D\", 25],\n            ]\n        }]\n    }\n\n    chart = Chart([cfgA, cfgB, cfgC])\n    chart.reset()\n    chart.add(3, {\n        \"name\" : \"ZZ\", \n        \"y\" : random.random() * 100\n    })\n\n\n    chart.update([cfgA, cfgB, cfgC])\n    chart.add(0, [_N(time.time() * 1000, 0), 50])\n    chart.add(1, [_N(time.time() * 1000, 0), 80])\n    chart.add(2, [_N(time.time() * 1000, 0), 90])\n    chart.add(3, {\n        \"name\" : \"ZZ\",\n        \"y\" : random.random() * 100\n    }, -1)"}
{"query": "请生成一个测试托管者与交易所服务器的真实网络延迟-支持同时测试多个交易所策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# Contact : ck@xueqiubot.com / WeChat@stay37\n\nimport time\nimport numpy as np\n\n\ndef test():\n    #延迟数据接收器\n    delay_list = []\n    for i in range(len(exchanges)):\n        delay_list.append([])\n    while True:\n        #延迟数据获取\n        for i in range(len(exchanges)):\n            send_t = time.time()\n            ticker = exchanges[i].GetTicker()\n            delay_list[i].append(round((time.time() - send_t) * 1000 , 2))\n        #数据输出 \n        delay_table = {\"type\":'table',\"title\":'延迟数据',\"cols\": ['账号序号','最近一次延迟','平均延迟','已测试次数'],\"rows\":[]}\n        for i in range(len(delay_list)):\n            delay_table['rows'].append([i + 1, str(delay_list[i][-1])+' ms', str(round(np.mean(delay_list[i]) , 2)) + ' ms', len(delay_list[i])])\n        LogStatus(\"输出的延迟为：发送一次get_ticker请求到获取到数据的真实时间\" + \"\\n\" + \"`\" + json.dumps(delay_table) + \"`\")\n        time.sleep(0.05)\n\n                \ndef main():\n    for i in range(len(exchanges)):\n        exchanges[i].SetContractType('swap')\n    test()"}
{"query": "请生成一个海龟策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport json\nimport time\n\nclass Turtle:\n    def __init__(self, account=None, donchian_channel_open_position=20, donchian_channel_stop_profit=10, atr_day_length=20, max_risk_ratio=0.5):\n        self.donchian_channel_open_position = donchian_channel_open_position  # 唐奇安通道的天数周期(开仓)\n        self.donchian_channel_stop_profit = donchian_channel_stop_profit  # 唐奇安通道的天数周期(止盈)\n        self.atr_day_length = atr_day_length  # ATR计算所用天数\n        self.max_risk_ratio = max_risk_ratio  # 最高风险度\n        self.state = {\n            \"position\": 0,  # 本策略净持仓数(正数表示多头，负数表示空头，0表示空仓)\n            \"last_price\": float(\"nan\"),  # 上次调仓价\n        }\n        positions = _C(exchange.GetPosition)\n        self.equity=0\n        for position in positions:\n            if position[\"Type\"]==PD_LONG:\n                self.state[\"position\"]=position[\"Amount\"]\n                self.state[\"last_price\"] = position[\"Price\"]\n                self.equity+=position[\"Margin\"]\n            elif position[\"Type\"]==PD_SHORT:\n                self.state[\"position\"]=-position[\"Amount\"]\n                self.state[\"last_price\"] = position[\"Price\"]\n                self.equity+=position[\"Margin\"]\n        self.account = _C(exchange.GetAccount)\n        self.equity += self.account[\"Stocks\"]+self.account[\"FrozenStocks\"]\n        #Log(self.equity)\n\n        self.n = 0  # 平均真实波幅(N值)\n        self.unit = 0  # 买卖单位\n        self.donchian_channel_high = 0  # 唐奇安通道上轨\n        self.donchian_channel_low = 0  # 唐奇安通道下轨\n        # 由于ATR是路径依赖函数，因此使用更长的数据序列进行计算以便使其值稳定下来\n        self.klines = exchange.GetRecords()\n\n    def recalc_paramter(self):\n        # 平均真实波幅(N值)\n        self.equity=0\n        positions = _C(exchange.GetPosition)\n        for position in positions:\n            if position[\"Type\"]==PD_LONG:\n                self.equity+=position[\"Margin\"]\n            elif position[\"Type\"]==PD_SHORT:\n                self.equity+=position[\"Margin\"]\n        self.account = _C(exchange.GetAccount)\n        self.equity += self.account[\"Stocks\"]+self.account[\"FrozenStocks\"]\n        #Log(self.equity)\n        records = _C(exchange.GetRecords)\n        self.n =TA.ATR(records, self.atr_day_length)[-1]\n        # 买卖单位\n        self.current_price = records[-1][\"Close\"]\n        self.unit = int((self.equity * 0.01*self.current_price*self.current_price) / (100 * self.n))\n        # 唐奇安通道上轨：前N个交易日的最高价\n        #Log(records)\n        self.donchian_channel_high =TA.Highest(records, self.donchian_channel_open_position , 'High') #唐奇安通道上轨：前N个交易日的最高价\n        self.donchian_channel_high =TA.Highest(records, 55 , 'High')\n        # 唐奇安通道下轨：前N个交易日的最低价\n        self.donchian_channel_low = TA.Lowest(records, self.donchian_channel_open_position , 'Low')\n        self.donchian_channel_low = TA.Lowest(records, 55 , 'Low')\n        #Log(\"唐其安通道上下轨: %f, %f\" % (self.donchian_channel_high, self.donchian_channel_low))\n        \n        self.stop_high = TA.Highest(records, self.donchian_channel_stop_profit , 'High') \n        self.stop_high = TA.Highest(records, 20 , 'High') \n        self.stop_low = TA.Highest(records, self.donchian_channel_stop_profit , 'Low') \n        self.stop_low = TA.Highest(records, 20, 'Low') \n\n        \n        boll = TA.BOLL(records, 50, 2)\n        self.up_line = boll[0][-1]\n        self.mid_line = boll[1][-1]\n        self.down_line = boll[2][-1]\n        close1 = records[-2]['Close']  # 最新收盘价\n        close30 = records[-30]['Close']  # 前30根K线的收盘价\n        hh30 = TA.Highest(records, 30, 'High')  # 最近30根K线的最高价\n        ll30 = TA.Lowest(records, 30, 'Low')  # 最近30根K线的最低价\n        self.cmi = abs((close1 - close30) / (hh30 - ll30)) * 100  # 计算市场波动指数\n\n        return True\n    def set_position(self, pos):\n        self.state[\"position\"] = pos\n        self.state[\"last_price\"] = self.current_price\n        positions = _C(exchange.GetPosition)\n        sell_amount =0\n        long_amount = 0\n        for position in positions:\n            if position[\"Type\"]==PD_LONG:\n                long_amount=position[\"Amount\"]\n            elif position[\"Type\"]==PD_SHORT:\n                sell_amount=position[\"Amount\"]\n\n        if pos>0:\n            if sell_amount>0:\n                exchange.SetDirection(\"closesell\")\n                exchange.Buy(self.current_price*1.005,sell_amount)\n            if pos>long_amount:\n                exchange.SetDirection(\"buy\")\n                exchange.Buy(self.current_price*1.005,pos-long_amount)\n            elif pos<long_amount:\n                exchange.SetDirection(\"closebuy\")\n                exchange.Sell(self.current_price*0.995,long_amount-pos)\n        elif pos<0:\n            pos=-pos \n            if long_amount>0:\n                exchange.SetDirection(\"closebuy\")\n                exchange.Sell(self.current_price*0.995,long_amount)\n            if pos>sell_amount:\n                exchange.SetDirection(\"sell\")\n                exchange.Sell(self.current_price*0.995,pos-sell_amount)\n            elif pos<sell_amount:\n                exchange.SetDirection(\"closesell\")\n                exchange.Buy(self.current_price*1.005,sell_amount-pos)\n        else:\n            if long_amount>0:\n                exchange.SetDirection(\"closebuy\")\n                exchange.Sell(self.current_price*0.995,long_amount)      \n            if sell_amount>0:\n                exchange.SetDirection(\"closesell\")\n                exchange.Buy(self.current_price*1.005,sell_amount)                \n        #self.target_pos.set_target_volume(self.state[\"position\"])\n    def try_open(self):\n        \"\"\"开仓策略\"\"\"\n        while self.state[\"position\"] == 0:\n            self.recalc_paramter()\n            #Log(\"最新价: %f\" % self.current_price)\n            if self.current_price > self.donchian_channel_high:  # 当前价>唐奇安通道上轨，买入1个Unit；(持多仓)\n            #if self.cmi>20 and self.current_price>self.up_line:\n                #Log(\"当前价>唐奇安通道上轨，买入1个Unit(持多仓): %d 手\" % self.unit)\n                self.set_position(self.state[\"position\"] + self.unit)\n            elif self.current_price < self.donchian_channel_low:  # 当前价<唐奇安通道下轨，卖出1个Unit；(持空仓)\n            #elif self.cmi>20 and self.current_price<self.down_line:\n                #Log(\"当前价<唐奇安通道下轨，卖出1个Unit(持空仓): %d 手\" % self.unit)\n                self.set_position(self.state[\"position\"] - self.unit)\n    def try_close(self):\n        \"\"\"交易策略\"\"\"\n        while self.state[\"position\"] != 0:\n            if True:\n                self.recalc_paramter()\n                Log(\"最新价: \", self.current_price)\n                #if self.cmi<20:\n                #    self.set_position(0)\n                if self.state[\"position\"] > 0:  # 持多单\n                    # 加仓策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了0.5N，就再加一个Unit的多仓,并且风险度在设定范围内(以防爆仓)\n                    if self.current_price >= self.state[\"last_price\"] + 0.5 * self.n and self.state[\"position\"] + self.unit<=4*self.unit:\n                        Log(\"加仓:加1个Unit的多仓\")\n                        self.set_position(self.state[\"position\"] + self.unit)\n                    # 止损策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了2N，就卖出全部头寸止损\n                    elif self.current_price <= self.state[\"last_price\"] - 2 * self.n:\n                        Log(\"止损:卖出全部头寸\")\n                        self.set_position(0)\n                    # 止盈策略: 如果是多仓且行情最新价跌破了10日唐奇安通道的下轨，就清空所有头寸结束策略,离场\n                    if self.current_price <= self.stop_low:\n                    #if self.current_price<self.mid_line:\n                        Log(\"止盈:清空所有头寸结束策略,离场\")\n                        self.set_position(0)\n                elif self.state[\"position\"] < 0:  # 持空单\n                    # 加仓策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了0.5N，就再加一个Unit的空仓,并且风险度在设定范围内(以防爆仓)\n                    if self.current_price <= self.state[\"last_price\"] - 0.5 * self.n and (-self.state[\"position\"]) + self.unit<=4*self.unit:\n                        Log(\"加仓:加1个Unit的空仓\")\n                        self.set_position(self.state[\"position\"] - self.unit)\n                    # 止损策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了2N，就平仓止损\n                    elif self.current_price >= self.state[\"last_price\"] + 2 * self.n:\n                        Log(\"止损:卖出全部头寸\")\n                        self.set_position(0)\n                    # 止盈策略: 如果是空仓且行情最新价升破了10日唐奇安通道的上轨，就清空所有头寸结束策略,离场\n                    if self.current_price >= self.stop_high:\n                    #if self.current_price>self.mid_line:\n                        Log(\"止盈:清空所有头寸结束策略,离场\")\n                        self.set_position(0)\n    def strategy(self):\n        \"\"\"海龟策略\"\"\"\n        Log(\"等待K线及账户数据...\")\n        while not self.recalc_paramter():\n            raise Exception(\"获取数据失败，请确认行情连接正常并已经登录交易账户\")\n        while True:\n            self.try_open()\n            self.try_close()\n\n\ndef main():\n    exchange.SetContractType(\"quarter\")\n    turtle = Turtle(donchian_channel_open_position=Donchian_open,donchian_channel_stop_profit=Donchian_stop,atr_day_length=Atr)\n    Log(\"策略开始运行\")\n\n    Log(\"当前持仓数: %d, 上次调仓价: %f\" % (turtle.state[\"position\"], turtle.state[\"last_price\"]))\n    turtle.strategy()"}
{"query": "请生成一个海龟策略btc现货版策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2019-01-01 00:00:00\nend: 2020-03-02 00:00:00\nperiod: 1d\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\",\"stocks\":0}]\nargs: [[\"fresh_rete\",24],[\"DC_range\",20],[\"atrlength\",14]]\n'''\n\n\nimport numpy as np\nimport pandas as pd\nimport datetime\n\n\ndata = {'ordertime':[],'id':[],'price':[]}\nhisorder = pd.DataFrame(data)\n    \ndef turtle():\n    #声明全局变量\n    global hisorder\n    \n    acct = exchange.GetAccount()\n\n    records=exchange.GetRecords(fresh_rete*60*60)\n\n    ticker = exchange.GetTicker()\n    \n\n    portfolio_value = acct.Balance+acct.FrozenBalance+(acct.Stocks+acct.FrozenStocks)*records[-1]['Close']\n    atr = TA.ATR(records, atrlength)[-1]\n    #计算得到unit大小\n    value = portfolio_value*trade_percent\n    unit =  min(round(value/atr,4),round(acct.Balance/(ticker['Last']+100),4))\n    #unit =  round(value/atr,2)\n\n    df = pd.DataFrame(records)\n    current_price = records[-1]['Close']\n    last_price = 0\n    if len(hisorder)!=0:\n        last_price = hisorder.iloc[-1]['price']\n    max_price = df[-DC_range:-2]['High'].max()\n    min_price = df[-int(DC_range/2):-2]['Low'].min() \n    \n    opensign = len(hisorder)==0 and current_price > max_price\n    \n\n    addsign = len(hisorder)!=0 and current_price > last_price + 0.5*atr\n\n\n    stopsign = len(hisorder)!=0 and current_price < min_price\n    \n    \n    closesign = len(hisorder)!=0 and current_price < (last_price - 2*atr)\n\n    \n#    if _D(records[-1]['Time']/1000) == '2020-01-25 00:00:00':\n#        Log(\"records[-1]\",records[-1])\n\n\n\n\n\n    if opensign | addsign:\n        if acct.Balance >= (ticker['Last']+10)*unit and unit >0:\n            id = exchange.Buy(ticker['Last']+10,unit)\n            orderinfo = exchange.GetOrder(id)\n            data = {'ordertime':_D(records[-1]['Time']/1000),'id':id,'price':records[-1]['Close']}\n            hisorder = hisorder.append(data,ignore_index=True)\n            Log('买入后，最新账户信息：', exchange.GetAccount())\n            Log(\"opensign\",opensign,\"addsign\",addsign)\n    #    else:\n    #        Log('余额已不足，请充值......', exchange.GetAccount())\n    if stopsign | closesign:\n        exchange.Sell(-1, acct.Stocks+acct.FrozenStocks)\n        data = {'ordertime':[],'id':[],'price':[]}\n        hisorder = pd.DataFrame(data)\n        Log('卖出后，最新账户信息：', exchange.GetAccount())\n        Log(\"stopsign\",stopsign,\"closesign\",closesign)\n\n    \n\n    \ndef main():\n    while True:\n        turtle()\n        Sleep(fresh_rete*60*60*1000)"}
{"query": "请生成一个深度做市-盘口控制-操盘机器人-做市工具策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# -*- coding: UTF-8 -*-\nimport requests\nimport time\nimport random\nimport hashlib\nimport sys\nimport threading\nfrom api import *\n\nsymbol = sys.argv[1]\ngap= float(sys.argv[2]) #密度/价差\nbaseamount = float(sys.argv[3])\nbasebuy = float(sys.argv[4])\namount_add\t= float(sys.argv[5]) \t#挂单增量\t数字型(number)\namount_add2 = float(sys.argv[6]) \t#挂单增量\t数字型(number)\nlongperoidlimit = int(sys.argv[7])\nbigbase = float(sys.argv[8])\t\t\t\t#大单基准量\norderlimit = int(sys.argv[9])   #总单量\napi_key = sys.argv[10]\nsecret_key = sys.argv[11]\n\nshortperoidlimit = 3\t#高频单量\n\npre_short_id = []\t#高平id标记\npre_long_id = []\t#低频id标记\npre_big_id = 0\n\nrequests.packages.urllib3.disable_warnings()\n\ndef GetTicker():\n\ndef GetPV():\n\ndef GetDepth():\n\ndef GetSign(sign_str):\n\n\ndef GetOrders():\n\ndef create_order(side,price,amount):\n\ndef CancelOrder(order_id):\n\ndef Buy(price,amount):\n\ndef Sell(price,amount):\n\ndef GetRecords(symbol,period):\n\ndef GetPrecision():\n\ndef getrr():\n\ndef ordersend_shortperoid():\n\ndef ordersend_longperoid():\n\ndef send_big_order():\n\ndef cancel():\n\n\nif __name__ == '__main__':\n\tprecision = GetPrecision()\n\tprint(precision)\n\ti = 0\n\tfor x in precision:\n\t\tif precision[i]['symbol'] == symbol:\n\t\t\tpricedot = precision[i]['price_precision']\n\t\t\tamountdot = precision[i]['amount_precision']\n\t\ti += 1\n\tpricegap =  max(gap,pow(10,-pricedot))\n\tthreading_list = [ordersend_shortperoid,ordersend_longperoid,send_big_order,cancel]\n\tthreadingList = []\n\tthreadingDict = {}\n\tfor x in threading_list:\n\t\tth = threading.Thread(target=x)\n\t\tthreadingList.append(th)\n\t\tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\n\t\tth.start()\n\n\twhile True:\n\t\ttry:\n\t\t\ttime.sleep(200)\n\t\t\tfor i in threadingList:\n\t\t\t\tif i.is_alive() is False:\n\t\t\t\t\tthreadingList.remove(i)\n\t\t\t\t\tresult = threadingDict.pop(i.name)\n\t\t\t\t\tth = threading.Thread(target=result)\n\t\t\t\t\tthreadingList.append(th)\n\t\t\t\t\tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\n\t\t\t\t\tth.start()\n\t\texcept Exception as e:\n\t\t\tprint('check error',e)"}
{"query": "请生成一个现货平衡策略-001v策略代码", "base_model_response": "，使用Python语言", "lora_model_response": "```typescript\nimport { TradingSession } from 'exchanges';\n\ninterface Position {\n  quantity: number;\n}\n\nclass Options extends TradingSession {\n  constructor(): TradingSession {\n    super('Options');\n  }\n\n  // 获取所有Position的总数量\n  getTotalPOS(): number {\n    return this.getPositions().length * 2;\n  }\n}\n```\n\n这是一个简单的示例，显示了如何使用Options和Position类来配置期货市场。在上面的代码中，我展示了如何创建一个具有2个订单量的`Options`实例，并获取该实例的总数量（即200个订单）。\n\n如果你需要这个示例的更复杂版本，可以将你的`positions`数组替换为`positions[]`。你可以像这样操作：\n\n```typescript\nconst positions = [];\nfor (let i = 0; i < 2; i++) {\n  const position = new Position({\n    quantity: i,\n  });\n  positions.push(position);\n}\n\nconst options = new Options();\noptions.setPositions(positions);\n\nconsole.log(options.getTotalPOS());\n```\n\n这个版本会打印出200个有效的`Position`，它们的总数量就是200个。", "original_response": "python\n\n\nimport time\nimport requests\nimport math\n\naccount = 0          #保存用户资产\nupdateProfitTime = 0   #更新收益率间隔时间\ntradeInfo = {}         #保存交易对信息\naccountAssets = {}\nticker = {}\nruntimeData = {}\nFunding = 0   #账户资金  为0的时候自动获取\nVersion = '0.0.1'\nsbs = list(symbols.split(','))\n\n\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Binance':\n    Log('只支持币安现货交易所！')\n    exit()\n\ndef init():\n    exchangeInfo = requests.get('https://api.binance.com/api/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法链接币安网络，需要海外托管者！！！')\n        exit()\n    for x in range(len(exchangeInfo['symbols'])):\n        for symbol in sbs:\n            if exchangeInfo['symbols'][x]['symbol'] == symbol+'USDT':\n                tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][x]['filters'][2]['minQty']) ,\n                'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][2]['stepSize']))))}\n    # Log('tradeInfo:',tradeInfo)\n\ndef UpdateAccount():\n    global accountAssets,Funding,account\n    acc = exchange.GetAccount()\n    if _G('Funding') is None:\n        Funding = account['Balance']\n        Log('Funding:',Funding)\n        _G('Funding',Funding)\n    else:\n        Funding = _G('Funding')\n\n    if account is None:\n        Log('更新账户超时！！！')\n        return\n\n    for x in range(len(acc['Info']['balances'])):\n        for symbol in sbs:\n            # Log(account['Info']['balances'])\n            if acc['Info']['balances'][x]['asset'] == symbol:\n                accountAssets[symbol] = acc['Info']['balances'][x]\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\n                # Log('USDT:',acc['Info']['balances'][x])\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\n\n    # Log('accountAssets:',accountAssets)\n\n\ndef UpdateTick():\n    global ticker,account\n    try:\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\n    except:\n        Log('更新行情超时')\n        return\n    for x in range(len(res)):\n        for symbol in sbs:\n            if res[x]['symbol'] == symbol + 'USDT':\n                # Log('res[x]:',res[x])\n                ticker[symbol] = res[x]\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\n    # Log('ticker:',ticker)\n    # account = 0\n    for symbol in sbs:\n        account += _N(ticker[symbol]['value'],4)\n\ndef Trade(symbol,direction,price,amount):\n    if amount < tradeInfo[symbol]['minQty']:\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n    else:\n        para = ''\n        url = '/api/v3/order'\n        para += 'symbol='+ symbol +'USDT'\n        para += '&side='+ direction\n        para += '&type=LIMIT&timeInForce=IOC'\n        para += '&quantity='+ str(amount)\n        para += '&price='+ str(price)\n        para += '&timestamp='+str(time.time() * 1000);\n        go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n        ret = go.wait()\n        if ret  is not None:\n            logType = LOG_TYPE_SELL\n            if direction == 'BUY':\n                logType =LOG_TYPE_BUY\n            exchange.Log(logType,price,amount,symbol)\n\ndef UpdateStatus():\n    global updateProfitTime\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\n        'rows': []\n    }\n    totalProfit = account - Funding\n    profitColors = DangerColor\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday   #平均日收益\n    dayRate = totalProfit / Funding * 100\n    accountTable['rows'].append([\n    runday,\n    Funding,\n    account,\n    str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n    str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n    str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n    str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n    i=1\n    for symbol in sbs:\n        table['rows'].append([\n        i,\n        symbol,\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\n        str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\n        str(_N(ticker[symbol]['value'],4))\n        ])\n        i += 1\n\n    retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n'\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = account - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n\ndef Process():\n\n    # Log('实时资金：',account)\n    for symbol in sbs:\n\n        pct = float(ticker[symbol]['value']) / float(account)\n        # Log(symbol,'amount:',amount,1 / len(sbs))\n        if pct > (1 / len(sbs) + 0.015):\n            # Log('SELL',pct)\n            Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\n            amount = _N( ( (pct-1/len(sbs) ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\n            Trade(symbol,'SELL',_N(float(ticker[symbol]['askPrice']), int(tradeInfo[symbol]['priceSize'])),  amount)\n        if pct < (1 / len(sbs) - 0.015):\n            # Log('Buy', pct)\n            Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\n            amount = _N( ( (1/len(sbs)-pct ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\n            Trade(symbol,'BUY',_N(float(ticker[symbol]['bidPrice']), tradeInfo[symbol]['priceSize']),  amount)\n\n\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef main():\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n        #休眠时间\n        Sleep(Interval * 1000)"}
{"query": "请生成一个现货指数平衡策略-v11曾实盘跑过一段时间现在疑似有bug因为不用了懒得改策略代码", "base_model_response": "```python\nimport numpy as np\n\nclass现货Index平衡策略:\n    def __init__(self):\n        pass\n\n    def trade(self, market_index):\n        # 执行交易操作，可能包括卖出、买入等操作\n        pass\n\n    def get_position_data(self, market_index):\n        # 获取市场位置数据，可能包含时间、单位等信息\n        pass\n\n    def update_positions(self):\n        # 更新市场位置数据，可能需要更新历史数据并计算新的价格\n        pass\n\n# 实际使用场景\ntrader =现货Index平衡策略()\ntrader.open_api('AAPL')\ntrader.close_api('AAPL')\nfor _ in range(30):\n    position_data = trader.get_position_data(trader市场_index)\n    trading_positions = trader.update_positions(position_data)\n\n# 实际运行结果\ntrader.run_trade(\"AAPL\", 1234567890)\nprint(trader.get_position_data(\"AAPL\"))\n```\n\n注意：这个策略的目的是为了模拟实际交易的过程，而不是用来实现自动交易。", "lora_model_response": "", "original_response": "python\n\nimport json\nimport time\nimport requests\nimport math\n\naccount = 0  \nupdateProfitTime = 0 \ntradeInfo = {} \naccountAssets = {}\nticker = {}\nruntimeData = {}\nFunding = 0\n\nsbs = list(symbols.split(','))\npcts = list(percent.split(','))\nfor i in range(len(pcts)):\n    pcts[i] = float(pcts[i])\n\np_dic = {\n            'ETH':[2,4], 'BTC':[2,5], 'XRP':[4,0], 'TRX':[5,1], 'LTC':[1,3], 'BNB':[1,3]\n         }    #价格、数量精度，按需求添加\n\n\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Binance':\n    Log('只支持币安现货交易所！')\n    exit()\n\ndef init():\n    exchangeInfo = requests.get('https://api.binance.com/api/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法链接币安网络，需要海外托管者！！！')\n        exit()\n    for x in range(len(exchangeInfo['symbols'])):\n        for symbol in sbs:\n            if exchangeInfo['symbols'][x]['symbol'] == symbol+'USDT':\n                tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][x]['filters'][2]['minQty']) ,\n                'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][2]['stepSize']))))}\n    # Log('tradeInfo:',tradeInfo)\n\ndef UpdateAccount():\n    global accountAssets,Funding,account\n    acc = exchange.GetAccount()\n\n    if acc is None:\n        Log('更新账户超时！！！')\n        return\n\n    if _G('Funding') is None:\n        Funding = acc['Balance']\n        Log('Funding:',Funding)\n        _G('Funding',Funding)\n    else:\n        Funding = _G('Funding')\n    if init_fund >0:\n        Funding = init_fund\n    \n\n    for x in range(len(acc['Info']['balances'])):\n        for symbol in sbs:\n            # Log(account['Info']['balances'])\n            if acc['Info']['balances'][x]['asset'] == symbol:\n                accountAssets[symbol] = acc['Info']['balances'][x]\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\n                # Log('USDT:',acc['Info']['balances'][x])\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\n\n    # Log('accountAssets:',accountAssets)\n\ndef UpdateTick():\n    global ticker,account\n    try:\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\n    except:\n        Log('更新行情超时')\n        return\n    for x in range(len(res)):\n        for symbol in sbs:\n            if res[x]['symbol'] == symbol + 'USDT':\n                # Log('res[x]:',res[x])\n                ticker[symbol] = res[x]\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\n    # Log('ticker:',ticker)\n    # account = 0\n    for symbol in sbs:\n        account += _N(ticker[symbol]['value'],4)\n\ndef UpdateStatus():\n    global updateProfitTime\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\n        'rows': []\n    }\n    totalProfit = account - Funding\n    profitColors = DangerColor\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday   #平均日收益\n    dayRate = totalProfit / Funding * 100\n    accountTable['rows'].append([\n    runday,\n    Funding,\n    account,\n    str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n    str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n    str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n    str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n    i=1\n    for symbol in sbs:\n        table['rows'].append([\n        i,\n        symbol,\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\n        str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\n        str(_N(ticker[symbol]['value'],4))\n        ])\n        i += 1\n\n    retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + '本策略改编自XMaxZone大佬的现货平衡策略-0.0.1v，原策略地址：https://www.fmz.com/strategy/322357' + '\\n'\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = account - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n\ndef Process():\n    # Log('实时资金：',account)\n    for i in range(len(sbs)):\n        pct = float(ticker[sbs[i]]['value']) / float(account)\n        # Log(symbol,'amount:',amount,1 / len(sbs))\n        if pct > (pcts[i] + delta):\n            # Log('SELL',pct)\n            amount = _N( ( (pct-pcts[i] ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\n                # Trade(sbs[i],'SELL',_N(float(ticker[sbs[i]]['askPrice']), int(tradeInfo[sbs[i]]['priceSize'])),  amount)\n                exchange.SetCurrency(sbs[i]+'_USDT')\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\n                exchange.Sell(float(ticker[sbs[i]]['bidPrice'])*(1-slip), amount)\n        if pct < (pcts[i] - delta):\n            # Log('Buy', pct)\n            amount = _N( ( (pcts[i]-pct ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\n                # Trade(sbs[i],'BUY',_N(float(ticker[sbs[i]]['bidPrice']), tradeInfo[sbs[i]]['priceSize']),  amount)\n                exchange.SetCurrency(sbs[i]+'_USDT')\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\n                exchange.Buy(float(ticker[sbs[i]]['bidPrice'])*(1+slip), amount)\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef main():\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n        #休眠时间\n        Sleep(Interval * 1000)"}
{"query": "请生成一个画线机器人一年翻倍回撤1完美曲线策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport random\n\ndef main():\n    account = exchange.GetAccount()\n    balance = account[\"Balance\"]\n    while True:\n        LogProfit(balance - account[\"Balance\"])\n        balance = balance * (1 + (0.5 - random.random()) / 1000 + 1 / 100000)\n        Sleep(1000 * 60)"}
{"query": "请生成一个简单的做市对冲功能策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n# -*- coding: UTF-8 -*-\nimport time\nfrom api import *\nfrom Huobiapi import *\nimport sqlite3\n\ndef wechatmsg(text,desp):\n\tserver = 'https://sc.ftqq.com/xxxxxx.send'\n\tpayload = {'text':text,'desp':desp}\n\trequests.post(server,params = payload)\n\ndef dingmsg(title,msg):\n\turl = 'https://oapi.dingtalk.com/robot/send?access_token=xxxxxx'\n\tdata = {\n\t\t\t \"msgtype\": \"markdown\",\n\t\t\t \"markdown\": {\n\t\t\t\t \"title\":title+msg,\n\t\t\t\t \"text\": \"#### \" + title + \"\\n\"\n\t\t\t\t\t\t \"> \" + msg\t\t\t\t\t\t \n\t\t\t}}\t\t \n\theader = {'Content-Type':'application/json'}\n\tr = requests.post(url = url ,headers=header,data = json.dumps(data)).json()\n\treturn r\n\ndef check():\n\ttry:\n\t\tpre_balance = {}\n\t\tconn = sqlite3.connect(\"/root/bot/hedge.db\")\n\t\tcursor = conn.cursor()\n\t\tsql = 'select * from balance order by id desc limit 20;'\n\t\tresult = list(cursor.execute(sql))\n\t\tfor a in result:\n\t\t\tif a[1] in list(pre_balance.keys()):\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tpre_balance[a[1]] = a[2]   #读取之前balance\n\t\tcoinname = list(pre_balance.keys())\n\t\tprint(pre_balance,coinname)\n\n\t\tbalance = GetBalance()\n\t\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\n\t\tfor x in balance:  \n\t\t\tsql = \"insert into balance (coin,balance,time) values(?,?,?);\"\n\t\t\tb = x['balance']+x['frozenBalance']\n\t\t\tif b != 0:\n\t\t\t\tv = (x['coin']['unit'],b,t)\n\t\t\t\tprint(v)\n\t\t\t\tcursor.execute(sql,v)\n\t\t\tfor n in coinname:\n\t\t\t\tif n == x['coin']['unit']:\n\t\t\t\t\td = round(b - pre_balance[n],5)   #数量差\n\t\t\t\t\tif d > 0:\n                        Sell(n,d)\n\t\t\t\t\t\tmsg = '对冲卖出'+n+'数量：'+str(d)\n\t\t\t\t\t\tprint(msg)\n\t\t\t\t\t\twechatmsg('对冲',msg)\n\t\t\t\t\t\tdingmsg('对冲',msg)\n\t\t\t\t\t\tsql = \"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\"\n\t\t\t\t\t\tv = (n,d,0,t)\n\t\t\t\t\t\tcursor.execute(sql,v)\n\t\t\t\t\telif d < 0:\n                        Buy(n,d)\n\t\t\t\t\t\tmsg = '对冲买入：'+n+'数量：'+str(d)\n\t\t\t\t\t\tprint(msg)\n\t\t\t\t\t\twechatmsg('对冲',msg)\n\t\t\t\t\t\tdingmsg('对冲',msg)\n\t\t\t\t\t\tsql = \"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\"\n\t\t\t\t\t\tv = (n,d,0,t)\n\t\t\t\t\t\tcursor.execute(sql,v)\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint('no hedge')\n\n\t\tconn.commit()\n\t\tconn.close()\n\texcept Exception as e:\n\t\traise e\n\t\ndef insert_balance():\n\ttry:\n\t\tconn = sqlite3.connect(\"hedge.db\")\n\t\tcursor = conn.cursor()\n\t\tbalance = GetBalance()\n\t\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\n\t\tfor x in balance:\n\t\t\tsql = \"insert into balance (coin,balance,time) values(?,?,?);\"\n\t\t\tb = x['balance']+x['frozenBalance']\n\t\t\tif b != 0:\n\t\t\t\tv = (x['coin']['unit'],b,t)\n\t\t\t\tcursor.execute(sql,v)\n\t\tconn.commit()\n\t\tconn.close()\n\t\tprint('finish')\n\texcept Exception as e:\n\t\tprint('err',e)\n\nif __name__ == '__main__':\n\twhile 1:\n\t\ttry:\n\t\t\tcheck()\n\t\texcept Exception as e:\n\t\t\tprint(e)\n\t\ttime.sleep(30)"}
{"query": "请生成一个移植-OKCoin-韭菜收割机-多品种版-注释python版策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2022-03-28 00:00:00\nend: 2022-03-28 23:59:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\",\"stocks\":0,\"fee\":[0,0]},{\"eid\":\"Binance\",\"currency\":\"ETH_USDT\"}]\nmode: 1\nargs: [[\"BurstThresholdPct\",0.00127],[\"MinStock\",0.001]]\n'''\n\nimport time\nclass LeeksReaper():  \n    def __init__(self,exchange):                                      #创建构造函数LeeksReaper                                          #构造一个空的对象\n        self.numTick = 0\n        self.lastTradeId = 0\n        self.vol = 0\n        self.askPrice = 0\n        self.bidPrice = 0\n        self.orderBook = {}\n        self.prices = []\n        self.tradeOrderId = 0\n        self.p = 0.5\n        self.account = None\n        self.preCalc = 0\n        self.preNet = 0\n\n        self.sgnum = 0\n        # self.cny = 0\n        # self.btc = 0\n\n        self.exchange = exchange\n        #以上都是self对象的属性\n\n    #创建一个方法\n    def updateTrades(self):\n\n        trades = _C(self.exchange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\n                trades = _C(self.exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\n\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\n\n        tradesvol = 0\n        for trade in trades:\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\n                temp = trade.Time if trade.Id == 0 else trade.Id\n                self.lastTradeId = max(temp, self.lastTradeId)\n                tradesvol = tradesvol + trade.Amount\n\n\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\n\n\n    #self对象的一个方法\n    def updateOrderBook(self):\n\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\n        orderBook = _C(self.exchange.GetDepth)\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\n            #返回undefined\n            return\n        \n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\n        #同上\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\n        #删除price数组的第一个值，并返回第一个值\n        del(self.prices[0])\n        #prices数组向后添加值，值为函数_N的返回值\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\n            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\n\n    #self对象的一个方法\n    def balanceAccount(self):\n        # 创建一个变量account用来接收GetAccount函数返回的值\n        account = _C(self.exchange.GetAccount)\n        #判断account是否为空，是就返回undefined\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n        #获取当前时间的时间戳数据\n        now = time.time()\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\n            #赋值\n            self.preCalc = now\n            #创建一个变量net用来接收_N函数的返回值\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\n            #判断net是否不等于self.preNet，如果是就执行下方语句\n            if (net != self.preNet):\n                #赋值\n                self.preNet = net\n                #调用函数LogProfit并传入net\n                LogProfit(net-10000)\n\n        #赋值\n        self.btc = account.Stocks\n        self.cny = account.Balance\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\n        balanced = False\n        #判断self.p的值是否小于0.48\n        # Log(self.p)\n        if (self.p < 0.48):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.cny =self.cny-300\n            self.cny -= 300\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Bids) > 0):\n                #调用buy函数并传入相应的参数\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.001)\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.001)\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.001)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #如果self.p大于0.52就执行下方语句\n        elif (self.p > 0.52):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.btc=self.btc-0.03\n            self.btc -= 0.03\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Asks) > 0):\n                #调用Sell函数并传入相应的参数\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.001)\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.001)\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.001)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n        #调用函数Sleep并传入参数BalanceTimeout\n        Sleep(BalanceTimeout)\n        #创建标量order来接收GetOrders函数返回的值\n        orders = _C(self.exchange.GetOrders)\n        #判断orders是否为真\n        if (orders):\n            #遍历orders\n            Log(orders)\n            for i in range(len(orders)):\n                #判断orders的id是否不等于self.tradeOrderId\n                if (orders[i].Id != self.tradeOrderId):\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\n                    Log(orders[i].Id)\n                    self.exchange.CancelOrder(orders[i].Id)\n\n\n\n\n\n    #self的一个方法\n    def poll(self):\n\n        #self.numTick自加1\n        self.numTick +=1\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\n        self.updateTrades()\n        self.updateOrderBook()\n        self.balanceAccount()\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\n        burstPrice = self.prices[-1] * BurstThresholdPct\n        #创建变量并赋值\n        bull = False\n        bear = False\n        tradeAmount = 0\n        #判断self.account是否为真\n        if (self.account):\n            #是真的话就调用LogStatus函数并传入相应的参数\n            Log(self.exchange.GetCurrency(),self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\",收割机当前启动次数:\",self.sgnum)\n\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\n        if (self.numTick > 2 and ((self.prices[-1] - max(self.prices[-6:-1]) > burstPrice) or (self.prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2]))):\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\n            bull = True\n            tradeAmount = self.cny / self.bidPrice * 0.99\n\n        #同上面if\n        elif (self.numTick > 2 and ((self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice) or (self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2]))):\n            bear = True\n            #赋值\n            tradeAmount = self.btc\n\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\n        if (self.vol < BurstThresholdVol):\n            tradeAmount *= self.vol / BurstThresholdVol\n\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\n        if (self.numTick < 5):\n            #tradeAmount=tradeAmount*0.8\n            tradeAmount *= 0.8\n\n        #判断self.numTick是否小于10\n        if (self.numTick < 10):\n            tradeAmount *= 0.8\n\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\n            return\n\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\n        tradePrice = self.bidPrice if bull else self.askPrice\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\n        while (tradeAmount >= MinStock):\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\n            orderId = self.exchange.Buy(self.bidPrice, tradeAmount) if bull else self.exchange.Sell(self.askPrice, tradeAmount)\n            self.sgnum+=1\n            Log(\"收割机第\",self.sgnum,\"次启动\")\n            #调用Sleep函数传入参数400，0.4秒后执行\n            Sleep(400)\n            #判断orderId是否为true\n            if (orderId):\n                #赋值\n                self.tradeOrderId = orderId\n                #赋值\n                order = None\n                while (True):\n                    #rder的值等于GetOrder函数的返回值\n                    order = self.exchange.GetOrder(orderId)\n                    #判断order是否为true\n                    if (order):\n                        #判断两边的值是否相等\n                        if (order.Status == ORDER_STATE_PENDING):\n                            #调用CancelOrder函数\n                            self.exchange.CancelOrder(orderId)\n                            #0.2秒后执行\n                            Sleep(200)\n                        else:\n                            #跳出循环\n                            break\n\n\n                #赋值\n                self.tradeOrderId = 0\n                tradeAmount -= order.DealAmount\n                tradeAmount *= 0.9\n                #判断两边是否相等\n                if (order.Status == ORDER_STATE_CANCELED):\n                    #调用self的updateOrderBook方法\n                    self.updateOrderBook()\n                    #判断是否为true,如果时就进行循环\n                    while (bull and self.bidPrice - tradePrice > 0.1):\n                        #赋值\n                        tradeAmount *= 0.99\n                        tradePrice += 0.1\n\n                    #判断是否为true,如果时就进行循环\n                    while (bear and self.askPrice - tradePrice < -0.1):\n                        tradeAmount *= 0.99\n                        tradePrice -= 0.1\n        #赋值\n        self.numTick = 0\n\n\n\n\n#函数main\ndef main():\n    #reaper 是构造函数的实例\n    reaperlist=[]\n    for coinexchange in exchanges:\n        reaper = LeeksReaper(coinexchange)\n        reaperlist.append(reaper)\n        reaper=None\n    while (True):\n        #通过实例调用poll方法\n        for coinreaper in reaperlist:\n            coinreaper.poll()\n        Sleep(TickInterval)"}
{"query": "请生成一个移植-OKCoin-韭菜收割机-注释python版策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2019-09-05 00:00:00\nend: 2019-09-05 22:00:00\nperiod: 1h\nbasePeriod: 1h\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\",\"stocks\":0,\"fee\":[0,0]}]\nmode: 1\n'''\n\nimport time\nclass LeeksReaper():  \n    def __init__(self):                                      #创建构造函数LeeksReaper                                          #构造一个空的对象\n        self.numTick = 0\n        self.lastTradeId = 0\n        self.vol = 0\n        self.askPrice = 0\n        self.bidPrice = 0\n        self.orderBook = {}\n        self.prices = []\n        self.tradeOrderId = 0\n        self.p = 0.5\n        self.account = None\n        self.preCalc = 0\n        self.preNet = 0\n\n        self.sgnum = 0\n        # self.cny = 0\n        # self.btc = 0\n        #以上都是self对象的属性\n\n    #创建一个方法\n    def updateTrades(self):\n\n        trades = _C(exchange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\n                trades = _C(exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\n\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\n\n        tradesvol = 0\n        for trade in trades:\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\n                temp = trade.Time if trade.Id == 0 else trade.Id\n                self.lastTradeId = max(temp, self.lastTradeId)\n                tradesvol = tradesvol + trade.Amount\n\n\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\n\n\n    #self对象的一个方法\n    def updateOrderBook(self):\n\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\n        orderBook = _C(exchange.GetDepth)\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\n            #返回undefined\n            return\n        \n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\n        #同上\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\n        #删除price数组的第一个值，并返回第一个值\n        del(self.prices[0])\n        #prices数组向后添加值，值为函数_N的返回值\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\n            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\n\n    #self对象的一个方法\n    def balanceAccount(self):\n        # 创建一个变量account用来接收GetAccount函数返回的值\n        account = _C(exchange.GetAccount)\n        #判断account是否为空，是就返回undefined\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n        #获取当前时间的时间戳数据\n        now = time.time()\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\n            #赋值\n            self.preCalc = now\n            #创建一个变量net用来接收_N函数的返回值\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\n            #判断net是否不等于self.preNet，如果是就执行下方语句\n            if (net != self.preNet):\n                #赋值\n                self.preNet = net\n                #调用函数LogProfit并传入net\n                LogProfit(net-10000)\n\n        #赋值\n        self.btc = account.Stocks\n        self.cny = account.Balance\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\n        balanced = False\n        #判断self.p的值是否小于0.48\n        # Log(self.p)\n        if (self.p < 0.48):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.cny =self.cny-300\n            self.cny -= 300\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Bids) > 0):\n                #调用buy函数并传入相应的参数\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.01)\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.01)\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.01)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #如果self.p大于0.52就执行下方语句\n        elif (self.p > 0.52):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.btc=self.btc-0.03\n            self.btc -= 0.03\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Asks) > 0):\n                #调用Sell函数并传入相应的参数\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.01)\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.01)\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.01)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n        #调用函数Sleep并传入参数BalanceTimeout\n        Sleep(BalanceTimeout)\n        #创建标量order来接收GetOrders函数返回的值\n        orders = _C(exchange.GetOrders)\n        #判断orders是否为真\n        if (orders):\n            #遍历orders\n            Log(orders)\n            for i in range(len(orders)):\n                #判断orders的id是否不等于self.tradeOrderId\n                if (orders[i].Id != self.tradeOrderId):\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\n                    Log(orders[i].Id)\n                    exchange.CancelOrder(orders[i].Id)\n\n\n\n\n\n    #self的一个方法\n    def poll(self):\n\n        #self.numTick自加1\n        self.numTick +=1\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\n        self.updateTrades()\n        self.updateOrderBook()\n        self.balanceAccount()\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\n        burstPrice = self.prices[-1] * BurstThresholdPct\n        #创建变量并赋值\n        bull = False\n        bear = False\n        tradeAmount = 0\n        #判断self.account是否为真\n        if (self.account):\n            #是真的话就调用LogStatus函数并传入相应的参数\n            LogStatus(self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\",收割机当前启动次数:\",self.sgnum)\n\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\n        if (self.numTick > 2 and (self.prices[-1] - max(self.prices[-6:-1]) > burstPrice or self.prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2])):\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\n            bull = True\n            tradeAmount = self.cny / self.bidPrice * 0.99\n\n        #同上面if\n        elif (self.numTick > 2 and (self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice or self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2])):\n            bear = True\n            #赋值\n            tradeAmount = self.btc\n\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\n        if (self.vol < BurstThresholdVol):\n            tradeAmount *= self.vol / BurstThresholdVol\n\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\n        if (self.numTick < 5):\n            #tradeAmount=tradeAmount*0.8\n            tradeAmount *= 0.8\n\n        #判断self.numTick是否小于10\n        if (self.numTick < 10):\n            tradeAmount *= 0.8\n\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\n            return\n\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\n        tradePrice = self.bidPrice if bull else self.askPrice\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\n        while (tradeAmount >= MinStock):\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\n            orderId = exchange.Buy(self.bidPrice, tradeAmount) if bull else exchange.Sell(self.askPrice, tradeAmount)\n            self.sgnum+=1\n            Log(\"收割机第\",self.sgnum,\"次启动\")\n            #调用Sleep函数传入参数400，0.4秒后执行\n            Sleep(400)\n            #判断orderId是否为true\n            if (orderId):\n                #赋值\n                self.tradeOrderId = orderId\n                #赋值\n                order = None\n                while (True):\n                    #rder的值等于GetOrder函数的返回值\n                    order = exchange.GetOrder(orderId)\n                    #判断order是否为true\n                    if (order):\n                        #判断两边的值是否相等\n                        if (order.Status == ORDER_STATE_PENDING):\n                            #调用CancelOrder函数\n                            exchange.CancelOrder(orderId)\n                            #0.2秒后执行\n                            Sleep(200)\n                        else:\n                            #跳出循环\n                            break\n\n\n                #赋值\n                self.tradeOrderId = 0\n                tradeAmount -= order.DealAmount\n                tradeAmount *= 0.9\n                #判断两边是否相等\n                if (order.Status == ORDER_STATE_CANCELED):\n                    #调用self的updateOrderBook方法\n                    self.updateOrderBook()\n                    #判断是否为true,如果时就进行循环\n                    while (bull and self.bidPrice - tradePrice > 0.1):\n                        #赋值\n                        tradeAmount *= 0.99\n                        tradePrice += 0.1\n\n                    #判断是否为true,如果时就进行循环\n                    while (bear and self.askPrice - tradePrice < -0.1):\n                        tradeAmount *= 0.99\n                        tradePrice -= 0.1\n        #赋值\n        self.numTick = 0\n\n\n\n\n#函数main\ndef main():\n    #reaper 是构造函数的实例\n    reaper = LeeksReaper()\n    while (True):\n        #通过实例调用poll方法\n        reaper.poll()\n        Sleep(TickInterval)"}
{"query": "请生成一个简易等差合约网格策略代码", "base_model_response": "```python\nimport random\n\ndef generate_grid(grid, num_rows, num_cols):\n    return [(random.randint(0, len(grid[0])) + 1, random.randint(0, len(grid[1])) + 1) for _ in range(num_rows)] + [(random.randint(0, len(grid)) + 1, random.randint(0, len(grid[2])) + 1) for _ in range(num_cols)]\n\ndef main():\n    grid = generate_grid([3, 2, 4], 5, 6)\n    \n    print(\"\\nGrid: \", grid)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n这个简单的等差数列网格策略代码，使用随机选择每行的元素来填充网格。然后，它会创建一个新的等差数列网格，并将其添加到原始网格上。最后，它打印出新的网格。\n\n请注意，这只是一个非常基础的等差数列网格策略代码，你可能需要根据你的具体需求进行修改和扩展。", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2021-01-01 00:00:00\nend: 2021-11-17 00:00:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"BTC_USDT\",\"balance\":2500}]\nargs: [[\"H\",30],[\"n1\",0.001],[\"grid\",300],[\"xia\",50000]]\n'''\n\ndef CancelPendingOrders():\n    orders = _C(exchanges[0].GetOrders)\n    if len(orders)>0:\n        for j in range(len(orders)):\n            exchanges[0].CancelOrder(orders[j].Id, orders[j])\n            j=j+1\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(M)\n    currency=exchange.GetCurrency()\n    if _G('buyp') and _G('sellp'):\n        buyp=_G('buyp')\n        sellp=_G('sellp')\n        Log('读取网格价格')\n    else:\n        ticker=exchange.GetTicker()\n        buyp=ticker[\"Last\"]-grid\n        sellp=ticker[\"Last\"]+grid\n        _G('buyp',buyp)\n        _G('sellp',sellp)\n        Log('网格数据初始化')\n    while True:\n            account=exchange.GetAccount()\n            ticker=exchange.GetTicker()\n            position=exchange.GetPosition()\n            orders=exchange.GetOrders()\n            if len(position)==0:\n                if ticker[\"Last\"]>shang:\n                    exchange.SetDirection('sell')\n                    exchange.Sell(-1,n1*H)\n                    Log(currency,'到达开空区域,买入空头底仓')\n                    \n                else:\n                    exchange.SetDirection('buy')\n                    exchange.Buy(-1,n1*H)\n                    Log(currency,'到达开多区域,买入多头底仓')\n            if len(position)==1:\n                if position[0][\"Type\"]==1:\n                    if ticker[\"Last\"]<xia:\n                        Log(currency,'空单全部止盈反手')\n                        exchange.SetDirection('closesell')\n                        exchange.Buy(-1,position[0].Amount)\n                    else:\n                        orders=exchange.GetOrders()\n                        if len(orders)==0:\n                            exchange.SetDirection('sell')\n                            exchange.Sell(sellp,n1)\n                            exchange.SetDirection('closesell')\n                            exchange.Buy(buyp,n1)\n                        if len(orders)==1:\n                            if orders[0][\"Type\"]==1: #止盈成交\n                                Log(currency,'网格减仓,当前份数:',position[0].Amount)\n                                CancelPendingOrders()\n                                buyp=buyp-grid\n                                sellp=sellp-grid\n                                LogProfit(account[\"Balance\"])\n                            if orders[0][\"Type\"]==0:\n                                Log(currency,'网格加仓,当前份数:',position[0].Amount)\n                                CancelPendingOrders()\n                                buyp=buyp+grid\n                                sellp=sellp+grid\n                                LogProfit(account[\"Balance\"])\n            \n                if position[0][\"Type\"]==0:\n                    if ticker[\"Last\"]>float(shang):\n                        Log(currency,'多单全部止盈反手')\n                        exchange.SetDirection('closebuy')\n                        exchange.Sell(-1,position[0].Amount)\n                    else:\n                        orders=exchange.GetOrders()\n                        if len(orders)==0:\n                            exchange.SetDirection('buy')\n                            exchange.Buy(buyp,n1)\n                            exchange.SetDirection('closebuy')\n                            exchange.Sell(sellp,n1)\n                        if len(orders)==1:\n                            if orders[0][\"Type\"]==0: #止盈成交\n                                Log(currency,'网格减仓,当前份数:',position[0].Amount)\n                                CancelPendingOrders()\n                                buyp=buyp+grid\n                                sellp=sellp+grid\n                                LogProfit(account[\"Balance\"])\n                            if orders[0][\"Type\"]==1:\n                                Log(currency,'网格加仓,当前份数:',position[0].Amount)\n                                CancelPendingOrders()\n                                buyp=buyp-grid\n                                sellp=sellp-grid\n                                LogProfit(account[\"Balance\"])"}
{"query": "请生成一个练习01RSI策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n\ndef RSI():\n    ticker = exchange.GetTicker()\n    account = exchange.GetAccount()\n    r = exchange.GetRecords(PERIOD_H1 * 4)\n    rsi = TA.RSI(r, 14)\n    is_buy = False\n    is_sell = False\n    if rsi[-1] > 70 and account[\"Stocks\"] > 0:\n        id = exchange.Sell(ticker[\"Buy\"], account[\"Stocks\"] * 0.01)\n        is_buy = True\n    elif rsi[-1] < 30 and account[\"Balance\"] > 0:\n        id = exchange.Buy(ticker[\"Sell\"], account[\"Balance\"] / ticker[\"Sell\"] * 0.01)\n        is_sell = True\n\n\n    if is_buy or is_sell:\n        Sleep(1000 * 60 * 4)\n        \n#    if rsi[-1] < 40 and account[\"Balance\"] > 0:\n#        id = exchange.Buy(ticker[\"Buy\"], account[\"Balance\"] / ticker[\"Sell\"] * 0.0005)\n#    if rsi[-1] > 60 and account[\"Stocks\"] > 0:\n#        id = exchange.Sell(ticker[\"Sell\"], account[\"Stocks\"] * 0.0005)\n#    if rsi[-1] < 40 and account[\"Balance\"] > 0:\n#        id = exchange.Buy(ticker[\"Buy\"], account[\"Balance\"] / ticker[\"Sell\"] * 0.05)\n    return\n \ndef main():\n    Log(\"策略开始 !\")\n    i = 0\n    while True:        #循环\n        RSI()       #执行策略主函数\n        i = i + 1\n        if i % 50 == 0:\n            account = exchange.GetAccount()\n            Log(account[\"Balance\"], account[\"Stocks\"])\n        \n'''\ndef main():\n    Log(\"策略开始 !\")\n    ticker = exchange.GetTicker()\n    account = exchange.GetAccount()\n    id = exchange.Buy(ticker[\"Buy\"], 0.01)\n    Log(account[\"Balance\"])\n    Log(id)\n    Sleep(60 * 1000)\n'''"}
{"query": "请生成一个网格合约策略代码", "base_model_response": "，实现自动执行智能合约", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2020-02-27 00:00:00\nend: 2020-02-27 00:00:00\nperiod: 1d\nexchanges: [{\"eid\":\"Futures_OKCoin\",\"currency\":\"ETH_USD\",\"stocks\":1.6}]\n'''\n#常规上下网格\nimport json\nglobal_param={\n              'sell_id':0,\n              'buy_id':0,\n              'buy_amount':0,#当前多单数量\n              'sell_amount':0,#当前空单数量\n              'buy_profit':0,#多单利润\n              'sell_profit':0#空单利润\n             }\n\ndef open_order(price):\n    net_buy_count = global_param['buy_amount'] / net_amount\n    net_sell_count = global_param['sell_amount'] / net_amount\n    if(net_buy_count>= net_limit or net_sell_count>=net_limit):\n        Log(\"超过网格数量限制，不开仓！\")\n        return\n    if(net_type == 1 or net_type == 2):#如果设置为开空或者多空双开\n        exchange.SetDirection(\"sell\")#设置下单类型为做空\n        order_id = exchange.Sell(_N(price*(1+net_interval),2),net_amount)#以当前价格上限开空，合约数量为10张下单\n        global_param['sell_id'] = order_id\n    if(net_type == 0 or net_type == 2):#如果设置为开多或者多空双开\n        exchange.SetDirection(\"buy\")#设置下单类型为做多\n        order_id = exchange.Buy(_N(price*(1-net_interval),2),net_amount)#以当前价格下限开多，合约数量为10张下单                        \n        global_param['buy_id'] = order_id\n        \ndef cancel_order():\n    for order in _C(exchange.GetOrders):\n        _C(exchange.CancelOrder,int(order['Id']))\n    global_param['sell_id']=0\n    global_param['buy_id']=0\n        \ndef judge_order_finish():\n    if(global_param['buy_id']!=0):\n        order = exchange.GetOrder(global_param['buy_id'])\n        if(order[\"Status\"]==ORDER_STATE_CLOSED):\n            return True\n        else:\n            return False\n    if(global_param['sell_id']!=0):\n        order = exchange.GetOrder(global_param['sell_id'])\n        if(order[\"Status\"]==ORDER_STATE_CLOSED):\n            return True  \n        else:\n            return False\n    return True\n        \ndef get_position():\n    global_param['sell_amount'] = 0\n    global_param['sell_profit'] = 0\n    global_param['buy_amount'] = 0\n    global_param['buy_profit'] = 0\n    positions= exchange.GetPosition()\n    for position in positions:\n        if(position['Type']==PD_SHORT): #空仓      \n            global_param['sell_amount'] = position['Amount']#获取空单持仓\n            global_param['sell_profit'] = position['Profit']#获取空单盈利\n        elif(position['Type']==PD_LONG):\n            global_param['buy_amount'] = position['Amount']#获取多单持仓\n            global_param['buy_profit'] = position['Profit']#获取多单盈利\n\n    \ndef check_stop(price):#止盈止损判断\n    total_profit = global_param['sell_profit'] + global_param['buy_profit']\n    if( total_profit>= stop_profit or total_profit<=-stop_loss):#如果获利达到止盈值或者亏损达到止损值 平仓\n        Log(\"止盈止损平仓，当前持仓总盈利\",total_profit)\n        if(global_param['sell_amount']>0):  \n            Log(\"sell_amount\",global_param['sell_amount'])\n            exchange.SetDirection(\"closesell\");#设置下单类型为平空\n            exchange.Buy(_N(price*1.005,2),global_param['sell_amount'])\n        if(global_param['buy_amount']>0):\n            Log(\"buy_amount\",global_param['buy_amount'])\n            exchange.SetDirection(\"closebuy\");#设置下单类型为平多\n            exchange.Sell(_N(price*0.995,2),global_param['buy_amount'])\n                \ndef main():\n    exchange.SetContractType(contract_type)#设置合约\n    exchange.SetMarginLevel(margin_level)#杠杆比例\n    while True:\n        ticker = exchange.GetTicker()\n        price = ticker['Last']\n        get_position()\n        check_stop(price)\n        if(judge_order_finish()):\n            Log(\"当前价格为:\",price)\n            cancel_order()#撤单\n            open_order(price)#下单\n        Sleep(1000)"}
{"query": "请生成一个网格管理工具策略代码", "base_model_response": "", "lora_model_response": "示例\n\n下面是一个简单的网格管理工具策略代码，这个模型是基于python的一个简单的二维网格算法。\n\n```python\nclass GridManager:\n    def __init__(self, numgrid, numnodes):\n        self.numgrid = numgrid\n        self.numnodes = numnodes\n        self.grid = {}\n        for i in range(self.numgrid):\n            self.grid[i] = {}", "original_response": "# 创建了一个价格1000-800，数量为10的等差网格\nGridPriceManager(upper_price=1000, lower_price=800, grid_num=10)\n\n# 创建了一个价格1000-800，间隔为1%的等比网格\nGridPriceManager(upper_price=1000, lower_price=800, interval=1)\n\n# 传入已有网格信息\ndata = {\n\t\"grid_list\":    {99:None,100:None,101:None,102:None,103:None,104:None},\n\t\"interval\":     None,\n\t\"upper_price\":  104,\n\t\"lower_price\":  99,\n\t\"grid_num\":     6,\n\t\"side\":         \"long\",\n\t\"grid_diff\":    1,\n\t\"type\":         \"等差\",\n}\nGridPriceManager(Data=data)\n\n# ==========================================\n\ngm = GridPriceManager(1000, 800, 10)\n\n# 底仓事件，在调用base_position方法时会触发此事件\n@gm.event('base_position')\ndef base_position(price):\n    # 传入最近的网格价格，以此价格作为买入价格参考\n    print(price)\n    return 123456\t# 返回底仓订单，manger将订单记录\n\n# ==========================================\n\npython\ngm = GridPriceManager(1000, 800, 10)\n\n# 底仓事件，在调用base_position方法时会触发此事件\n@gm.event('base_position')\ndef base_position(price):\n    # 传入最近的网格价格，以此价格作为买入价格参考\n    print(price)\n    return 123456\t# 返回底仓订单，manger将订单记录\n\n# ==========================================\n\npython\nclass GridPriceManager:\n    def __init__(self, Data=None, upper_price=None, lower_price=None, interval=None, grid_num=None, side: Literal['long','short']='long') -> dict:\n        self.interval = interval\n        self.upper_price = upper_price\n        self.lower_price = lower_price\n        self.grid_num = grid_num\n        self.side = side\n        self.grid_diff = None\n        self.type = None    # 网格类型\n        if self.grid_num is not None:\n            self.grid_diff = (self.upper_price - self.lower_price) / (self.grid_num - 1)\n        if Data is None: \n            if self.interval is None:\n                self.grid_list = self._generate_grid_list_difference()\n                self.type = \"等差\"\n            else:\n                self.grid_list = self._generate_grids_list_ratio()\n                self.type = \"等比\"\n        else:\n            self.grid_list = Data[\"grid_list\"]\n            self.interval = Data[\"interval\"]\n            self.upper_price = Data[\"upper_price\"]\n            self.lower_price = Data[\"lower_price\"]\n            self.grid_num = Data[\"grid_num\"]\n            self.side = Data[\"side\"]\n            self.grid_diff = Data[\"grid_diff\"]\n            self.type = Data[\"type\"]\n        self.data = f\"网格类型: {self.type}, 网格数量: {len(self.grid_list)}, 上下区间: [{self.upper_price}-{self.lower_price}, 方向: {self.side}]\"\n        self.callback = {}\n\n    def event(self, event_name):\n        \"\"\"事件\"\"\"\n        def decorator(func):\n            self.callback[event_name] = func\n            return func\n        return decorator\n\n    def _generate_grid_list_difference(self) -> dict:\n        \"\"\"等差网格生成\"\"\"\n        grid_list = {}\n        price = self.lower_price\n        for _ in range(self.grid_num):\n            grid_list[price] = None\n            price += self.grid_diff\n        grid_list[self.upper_price] = None\n        return grid_list\n\n    def _generate_grids_list_ratio(self) -> dict:\n        \"\"\"等比网格生成\"\"\"\n        ratio = 1 + self.interval / 100\n        grid = [self.lower_price * (ratio ** i) for i in range(-100, 101)]\n        return {round(g, 8): None for g in grid if self.lower_price <= g <= self.upper_price}\n\n\n    def get_nearest_buy_price(self, current_price) -> float:\n        \"\"\"获取最近网格买入价格\"\"\"\n        nearest_price = None\n        for price in sorted(self.grid_list.keys()):\n            if price > current_price:\n                break\n            nearest_price = price\n        return nearest_price\n\n    def get_nearest_sell_price(self, current_price) -> float:\n        \"\"\"获取最近网格卖出价格\"\"\"\n        nearest_price = None\n        for price in sorted(self.grid_list.keys(), reverse=True):\n            if price < current_price:\n                break\n            nearest_price = price\n        return nearest_price\n    \n    def base_position(self, ticker) -> Union[str, int]:\n        \"\"\"底仓\"\"\"\n        if self.side == \"short\":\n            t = self.get_nearest_sell_price(ticker)\n        else:\n            t = self.get_nearest_buy_price(ticker)\n        order_id = self.callback[\"base_position\"](t)\n        self.grid_list[t] = order_id\n        self.callback[\"change\"](self.grid_list)\n        return order_id\n    \n    def add_order(self, order_id) -> Union[Dict, bool]:\n        \"\"\"增加网格上下挂单\"\"\"\n        up_price = None\n        down_price = None\n        ticker = None\n        keys = list(self.grid_list.keys())\n        for i in range(len(keys)-1):\n            if self.grid_list[keys[i]] == order_id:\n                ticker = keys[i]\n                try:\n                    if self.side is None or self.side == \"long\":\n                        up_price = keys[i+1]\n                        down_price = keys[i-1]\n                    else:\n                        up_price = keys[i-1]\n                        down_price = keys[i+1]\n                except IndexError:\n                    return False\n                break\n\n        PriceDict = {\"up\": up_price, \"down\": down_price}\n        d = self.callback[\"add_order\"](PriceDict)\n        d = {\"up\": d[\"up\"], \"down\": d[\"down\"]}\n        self.grid_list[up_price] = d[\"up\"]\n        self.grid_list[down_price] = d[\"down\"]\n        self.grid_list[ticker] = None\n        self.callback[\"change\"](self.grid_list)\n        return d\n    \n    def cancel_order(self, order_id):\n        \"\"\"撤销订单\"\"\"\n        result = self.callback[\"cancel_order\"](order_id)\n        if result == True:\n            for items in self.grid_list.items():\n                if items[1] == order_id:\n                    self.grid_list[items[0]] = None\n                    self.callback[\"change\"](self.grid_list)\n                    break\n\ndef main():\n    gm = GridPriceManager(1000, 500, 10)\n\n    @gm.event('add_order')\n    def add_order(price):\n        print(price)\n        return {\n            'up': 36543,\n            'down': 87957,\n        }\n\n    @gm.event('cancel_order')\n    def cancel_order(order_id):\n        return True\n\n    @gm.event('base_position')\n    def base_position(price):\n        print(price)\n        return 123456\n\n    a = gm.base_position(600)\n    print(a)\n    a = gm.add_order(123456)\n    print(gm.grid_list)\n    gm.cancel_order(87957)\n    print(gm.grid_list)"}
{"query": "请生成一个自动获取币安永续合约交易精度最小开仓u已弃坑策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\ndef init():\n    global symbols, min_value\n    # 获取交易规则\n    exchange.SetBase('https://dapi.binance.com')\n    rule = exchange.IO(\"api\", \"GET\", \"/dapi/v1/exchangeInfo\", \"\", \"\")[\"symbols\"]\n    Log(rule)\n    # 获取交易对名称\n    for i in range(len(exchanges)):\n        exchanges[i].SetMarginLevel(M)\n        exchanges[i].SetContractType(\"swap\")  # 设置永续合约\n        _symbol = exchanges[i].GetCurrency().split(\"_\")[0]   # +'USDT'币本位交易对名称\n        # 设置交易精度\n        j = 0\n        flag1 = False\n        flag2 = False\n        #Log(rule)\n        while (j < len(rule)) and flag1 == False and flag2 == False:\n            if str(rule[j][\"symbol\"]).rfind(_symbol)>=0:\n                for x in rule[j][\"filters\"]:\n                    if x[\"filterType\"] == \"PRICE_FILTER\" and flag1 == False:\n                        #Log(\"价格\",x[\"tickSize\"])\n                        #Log(len(str(float(x[\"tickSize\"])).split('.')[-1]))\n                        price_precision = len(str(float(x[\"tickSize\"])).split('.')[-1])\n                        flag1 = True\n                    elif x[\"filterType\"] == \"LOT_SIZE\" and flag2 == False:\n                        amount_precision = len(x[\"minQty\"].split('.')[-1])\n                        flag2 = True\n            j = j + 1\n        exchanges[i].SetPrecision(price_precision, amount_precision)\n    Log(\"初始化结束\")"}
{"query": "请生成一个获取和讯期货数据Python版本策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#coding: utf-8\nimport urllib2 as url\nimport json\nimport time\n\ndef hxRecords(instrument,timeFrame=1,size=1,includeLastBar=True,to_df=True):\n    ##从和讯获取期货实时数据\n    pInst=instrument.lower()\n    if pInst[-4]!='1':\n        pInst=pInst[:-3]+'1'+pInst[-3:]\n    xchg=None\n    for i in instList:\n        if pInst[:-4] in i['inst']:\n            xchg=i['xchg']\n    if xchg is None:\n        print (\"获取K线时发生错误: 找不到合约\")\n        return None\n    tfs=[1,5,15,30,60,'D','W']\n    tf=None\n    for i in range(len(tfs)):\n        if timeFrame==tfs[i]:\n            tf=i\n    if tf is None:\n        print(\"获取K线时发生错误: K线周期不正确\")\n        return None\n    now=time.localtime()\n    timestr=str(now.tm_year+1)+str(12)+str(31)+'000000'\n    resp='http://webftcn.hermes.hexun.com/shf/kline?code=' + xchg + pInst + '&start=' + timestr + '&number=-' + str(size) + '&type=' + str(tf)\n    try:\n        resp=url.urlopen(resp)\n        resp=resp.read()[1:-2]\n        resp=json.loads(resp)['Data']\n    except:\n        print '获取K线时发生错误: 不完整的JSON数据'\n        return None\n    re=[]\n    pw=float(resp[4])\n    for i in resp[0]:\n        res=dict(Time=time.mktime(time.strptime(str(i[0]),'%Y%m%d%H%M%S'))*1000,Open=i[2]/pw,High=i[4]/pw\n                ,Low=i[5]/pw,Close=i[3]/pw,Volume=i[6])\n        re.append(res)\n    if to_df:\n        re=pd.DataFrame(re)\n        col=[]\n        for i in re.columns:\n            if i is 'Time':\n                i='Date'\n            col.append(i.lower())\n        re.columns=col\n        re['date']=re['date'].map(ts_dt64)\n    return re\n        \n\ninstList = [{\n    \"xchg\": \"SHFE\",\n    \"inst\": [\"fu\", \"ru\", \"wr\"]\n}, {\n    \"xchg\": \"SHFE2\",\n    \"inst\": [\"ag\", \"au\"]\n}, {\n    \"xchg\": \"SHFE3\",\n    \"inst\": [\"al\", \"bu\", \"cu\", \"hc\", \"ni\", \"pb\", \"rb\", \"sn\", \"zn\"]\n}, {\n    \"xchg\": \"CZCE\",\n    \"inst\": [\"cf\", \"fg\", \"lr\", \"ma\", \"oi\", \"pm\", \"ri\", \"rm\", \"rs\", \"sf\", \"sm\", \"sr\", \"ta\", \"wh\", \"zc\"]\n}, {\n    \"xchg\": \"DCE\",\n    \"inst\": [\"a\", \"b\", \"bb\", \"c\", \"cs\", \"fb\", \"i\", \"j\", \"jd\", \"jm\", \"l\", \"m\", \"p\", \"pp\", \"v\", \"y\"]\n}]\n\ndef main():\n    Log(exchange.GetAccount())"}
{"query": "请生成一个获取持仓均价你用对了吗策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\ndef  getAvgPrice(position):\n    if hasattr(position[0],'Info') and hasattr(position[0].Info,'cost_open'):# Huobi\n        return position[0].Info.cost_open\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'avg_cost'):#OKex\n        return position[0].Info.avg_cost\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'entryPrice'):#binance\n        return position[0].Info.entryPrice\n    else:\n        return position[0][\"Price\"] \n\ndef main():\n    Log(exchange.GetAccount())\n    position = exchanges[0].GetPosition()\n    if len(position)>0:\n        avgPrice = getAvgPrice(position)\n        Log(avgPrice)"}
{"query": "请生成一个要饭机器人30策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n\n#!,encrypt\n'''backtest\nstart: 2022-01-01 00:00:00\nend: 2022-01-31 23:59:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"OKX\",\"currency\":\"ETH_USDT\",\"balance\":1000,\"stocks\":0,\"fee\":[0.08,0.1]}]\n'''\n\nfrom datetime import datetime, timedelta, timezone\nimport json\n\nIs_Debug = False\nmanager = None\ndebug = None\nlog = None\n\ndef main():\n    Log('开始要饭了')\n    EnableLog(Is_Debug)\n    OnInit()\n    while True:\n        Sleep(1000)\n        manager.LoadData()\n        OnCommand()\n        manager.OnTick()\n        manager.SaveData()\n    Log('要饭结束了')\n\n#如果曾经没有数据，则初始化所有数据。\ndef OnInit():\n    #设置重试时间间隔\n    _CDelay(600000)\n    #过滤网络错误日志\n    global Is_Debug\n    if Is_Debug == False:\n        SetErrorFilter(\"400:|503:|429:|504:\")\n    \n    global manager\n    manager = Manager()\n\n    return\n\n#处理来自UI的交互响应\ndef OnCommand():\n    pass\n\n\nclass Manager:\n    Account = None\n    Tick = None\n    State = \"\"\n    Node_List = []\n\n    BuyPrice = 0\n    SellPrice = 0\n    Balance = 0\n    Stocks = 0\n    TickTime = 0\n    FrozenBalance = 0\n    FrozenStocks = 0\n\n    #防守模式中的盈利次数\n    DefenceProfitCount = 0\n\n    ClearOrder = 0\n\n    def Ins():\n        global manager\n        if manager == None:\n            manager = Manager()\n        return manager\n\n    def GetInfo(self):\n        self.Tick = _C(exchange.GetTicker)\n        if self.Tick == None:\n            return False\n        \n        self.Account = _C(exchange.GetAccount)\n        if self.Account == None:\n            return False\n        \n        self.SellPrice = self.Tick[\"Sell\"]\n        self.BuyPrice = self.Tick[\"Buy\"]\n        self.Balance = self.Account[\"Balance\"]\n        self.Stocks = self.Account['Stocks']\n        self.TickTime = self.Tick['Time']\n        self.FrozenBalance = self.Account['FrozenBalance']\n        self.FrozenStocks = self.Account['FrozenStocks']\n        return True\n\n    def OnTick(self):\n        if self.GetInfo() == False:\n            return\n\n        if self.State == \"\":\n            #第一次运行\n            MyLog.Ins().StartTime = self.TickTime\n            MyLog.Ins().StartMoney = self.TotalMoney()\n            self.ToAttack()\n        else:\n            MyLog.Ins().PrintLog()\n\n        if self.State == \"平仓\":\n            self.ClearTick()\n            return\n\n        if self.State == '防守':\n            if self.DefenceProfitCount >= UI_AttackThreshold:\n                MyLog.Write(\"防守计分足够，进入进攻模式。\")\n                self.ToAttack()\n                return\n\n        if len(self.Node_List) == 0:\n            #仓位空，原地买\n            node = Node.Buy(self.SellPrice, self.GetBuyNumber())\n            if node != None:\n                self.Node_List.append(node)\n                last_node = Node.Buy(Node.MinLeftPrice(), self.GetBuyNumber())\n                if last_node != None:\n                    self.Node_List.insert(0, last_node)\n            return\n\n        if Node.CenterNode() != None:\n            #我在节点中间\n            if self.NodeCheck(Node.CenterNode()):\n                #检查自己\n                return\n            \n            index = Manager.Ins().Node_List.index(Node.CenterNode())\n            if index > 0:\n                #说明左边有节点\n                left = self.Node_List[index-1]\n                #问问节点\n                if self.NodeCheck(left):\n                    return\n                #问问买单\n                if Node.CenterNode()['buy_order'] == 0:\n                    self.NodeBuy(Node.CenterNode())\n                    MyLog.AddBuyBuyTimes()\n                    return\n            else:\n                #说明左边没节点\n                if len(self.Node_List) < UI_NodeCount:\n                    #那就建一个节点\n                    left_node = Node.Buy(Node.CenterNode()['buy_price'] * 0.995, self.GetBuyNumber())\n                    if left_node != None:\n                        self.Node_List.insert(0, left_node)\n                    MyLog.AddBuyBuyTimes()\n                    return\n\n            #再看看右边有没有\n            if index < len(self.Node_List) - 1:\n                right = self.Node_List[index + 1]\n                if self.NodeCheck(right):\n                    return\n                #右边的，不用下买单，不然会亏\n\n        if self.SellPrice < Node.MinPrice():\n            #重新检查自己是不是在所有节点左边\n            if len(self.Node_List) >= UI_NodeCount:\n                #看看高位有没有垃圾仓\n                if Node.HasSell(Node.MaxNode()) == False:\n                    #再看看买单是不是成功了，以防万一\n                    if Node.CheckBuy(Node.MaxNode()) == False:\n                        #这是个垃圾单，可以删除\n                        Node.NodeClear(Node.MaxNode())\n                        self.Node_List.remove(Node.MaxSellPrice)\n                        return\n                #平仓\n                MyLog.Write(\"节点在最左边，并且仓位满了，平仓\" + \"当前价格：\" + str(self.SellPrice))\n                self.ToClear()\n                return\n            else:\n                #贴边买一个\n                MyLog.Write(\"节点在最左边，仓位没好，买一单\" + \"当前价格：\" + str(self.SellPrice))\n                new_node = Node.Buy(Node.MinLeftPrice(),self.GetBuyNumber())\n                if new_node != None:\n                    self.Node_List.insert(0,new_node)\n                MyLog.AddBuyBuyTimes()\n                return\n\n        if self.SellPrice > Node.MaxSellPrice():\n            #我在所有节点的右边\n            #看看满了没，没满就下单，满了就减仓\n            if len(self.Node_List) >= UI_NodeCount:\n                #满了，减仓\n                if Node.HasSell(Node.MinNode()) == False:\n                    if Node.HasBuy(Node.MinNode()) == False or Node.CheckBuy(Node.MinNode()) == False:\n                        MyLog.Write(\"突然暴涨，单还满了，减个仓\" + \"。当前价格：\" + str(self.SellPrice))\n                        Node.NodeClear(Node.MinNode())\n                        self.Node_List.remove(Node.MinNode())\n                        return\n                self.NodeCheck(Node.MinNode())\n            else:\n                #下单，贴\n                MyLog.Write(\"突然暴涨，单没满，从下往上补仓位\" + \"当前价格：\" + str(self.SellPrice))\n                new_node = Node.Buy(Node.MaxSellPrice(), self.GetBuyNumber())\n                if new_node != None:\n                    self.Node_List.append(new_node)\n\n\n    def NodeBuy(self,_node):\n        node = Node.Buy(_node['buy_price'], self.GetBuyNumber())\n        if node == None:\n            return None\n        _node['buy_order'] = node['buy_order']\n        _node['state'] = node['state']\n        _node['number'] = 0\n        \n        return _node\n\n    def NodeCheck(self,_node):\n        if Node.HasSell(_node):\n            #我有卖单,检查卖单\n            if Node.CheckSell(_node):\n                MyLog.Write(\"我所处的节点卖好了。\" + \"当前价格：\" + str(self.SellPrice))\n                MyLog.Ins().WriteProfit(Node.GetProfit(_node))\n                Node.Reset_Node(_node)\n                MyLog.Ins().BuyBuy_Count = 0#重新计数\n                return True\n        else:\n            if Node.HasBuy(_node):\n                if Node.CheckBuy(_node):\n                    Node.Sell(_node)\n                    return True\n        return False\n\n    def DelEmptyNode(self,_node):\n        self.Node_List.remove(_node)\n        Node.NodeClear(_node)\n        return\n\n    #处理卖掉的节点。\n    def DelSellNode(self,_node):\n        self.Node_List.remove(_node)\n        MyLog.Ins().WriteProfit(Node.GetProfit(_node))\n        return\n\n\n    #平仓\n    def ClearTick(self):\n        #收集清单，逐一取消\n        MyLog.Write(\"平仓运行中\")\n        orders = exchange.GetOrders()\n        if len(orders) > 0:\n            MyLog.Write(\"未处理订单大于0，取消订单\")\n            for _o in orders:\n                Node.CancelOrder(_o['Id'])\n            return\n        self.Node_List.clear()\n        #统计仓位，统一售卖\n        if self.Stocks + self.FrozenStocks > 50 / self.BuyPrice:\n            MyLog.Write(\"有持仓，卖掉\")\n            if self.ClearOrder == 0:\n                #售卖\n                MyLog.Write(\"有持仓，数量：\" + str(_N(self.Stocks,4)) + \"。 卖价：\" + str(_N(self.BuyPrice * 0.999,4)))\n                order_id = exchange.Sell(self.BuyPrice * 0.999, self.Stocks)\n                if order_id == None:\n                    MyLog.Write(\"奇怪的错误产生了，160行左右。\")\n                    return\n                self.ClearOrder = order_id\n                Sleep(100000)\n                return\n            else:\n                order = _C(exchange.GetOrder,self.ClearOrder)\n                if order['Status'] != 1:\n                    MyLog.Write(\"订单没有卖掉，重新换价格\")\n                    Node.CancelOrder(self.ClearOrder)\n                    self.ClearOrder = 0\n                    return\n                elif order['Status'] == 1:\n                    MyLog.Write(\"订单卖掉了，退出平仓模式\")\n                    self.ClearOrder = 0\n\n                #无限循环，直到卖完币\n        \n        #当清单为0，仓位为0，则进入防守模式。\n        self.ToDefence()\n\n    #转移到防守阶段\n    def ToDefence(self):\n        MyLog.Write('进入防守')\n        if self.State == \"平仓\":\n            MyLog.Ins().Defence_Count += 1\n        MyLog.Ins().StateWrite(\"防守\",self.State)\n        self.State = \"防守\"\n        self.DefenceProfitCount = 0\n    \n    #转移到进攻阶段\n    def ToAttack(self):\n        MyLog.Write('进入进攻模式')\n        MyLog.Ins().StateWrite(\"进攻\",self.State)\n        MyLog.Ins().Attack_Count += 1\n        self.State = \"进攻\"\n        self.Node_List.clear()\n\n    #转移到平仓阶段\n    def ToClear(self):\n        MyLog.Write('开始平仓')\n        if self.State == \"防守\":#如果来自于防守模式，不用平仓，直接重新进入防守模式。\n            self.Node_List.clear()\n            self.ToDefence()\n            return\n        MyLog.Ins().StateWrite(\"平仓\",self.State)\n        self.State = \"平仓\"\n        self.ClearOrder = 0\n\n    def LoadData(self):\n        MyLog.Ins().LoadData()\n        if MyLog.Ins().StartTime == None:\n            #第一次运行，不加载后续数据了\n            return\n        self.Node_List = json.loads(_G('Node_List'))\n        self.State = _G(\"State\")\n        self.DefenceProfitCount = _G('DefenceProfitCount')\n        self.ClearOrder = _G('ClearOrder')\n\n    def SaveData(self):\n        MyLog.Ins().SaveData()\n        _G(\"Node_List\",json.dumps(self.Node_List))\n        _G(\"State\",self.State)\n        _G(\"DefenceProfitCount\",self.DefenceProfitCount)\n        _G(\"ClearOrder\",self.ClearOrder)\n    \n    def TotalMoney(self):\n        return self.Balance + self.FrozenBalance + (self.Stocks + self.FrozenStocks) * self.BuyPrice\n\n    def GetBuyNumber(self):\n        number = self.TotalMoney() * UI_AttackRatio / UI_NodeCount / self.SellPrice\n        #去掉太多的精度\n        return _N(number,4)\n\nclass Node:\n\n    #创建一个数据并返回\n    def CreateNodeData(_state):\n        data = {}\n        data['state'] = _state\n        data['buy_price'] = 0\n        data['sell_price'] = 0\n        data['buy_order'] = 0\n        data['sell_order']=0\n        data['number'] = 0\n        return data\n\n    #Node还要用，重置下\n    def Reset_Node(_node):\n        _node['number'] = 0\n        _node['buy_order'] = 0\n        _node['sell_order'] = 0\n\n\n    def Buy(_price,_number):\n        MyLog.Write('买单，价格：' + str(_price) + '. 数量：' + str(_number) + \"。 价值：\" + str(_N(_number * _price,2)))\n        if Manager.Ins().State == \"进攻\":\n            buy_id = exchange.Buy(_price, _number)\n            if buy_id == None:\n                return None\n        else:\n            buy_id = 1\n        node = Node.CreateNodeData(Manager.Ins().State)\n        node['state'] = Manager.Ins().State\n        node['buy_price'] = _price\n        node['sell_price'] = _price * 1.005\n        node['buy_order'] = buy_id\n        node['number'] = 0\n\n        return node\n\n    def HasBuy(_node):\n        return _node['buy_order'] != 0\n\n    def HasSell(_node):\n        return _node['sell_order'] != 0\n    \n    #查看这个节点是不是右边的节点\n    def IsRight(_node):\n        right_price = Manager.Ins().SellPrice * 1.005\n        if right_price > _node['buy_price'] and right_price < _node['sell_price']:\n            return True\n        return False\n\n    def IsLeft(_node):\n        right_price = Manager.Ins().SellPrice * 0.995\n        if right_price > _node['buy_price'] and right_price < _node['sell_price']:\n            return True\n        return False\n\n    def CenterNode():\n        for node in Manager.Ins().Node_List:\n            if Manager.Ins().SellPrice > node['buy_price'] and Manager.Ins().SellPrice < node['sell_price']:\n                return node\n        return None\n\n    def MaxNode():\n        return Manager.Ins().Node_List[-1]\n\n    def MaxBuyPrice():\n        return Node.MaxNode()['buy_price']\n\n    def MaxSellPrice():\n        return Node.MaxNode()['sell_price']\n\n    def MaxHasSell():\n        return Node.MaxNode()['sell_order'] != 0\n\n    def MinNode():\n        return Manager.Ins().Node_List[0]\n\n    def MinPrice():\n        return Manager.Ins().Node_List[0]['buy_price']\n\n    def MinLeftPrice():\n        return _N(Node.MinPrice() * 0.995,4)\n\n    #检查买单是否OK\n    def CheckBuy(_node):\n        if _node['state'] == \"防守\":\n            _node['number'] = 1\n            return True\n        order = _C(exchange.GetOrder,_node['buy_order'])\n        if order['Status'] == 1:\n            _node['number'] = order['DealAmount']\n            return True\n        return  False\n\n    def MinSellPrice():\n        return Manager.Ins().Node_List[0]['sell_price']\n\n    def MinHasSell():\n        return Manager.Ins().Node_List[0]['sell_order'] != 0\n    \n    def Sell(_node):\n        MyLog.Write('卖单，价格：' + str(_node['sell_price']))\n        if _node['state'] == \"防守\":\n            _node['sell_order'] = 1\n            return True\n        # 仓位判断，容差\n        # if Manager.Ins().Stocks < _node['number']:\n        #     _node['number'] = Manager.Ins().Stocks\n        \n        order_id = exchange.Sell(_node['sell_price'], _node['number'])\n        if order_id == None:\n            return False\n        _node['sell_order'] = order_id\n        return True\n\n    def CheckSell(_node):\n        if _node['state'] == \"防守\":\n            if Manager.Ins().BuyPrice > _node['sell_price']:\n                return True\n            return False\n        \n        order = _C(exchange.GetOrder,_node['sell_order'])\n        #再次精准仓位\n        if order['Status'] == 1:\n            return True\n        return False\n\n    def GetProfit(_node):\n        value = (_node['sell_price'] - _node['buy_price']) * _node['number']\n        return _N(value,2)\n    \n    def NodeClear(_node):\n        if _node['state'] == \"防守\":\n            return\n\n        if _node['sell_order'] != 0:\n            Node.CancelOrder(_node['sell_order'])\n        if _node['buy_order'] != 0:\n            Node.CancelOrder(_node['buy_order'])\n\n    #确保订单取消成功\n    def CancelOrder(_id):\n        MyLog.Write('取消订单:' + str(_id))\n        while True:\n            order = _C(exchange.GetOrder,_id)\n            if order['Status'] == 1:\n                return True\n            if order['Status'] != 2:\n                result = exchange.CancelOrder(_id)\n                if result == True:\n                    return True\n                Sleep(1000)\n            elif order['Status'] == 2:\n                return True\n\n\nclass MyLog:\n    #第一次运行的时间\n    StartTime = 0\n    StartMoney = 0\n    Profit_List = []\n    State_List = []\n    Log_Tables = []\n\n    Attack_Count = 0\n    Defence_Count = 0\n    Exchange_Count = 0\n\n    #当期网格收益\n    StateProfit = 0\n\n    #连续购买计数\n    BuyBuy_Count = 0\n    BuyBuyClear_Count = 0\n\n    def Ins():\n        global log\n        if log == None:\n            log = MyLog()\n        \n        return log\n    \n    def LoadData(self):\n        self.Log_Tables = []\n        self.StartTime = _G(\"StartTime\")\n        if self.StartTime == None:\n            return\n        \n        self.StartMoney = _G(\"StartMoney\")\n        self.Profit_List = json.loads(_G(\"Profit_List\"))\n        self.State_List = json.loads(_G(\"State_List\"))\n        self.Attack_Count = _G(\"Attack_Count\")\n        self.Defence_Count = _G(\"Defence_Count\")\n        self.Exchange_Count = _G(\"Exchange_Count\")\n        self.StateProfit = _G(\"StateProfit\")\n        self.BuyBuy_Count = _G(\"BuyBuy_Count\")\n        self.BuyBuyClear_Count = _G(\"BuyBuyClear_Count\")\n\n    def SaveData(self):\n        _G(\"StartTime\",self.StartTime)\n        _G(\"StartMoney\",self.StartMoney)\n        _G(\"Profit_List\",json.dumps(self.Profit_List))\n        _G(\"State_List\",json.dumps(self.State_List))\n        _G(\"Attack_Count\",self.Attack_Count)\n        _G(\"Defence_Count\",self.Defence_Count)\n        _G(\"Exchange_Count\",self.Exchange_Count)\n        _G(\"StateProfit\",self.StateProfit)\n        _G(\"BuyBuy_Count\", self.BuyBuy_Count)\n        _G(\"BuyBuyClear_Count\", self.BuyBuyClear_Count)\n\n    def WriteProfit(self,_value):\n        if Manager.Ins().State == \"防守\":\n            #Log(\"防守计分一次\")\n            Manager.Ins().DefenceProfitCount += 1\n            return\n\n        #Log(\"感谢好心人，给了我\" + str(_value) + \"USDT。\")\n        self.StateProfit += _value\n        self.Exchange_Count += 1\n        data = []\n        #日期，利润，当前浮亏,当前币价\n        data.append(self.GetTimeStr(Manager.Ins().TickTime))\n        data.append(_value)\n        data.append(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\n        data.append(_N(Manager.Ins().BuyPrice,2))\n        if len(self.Profit_List) > 10:\n            self.Profit_List.pop()\n        self.Profit_List.insert(0,data)\n        #利润日志\n        LogProfit(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\n\n    def AddBuyBuyTimes():\n        MyLog.Ins().BuyBuy_Count += 1\n        if MyLog.Ins().BuyBuy_Count >= UI_DefenceThreshold and Manager.Ins().State == \"进攻\":\n            MyLog.Write(\"达到了连续购买阈值，进入防守模式\")\n            if Manager.Ins().State == \"进攻\":\n                MyLog.Ins().BuyBuyClear_Count += 1\n            Manager.Ins().ToClear()\n\n\n    def GetTimeStr(self,_time):\n        utc_dt = datetime.utcfromtimestamp(_time/1000)\n        cn_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))\n        d = cn_dt.strftime('%Y-%m-%d %H:%M:%S')\n        return d\n    \n    def GetRunDays(self):\n        now_date = datetime.utcfromtimestamp(Manager.Ins().TickTime/1000)\n        start_date = datetime.utcfromtimestamp(self.StartTime/1000)\n        span = now_date - start_date\n        run_time = span.days\n        if run_time < 1:\n            run_time = 1\n        return run_time\n\n    def GetToTalProfit(self):\n        return Manager.Ins().TotalMoney() - self.StartMoney\n\n    def GetAnnualized(self):\n        a = self.GetToTalProfit() / self.GetRunDays() * 365 / self.StartMoney * 100\n        return _N(a,2)\n\n    def PrintLog(self):\n        #基础信息表\n        rows = []\n        rows.append([\"当期启动时间：\",self.GetTimeStr(self.StartTime)])\n        rows.append([\"当期初始资金：\", self.StartMoney])\n        rows.append([\"当前总仓：\", _N(Manager.Ins().TotalMoney(),4)])\n        rows.append([\"当前利润：\",_N(self.GetToTalProfit(),4)])\n        rows.append([\"当前年化：\",str(self.GetAnnualized()) + \"%\"])\n        rows.append([\"当前持币:\",_N(Manager.Ins().Stocks,4)])\n        rows.append([\"当前锁币：\", _N(Manager.Ins().FrozenStocks,4)])\n        rows.append([\"钱包剩余：\", _N(Manager.Ins().Balance,4)])\n        rows.append([\"钱包冻结：\", _N(Manager.Ins().FrozenBalance,4)])\n        rows.append(['当前状态：',Manager.Ins().State])\n        rows.append([\"防御次数：\", self.Defence_Count])\n        rows.append([\"强平次数：\", self.BuyBuyClear_Count])\n        self.Add_Log_Table(\"基础信息\",[\"项目\",\"内容\"], rows)\n        #Log(json.dumps(rows))\n        #构建并添加仓位表\n        n_list = []\n        for _node in Manager.Ins().Node_List:\n            n = []\n            n.append(_node['buy_price'])\n            n.append(_node['buy_order'])\n            n.append(_node['sell_price'])\n            n.append(_node['sell_order'])\n            n.append(_node['number'])\n            n_list.append(n)\n        global Is_Debug\n        if Is_Debug:\n            self.Add_Log_Table(\"仓位信息\",['买价','买单',\"卖价\",\"卖单\",\"仓位数量\"],n_list)\n        #添加利润表\n        self.Add_Log_Table(\"收益记录\",[\"时间\",\"利润\",\"当前浮亏\",\"当前币价\"], self.Profit_List)\n        #添加状态表\n        self.Add_Log_Table(\"状态表\",[\"时间\",\"进入状态\",\"上一个状态\",\"当前币价\",\"当前盈利\",\"上期网格收益\",\"上期成交数\"],self.State_List)\n        #调参日志\n        \n        LogStatus('`' + json.dumps(self.Log_Tables) + '`')\n    \n    def StateWrite(self,_name,_lastname):\n        #时间，状态，上一个状态，此时市场价，此时盈利\n        data = [self.GetTimeStr(Manager.Ins().TickTime), _name, _lastname, _N(Manager.Ins().SellPrice,2), _N(self.GetToTalProfit(),2),_N(self.StateProfit,2),self.Exchange_Count]\n        self.State_List.insert(0, data)\n\n        if len(self.State_List) >= 100:\n            self.State_List.pop()\n        \n        self.StateProfit = 0\n        self.Exchange_Count = 0\n        self.BuyBuy_Count = 0\n\n    def Add_Log_Table(self, _title, _cols, _rows):\n        table = {\n            \"type\" : \"table\", \n            \"title\" : _title, \n            \"cols\" : _cols, \n            \"rows\" : _rows\n        }\n        self.Log_Tables.append(table)\n\n    def Write(_str):\n        global Is_Debug\n        if Is_Debug:\n            Log(str(_str))"}
{"query": "请生成一个轮询价格买入卖出策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\nimport numpy as np\nimport json\n\n#全局变量\nprice_precision = {}\namount_precision = {}\nhands = {}\ncan_buy_price = {}\ncan_sell_price = {}\nclass mid_class():\n    def __init__(self, this_exchange):\n        '''\n        初始化数据填充交易所的信息，首次获取价格，首次获取account信息\n        设定好密钥……\n        \n        Args:\n            this_exchange: FMZ的交易所结构\n        \n        '''\n        self.init_timestamp = time.time()\n        self.exchange = this_exchange\n        self.name = self.exchange.GetName()\n        self.jyd = self.exchange.GetCurrency()        \n    \n    def get_precision(self,pair):\n        '''\n        获取交易对的价格精度和数量精度\n        '''\n        precision = [4,6,1]\n        if pair not in price_precision.keys():\n            Log('没有配置价格精度： ' + pair)\n            return precision\n        if pair not in amount_precision.keys():\n            Log('没有配置数量精度: ' + pair)\n            return precision\n        if pair not in hands.keys():\n            Log('没有配置一手数量: ' + pair)\n            return precision\n        return [price_precision[pair], amount_precision[pair], hands[pair]]\n        \n    def switch_currency(self,pair):\n        '''\n        替换交易对\n        '''\n        self.exchange.IO(\"currency\",pair)\n\n    def get_account(self):\n        '''\n        获取账户信息\n        \n        Returns:\n            获取信息成功返回True，获取信息失败返回False\n        '''\n        self.Balance = '---'\n        self.Amount = '---'\n        self.FrozenBalance = '---'\n        self.FrozenStocks = '---'\n        \n        try:\n            self.account = self.exchange.GetAccount()\n\n            self.Balance =  self.account['Balance']\n            self.Amount = self.account['Stocks']\n            self.FrozenBalance =  self.account['FrozenBalance']\n            self.FrozenStocks = self.account['FrozenStocks']\n            return True\n        except:\n            return False\n    \n    def get_ticker(self):\n        '''\n        获取市价信息\n        \n        Returns:\n            获取信息成功返回True，获取信息失败返回False\n        '''\n        self.high = '---'\n        self.low = '---'\n        self.Sell =  '---'\n        self.Buy =  '---'\n        self.last =  '---'\n        self.Volume = '---'\n        \n        try:\n            self.ticker = self.exchange.GetTicker()\n        \n            self.high = self.ticker['High']\n            self.low = self.ticker['Low']\n            self.Sell =  self.ticker['Sell']\n            self.Buy =  self.ticker['Buy']\n            self.last =  self.ticker['Last']\n            self.Volume = self.ticker['Volume']\n            return True\n        except:\n            return False\n        \n        \n    def get_depth(self):\n        '''\n        获取深度信息\n        \n        Returns:\n            获取信息成功返回True，获取信息失败返回False\n        '''\n        self.Ask = '---'\n        self.Bids = '---'\n        \n        try:\n            self.Depth = self.exchange.GetDepth()\n            self.Ask = self.Depth['Asks']\n            self.Bids = self.Depth ['Bids']\n            return True\n        except:\n            return False\n        \n        \n    \n    def get_ohlc_data(self, period = PERIOD_M1):\n        '''\n        获取K线信息\n        \n        Args:\n            period: K线周期，PERIOD_M1 指1分钟, PERIOD_M5 指5分钟, PERIOD_M15 指15分钟,\n            PERIOD_M30 指30分钟, PERIOD_H1 指1小时, PERIOD_D1 指一天。\n        '''\n        self.ohlc_data = exchange.GetRecords(period)\n        \n        \n    \n    def create_order(self, order_type, price, amount):\n        '''\n        post一个挂单信息\n        \n        Args:\n            order_type：挂单类型，'buy'指挂买单，'sell'指挂卖单\n            price：挂单价格\n            amount:挂单数量\n            \n        Returns:\n            挂单Id号，可用以取消挂单\n        '''\n        if order_type == 'buy':\n            try:\n                order_id = self.exchange.Buy( price, amount)\n            except:\n                return False\n            \n        elif order_type == 'sell':\n            try:\n                order_id = self.exchange.Sell( price, amount)\n            except:\n                return False\n        \n        return order_id\n    \n    def get_orders(self):\n        self.undo_ordes = self.exchange.GetOrders()\n        return self.undo_ordes\n    \n    def cancel_order(self, order_id):\n        '''\n        取消一个挂单信息\n        \n        Args:\n            order_id：希望取消的挂单ID号\n            \n        Returns:\n            取消挂单成功返回True，取消挂单失败返回False\n        '''\n        return self.exchange.CancelOrder(order_id)\n        \n    def refreash_data(self):\n        '''\n        刷新信息\n        \n        Returns:\n            刷新信息成功返回 'refreash_data_finish!' 否则返回相应刷新失败的信息提示\n        '''\n\n        if not self.get_account():\n            return 'false_get_account'\n        \n        if not self.get_ticker():\n            return 'false_get_ticker'\n        if not self.get_depth():\n            return 'false_get_depth'\n        try:\n            self.get_ohlc_data()\n        except:\n            return 'false_get_K_line_info'\n        \n        return 'refreash_data_finish!'\n\n \nclass qushi_class():\n    def __init__(self, mid_class, amount_N, price_N):\n        '''\n        设定好初始需要考虑的参数\n        Args:\n            mid_class: 所使用的交易所中间层\n            amount_N：数量小数点限制\n            price_N：价格小数点限制\n            \n        Attributes：\n            amount_N：数量小数点限制\n            price_N：价格小数点限制\n            init_time：初始时间\n            last_time：上一次执行操作的时间\n            trade_list:交易请求的id\n        '''\n        self.jys = mid_class\n        \n        self.init_time = time.time()\n        self.last_time = time.time()\n        \n        self.amount_N = amount_N\n        self.price_N = price_N\n        \n        self.trade_list = []\n    \n    def cancel_orders(self):\n        '''\n        遍历当前挂单，如果时间超时则取消\n        '''\n        undo_orders = self.jys.get_orders()\n        for i in range(len(undo_orders)):\n           self.jys.cancel_order(undo_orders[i].Id)\n\n            \n    def refreash_data(self):\n        '''\n        用来从交易所获取最新的价格和数量信息\n        \n        Attributes：\n            B：商品币数量\n            money：计价币数量\n            can_buy_B：当前理论可购买商品币数量\n            Buy_price:当前市场上最近的一单挂单买价\n        '''\n        \n        message = self.jys.refreash_data()\n        if message == 'refreash_data_finish!':\n            self.B = self.jys.Amount\n            self.money = self.jys.Balance\n            self.Buy_price = self.jys.Buy\n            self.Sell_price = self.jys.Sell\n            self.can_buy_B = self.money/ self.Sell_price * 0.9\n            #要求仓位只能是30%\n            if self.B > ((self.B + self.can_buy_B)*0.3):\n                self.can_buy_B = 0\n            else:\n                self.can_buy_B = _N(self.can_buy_B, self.amount_N )\n            return True\n        else:\n            return False\n            \n    def make_trade_by_dict(self, trade_dicts):\n        '''\n        用来批量完成交易订单\n        \n        Attributes：\n            trade_list:已提交的交易请求的id\n        '''\n        for this_trade in trade_dicts:\n            this_price = _N(this_trade['price'], self.price_N )\n            this_amount = _N(this_trade['amount'], self.amount_N )\n            \n            this_trade_id = self.jys.create_order( this_trade['side'], this_price , this_amount ) \n            self.trade_list.append( this_trade_id )\n    \n    def condition_chicang(self, hands_num):\n        '''\n        根据持仓情况来做交易判定的条件\n        Args:\n            hands_num：表示交易一共几手（我们假设当前每次交易不高于一手）\n            \n        Attributes：\n            min_trade_B: 一手最多交易的商品币数量\n            min_trade_money: 一手最多交易的计价币数量\n        \n        '''\n        self.min_trade_B = (self.can_buy_B + self.B) / hands_num\n        self.min_buy_B = min(self.min_trade_B, self.can_buy_B)\n        self.min_sell_B = min(self.min_trade_B, self.B)\n        self.min_trade_money = self.min_trade_B* self.jys.Buy\n\n\n    \n    def condition_qushi(self):\n        '''\n        根据市场价格情况来做交易判定的条件\n        '''\n        rt = False\n        currency = self.jys.jyd\n        #Log('cur price' + self.jys.Sell)\n        #Log('cur range' + can_buy_price[currency][0])\n        if self.jys.Sell > can_buy_price[currency][0] and self.jys.Sell < can_buy_price[currency][1]:\n            rt = 'Buy'\n        if self.jys.Buy > can_sell_price[currency][0] and self.jys.Buy < can_sell_price[currency][1]:\n            rt = 'Sell'\n       \n        return rt\n    \n    \n    def make_trade_dicts(self, hands_num ):\n        '''\n        制作交易用字典表单\n        Args:\n            hands_num：一共交易多少手\n            change_pct：价格变化多少交易一手\n            \n        Returns：\n            this_trade_dicts: 根据当前价格变化，制作出需交易的字典的列表\n        \n        '''\n        self.condition_chicang(hands_num)\n        rt = self.condition_qushi()\n        this_trade_dicts = []\n        if rt:\n            if rt == 'Buy':\n                if self.min_buy_B > 10**-self.amount_N:\n                    this_trade_dicts.append({\n                        'side':'buy',\n                        'price':self.jys.Buy,\n                        'amount':self.min_buy_B\n                    })\n            else:\n                if self.min_sell_B > 10**-self.amount_N:\n                    this_trade_dicts.append({\n                        'side':'sell',\n                        'price':self.jys.Sell,\n                        'amount':self.min_sell_B\n                    })\n            return this_trade_dicts\n        else:\n            return False\n\n\n\ndef main():\n\n    #获取配置的值\n    global price_precision\n    price_precision = json.loads(PRICE_PRECISION)\n    global amount_precision \n    amount_precision = json.loads(AMOUNT_PRECISION)\n    global hands \n    hands = json.loads(HANDS)\n    global can_buy_price\n    can_buy_price = json.loads(CAN_BUY_PRICE)\n    global can_sell_price\n    can_sell_price = json.loads(CAN_SELL_PRICE)\n    round = 1\n    while True:\n        Sleep(1000)\n        for i in range(len(exchanges)):\n            #定义交易中间件\n            test_mid = mid_class(exchanges[i])\n            currency = test_mid.jyd\n            #获取交易对的价格，数量精度\n            currency_precision = test_mid.get_precision(currency)\n            #生成策略类\n            test_qushi = qushi_class(test_mid , currency_precision[0], currency_precision[1])\n            #获取最新数据\n            result  = test_qushi.refreash_data()\n            if result == True:\n                now_trade_dicts = test_qushi.make_trade_dicts(currency_precision[2])\n                if now_trade_dicts:\n                    test_qushi.make_trade_by_dict(now_trade_dicts)\n                    now_trade_dicts = False\n            #检查挂单情况\n            if round % 20 == 0:\n                Log('开始撤单')\n                Log(test_mid.account)\n                test_qushi.cancel_orders()\n        \n        round = round + 1"}
{"query": "请生成一个追涨杀跌策略代码", "base_model_response": "，该策略应包括多头趋势和空头趋势", "lora_model_response": "", "original_response": "python\nlist=[]\n\ndef doTicker():\n    #Log(exchange.GetAccount())\n    #Log(list)\n    ticker = exchange.GetTicker()\n    last = ticker.Last\n    if len(list) < LENGTH:\n        list.append(last)\n    else:\n        pMax = max(list)\n        pMin = min(list)\n        if last > pMax:\n            Log(\"buy \" + str(exchange.GetAccount()))\n            account = exchange.GetAccount()\n            if account.Balance > last:\n                #id = exchange.Buy(last, 1)\n                id = exchange.Buy(-1, 1)\n                Log(\"buy id --> \" + str(id))\n        elif last < pMin:\n            Log(\"sell \" + str(exchange.GetAccount()))\n            account = exchange.GetAccount()\n            if account.Stocks > 0:\n                #id = exchange.Sell(last, 1)\n                id = exchange.Sell(-1, 1)\n                Log(\"sell id --> \" + str(id))\n        list.pop(0)\n        list.append(last)\n\ndef main():\n    while(true):\n        doTicker() #执行策略\n        Sleep(PERIOD * 1000) #休息一段时间"}
{"query": "请生成一个钉钉群机器人推送超长信息必备策略代码", "base_model_response": "```cpp\n#include <iostream>\nusing namespace std;\n\nstring getNewMessage() {\n    string message = \"\";\n    \n    // 假设你有一个消息库，你只需要发送新消息即可完成任务。\n    string newMessage = \"你好\";\n    cout << \"这里是你需要的新的消息：\" << newMessage << endl;\n    \n    return message;\n}\n\nvoid sendToGroup(string message, int maxChars, string minChars) {\n    // 检查消息长度是否超过最大字符的数量和最小字符数量限制\n    if (message.length() > maxChars) {\n        cout << \"这个消息长度已经超过了最大字符数量，尝试发送其他消息。\"\n                << endl;\n        return;\n    }\n    \n    // 使用字符串连接来发送消息\n    string copy = getNewMessage();\n    \n    // 计算每个单词的最大字符数量\n    vector<string> words(maxChars);\n    \n    // 遍历每个单词\n    for (int i = 0; i < words.size(); i++) {\n        int maxChar = 0;\n        \n        for (int j = 1; j < words[i].length(); j++) {\n            char ch = words[i][j];\n            \n            // 如果字符大于当前最大字符，那么就将新消息换为大写\n            if (ch > ch.toUpperCase()) {\n                ch = ch.toUpperCase();\n            }\n            \n            maxChar++;\n        }\n        \n        copy += words[i] + ' ';\n        copied += maxChar;\n        \n        // 将大写单词替换回原始大写\n       复制 = copy.replace(newChar, maxChar, ch);\n        \n        // 将输入的字符串转换成字符串连接\n        strings::join copy, minChars);\n        \n        // 打印新消息\n        cout << \"这是你的新消息：\" << copy << endl;\n    }\n}\n```\n\n注意：这只是一个基本的策略示例，实际使用时还需要考虑更多的因素，例如消息的主题、内容等。", "lora_model_response": "```java\nimport java.util.List;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class ZongDongGroupBot {\n    public static void main(String[] args) {\n        SpringApplication.run(ZongDongGroupBot.class, args);\n    }\n\n    @Autowired\n    private JiaotongCloudClient client;\n    @Autowired\n    private List<ZongDongGroupTopic> topics;\n\n    public void doGet() {\n        try (List<String> data = client.listData()) {\n            for (String type : data.get(1)) {\n                if (type.equals(\"group\")) {\n                    ZongDongGroupTopic zongDongGroupTopic = new ZongDongGroupTopic();\n                    List<ZongDongGroupTopic> topicList = new ArrayList<>();\n                    List<ZongDongGroupTopic> topic1List = new ArrayList<>();\n                    List<ZongDongGroupTopic> topic2List = new ArrayList<>();\n                    for (String topicId : topicList) {\n                        ZongDongGroupTopic topic = new ZongDongGroupTopic(topicId);\n                        topicList.add(topic);\n                    }\n                    String id = ZongDongGroupTopic.generateLongId(30000, -1).toString();\n                    topic1List.add(zongDongGroupTopic);\n                    topic2List.add(topic1List);\n                }\n            }\n        }\n    }\n}\n```\n\n这个代码实现了一个轮询群消息，从服务器获取所有组的消息，然后将这些消息发送给新建立的群组。", "original_response": "python\n#!Python3\n\n\"\"\"\n《策略代写》 与 （此程序帮助），致信QQ：35787501\n\n钉钉长消息推送，用于群自定义机器人\n由于@可推送的信息过短，在字符串长度过长时，可以使用此程序\n\"\"\"\n\nimport time\nimport json\nimport hmac\nimport hashlib\nimport base64\nimport urllib.parse\nimport urllib.request\n\n\ndef send_request(url, data):\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\n                      'AppleWebKit/537.36 (KHTML, like Gecko) '\n                      'Chrome/92.0.4515.159 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;'\n                  'q=0.9,image/avif,image/webp,image/apng,*/*;'\n                  'q=0.8,application/signed-exchange;v=b3;q=0.9',\n        \"Content-Type\": \"application/json\",\n        \"Charset\": \"UTF-8\",\n    }\n    request = urllib.request.Request(url=url, data=json.dumps(data).encode(\"utf-8\"), headers=headers)\n    opener = urllib.request.urlopen(request)\n    return opener.read().decode()\n\n\ndef get_time_sign(secret):\n    timestamp = str(round(time.time() * 1000))\n    secret_enc = secret.encode('utf-8')\n    string_to_sign = '{}\\n{}'.format(timestamp, secret)\n    string_to_sign_enc = string_to_sign.encode('utf-8')\n    h_mac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()\n    sign = urllib.parse.quote_plus(base64.b64encode(h_mac_code))\n    return timestamp, sign\n\n\ndef send(text):\n    timestamp, sign = get_time_sign(ding_secret)\n    my_url = \"{}&timestamp={}&sign={}\".format(ding_url, timestamp, sign)\n    data = {\"msgtype\": \"text\", \"text\": {\"content\": text}}\n    return send_request(my_url, data)\n\n\ndef LogDing(*args):\n    Log(send(\" \".join(args)))\n\n\ndef main():\n    LogDing(\" test \" * 1000)\n\n\next.LogDing = LogDing"}
{"query": "请生成一个震荡突破策略策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\nimport json\nimport time\n\nimport requests\nfrom kumex.client import Trade\n\n\ndef check_response_data(response_data):\n    if response_data.status_code == 200:\n        try:\n            d = response_data.json()\n        except ValueError:\n            raise Exception(response_data.content)\n        else:\n            if d and d.get('s'):\n                if d.get('s') == 'ok':\n                    return d\n                else:\n                    raise Exception(\"{}-{}\".format(response_data.status_code, response_data.text))\n    else:\n        raise Exception(\"{}-{}\".format(response_data.status_code, response_data.text))\n\n\ndef get_kline(s, r, f, t, timeout=5, is_sandbox=False):\n    headers = {}\n    url = 'https://kitchen.kumex.com/kumex-kline/history'\n    if is_sandbox:\n        url = 'https://kitchen-sdb.kumex.com/kumex-kline/history'\n    uri_path = url\n    data_json = ''\n    p = []\n    if s:\n        p.append(\"{}={}\".format('symbol', s))\n    if r:\n        p.append(\"{}={}\".format('resolution', r))\n    if f:\n        p.append(\"{}={}\".format('from', f))\n    if t:\n        p.append(\"{}={}\".format('to', t))\n    data_json += '&'.join(p)\n    uri_path += '?' + data_json\n\n    response_data = requests.request('GET', uri_path, headers=headers, timeout=timeout)\n    return check_response_data(response_data)\n\n\nclass Shock(object):\n\n    def __init__(self):\n        # read configuration from json file\n        with open('config.json', 'r') as file:\n            config = json.load(file)\n\n        self.api_key = config['api_key']\n        self.api_secret = config['api_secret']\n        self.api_passphrase = config['api_passphrase']\n        self.sandbox = config['is_sandbox']\n        self.symbol = config['symbol']\n        self.resolution = int(config['resolution'])\n        self.valve = float(config['valve'])\n        self.leverage = float(config['leverage'])\n        self.size = int(config['size'])\n        self.trade = Trade(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\n\n\nif __name__ == \"__main__\":\n    shock = Shock()\n\n    while 1:\n        time_to = int(time.time())\n        time_from = time_to - shock.resolution * 60 * 35\n        data = get_kline(shock.symbol, shock.resolution, time_from, time_to, is_sandbox=shock.sandbox)\n        print('now time =', time_to)\n        print('symbol closed time =', data['t'][-1])\n        if time_to != data['t'][-1]:\n            continue\n        now_price = int(data['c'][-1])\n        print('closed price =', now_price)\n        # high_track\n        high = data['h'][-31:-1]\n        high.sort(reverse=True)\n        high_track = float(high[0])\n        print('high_track =', high_track)\n\n        # low_track\n        low = data['l'][-31:-1]\n        low.sort()\n        low_track = float(low[0])\n        print('low_track =', low_track)\n\n        # interval_range\n        interval_range = (high_track - low_track) / (high_track + low_track)\n        print('interval_range =', interval_range)\n\n        order_flag = 0\n        # current position qty of the symbol\n        position_details = shock.trade.get_position_details(shock.symbol)\n        position_qty = int(position_details['currentQty'])\n        print('current position qty of the symbol =', position_qty)\n        if position_qty > 0:\n            order_flag = 1\n        elif position_qty < 0:\n            order_flag = -1\n\n        if order_flag == 1 and now_price < low_track:\n            order = shock.trade.create_limit_order(shock.symbol, 'sell', position_details['realLeverage'],\n                                                   position_qty, now_price)\n            print('order_flag == 1,order id =', order['orderId'])\n            order_flag = 0\n        elif order_flag == -1 and now_price > high_track:\n            order = shock.trade.create_limit_order(shock.symbol, 'buy', position_details['realLeverage'],\n                                                   position_qty, now_price)\n            print('order_flag == -1,order id =', order['orderId'])\n            order_flag = 0\n\n        if interval_range < shock.valve and order_flag == 0:\n            if now_price > high_track:\n                order = shock.trade.create_limit_order(shock.symbol, 'buy', shock.leverage, shock.size, now_price)\n                print('now price > high track,buy order id =', order['orderId'])\n                order_flag = 1\n            if now_price < high_track:\n                order = shock.trade.create_limit_order(shock.symbol, 'sell', shock.leverage, shock.size, now_price)\n                print('now price < high track,sell order id =', order['orderId'])\n                order_flag = -1"}
{"query": "请生成一个韭菜保护程序唐安奇通道均仓策略策略代码", "base_model_response": "", "lora_model_response": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_PATH 1000\n\nvoid* main()\n{\n    char* str;\n    \n    int i, j;\n    \n    int x = 255;\n    int y = 0;\n    int x1 = 0, x2 = (MAX_PATH/2) - 1, y1 = 0, y2 = (MAX_PATH/2) - 1, dx = 3, dy = 3, z1 = 0, z2 = 0;\n\n    z1 = 0; // Z1\n    z2 = 0; // Z2\n    z1 = x1 * dy / max(dx,dy); // Z1\n    z2 = x2 * dx / max(dx,dy);\n    x1 = 0; // X1\n    x2 = x1 + dy; // X2\n    \n    int g = 0, v = 0, r;\n    void* p1= NULL;\n    \n    printf(\"Path: %d\\n\",MAX_PATH);\n\n    do {\n        printf(\"%s \",str, end一看);\n        \n        if(str[4] !='\\n')\n            printf(\"%s \",str[4]);\n\n        if(str[6] != '\\n')\n            printf(\"%s \",str[6]);\n    \n        if(z1 == 0 || (z2 == 0 || z1 > z2))\n            print(\"Z is in the wrong direction.\\n\");\n\n        if(z1 < z2)\n            z1 = z2; \n        if(z2 < z1)\n            z2 = z1;\n\n        for(i = 0 ; i < 3 ; i++)\n            z1 += dx * dx;\n            \n        if(y == 0 || (y1 > 0 || y2 < 0))\n            printf(\"Y is in the wrong direction.\\n\");\n      \n        if(x >= 0 && x < MAX_PATH - 256 )\n            printf(\"%s\\n\",str + (x-1)*dx);\n        else if(y >= 0 && y < MAX_PATH - 256)\n            printf(\"%s\\n\",str + (y-1)*dy);\n        \n        if(g < 0 || v < 0 || r < 0) { \n            print(\"G is too low.\"); \n            v = -v;\n        }\n        else if(v < 0) { \n            print(\"V is too high. \"); \n            g = -g;\n        }\n        \n        if(v >= 0 && g < 0)\n            z1 += 5; // The next point is at z1\n        else if(g >= 0 && v < 0)\n            x1 += 5; // The next point is at x1\n        else if(v >= 0 && g >= 0)\n            y1 += 5; // The next point is at y1\n        \n        for(i = 0 ; i < 3 ; i++)\n            if(dx < 0 && dx >= x1 || dy < 0 && dy >= y2 || dz < 0 && dz >= z1) { \n                dy = i+dx;\n            }else if(dx < 0 && dx <= x1) { \n                dx = i;\n            }else if(dy < 0 && dy <= y2) { \n                dy = i+dy;\n            }else if(dz < 0 && dz <= z1) { \n                dx = i+dz; \n            }else {  \n                break; \n            }\n            \n        printf(\"%s\\n\",str + z2*(z1-z2) + z1);\n        \n        if(x > 0 || x < MAX_PATH - 256) { \n            if(g < 0)\n                x1 = min(x1-x1*dy,x1+dx)*dx;\n            if(v < 0)\n                x2 = min(x2-x2*dy,x2+dx)*dx;\n            if(r < 0)\n                x = min(x=x-x1*x1,x.x);\n        } else if(y > 0 || y < MAX_PATH - 256) { \n            if(g < 0)\n                y1 = min(y1-y1*dy,y1+dx)*dx;\n            if(v < 0)\n                y2 = min(y2-y2*dy,y2+dx)*dx;\n            if(r < 0)\n                y = min(y=y-y1*y1,y.y);\n        } else if(x >= 0 && x < MAX_PATH-256) { \n            if(g < 0)\n                x1 = min(x1-x1*dy,x1+dx)*dx;\n            if(v < 0)\n                x2 = min(x2", "original_response": "python\n'''backtest\nstart: 2021-04-01 00:00:00\nend: 2021-04-30 23:59:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"ETH_USDT\",\"stocks\":0}]\n'''\n\nimport time\nclass juncang_strategy():  \n    def __init__(self,exchange):\n        self.p = 0.5\n        self.account = None\n        self.cny = 0\n        self.btc = 0\n        self.exchange =exchange\n    \n    #K线合成函数\n    def k_compose(self,Recordlist,num):\n        newRecordlist = []\n        for i in range(len(Recordlist)):\n            if (i+1)%num == 1:\n                tempk = {}\n                tempk[\"Time\"]=Recordlist[i][\"Time\"]\n                tempk[\"Open\"]=Recordlist[i][\"Open\"]\n                tempk[\"High\"]=Recordlist[i][\"High\"]\n                tempk[\"Low\"]=Recordlist[i][\"Low\"]\n                tempk[\"Close\"]=Recordlist[i][\"Close\"]\n                tempk[\"Volume\"]=Recordlist[i][\"Volume\"]\n                newRecordlist.append(tempk)\n            elif (i+1)%num == 0:\n                if Recordlist[i][\"High\"]>tempk[\"High\"]:\n                    tempk[\"High\"] = Recordlist[i][\"High\"]\n                if Recordlist[i][\"Low\"]<tempk[\"Low\"]:\n                    tempk[\"Low\"] = Recordlist[i][\"Low\"]\n                tempk[\"Time\"]=Recordlist[i][\"Time\"]\n                tempk[\"Close\"]=Recordlist[i][\"Close\"]\n                tempk[\"Volume\"]=tempk[\"Volume\"]+Recordlist[i][\"Volume\"]\n                del(newRecordlist[-1])\n                newRecordlist.append(tempk)\n            else:\n                if Recordlist[i][\"High\"]>tempk[\"High\"]:\n                    tempk[\"High\"] = Recordlist[i][\"High\"]\n                if Recordlist[i][\"Low\"]<tempk[\"Low\"]:\n                    tempk[\"Low\"] = Recordlist[i][\"Low\"]\n                del(newRecordlist[-1])\n                newRecordlist.append(tempk)\n        return newRecordlist\n\n    #唐安奇通道计算，分析出当前什么行情\n    def donchian(self):\n        exchange.SetMaxBarLen(2000)\n        temp_k = _C(self.exchange.GetRecords,PERIOD_D1)\n        week_kline = self.k_compose(temp_k,7)\n        rt=False\n        # Log(len(week_kline),week_kline[-1][\"High\"],TA.Highest(week_kline, 20, 'High'))\n        if len(week_kline)>20:\n            if week_kline[-1][\"High\"]>TA.Highest(week_kline, 20, 'High'):\n                rt = '全仓'\n            elif week_kline[-1][\"High\"]<TA.Highest(week_kline, 20, 'High') and week_kline[-1][\"Low\"]>TA.MA(week_kline, 10)[-1]:\n                rt = '均仓'\n            elif week_kline[-1][\"Low\"]<TA.MA(week_kline, 10)[-1]:\n                rt = '空仓'\n        else:\n            rt = '均仓'\n        return rt\n    def cancelAllOrders(self):\n        orders = self.exchange.GetOrders()\n        for order in orders:\n            self.exchange.CancelOrder(order['Id'], order)\n        return True\n    #全仓买入函数\n    def allin(self):\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\n        account = _C(self.exchange.GetAccount)\n        self.cny = account.Balance\n        buynum=_N(self.cny*0.99/kr[-1].Close,3)\n        if buynum>0:\n            Log(\"全仓allin\")\n            self.exchange.Buy(kr[-1].Close,buynum)\n        \n    #全仓卖出函数\n    def allout(self):\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\n        account = _C(self.exchange.GetAccount)\n        self.btc = _N(account.Stocks,3)\n        if self.btc>0:\n            Log(\"空仓allout\")\n            self.exchange.Sell(kr[-1].Close,self.btc)\n    #均仓函数\n    def balanceAccount(self):\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\n        account = _C(self.exchange.GetAccount)\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n\n        #赋值\n        self.btc = account.Stocks\n        self.cny = account.Balance\n        \n        accountmoney=self.btc * kr[-1].Close + self.cny\n        self.p = self.btc * kr[-1].Close / accountmoney\n        tradenum=_N(accountmoney/kr[-1].Close/100,3)\n        if tradenum<0.001:\n            tradenum=0.001\n        #判断self.p的值是否小于0.48\n        # Log(self.p)\n        if (0.45<self.p < 0.49):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #判断self.p的值是否大于0.52\n        elif (0.55 > self.p > 0.51):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            #调用Sell函数并传入相应的参数\n            self.exchange.Sell(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p >= 0.55):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡,快速平仓\", self.p)\n\n            self.exchange.Sell(kr[-1].Close, _N(tradenum*10,3))\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p <= 0.45):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡，快速建仓\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, _N(tradenum*10,3))\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n    #交易循环\n    def loop(self):\n        self.cancelAllOrders()\n        rt=self.donchian()\n        if rt=='全仓':\n            self.allin()\n        elif rt=='均仓':\n            self.balanceAccount()\n        else:\n            self.allout()\n        Sleep(1000*60)\n\n\n\n\n#函数main\ndef main():\n    #reaper 是构造函数的实例\n    reaper = juncang_strategy(exchange)\n    while (True):\n        reaper.loop()"}
{"query": "请生成一个马丁变种原始版策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "python\n'''backtest\nstart: 2021-05-01 00:00:00\nend: 2021-05-14 00:00:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"EOS_USDT\",\"balance\":1000}]\nargs: [[\"zuokong\",true],[\"n\",3],[\"E\",0.02]]\n'''\ndef main():\n    while True:\n        exchange.SetContractType(\"swap\")\n        exchange.SetMarginLevel(MarginLevel)\n        ticker = _C(exchange.GetTicker)\n        account = _C(exchange.GetAccount)\n        position = _C(exchange.GetPosition)\n        if zuoduo:\n            if len(position) == 0:   \n                    exchange.SetDirection(\"buy\")\n                    exchange.Buy(-1, k, \"开多\")\n            if len(position) > 0:\n                if position[0].Type==0:\n                    \n                    if position[0].Price+Q<ticker[\"Last\"]:\n                        exchange.SetDirection(\"closebuy\")\n                        exchange.Sell(-1, position[0].Amount) \n                        account = exchange.GetAccount()\n                        LogProfit(account[\"Balance\"]) \n                    fx=(E/n)*position[0].Amount  \n                    if position[0].Profit<position[0].Margin * -fx :\n                        #轮询加仓\n                            exchange.SetDirection(\"buy\")\n                            exchange.Buy(-1, k)\n                            LogProfit(account[\"Balance\"])     \n        if zuokong:\n            if len(position) == 0:   \n                    exchange.SetDirection(\"sell\")\n                    exchange.Sell(-1, k, \"开空\")\n            if len(position) > 0:\n                if position[0].Type == 1 :\n                    fp=Q*position[0].Amount\n                    if position[0].Profit > 0.01*fp*ticker[\"Last\"] :\n                        exchange.SetDirection(\"closesell\")\n                        exchange.Buy(-1, position[0].Amount) \n                        account = exchange.GetAccount()\n                        LogProfit(account[\"Balance\"]) \n                    fx=(E/n)*position[0].Amount  \n                    if position[0].Profit<position[0].Margin * -fx :\n                        #轮询加仓\n                            exchange.SetDirection(\"sell\")\n                            exchange.Sell(-1, n)\n                            LogProfit(account[\"Balance\"])\n        \n        Sleep(3000)"}
{"query": "请生成一个高频跨期套利策略策略代码", "base_model_response": "，这个策略主要操作在两个不同的时间段内", "lora_model_response": "", "original_response": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport json\nimport time\n\nfrom kumex.client import Trade, Market\n\n\nclass Hf(object):\n\n    def __init__(self):\n        # read configuration from json file\n        with open('config.json', 'r') as file:\n            config = json.load(file)\n\n        self.api_key = config['api_key']\n        self.api_secret = config['api_secret']\n        self.api_passphrase = config['api_passphrase']\n        self.sandbox = config['is_sandbox']\n        self.symbol_a = config['symbol_a']\n        self.symbol_b = config['symbol_b']\n        self.spread_mean = float(config['spread_mean'])\n        self.leverage = float(config['leverage'])\n        self.size = int(config['size'])\n        self.num_param = float(config['num_param'])\n        self.trade = Trade(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\n        self.market = Market(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\n\n    def get_symbol_price(self, symbol):\n        ticker = self.market.get_ticker(symbol)\n        return float(ticker['price'])\n\n\nif __name__ == '__main__':\n    hf = Hf()\n    while 1:\n        # ticker of symbols\n        price_af = hf.get_symbol_price(hf.symbol_a)\n        price_bf = hf.get_symbol_price(hf.symbol_b)\n        # position of symbols\n        position_a = hf.trade.get_position_details(hf.symbol_a)\n        position_a_qty = int(position_a['currentQty'])\n        position_b = hf.trade.get_position_details(hf.symbol_b)\n        position_b_qty = int(position_b['currentQty'])\n        # interval of price\n        new_spread = price_af - price_bf\n        print('new_spread =', new_spread)\n\n        if position_a_qty == position_b_qty == 0 and new_spread < (hf.spread_mean - hf.num_param):\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'buy', hf.leverage, hf.size, price_af + 1)\n            print('buy %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'sell', hf.leverage, hf.size, price_bf - 1)\n            print('sell %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\n        elif position_a_qty == position_b_qty == 0 and new_spread > (hf.spread_mean + hf.num_param):\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'sell', hf.leverage, hf.size, price_af - 1)\n            print('sell %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'buy', hf.leverage, hf.size, price_bf + 1)\n            print('buy %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\n        elif position_a_qty > 0 and position_b_qty < 0 and new_spread > hf.spread_mean:\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'sell', position_a['realLeverage'],\n                                                    position_a_qty, price_af + 1)\n            print('sell %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'buy', position_a['realLeverage'],\n                                                     position_a_qty, price_bf - 1)\n            print('buy %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\n        elif position_a_qty < 0 and position_b_qty > 0 and new_spread < hf.spread_mean:\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'buy', position_a['realLeverage'],\n                                                    position_a_qty, price_af - 1)\n            print('buy %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'sell', position_a['realLeverage'],\n                                                     position_a_qty, price_bf + 1)\n            print('sell %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\n\n        time.sleep(60)"}
{"query": "请生成一个# 双均线策略(期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. from gm.api import *\n4. import talib\n\n\n7. '''\n8. 本策略以SHFE.rb2101为交易标的，根据其一分钟(即60s频度）bar数据建立双均线模型，\n9. 短周期为20，长周期为60，当短期均线由上向下穿越长期均线时做空，\n10. 当短期均线由下向上穿越长期均线时做多,每次开仓前先平掉所持仓位，再开仓。\n11. 注：为了适用于仿真和实盘，在策略中增加了一个“先判断是否平仓成功再开仓”的判断逻辑，以避免出现未平仓成功，可用资金不足的情况。\n12. 回测数据为:SHFE.rb2101的60s频度bar数据\n13. 回测时间为:2020-04-01 09:00:00到2020-05-31 15:00:00\n14. '''\n\n\n17. def init(context):\n18. context.short = 20                                             # 短周期均线\n19. context.long = 60                                              # 长周期均线\n20. context.symbol = 'SHFE.rb2101'                                 # 订阅交易标的\n21. context.period = context.long + 1                              # 订阅数据滑窗长度\n22. context.open_long = False                                      # 开多单标记\n23. context.open_short = False                                     # 开空单标记\n24. subscribe(context.symbol, '60s', count=context.period)         # 订阅行情\n\n\n27. def on_bar(context, bars):\n28. # 获取通过subscribe订阅的数据\n29. prices = context.data(context.symbol, '60s', context.period, fields='close')\n\n31. # 利用talib库计算长短周期均线\n32. short_avg = talib.SMA(prices.values.reshape(context.period), context.short)\n33. long_avg = talib.SMA(prices.values.reshape(context.period), context.long)\n\n35. # 查询持仓\n36. position_long = context.account().position(symbol=context.symbol, side=1)\n37. position_short = context.account().position(symbol=context.symbol, side=2)\n\n39. # 短均线下穿长均线，做空(即当前时间点短均线处于长均线下方，前一时间点短均线处于长均线上方)\n40. if long_avg[-2] < short_avg[-2] and long_avg[-1] >= short_avg[-1]:\n\n42. # 无多仓情况下，直接开空\n43. if not position_long:\n44. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell, position_effect=PositionEffect_Open,\n45. order_type=OrderType_Market)\n46. print(context.symbol, '以市价单调空仓到仓位')\n\n48. # 有多仓情况下，先平多，再开空(开空命令放在on_order_status里面)\n49. else:\n50. context.open_short = True\n\n52. # 以市价平多仓\n53. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell, position_effect=PositionEffect_Close,\n54. order_type=OrderType_Market)\n55. print(context.symbol, '以市价单平多仓')\n\n57. # 短均线上穿长均线，做多（即当前时间点短均线处于长均线上方，前一时间点短均线处于长均线下方）\n58. if short_avg[-2] < long_avg[-2] and short_avg[-1] >= long_avg[-1]:\n\n60. # 无空仓情况下，直接开多\n61. if not position_short:\n62. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy, position_effect=PositionEffect_Open,\n63. order_type=OrderType_Market)\n64. print(context.symbol, '以市价单调多仓到仓位')\n\n66. # 有空仓的情况下，先平空，再开多(开多命令放在on_order_status里面)\n67. else:\n68. context.open_long = True\n\n70. # 以市价平空仓\n71. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n72. position_effect=PositionEffect_Close, order_type=OrderType_Market)\n73. print(context.symbol, '以市价单平空仓')\n\n\n76. def on_order_status(context, order):\n\n78. # 查看下单后的委托状态\n79. status = order['status']\n\n81. # 成交命令的方向\n82. side = order['side']\n\n84. # 交易类型\n85. effect = order['position_effect']\n\n87. # 当平仓委托全成后，再开仓\n88. if status == 3:\n\n90. # 以市价开空仓，需等到平仓成功无仓位后再开仓\n91. # 如果无多仓且side=2（说明平多仓成功），开空仓\n92. if effect == 2 and side == 2 and context.open_short:\n93. context.open_short = False\n94. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell, position_effect=PositionEffect_Open,\n95. order_type=OrderType_Market)\n96. print(context.symbol, '以市价单调空仓到仓位')\n\n98. # 以市价开多仓,需等到平仓成功无仓位后再开仓\n99. # 如果无空仓且side=1（说明平空仓成功），开多仓\n100. if effect == 2 and side == 1 and context.open_long:\n101. context.open_long = False\n102. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy, position_effect=PositionEffect_Open,\n103. order_type=OrderType_Market)\n104. print(context.symbol, '以市价单调多仓到仓位')\n\n\n107. if __name__ == '__main__':\n108. '''\n109. strategy_id策略ID,由系统生成\n110. filename文件名,请与本文件名保持一致\n111. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n112. token绑定计算机的ID,可在系统设置-密钥管理中生成\n113. backtest_start_time回测开始时间\n114. backtest_end_time回测结束时间\n115. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n116. backtest_initial_cash回测初始资金\n117. backtest_commission_ratio回测佣金比例\n118. backtest_slippage_ratio回测滑点比例\n119. '''\n120. run(strategy_id='strategy_id',\n121. filename='main.py',\n122. mode=MODE_BACKTEST,\n123. token='token_id',\n124. backtest_start_time='2020-04-01 09:00:00',\n125. backtest_end_time='2020-05-31 15:00:00',\n126. backtest_adjust=ADJUST_NONE,\n127. backtest_initial_cash=10000000,\n128. backtest_commission_ratio=0.0001,\n129. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# Dual Thrust(期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. from gm.api import *\n\n\n6. \"\"\"\n7. Dual Thrust是一个趋势跟踪系统\n8. 计算前N天的最高价－收盘价和收盘价－最低价。然后取这2N个价差的最大值，乘以k值。把结果称为触发值。\n9. 在今天的开盘，记录开盘价，然后在价格超过上轨（开盘＋触发值）时马上买入，或者价格低于下轨（开盘－触发值）时马上卖空。\n10. 没有明确止损。这个系统是反转系统，也就是说，如果在价格超过（开盘＋触发值）时手头有空单，则平空开多。\n11. 同理，如果在价格低于（开盘－触发值）时手上有多单，则平多开空。\n12. 选用了SHFE的rb2010 在2020-02-07 15:00:00 到 2020-04-15 15:00:00' 进行回测。\n13. 注意：\n14. 1：为回测方便，本策略使用了on_bar的一分钟来计算，实盘中可能需要使用on_tick。\n15. 2：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交\n16. \"\"\"\n\n\n19. # 策略中必须有init方法\n20. def init(context):\n\n22. # 设置要进行回测的合约（可以在掘金终端的仿真交易中查询标的代码）\n23. context.symbol = 'SHFE.rb2010'  # 订阅&交易标的, 此处订阅的是上期所的螺纹钢 2010\n\n25. # 设置参数\n26. context.N = 5\n27. context.k1 = 0.2\n28. context.k2 = 0.2\n\n30. # 获取当前时间\n31. time = context.now.strftime('%H:%M:%S')\n\n33. # 如果策略执行时间点是交易时间段，则直接执行algo定义buy_line和sell_line，以防直接进入on_bar()导致context.buy_line和context.sell_line未定义\n34. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\n35. algo(context)\n\n37. # 如果是交易时间段，等到开盘时间确保进入algo()\n38. schedule(schedule_func = algo, date_rule = '1d', time_rule = '09:00:00')\n39. schedule(schedule_func = algo, date_rule = '1d', time_rule = '21:00:00')\n\n41. # 只需要最新价，所以只需要订阅一个, 如果用tick，次数太多，用一分钟线代替\n42. subscribe(symbols=context.symbol, frequency='60s', count = 1)\n\n\n45. def algo(context):\n46. # 取历史数据\n47. data = history_n(symbol=context.symbol, frequency='1d', end_time=context.now,\n48. fields='symbol,open,high,low,close', count=context.N + 1, df=True)\n49. # 取开盘价\n50. # 回测模式下，开盘价可以直接用history_n取到\n51. if context.mode == 2:\n52. # 获取当天的开盘价\n53. current_open = data['open'].loc[context.N]\n54. # 去掉当天的实时数据\n55. data.drop(context.N, inplace = True)\n56. # 如果是实时模式，开盘价需要用current取到\n57. else:\n58. # 获取当天的开盘价\n59. current_open = current(context.symbol)[0]['open']\n\n61. # 计算Dual Thrust 的上下轨\n62. HH = data['high'].max()\n63. HC = data['close'].max()\n64. LC = data['close'].min()\n65. LL = data['low'].min()\n66. range = max(HH - LC, HC - LL)\n67. context.buy_line = current_open + range * context.k1  # 上轨\n68. context.sell_line = current_open - range * context.k2  # 下轨\n\n\n71. def on_bar(context, bars):\n72. # 取出订阅的这一分钟的bar\n73. bar = bars[0]\n74. # 取出买卖线\n75. buy_line =  context.buy_line\n76. sell_line = context.sell_line\n\n78. # 获取现有持仓\n79. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n80. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\n\n82. # 交易逻辑部分\n83. # 如果超过range的上界\n84. if bar.close > buy_line:\n85. if position_long:  # 已经持有多仓，直接返回\n86. return\n87. elif position_short:  # 已经持有空仓，平仓再做多。\n88. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n89. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n90. print('市价单平空仓', context.symbol)\n91. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n92. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n93. print('市价单开多仓', context.symbol)\n94. else:  # 没有持仓时，市价开多。\n95. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n96. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n97. print('市价单开多仓', context.symbol)\n98. # 如果低于range的下界\n99. elif bar.close < sell_line:\n100. if position_long:  # 已经持有多仓， 平多再开空。\n101. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n102. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n103. print('市价单平多仓', context.symbol)\n104. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n105. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n106. print('市价单开空仓', context.symbol)\n107. elif position_short:  # 已经持有空仓，直接返回。\n108. return\n109. else:  # 没有持仓，直接开空\n110. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n111. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n112. print('市价单开空仓', context.symbol)\n\n\n115. if __name__ == '__main__':\n116. '''\n117. strategy_id策略ID,由系统生成\n118. filename文件名,请与本文件名保持一致\n119. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n120. token绑定计算机的ID,可在系统设置-密钥管理中生成\n121. backtest_start_time回测开始时间\n122. backtest_end_time回测结束时间\n123. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n124. backtest_initial_cash回测初始资金\n125. backtest_commission_ratio回测佣金比例\n126. backtest_slippage_ratio回测滑点比例\n127. '''\n128. run(strategy_id='strategy_id',\n129. filename='main.py',\n130. mode=MODE_BACKTEST,\n131. token='token_id',\n132. backtest_start_time='2020-02-07 15:00:00',\n133. backtest_end_time='2020-04-15 15:00:00',\n134. backtest_initial_cash= 30000,\n135. backtest_commission_ratio=0.0001,\n136. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# R-Breaker(期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. import pandas as pd\n4. from gm.api import *\n5. from datetime import datetime, timedelta\n\n\n8. \"\"\"\n9. R-Breaker是一种短线日内交易策略\n10. 根据前一个交易日的收盘价、最高价和最低价数据通过一定方式计算出六个价位，从大到小依次为：\n11. 突破买入价、观察卖出价、反转卖出价、反转买入、观察买入价、突破卖出价。以此来形成当前交易\n12. 日盘中交易的触发条件。\n13. 追踪盘中价格走势，实时判断触发条件。具体条件如下：\n14. 突破\n15. 在空仓条件下，如果盘中价格超过突破买入价，则采取趋势策略，即在该点位开仓做多。\n16. 在空仓条件下，如果盘中价格跌破突破卖出价，则采取趋势策略，即在该点位开仓做空。\n17. 反转\n18. 持多单，当日内最高价超过观察卖出价后，盘中价格出现回落，且进一步跌破反转卖出价构成的支撑线时，采取反转策略，即在该点位反手做空。\n19. 持空单，当日内最低价低于观察买入价后，盘中价格出现反弹，且进一步超过反转买入价构成的阻力线时，采取反转策略，即在该点位反手做多。\n20. 设定止损条件。当亏损达到设定值后，平仓。\n\n22. 注意：\n23. 1：为回测方便，本策略使用了on_bar的一分钟来计算，实盘中可能需要使用on_tick。\n24. 2：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交。\n25. 3：本策略使用在15点收盘时全平的方式来处理不持有隔夜单的情况，实际使用中15点是无法平仓的。\n26. \"\"\"\n\n\n29. def init(context):\n30. # 设置交易品种\n31. context.symbol = 'SHFE.ag'\n32. # 设置止损点数\n33. context.stopLossPrice = 50\n\n35. # 获取前一交易日的主力合约\n36. startDate = get_previous_trading_date(exchange='SHFE', date=context.now.date())\n37. continuous_contract = get_continuous_contracts(context.symbol, startDate, startDate)\n38. context.mainContract = continuous_contract[0]['symbol']\n\n40. # 获取当前时间\n41. time = context.now.strftime('%H:%M:%S')\n\n43. # 如果当前时间是非交易时间段，则直接执行algo,以防直接进入on_bar()导致context.bBreak等未定义\n44. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\n45. algo(context)\n\n47. # 如果是交易时间段，等到开盘时间确保进入algo()\n48. schedule(schedule_func = algo, date_rule = '1d', time_rule = '09:00:00')\n49. schedule(schedule_func = algo, date_rule = '1d', time_rule = '21:00:00')\n\n51. # 订阅行情\n52. subscribe(continuous_contract[0]['symbol'], frequency='60s', count=1)\n\n\n55. def algo(context):\n56. # 检查主力和约，发生变化则更换订阅\n57. # 由于主力合约在盘后才公布，为了防止未来函数，选择上一交易日的主力合约。\n58. startDate = get_previous_trading_date(exchange='SHFE', date=context.now.date())\n59. contractInfo = get_continuous_contracts(context.symbol, startDate, startDate)\n60. if context.mainContract != contractInfo[0]['symbol']:\n61. context.mainContract = contractInfo[0]['symbol']\n62. subscribe(context.mainContract, frequency='60s', count=1, unsubscribe_previous=True)\n\n64. # 获取历史数据\n65. data = history_n(symbol=context.mainContract, frequency='1d',\n66. end_time=context.now, fields='high,low,open,symbol,close', count=2, df=True)\n67. high = data['high'].iloc[0]  # 前一日的最高价\n68. low = data['low'].iloc[0]  # 前一日的最低价\n69. close = data['close'].iloc[0]  # 前一日的收盘价\n70. pivot = (high + low + close) / 3  # 枢轴点\n71. context.bBreak = high + 2 * (pivot - low)  # 突破买入价\n72. context.sSetup = pivot + (high - low)  # 观察卖出价\n73. context.sEnter = 2 * pivot - low  # 反转卖出价\n74. context.bEnter = 2 * pivot - high  # 反转买入价\n75. context.bSetup = pivot - (high - low)  # 观察买入价\n76. context.sBreak = low - 2 * (high - pivot)  # 突破卖出价\n77. context.data = data\n\n\n80. def on_bar(context, bars):\n\n82. # 获取止损价\n83. STOP_LOSS_PRICE = context.stopLossPrice\n\n85. # 设置参数\n86. bBreak = context.bBreak\n87. sSetup = context.sSetup\n88. sEnter = context.sEnter\n89. bEnter = context.bEnter\n90. bSetup = context.bSetup\n91. sBreak = context.sBreak\n92. data = context.data\n\n94. # 获取现有持仓\n95. position_long = context.account().position(symbol=context.mainContract, side=PositionSide_Long)\n96. position_short = context.account().position(symbol=context.mainContract, side=PositionSide_Short)\n\n98. # 突破策略:\n99. if not position_long and not position_short:  # 空仓条件下\n100. if bars[0].close > bBreak:\n101. # 在空仓的情况下，如果盘中价格超过突破买入价，则采取趋势策略，即在该点位开仓做多\n102. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Buy,\n103. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做多\n104. print(\"空仓,盘中价格超过突破买入价: 开仓做多\")\n105. context.open_position_price = bars[0].close\n106. elif bars[0].close < sBreak:\n107. # 在空仓的情况下，如果盘中价格跌破突破卖出价，则采取趋势策略，即在该点位开仓做空\n108. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Sell,\n109. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做空\n110. print(\"空仓,盘中价格跌破突破卖出价: 开仓做空\")\n111. context.open_position_price = bars[0].close\n\n113. # 设置止损条件\n114. else:  # 有持仓时\n115. # 开仓价与当前行情价之差大于止损点则止损\n116. if (position_long and context.open_position_price - bars[0].close >= STOP_LOSS_PRICE) or \\\n117. (position_short and bars[0].close - context.open_position_price >= STOP_LOSS_PRICE):\n118. print('达到止损点，全部平仓')\n119. order_close_all()  # 平仓\n\n121. # 反转策略:\n122. if position_long:  # 多仓条件下\n123. if data.high.iloc[1] > sSetup and bars[0].close < sEnter:\n124. # 多头持仓,当日内最高价超过观察卖出价后，\n125. # 盘中价格出现回落，且进一步跌破反转卖出价构成的支撑线时，\n126. # 采取反转策略，即在该点位反手做空\n127. order_close_all()  # 平仓\n128. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Sell,\n129. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做空\n130. print(\"多头持仓,当日内最高价超过观察卖出价后跌破反转卖出价: 反手做空\")\n131. context.open_position_price = bars[0].close\n132. elif position_short:  # 空头持仓\n133. if data.low.iloc[1] < bSetup and bars[0].close > bEnter:\n134. # 空头持仓，当日内最低价低于观察买入价后，\n135. # 盘中价格出现反弹，且进一步超过反转买入价构成的阻力线时，\n136. # 采取反转策略，即在该点位反手做多\n137. order_close_all()  # 平仓\n138. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Buy,\n139. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做多\n140. print(\"空头持仓,当日最低价低于观察买入价后超过反转买入价: 反手做多\")\n141. context.open_position_price = bars[0].close\n\n143. if context.now.hour == 14 and context.now.minute == 59:\n144. order_close_all()\n145. print('全部平仓')\n\n\n148. if __name__ == '__main__':\n149. run(strategy_id='strategy_id',\n150. filename='main.py',\n151. mode=MODE_BACKTEST,\n152. token='token_id',\n153. backtest_start_time='2019-10-1 15:00:00',\n154. backtest_end_time='2020-04-16 15:00:00',\n155. backtest_initial_cash=1000000,\n156. backtest_commission_ratio=0.0001,\n157. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 菲阿里四价(期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. from gm.api import *\n\n\n6. \"\"\"\n7. 上轨=昨日最高点；\n8. 下轨=昨日最低点；\n9. 止损=今日开盘价;\n10. 如果没有持仓，且现价大于了昨天最高价做多，小于昨天最低价做空。\n11. 如果有多头持仓，当价格跌破了开盘价止损。\n12. 如果有空头持仓，当价格上涨超过开盘价止损。\n13. 选取 进行了回测。\n14. 注意：\n15. 1：为回测方便，本策略使用了on_bar的一分钟来计算，实盘中可能需要使用on_tick。\n16. 2：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交。\n17. \"\"\"\n\n\n20. def init(context):\n21. # 设置标的\n22. context.symbol = 'SHFE.rb2010'\n23. # 订阅一分钟线\n24. subscribe(symbols = context.symbol,frequency = '60s',count = 1)\n25. # 记录开仓次数，保证一天只开仓一次\n26. context.count = 0\n27. # 记录当前时间\n28. time = context.now.strftime('%H:%M:%S')\n\n30. # 如果当前时间点是交易时间段，则直接执行algo获取历史数据，以防直接进入on_bar()导致context.history_data未定义\n31. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\n32. algo(context)\n\n34. # 如果是非交易时间段，等到上午9点或晚上21点再执行algo()\n35. schedule(schedule_func = algo, date_rule = '1d', time_rule = '09:00:00')\n36. schedule(schedule_func = algo, date_rule = '1d', time_rule = '21:00:00')\n\n\n39. def algo(context):\n40. # 获取历史的n条信息\n41. context.history_data = history_n(symbol=context.symbol, frequency = '1d', end_time = context.now,\n42. fields='symbol,open,high,low',count=2, df=True)\n\n\n45. def on_bar(context,bars):\n46. # 取出订阅的一分钟bar\n47. bar = bars[0]\n48. # 提取数据\n49. data = context.history_data\n50. # 现有持仓情况\n51. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n52. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\n\n54. # 如果是回测模式\n55. if context.mode == 2:\n56. # 开盘价直接在data最后一个数据里取到,前一交易日的最高和最低价为history_data里面的倒数第二条中取到\n57. open = data.loc[1, 'open']\n58. high = data.loc[0, 'high']\n59. low = data.loc[0, 'low']\n\n61. # 如果是实时模式\n62. else:\n63. # 开盘价通过current取到\n64. open = current(context.symbol)[0]['open']\n65. # 实时模式不会返回当天的数据，所以history_data里面的最后一条数据是前一交易日的数据\n66. high = data.loc[-1, 'high']\n67. low = data.loc[-1, 'low']\n\n\n70. # 交易逻辑部分\n71. if position_long:  # 多头持仓小于开盘价止损。\n72. if bar.close < open:\n73. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n74. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n75. print('以市价单平多仓')\n76. elif position_short: # 空头持仓大于开盘价止损。\n77. if bar.close > open:\n78. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n79. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n80. print('以市价单平空仓')\n\n82. else:  # 没有持仓。\n83. if bar.close > high and not context.count:  # 当前的最新价大于了前一天的最高价\n84. # 开多\n85. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n86. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n87. print('以市价单开多仓')\n88. context.count = 1\n89. elif bar.close < low and not context.count:  # 当前最新价小于了前一天的最低价\n90. # 开空\n91. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n92. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n93. print('以市价单开空仓')\n94. context.count = 1\n\n96. # 每天收盘前一分钟平仓\n97. if context.now.hour == 14 and context.now.minute == 59:\n98. order_close_all()\n99. print('全部平仓')\n100. context.count = 0\n\n\n103. if __name__ == '__main__':\n104. '''\n105. strategy_id策略ID,由系统生成\n106. filename文件名,请与本文件名保持一致\n107. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n108. token绑定计算机的ID,可在系统设置-密钥管理中生成\n109. backtest_start_time回测开始时间\n110. backtest_end_time回测结束时间\n111. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n112. backtest_initial_cash回测初始资金\n113. backtest_commission_ratio回测佣金比例\n114. backtest_slippage_ratio回测滑点比例\n115. '''\n116. run(strategy_id='strategy_id',\n117. filename='main.py',\n118. mode=MODE_BACKTEST,\n119. token='token_id',\n120. backtest_start_time='2020-01-01 15:00:00',\n121. backtest_end_time='2020-09-01 16:00:00',\n122. backtest_adjust=ADJUST_PREV,\n123. backtest_initial_cash=100000,\n124. backtest_commission_ratio=0.0001,\n125. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 小市值(股票)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from gm.api import *\n4. from datetime import timedelta\n\n\n7. \"\"\"\n8. 小市值策略\n9. 本策略每个月触发一次，计算当前沪深市场上市值最小的前30只股票，并且等权重方式进行买入。\n10. 对于不在前30的有持仓的股票直接平仓。\n11. 回测时间为：2005-01-01 08:00:00 到 2020-10-01 16:00:00\n12. \"\"\"\n\n\n15. def init(context):\n16. # 每月第一个交易日的09:40 定时执行algo任务（仿真和实盘时不支持该频率）\n17. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\n18. # 使用多少的资金来进行开仓。\n19. context.ratio = 0.8\n20. # 定义股票池数量\n21. context.num = 30\n22. # 通过get_instruments获取所有的上市股票代码\n23. context.all_stock = get_instruments(exchanges='SHSE, SZSE', sec_types=[1], skip_suspended=False,\n24. skip_st=False, fields='symbol, listed_date, delisted_date',\n25. df=True)\n\n\n28. def algo(context):\n29. # 获取筛选时间：date1表示当前日期之前的100天，date2表示当前时间\n30. date1 = (context.now - timedelta(days=100)).strftime(\"%Y-%m-%d %H:%M:%S\")\n31. date2 = context.now.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n33. # 上市不足100日的新股和退市股和B股\n34. code = context.all_stock[(context.all_stock['listed_date'] < date1) & (context.all_stock['delisted_date'] > date2) &\n35. (context.all_stock['symbol'].str[5] != '9') & (context.all_stock['symbol'].str[5] != '2')]\n36. # 剔除停牌和st股\n37. df_code = get_history_instruments(symbols=code['symbol'].to_list(), start_date=date2, end_date=date2, df=True)\n38. df_code = df_code[(df_code['is_suspended'] == 0) & (df_code['sec_level'] == 1)]\n\n40. # 获取所有股票市值\n41. fundamental = get_fundamentals_n('trading_derivative_indicator', df_code['symbol'].to_list(),\n42. context.now, fields='TOTMKTCAP', order_by='TOTMKTCAP', count=1, df=True)\n\n44. # 对市值进行排序（升序），并且获取前30个。 最后将这个series 转化成为一个list即为标的池\n45. trade_symbols = fundamental.reset_index(\n46. drop=True).loc[:context.num - 1, 'symbol'].to_list()\n47. print('本次股票池有股票数目: ', len(trade_symbols))\n\n49. # 计算每个个股应该在持仓中的权重\n50. percent = 1.0 / len(trade_symbols) * context.ratio\n\n52. # 获取当前所有仓位\n53. positions = context.account().positions()\n\n55. # 平不在标的池的仓位\n56. for position in positions:\n57. symbol = position['symbol']\n58. if symbol not in trade_symbols:\n59. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n60. position_side=PositionSide_Long)\n61. print('市价单平不在标的池的', symbol)\n\n63. # 将标中已有持仓的和还没有持仓的都调整到计算出来的比例。\n64. for symbol in trade_symbols:\n65. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\n66. position_side=PositionSide_Long)\n67. print(symbol, '以市价单调整至权重', percent)\n\n\n70. if __name__ == '__main__':\n71. '''\n72. strategy_id策略ID,由系统生成\n73. filename文件名,请与本文件名保持一致\n74. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n75. token绑定计算机的ID,可在系统设置-密钥管理中生成\n76. backtest_start_time回测开始时间\n77. backtest_end_time回测结束时间\n78. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n79. backtest_initial_cash回测初始资金\n80. backtest_commission_ratio回测佣金比例\n81. backtest_slippage_ratio回测滑点比例\n82. '''\n83. run(strategy_id='13a64e72-e900-11eb-b05f-309c2322ba62',\n84. filename='main.py',\n85. mode=MODE_BACKTEST,\n86. token='2b62e7651c9897d0cdd4a6cd818a7ba8488af710',\n87. backtest_start_time='2005-01-01 08:00:00',\n88. backtest_end_time='2020-10-01 16:00:00',\n89. backtest_adjust=ADJUST_PREV,\n90. backtest_initial_cash=1000000,\n91. backtest_commission_ratio=0.0001,\n92. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 布林线均值回归(股票)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. from gm.api import *\n\n\n6. \"\"\"\n7. 本策略采用布林线进行均值回归交易。当价格触及布林线上轨的时候进行卖出，当触及下轨的时候，进行买入。\n8. 使用600004在 2009-09-17 13:00:00 到 2020-03-21 15:00:00 进行了回测。\n9. 注意：\n10. 1：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交。\n11. \"\"\"\n\n13. # 策略中必须有init方法\n14. def init(context):\n15. # 设置布林线的三个参数\n16. context.maPeriod = 26  # 计算BOLL布林线中轨的参数\n17. context.stdPeriod = 26  # 计算BOLL 标准差的参数\n18. context.stdRange = 1  # 计算BOLL 上下轨和中轨距离的参数\n\n20. # 设置要进行回测的合约\n21. context.symbol = 'SHSE.600004'  # 订阅&交易标的, 此处订阅的是600004\n22. context.period = max(context.maPeriod, context.stdPeriod, context.stdRange) + 1  # 订阅数据滑窗长度\n\n24. # 订阅行情\n25. subscribe(symbols= context.symbol, frequency='1d', count=context.period)\n\n\n28. def on_bar(context, bars):\n29. # 获取数据滑窗，只要在init里面有订阅，在这里就可以取的到，返回值是pandas.DataFrame\n30. data = context.data(symbol=context.symbol, frequency='1d', count=context.period, fields='close')\n\n32. # 计算boll的上下界\n33. bollUpper = data['close'].rolling(context.maPeriod).mean() \\\n34. + context.stdRange * data['close'].rolling(context.stdPeriod).std()\n35. bollBottom = data['close'].rolling(context.maPeriod).mean() \\\n36. - context.stdRange * data['close'].rolling(context.stdPeriod).std()\n37. # 获取现有持仓\n38. pos = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n\n40. # 交易逻辑与下单\n41. # 当有持仓，且股价穿过BOLL上界的时候卖出股票。\n42. if data.close.values[-1] > bollUpper.values[-1] and data.close.values[-2] < bollUpper.values[-2]:\n43. if pos:  # 有持仓就市价卖出股票。\n44. order_volume(symbol=context.symbol, volume=100, side=OrderSide_Sell,\n45. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n46. print('以市价单卖出一手')\n\n48. # 当没有持仓，且股价穿过BOLL下界的时候买出股票。\n49. elif data.close.values[-1] < bollBottom.values[-1] and data.close.values[-2] > bollBottom.values[-2]:\n50. if not pos:  # 没有持仓就买入一百股。\n51. order_volume(symbol=context.symbol, volume=100, side=OrderSide_Buy,\n52. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n53. print('以市价单买入一手')\n\n\n56. if __name__ == '__main__':\n57. '''\n58. strategy_id策略ID,由系统生成\n59. filename文件名,请与本文件名保持一致\n60. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n61. token绑定计算机的ID,可在系统设置-密钥管理中生成\n62. backtest_start_time回测开始时间\n63. backtest_end_time回测结束时间\n64. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n65. backtest_initial_cash回测初始资金\n66. backtest_commission_ratio回测佣金比例\n67. backtest_slippage_ratio回测滑点比例\n68. '''\n69. run(strategy_id='strategy_id',\n70. filename='main.py',\n71. mode=MODE_BACKTEST,\n72. token='token_id',\n73. backtest_start_time='2009-09-17 13:00:00',\n74. backtest_end_time='2020-03-21 15:00:00',\n75. backtest_adjust=ADJUST_PREV,\n76. backtest_initial_cash=1000,\n77. backtest_commission_ratio=0.0001,\n78. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# alpha对冲(股票+期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from gm.api import *\n\n\n6. '''\n7. 本策略每隔1个月定时触发计算SHSE.000300成份股的过去一天EV/EBITDA值并选取30只EV/EBITDA值最小且大于零的股票\n8. 对不在股票池的股票平仓并等权配置股票池的标的\n9. 并用相应的CFFEX.IF对应的真实合约等额对冲\n10. 回测数据为:SHSE.000300和他们的成份股和CFFEX.IF对应的真实合约\n11. 回测时间为:2017-07-01 08:00:00到2017-10-01 16:00:00\n12. 注意：本策略仅供参考，实际使用中要考虑到期货和股票处于两个不同的账户，需要人为的保证两个账户的资金相同。\n13. '''\n\n\n16. def init(context):\n17. # 每月第一个交易日09:40:00的定时执行algo任务（仿真和实盘时不支持该频率）\n18. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\n19. # 设置开仓在股票和期货的资金百分比(期货在后面自动进行杠杆相关的调整)\n20. context.percentage_stock = 0.4\n21. context.percentage_futures = 0.4\n\n\n24. def algo(context):\n25. # 获取当前时刻\n26. now = context.now\n\n28. # 获取上一个交易日\n29. last_day = get_previous_trading_date(exchange='SHSE', date=now)\n\n31. # 获取沪深300成份股的股票代码\n32. stock300 = get_history_constituents(index='SHSE.000300', start_date=last_day,\n33. end_date=last_day)[0]['constituents'].keys()\n\n35. # 获取上一个工作日的CFFEX.IF对应的合约\n36. index_futures = get_continuous_contracts(csymbol='CFFEX.IF', start_date=last_day, end_date=last_day)[-1]['symbol']\n\n38. # 获取当天有交易的股票\n39. not_suspended_info = get_history_instruments(symbols=stock300, start_date=now, end_date=now)\n40. not_suspended_symbols = [item['symbol'] for item in not_suspended_info if not item['is_suspended']]\n\n42. # 获取成份股EV/EBITDA大于0并为最小的30个\n43. fin = get_fundamentals(table='trading_derivative_indicator', symbols=not_suspended_symbols,\n44. start_date=now, end_date=now, fields='EVEBITDA',\n45. filter='EVEBITDA>0', order_by='EVEBITDA', limit=30, df=True)\n46. fin.index = fin.symbol\n\n48. # 获取当前仓位\n49. positions = context.account().positions()\n\n51. # 平不在标的池或不为当前股指期货主力合约对应真实合约的标的\n52. for position in positions:\n53. symbol = position['symbol']\n54. sec_type = get_instrumentinfos(symbols=symbol)[0]['sec_type']\n\n56. # 若类型为期货且不在标的池则平仓\n57. if sec_type == SEC_TYPE_FUTURE and symbol != index_futures:\n58. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n59. position_side=PositionSide_Short)\n60. print('市价单平不在标的池的', symbol)\n61. elif symbol not in fin.index:\n62. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n63. position_side=PositionSide_Long)\n64. print('市价单平不在标的池的', symbol)\n\n66. # 获取股票的权重\n67. percent = context.percentage_stock / len(fin.index)\n\n69. # 买在标的池中的股票\n70. for symbol in fin.index:\n71. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\n72. position_side=PositionSide_Long)\n73. print(symbol, '以市价单调多仓到仓位', percent)\n\n75. # 获取股指期货的保证金比率\n76. ratio = get_history_instruments(symbols=index_futures, start_date=last_day, end_date=last_day)[0]['margin_ratio']\n\n78. # 更新股指期货的权重\n79. percent = context.percentage_futures * ratio\n\n81. # 买入股指期货对冲\n82. # 注意：股指期货的percent参数是按照期货的保证金来算比例，不是按照合约价值， 比如说0.1就是用0.1的仓位的资金全部买入期货。\n83. order_target_percent(symbol=index_futures, percent=percent, order_type=OrderType_Market,\n84. position_side=PositionSide_Short)\n85. print(index_futures, '以市价单调空仓到仓位', percent)\n\n\n88. if __name__ == '__main__':\n89. '''\n90. strategy_id策略ID,由系统生成\n91. filename文件名,请与本文件名保持一致\n92. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n93. token绑定计算机的ID,可在系统设置-密钥管理中生成\n94. backtest_start_time回测开始时间\n95. backtest_end_time回测结束时间\n96. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n97. backtest_initial_cash回测初始资金\n98. backtest_commission_ratio回测佣金比例\n99. backtest_slippage_ratio回测滑点比例\n100. '''\n101. run(strategy_id='strategy_id',\n102. filename='main.py',\n103. mode=MODE_BACKTEST,\n104. token='token_id',\n105. backtest_start_time='2017-07-01 08:00:00',\n106. backtest_end_time='2017-10-01 16:00:00',\n107. backtest_adjust=ADJUST_PREV,\n108. backtest_initial_cash=10000000,\n109. backtest_commission_ratio=0.0001,\n110. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 多因子选股(股票)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. from gm.api import *\n5. from pandas import DataFrame\n6. '''\n7. 本策略每隔1个月定时触发,根据Fama-French三因子模型对每只股票进行回归，得到其alpha值。\n8. 假设Fama-French三因子模型可以完全解释市场，则alpha为负表明市场低估该股，因此应该买入。\n9. 策略思路：\n10. 计算市场收益率、个股的账面市值比和市值,并对后两个进行了分类,\n11. 根据分类得到的组合分别计算其市值加权收益率、SMB和HML.\n12. 对各个股票进行回归(假设无风险收益率等于0)得到alpha值.\n13. 选取alpha值小于0并为最小的10只股票进入标的池\n14. 平掉不在标的池的股票并等权买入在标的池的股票\n15. 回测数据:SHSE.000300的成份股\n16. 回测时间:2017-07-01 08:00:00到2017-10-01 16:00:00\n17. '''\n18. def init(context):\n19. # 每月第一个交易日的09:40 定时执行algo任务（仿真和实盘时不支持该频率）\n20. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\n21. # 数据滑窗\n22. context.date = 20\n23. # 设置开仓的最大资金量\n24. context.ratio = 0.8\n25. # 账面市值比的大/中/小分类\n26. context.BM_BIG = 3.0\n27. context.BM_MID = 2.0\n28. context.BM_SMA = 1.0\n29. # 市值大/小分类\n30. context.MV_BIG = 2.0\n31. context.MV_SMA = 1.0\n\n33. # 计算市值加权的收益率的函数,MV为市值的分类对应的组别,BM为账目市值比的分类对应的组别\n34. def market_value_weighted(stocks, MV, BM):\n35. select = stocks[(stocks['NEGOTIABLEMV'] == MV) & (stocks.['BM'] == BM)] # 选出市值为MV，账目市值比为BM的所有股票数据\n36. market_value = select['mv'].values     # 对应组的全部市值数据\n37. mv_total = np.sum(market_value)        # 市值求和\n38. mv_weighted = [mv / mv_total for mv in market_value]   # 市值加权的权重\n39. stock_return = select['return'].values\n\n41. # 返回市值加权的收益率的和\n42. return_total = []\n43. for i in range(len(mv_weighted)):\n44. return_total.append(mv_weighted[i] * stock_return[i])\n45. return_total = np.sum(return_total)\n46. return return_total\n\n48. def algo(context):\n49. # 获取上一个交易日的日期\n50. last_day = get_previous_trading_date(exchange='SHSE', date=context.now)\n51. # 获取沪深300成份股\n52. context.stock300 = get_history_constituents(index='SHSE.000300', start_date=last_day,\n53. end_date=last_day)[0]['constituents'].keys()\n54. # 获取当天有交易的股票\n55. not_suspended = get_history_instruments(symbols=context.stock300, start_date=last_day, end_date=last_day)\n56. not_suspended = [item['symbol'] for item in not_suspended if not item['is_suspended']]\n57. fin = get_fundamentals(table='trading_derivative_indicator', symbols=not_suspended,\n58. start_date=last_day, end_date=last_day,fields='PB,NEGOTIABLEMV', df=True)  # 获取P/B和市值数据\n\n60. # 计算账面市值比,为P/B的倒数\n61. fin['PB'] = (fin['PB'] ** -1)\n62. # 计算市值的50%的分位点,用于后面的分类\n63. size_gate = fin['NEGOTIABLEMV'].quantile(0.50)\n64. # 计算账面市值比的30%和70%分位点,用于后面的分类\n65. bm_gate = [fin['PB'].quantile(0.30), fin['PB'].quantile(0.70)]\n66. fin.index = fin.symbol\n67. # 设置存放股票收益率的list\n68. x_return = []\n\n70. # 对未停牌的股票进行处理\n71. for symbol in not_suspended:\n72. # 计算收益率，存放到x_return里面\n73. close = history_n(symbol=symbol, frequency='1d', count=context.date + 1, end_time=last_day, fields='close',\n74. skip_suspended=True, fill_missing='Last', adjust=ADJUST_PREV, df=True)['close'].values\n75. stock_return = close[-1] / close[0] - 1\n76. pb = fin['PB'][symbol]\n77. market_value = fin['NEGOTIABLEMV'][symbol]\n78. # 获取[股票代码， 股票收益率, 账面市值比的分类, 市值的分类, 流通市值]\n79. # 其中账面市值比的分类为：大（3）、中（2）、小（1）\n80. # 流通市值的分类：大（2）、小（1）\n81. if pb < bm_gate[0]:\n82. if market_value < size_gate:\n83. label = [symbol, stock_return, context.BM_SMA, context.MV_SMA, market_value]\n84. else:\n85. label = [symbol, stock_return, context.BM_SMA, context.MV_BIG, market_value]\n86. elif pb < bm_gate[1]:\n87. if market_value < size_gate:\n88. label = [symbol, stock_return, context.BM_MID, context.MV_SMA, market_value]\n89. else:\n90. label = [symbol, stock_return, context.BM_MID, context.MV_BIG, market_value]\n91. elif market_value < size_gate:\n92. label = [symbol, stock_return, context.BM_BIG, context.MV_SMA, market_value]\n93. else:\n94. label = [symbol, stock_return, context.BM_BIG, context.MV_BIG, market_value]\n95. if len(x_return) == 0:\n96. x_return = label\n97. else:\n98. x_return = np.vstack([x_return, label])\n\n100. # 将股票代码、 股票收益率、 账面市值比的分类、 市值的分类、 流通市值存为数据表\n101. stocks = DataFrame(data=x_return, columns=['symbol', 'return', 'BM', 'NEGOTIABLEMV', 'mv'])\n102. stocks.index = stocks.symbol\n103. columns = ['return', 'BM', 'NEGOTIABLEMV', 'mv']\n104. for column in columns:\n105. stocks[column] = stocks[column].astype(np.float64)\n\n107. # 计算SMB.HML和市场收益率（市值加权法）\n108. smb_s = (market_value_weighted(stocks, context.MV_SMA, context.BM_SMA) +\n109. market_value_weighted(stocks, context.MV_SMA, context.BM_MID) +\n110. market_value_weighted(stocks, context.MV_SMA, context.BM_BIG)) / 3\n\n112. # 获取大市值组合的市值加权组合收益率\n113. smb_b = (market_value_weighted(stocks, context.MV_BIG, context.BM_SMA) +\n114. market_value_weighted(stocks, context.MV_BIG, context.BM_MID) +\n115. market_value_weighted(stocks, context.MV_BIG, context.BM_BIG)) / 3\n116. smb = smb_s - smb_b\n\n118. # 获取大账面市值比组合的市值加权组合收益率\n119. hml_b = (market_value_weighted(stocks, context.MV_SMA, 3) +\n120. market_value_weighted(stocks, context.MV_BIG, context.BM_BIG)) / 2\n\n122. # 获取小账面市值比组合的市值加权组合收益率\n123. hml_s = (market_value_weighted(stocks, context.MV_SMA, context.BM_SMA) +\n124. market_value_weighted(stocks, context.MV_BIG, context.BM_SMA)) / 2\n125. hml = hml_b - hml_s\n\n127. # 获取市场收益率\n128. close = history_n(symbol='SHSE.000300', frequency='1d', count=context.date + 1,\n129. end_time=last_day, fields='close', skip_suspended=True,\n130. fill_missing='Last', adjust=ADJUST_PREV, df=True)['close'].values\n131. market_return = close[-1] / close[0] - 1\n132. coff_pool = []\n\n134. # 对每只股票进行回归获取其alpha值\n135. for stock in stocks.index:\n136. x_value = np.array([[market_return], [smb], [hml], [1.0]])\n137. y_value = np.array([stocks['return'][stock]])\n138. # OLS估计系数\n139. coff = np.linalg.lstsq(x_value.T, y_value)[0][3]\n140. coff_pool.append(coff)\n\n142. # 获取alpha最小并且小于0的10只的股票进行操作(若少于10只则全部买入)\n143. stocks['alpha'] = coff_pool\n144. stocks = stocks[stocks.alpha < 0].sort_values(by='alpha').head(10)\n145. symbols_pool = stocks.index.tolist()\n146. positions = context.account().positions()\n\n148. # 平不在标的池的股票\n149. for position in positions:\n150. symbol = position['symbol']\n151. if symbol not in symbols_pool:\n152. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n153. position_side=PositionSide_Long)\n154. print('市价单平不在标的池的', symbol)\n\n156. # 获取股票的权重\n157. percent = context.ratio / len(symbols_pool)\n\n159. # 买在标的池中的股票\n160. for symbol in symbols_pool:\n161. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\n162. position_side=PositionSide_Long)\n163. print(symbol, '以市价单调多仓到仓位', percent)\n\n165. if __name__ == '__main__':\n166. '''\n167. strategy_id策略ID,由系统生成\n168. filename文件名,请与本文件名保持一致\n169. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n170. token绑定计算机的ID,可在系统设置-密钥管理中生成\n171. backtest_start_time回测开始时间\n172. backtest_end_time回测结束时间\n173. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n174. backtest_initial_cash回测初始资金\n175. backtest_commission_ratio回测佣金比例\n176. backtest_slippage_ratio回测滑点比例\n177. '''\n178. run(strategy_id='strategy_id',\n179. filename='main.py',\n180. mode=MODE_BACKTEST,\n181. token='token_id',\n182. backtest_start_time='2017-07-01 08:00:00',\n183. backtest_end_time='2017-10-01 16:00:00',\n184. backtest_adjust=ADJUST_PREV,\n185. backtest_initial_cash=10000000,\n186. backtest_commission_ratio=0.0001,\n187. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 网格交易(期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. import pandas as pd\n5. from gm.api import *\n\n7. '''\n8. 本策略标的为：SHFE.rb1901\n9. 价格中枢设定为：前一交易日的收盘价\n10. 从阻力位到压力位分别为：1.03 * open、1.02 * open、1.01 * open、open、0.99 * open、0.98 * open、0.97 * open\n11. 每变动一个网格，交易量变化100个单位\n12. 回测数据为:SHFE.rb1901的1min数据\n13. 回测时间为:2017-07-01 08:00:00到2017-10-01 16:00:00\n14. '''\n\n\n17. def init(context):\n18. # 策略标的为SHFE.rb1901\n19. context.symbol = 'SHFE.rb1901'\n20. # 订阅SHFE.rb1901, bar频率为1min\n21. subscribe(symbols = context.symbol, frequency='60s')\n22. # 设置每变动一格，增减的数量\n23. context.volume = 1\n24. # 储存前一个网格所处区间，用来和最新网格所处区间作比较\n25. context.last_grid = 0\n26. # 以前一日的收盘价为中枢价格\n27. context.center = history_n(symbol= context.symbol,frequency='1d',end_time=context.now,count = 1,fields = 'close')[0]['close']\n28. # 记录上一次交易时网格范围的变化情况（例如从4区到5区，记为4,5）\n29. context.grid_change_last = [0,0]\n\n\n32. def on_bar(context, bars):\n33. bar = bars[0]\n34. # 获取多仓仓位\n35. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n36. # 获取空仓仓位\n37. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\n\n39. # 设置网格和当前价格所处的网格区域\n40. context.band = np.array([0.97, 0.98, 0.99, 1, 1.01, 1.02, 1.03]) * context.center\n41. grid = pd.cut([bar.close], context.band, labels=[1, 2, 3, 4, 5, 6])[0]\n\n43. # 如果价格超出网格设置范围，则提示调节网格宽度和数量\n44. if np.isnan(grid):\n45. print('价格波动超过网格范围，可适当调节网格宽度和数量')\n\n47. # 如果新的价格所处网格区间和前一个价格所处的网格区间不同，说明触碰到了网格线，需要进行交易\n48. # 如果新网格大于前一天的网格，做空或平多\n49. if context.last_grid < grid:\n50. # 记录新旧格子范围（按照大小排序）\n51. grid_change_new = [context.last_grid,grid]\n52. # 几种例外：\n53. # 当last_grid = 0 时是初始阶段，不构成信号\n54. # 如果此时grid = 3，说明当前价格仅在开盘价之下的3区域中，没有突破网格线\n55. # 如果此时grid = 4，说明当前价格仅在开盘价之上的4区域中，没有突破网格线\n56. if context.last_grid == 0:\n57. context.last_grid = grid\n58. return\n59. if context.last_grid != 0:\n60. # 如果前一次开仓是4-5，这一次是5-4，算是没有突破，不成交\n61. if grid_change_new != context.grid_change_last:\n62. # 更新前一次的数据\n63. context.last_grid = grid\n64. context.grid_change_last = grid_change_new\n65. # 如果有多仓，平多\n66. if position_long:\n67. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Sell, order_type=OrderType_Market,\n68. position_effect=PositionEffect_Close)\n69. print('以市价单平多仓{}手'.format(context.volume))\n70. # 否则，做空\n71. if not position_long:\n72. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Sell, order_type=OrderType_Market,\n73. position_effect=PositionEffect_Open)\n74. print('以市价单开空{}手'.format(context.volume))\n\n76. # 如果新网格小于前一天的网格，做多或平空\n77. if context.last_grid > grid:\n78. # 记录新旧格子范围（按照大小排序）\n79. grid_change_new = [grid,context.last_grid]\n80. # 几种例外：\n81. # 当last_grid = 0 时是初始阶段，不构成信号\n82. # 如果此时grid = 3，说明当前价格仅在开盘价之下的3区域中，没有突破网格线\n83. # 如果此时grid = 4，说明当前价格仅在开盘价之上的4区域中，没有突破网格线\n84. if context.last_grid == 0:\n85. context.last_grid = grid\n86. return\n87. if context.last_grid != 0:\n88. # 如果前一次开仓是4-5，这一次是5-4，算是没有突破，不成交\n89. if grid_change_new != context.grid_change_last:\n90. # 更新前一次的数据\n91. context.last_grid = grid\n92. context.grid_change_last = grid_change_new\n93. # 如果有空仓，平空\n94. if position_short:\n95. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Buy,\n96. order_type=OrderType_Market,\n97. position_effect=PositionEffect_Close)\n98. print('以市价单平空仓{}手'.format(context.volume))\n\n100. # 否则，做多\n101. if not position_short:\n102. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Buy,\n103. order_type=OrderType_Market,\n104. position_effect=PositionEffect_Open)\n105. print('以市价单开多{}手'.format(context.volume))\n\n107. # 设计一个止损条件：当持仓量达到10手，全部平仓\n108. if position_short == 10 or position_long == 10:\n109. order_close_all()\n110. print('触发止损，全部平仓')\n\n\n113. if __name__ == '__main__':\n114. '''\n115. strategy_id策略ID,由系统生成\n116. filename文件名,请与本文件名保持一致\n117. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n118. token绑定计算机的ID,可在系统设置-密钥管理中生成\n119. backtest_start_time回测开始时间\n120. backtest_end_time回测结束时间\n121. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n122. backtest_initial_cash回测初始资金\n123. backtest_commission_ratio回测佣金比例\n124. backtest_slippage_ratio回测滑点比例\n125. '''\n126. run(strategy_id='strategy_id',\n127. filename='main.py',\n128. mode=MODE_BACKTEST,\n129. token='token_id',\n130. backtest_start_time='2018-07-01 08:00:00',\n131. backtest_end_time='2018-10-01 16:00:00',\n132. backtest_adjust=ADJUST_PREV,\n133. backtest_initial_cash=100000,\n134. backtest_commission_ratio=0.0001,\n135. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 指数增强(股票)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. from gm.api import *\n5. from pandas import DataFrame\n\n\n8. '''\n9. 本策略以0.8为初始权重跟踪指数标的沪深300中权重大于0.35%的成份股.\n10. 个股所占的百分比为(0.8*成份股权重)*100%.然后根据个股是否:\n11. 1.连续上涨5天 2.连续下跌5天\n12. 来判定个股是否为强势股/弱势股,并对其把权重由0.8调至1.0或0.6\n13. 回测时间为:2017-07-01 08:50:00到2017-10-01 17:00:00\n14. '''\n\n\n17. def init(context):\n18. # 资产配置的初始权重,配比为0.6-0.8-1.0\n19. context.ratio = 0.8\n\n21. # 获取沪深300当时的成份股和相关数据\n22. stock300 = get_history_constituents(index='SHSE.000300', start_date='2017-06-30', end_date='2017-06-30')[0][\n23. 'constituents']\n24. stock300_symbol = []\n25. stock300_weight = []\n26. for key in stock300:\n27. # 保留权重大于0.35%的成份股\n28. if (stock300[key] / 100) > 0.0035:\n29. stock300_symbol.append(key)\n30. stock300_weight.append(stock300[key] / 100)\n31. context.stock300 = DataFrame([stock300_weight], columns=stock300_symbol, index=['weight']).T\n32. print('选择的成分股权重总和为: ', np.sum(stock300_weight))\n33. subscribe(symbols=stock300_symbol, frequency='1d', count=5, wait_group=True)\n\n\n36. def on_bar(context, bars):\n37. # 若没有仓位则按照初始权重开仓\n38. for bar in bars:\n39. symbol = bar['symbol']\n40. position = context.account().position(symbol=symbol, side=PositionSide_Long)\n41. if not position:\n42. buy_percent = context.stock300['weight'][symbol] * context.ratio\n43. order_target_percent(symbol=symbol, percent=buy_percent, order_type=OrderType_Market,\n44. position_side=PositionSide_Long)\n45. print(symbol, '以市价单开多仓至仓位:', buy_percent)\n46. else:\n\n48. # 获取过去5天的价格数据,若连续上涨则为强势股,权重+0.2;若连续下跌则为弱势股,权重-0.2\n49. recent_data = context.data(symbol=symbol, frequency='1d', count=5, fields='close')['close'].tolist()\n50. if all(np.diff(recent_data) > 0):\n51. buy_percent = context.stock300['weight'][symbol] * (context.ratio + 0.2)\n52. order_target_percent(symbol=symbol, percent=buy_percent, order_type=OrderType_Market,\n53. position_side=PositionSide_Long)\n54. print('强势股', symbol, '以市价单调多仓至仓位:', buy_percent)\n55. elif all(np.diff(recent_data) < 0):\n56. buy_percent = context.stock300['weight'][symbol] * (context.ratio - 0.2)\n57. order_target_percent(symbol=symbol, percent=buy_percent, order_type=OrderType_Market,\n58. position_side=PositionSide_Long)\n59. print('弱势股', symbol, '以市价单调多仓至仓位:', buy_percent)\n\n\n62. if __name__ == '__main__':\n63. '''\n64. strategy_id策略ID,由系统生成\n65. filename文件名,请与本文件名保持一致\n66. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n67. token绑定计算机的ID,可在系统设置-密钥管理中生成\n68. backtest_start_time回测开始时间\n69. backtest_end_time回测结束时间\n70. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n71. backtest_initial_cash回测初始资金\n72. backtest_commission_ratio回测佣金比例\n73. backtest_slippage_ratio回测滑点比例\n74. '''\n75. run(strategy_id='strategy_id',\n76. filename='main.py',\n77. mode=MODE_BACKTEST,\n78. token='token_id',\n79. backtest_start_time='2017-07-01 08:00:00',\n80. backtest_end_time='2017-10-01 16:00:00',\n81. backtest_adjust=ADJUST_PREV,\n82. backtest_initial_cash=10000000,\n83. backtest_commission_ratio=0.0001,\n84. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 跨品种套利(期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from gm.api import *\n4. import numpy as np\n\n6. def init(context):\n7. # 选择的两个合约\n8. context.symbol = ['DCE.j1901', 'DCE.jm1901']\n9. # 订阅历史数据\n10. subscribe(symbols=context.symbol,frequency='1d',count=11,wait_group=True)\n\n12. def on_bar(context, bars):\n13. # 数据提取\n14. j_close = context.data(symbol=context.symbol[0],frequency='1d',fields='close',count=31).values\n15. jm_close = context.data(symbol=context.symbol[1],frequency='1d',fields='close',count=31).values\n16. # 提取最新价差\n17. new_price = j_close[-1] - jm_close[-1]\n18. # 计算历史价差,上下限，止损点\n19. spread_history = j_close[:-2] -  jm_close[:-2]\n20. context.spread_history_mean = np.mean(spread_history)\n21. context.spread_history_std = np.std(spread_history)\n22. context.up = context.spread_history_mean + 0.75 * context.spread_history_std\n23. context.down = context.spread_history_mean - 0.75 * context.spread_history_std\n24. context.up_stoppoint = context.spread_history_mean + 2 * context.spread_history_std\n25. context.down_stoppoint = context.spread_history_mean - 2 * context.spread_history_std\n26. # 查持仓\n27. position_jm_long = context.account().position(symbol=context.symbol[0],side=1)\n28. position_jm_short = context.account().position(symbol=context.symbol[0],side=2)\n\n30. # 设计买卖信号\n31. # 设计开仓信号\n32. if not position_jm_short and not position_jm_long:\n33. if new_price > context.up:\n34. print('做空价差组合')\n35. order_volume(symbol=context.symbol[0],side=OrderSide_Sell,volume=1,order_type=OrderType_Market,position_effect=1)\n36. order_volume(symbol=context.symbol[1], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n37. if new_price < context.down:\n38. print('做多价差组合')\n39. order_volume(symbol=context.symbol[0], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n40. order_volume(symbol=context.symbol[1], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n\n42. # 设计平仓信号\n43. # 持jm多仓时\n44. if position_jm_long:\n45. if new_price >= context.spread_history_mean:\n46. # 价差回归到均值水平时，平仓\n47. print('价差回归到均衡水平，平仓')\n48. order_volume(symbol=context.symbol[0], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n49. order_volume(symbol=context.symbol[1], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n\n51. if new_price < context.down_stoppoint:\n52. # 价差达到止损位，平仓止损\n53. print('价差超过止损点，平仓止损')\n54. order_volume(symbol=context.symbol[0], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n55. order_volume(symbol=context.symbol[1], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n\n57. # 持jm空仓时\n58. if position_jm_short:\n59. if new_price <= context.spread_history_mean:\n60. # 价差回归到均值水平时，平仓\n61. print('价差回归到均衡水平，平仓')\n62. order_volume(symbol=context.symbol[0], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n63. order_volume(symbol=context.symbol[1], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n\n65. if new_price > context.up_stoppoint:\n66. # 价差达到止损位，平仓止损\n67. print('价差超过止损点，平仓止损')\n68. order_volume(symbol=context.symbol[0], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n69. order_volume(symbol=context.symbol[1], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n\n\n72. if __name__ == '__main__':\n73. '''\n74. strategy_id策略ID,由系统生成\n75. filename文件名,请与本文件名保持一致\n76. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n77. token绑定计算机的ID,可在系统设置-密钥管理中生成\n78. backtest_start_time回测开始时间\n79. backtest_end_time回测结束时间\n80. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n81. backtest_initial_cash回测初始资金\n82. backtest_commission_ratio回测佣金比例\n83. backtest_slippage_ratio回测滑点比例\n84. '''\n85. run(strategy_id='strategy_id',\n86. filename='main.py',\n87. mode=MODE_BACKTEST,\n88. token='token',\n89. backtest_start_time='2018-02-01 08:00:00',\n90. backtest_end_time='2018-12-31 16:00:00',\n91. backtest_adjust=ADJUST_PREV,\n92. backtest_initial_cash=2000000,\n93. backtest_commission_ratio=0.0001,\n94. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 跨期套利(期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. from gm.api import *\n5. '''\n6. 通过计算两个真实价格序列回归残差的0.9个标准差上下轨,并在价差突破上轨的时候做空价差,价差突破下轨的时候做多价差\n7. 并在回归至标准差水平内的时候平仓\n8. 回测数据为:DCE.m1801和DCE.m1805的1min数据\n9. 回测时间为:2017-09-25 08:00:00到2017-10-01 15:00:00\n10. '''\n11. def init(context):\n12. context.goods = ['DCE.m1801', 'DCE.m1805']\n13. # 订阅品种数据\n14. subscribe(symbols = context.goods,frequency = '1d',count = 31,wait_group = True)\n\n16. def on_bar(context, bars):\n17. # 获取历史数据\n18. close_1801 = context.data(symbol=context.goods[0], frequency='1d', count=31, fields='close')['close'].values\n19. close_1805 = context.data(symbol=context.goods[1], frequency='1d', count=31, fields='close')['close'].values\n20. # 计算上下轨\n21. spread = close_1801[:-2] - close_1805[:-2]\n22. spread_new = close_1801[-1] - close_1805[-1]\n23. up = np.mean(spread) + 0.75 * np.std(spread)\n24. down = np.mean(spread) - 0.75 * np.std(spread)\n25. up_stop = np.mean(spread) + 2 * np.std(spread)\n26. down_stop = np.mean(spread) - 2 * np.std(spread)\n\n28. # 获取仓位\n29. position1801_long = context.account().position(symbol = context.goods[0],side =PositionSide_Long)\n30. position1801_short = context.account().position(symbol = context.goods[0],side =PositionSide_Short)\n\n32. # 没有仓位时\n33. if not position1801_short and not position1801_long:\n34. # 上穿上轨时，买近卖远\n35. if spread_new > up:\n36. order_volume(symbol=context.goods[0], volume=1, order_type=OrderType_Market, side=OrderSide_Buy, position_effect=PositionEffect_Open)\n37. order_volume(symbol=context.goods[1], volume=1, order_type=OrderType_Market, side=OrderSide_Sell, position_effect=PositionEffect_Open)\n38. print('上穿上轨，买近卖远')\n39. # 下穿下轨时，卖近买远\n40. if spread_new < down:\n41. order_volume(symbol=context.goods[0], volume=1, order_type=OrderType_Market, side=OrderSide_Sell, position_effect=PositionEffect_Open)\n42. order_volume(symbol=context.goods[1], volume=1, order_type=OrderType_Market, side=OrderSide_Buy, position_effect=PositionEffect_Open)\n43. print('下穿下轨，卖近买远')\n\n45. # 价差回归到上轨时，平仓\n46. if position1801_long:\n47. if spread_new <= np.mean(spread):\n48. order_close_all()\n49. print('价差回归，平仓')\n50. if spread_new > up_stop:\n51. order_close_all()\n52. print('达到止损点，全部平仓')\n\n54. # 价差回归到下轨时，平仓\n55. if position1801_short:\n56. if spread_new >= np.mean(spread):\n57. order_close_all()\n58. print('价差回归，平全部仓')\n59. if spread_new < down_stop:\n60. order_close_all()\n61. print('达到止损点，全部平仓')\n\n63. if __name__ == '__main__':\n64. '''\n65. strategy_id策略ID,由系统生成\n66. filename文件名,请与本文件名保持一致\n67. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n68. token绑定计算机的ID,可在系统设置-密钥管理中生成\n69. backtest_start_time回测开始时间\n70. backtest_end_time回测结束时间\n71. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n72. backtest_initial_cash回测初始资金\n73. backtest_commission_ratio回测佣金比例\n74. backtest_slippage_ratio回测滑点比例\n75. '''\n76. run(strategy_id='strategy_id',\n77. filename='main.py',\n78. mode=MODE_BACKTEST,\n79. token='token_id',\n80. backtest_start_time='2017-07-01 08:00:00',\n81. backtest_end_time='2017-12-31 16:00:00',\n82. backtest_adjust=ADJUST_PREV,\n83. backtest_initial_cash=2000000,\n84. backtest_commission_ratio=0.0001,\n85. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 日内回转交易(股票)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import sys\n4. try:\n5. import talib\n6. except:\n7. print('请安装TA-Lib库')\n8. # 安装talib请看文档https://www.myquant.cn/docs/gm3_faq/154?\n9. sys.exit(-1)\n10. from gm.api import *\n\n\n13. def init(context):\n14. # 设置标的股票\n15. context.symbol = 'SHSE.600000'\n16. # 用于判定第一个仓位是否成功开仓\n17. context.first = 0\n18. # 订阅浦发银行, bar频率为1min\n19. subscribe(symbols=context.symbol, frequency='60s', count=35)\n20. # 日内回转每次交易100股\n21. context.trade_n = 100\n22. # 获取昨今天的时间\n23. context.day = [0, 0]\n24. # 用于判断是否到达接近收盘，所以不再交易\n25. context.ending = 1\n\n\n28. def on_bar(context, bars):\n29. bar = bars[0]\n30. # 配置底仓\n31. if context.first == 0:\n32. # 需要保持的总仓位\n33. context.total = 10000\n34. # 购买10000股浦发银行股票\n35. order_volume(symbol=context.symbol, volume=context.total, side=OrderSide_Buy,\n36. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n37. print(context.symbol, '以市价单开多仓10000股')\n38. context.first = 1.\n39. day = bar.bob.strftime('%Y-%m-%d')\n40. context.day[-1] = int(day[-2:])\n41. # 每天的仓位操作\n42. context.turnaround = [0, 0]\n43. return\n\n45. # 更新最新的日期\n46. day = bar.bob.strftime('%Y-%m-%d %H:%M:%S')\n47. context.day[0] = bar.bob.day\n\n49. # 若为新的一天,获取可用于回转的昨仓\n50. if context.day[0] != context.day[-1]:\n51. context.ending = 0\n52. context.turnaround = [0, 0]\n\n54. # 如果接近收盘，则不再交易\n55. if context.ending == 1:\n56. return\n\n58. # 若有可用的昨仓则操作\n59. if context.total >= 0:\n60. # 获取时间序列数据\n61. symbol = bar['symbol']\n62. recent_data = context.data(symbol=symbol, frequency='60s', count=35, fields='close')\n63. # 计算MACD线\n64. macd = talib.MACD(recent_data['close'].values)[0][-1]\n65. # 根据MACD>0则开仓,小于0则平仓\n66. if macd > 0:\n67. # 多空单向操作都不能超过昨仓位,否则最后无法调回原仓位\n68. if context.turnaround[0] + context.trade_n < context.total:\n69. # 计算累计仓位\n70. context.turnaround[0] += context.trade_n\n71. order_volume(symbol=context.symbol, volume=context.trade_n, side=OrderSide_Buy,\n72. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n73. print(symbol, '市价单开多仓', context.trade_n, '股')\n74. elif macd < 0:\n75. if context.turnaround[1] + context.trade_n < context.total:\n76. context.turnaround[1] += context.trade_n\n77. order_volume(symbol=context.symbol, volume=context.trade_n, side=OrderSide_Sell,\n78. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n79. print(symbol, '市价单开空仓', context.trade_n, '股')\n80. # 临近收盘时若仓位数不等于昨仓则回转所有仓位\n81. if day[11:16] == '14:55' or day[11:16] == '14:57':\n82. position = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n83. if position['volume'] != context.total:\n84. order_target_volume(symbol=context.symbol, volume=context.total, order_type=OrderType_Market,\n85. position_side=PositionSide_Long)\n86. print('市价单回转仓位操作...')\n87. context.ending = 1\n88. # 更新过去的日期数据\n89. context.day[-1] = context.day[0]\n\n\n92. if __name__ == '__main__':\n93. '''\n94. strategy_id策略ID,由系统生成\n95. filename文件名,请与本文件名保持一致\n96. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n97. token绑定计算机的ID,可在系统设置-密钥管理中生成\n98. backtest_start_time回测开始时间\n99. backtest_end_time回测结束时间\n100. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n101. backtest_initial_cash回测初始资金\n102. backtest_commission_ratio回测佣金比例\n103. backtest_slippage_ratio回测滑点比例\n104. '''\n105. run(strategy_id='strategy_id',\n106. filename='main.py',\n107. mode=MODE_BACKTEST,\n108. token='token_id',\n109. backtest_start_time='2017-09-01 08:00:00',\n110. backtest_end_time='2017-10-01 16:00:00',\n111. backtest_adjust=ADJUST_PREV,\n112. backtest_initial_cash=2000000,\n113. backtest_commission_ratio=0.0001,\n114. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 做市商交易(期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from gm.api import *\n\n\n6. '''\n7. 本策略通过不断对CZCE.CF801进行:\n8. 买(卖)一价现价单开多(空)仓和卖(买)一价平多(空)仓来做市\n9. 并以此赚取差价\n10. 回测数据为:CZCE.CF801的tick数据\n11. 回测时间为:2017-09-29 11:25:00到2017-09-29 11:30:00\n12. 需要特别注意的是:本平台对于回测对限价单固定完全成交,本例子 仅供参考.\n13. 敬请通过适当调整回测参数\n14. 1.backtest_commission_ratio回测佣金比例\n15. 2.backtest_slippage_ratio回测滑点比例\n16. 3.backtest_transaction_ratio回测成交比例\n17. 以及优化策略逻辑来达到更贴近实际的回测效果\n18. 目前只支持最近三个月的tick数据，回测时间和标的需要修改\n19. '''\n\n\n22. def init(context):\n23. # 订阅CZCE.CF801的tick数据\n24. context.symbol = 'CZCE.CF801'\n25. subscribe(symbols=context.symbol, frequency='tick')\n\n\n28. def on_tick(context, tick):\n29. quotes = tick['quotes'][0]\n30. # 获取持有的多仓\n31. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n32. # 获取持有的空仓\n33. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\n34. # 没有仓位则双向开限价单\n35. # 若有仓位则限价单平仓\n36. if not position_long:\n37. # 获取买一价\n38. price = quotes['bid_p']\n39. print('买一价为: ', price)\n40. order_target_volume(symbol=context.symbol, volume=1, price=price, order_type=OrderType_Limit,\n41. position_side=PositionSide_Long)\n42. print('CZCE.CF801开限价单多仓1手')\n43. else:\n44. # 获取卖一价\n45. price = quotes['ask_p']\n46. print('卖一价为: ', price)\n47. order_target_volume(symbol=context.symbol, volume=0, price=price, order_type=OrderType_Limit,\n48. position_side=PositionSide_Long)\n49. print('CZCE.CF801平限价单多仓1手')\n50. if not position_short:\n51. # 获取卖一价\n52. price = quotes['ask_p']\n53. print('卖一价为: ', price)\n54. order_target_volume(symbol=context.symbol, volume=1, price=price, order_type=OrderType_Limit,\n55. position_side=PositionSide_Short)\n56. print('CZCE.CF801卖一价开限价单空仓')\n57. else:\n58. # 获取买一价\n59. price = quotes['bid_p']\n60. print('买一价为: ', price)\n61. order_target_volume(symbol=context.symbol, volume=0, price=price, order_type=OrderType_Limit,\n62. position_side=PositionSide_Short)\n63. print('CZCE.CF801买一价平限价单空仓')\n\n\n66. if __name__ == '__main__':\n67. '''\n68. strategy_id策略ID,由系统生成\n69. filename文件名,请与本文件名保持一致\n70. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n71. token绑定计算机的ID,可在系统设置-密钥管理中生成\n72. backtest_start_time回测开始时间\n73. backtest_end_time回测结束时间\n74. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n75. backtest_initial_cash回测初始资金\n76. backtest_commission_ratio回测佣金比例\n77. backtest_slippage_ratio回测滑点比例\n78. backtest_transaction_ratio回测成交比例\n79. '''\n80. run(strategy_id='strategy_id',\n81. filename='main.py',\n82. mode=MODE_BACKTEST,\n83. token='token_id',\n84. backtest_start_time='2017-09-29 11:25:00',\n85. backtest_end_time='2017-09-29 11:30:00',\n86. backtest_adjust=ADJUST_PREV,\n87. backtest_initial_cash=500000,\n88. backtest_commission_ratio=0.00006,\n89. backtest_slippage_ratio=0.0001,\n90. backtest_transaction_ratio=0.5)"}
{"query": "请生成一个# 海龟交易法(期货)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. import pandas as pd\n5. from gm.api import *\n\n\n8. '''\n9. 以短期为例：20日线\n10. 第一步：获取历史数据，计算唐奇安通道和ATR\n11. 第二步：当突破唐奇安通道时，开仓。\n12. 第三步：计算加仓和止损信号。\n13. '''\n\n\n16. def init(context):\n17. # 设置计算唐奇安通道的参数\n18. context.n = 20\n19. # 设置合约标的\n20. context.symbol = 'DCE.i2012'\n21. # 设置交易最大资金比率\n22. context.ratio = 0.8\n23. # 订阅数据\n24. subscribe(symbols=context.symbol, frequency='60s', count=2)\n25. # 获取当前时间\n26. time = context.now.strftime('%H:%M:%S')\n27. # 如果策略执行时间点是交易时间段，则直接执行algo定义atr等参数，以防直接进入on_bar()导致atr等未定义\n28. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\n29. algo(context)\n30. # 如果是交易时间段，等到开盘时间确保进入algo()\n31. schedule(schedule_func=algo, date_rule='1d', time_rule='09:00:00')\n32. schedule(schedule_func=algo, date_rule='1d', time_rule='21:00:00')\n\n\n35. def algo(context):\n36. # 计算通道的数据:当日最低、最高、上一交易日收盘\n37. # 注：由于talib库计算ATR的结果与公式求得的结果不符，所以这里利用公式计算ATR\n38. # 如果是回测模式,当天的数据直接用history取到\n39. if context.mode == 2:\n40. data = history_n(symbol=context.symbol, frequency='1d', count=context.n+1, end_time=context.now, fields='close,high,low,bob', df=True) # 计算ATR\n41. tr_list = []\n42. for i in range(0, len(data)-1):\n43. tr = max((data['high'].iloc[i] - data['low'].iloc[i]), data['close'].shift(-1).iloc[i] - data['high'].iloc[i],\n44. data['close'].shift(-1).iloc[i] - data['low'].iloc[i])\n45. tr_list.append(tr)\n46. context.atr = int(np.floor(np.mean(tr_list)))\n47. context.atr_half = int(np.floor(0.5 * context.atr))\n\n\n50. # 计算唐奇安通道\n51. context.don_open = np.max(data['high'].values[-context.n:])\n52. context.don_close = np.min(data['low'].values[-context.n:])\n\n54. # 如果是实时模式，当天的数据需要用current取到\n55. if context.mode == 1:\n56. data = history_n(symbol=context.symbol, frequency='1d', count=context.n, end_time=context.now, fields='close,high,low',\n57. df=True)  # 计算ATR\n58. current_data = current(symbols=context.symbol)   # 最新一个交易日的最高、最低\n59. tr_list = []\n60. for i in range(1, len(data)):\n61. tr = max((data['high'].iloc[i] - data['low'].iloc[i]),\n62. data['close'].shift(-1).iloc[i] - data['high'].iloc[i],\n63. data['close'].shift(-1).iloc[i] - data['low'].iloc[i])\n64. tr_list.append(tr)\n\n66. # 把最新一期tr加入列表中\n67. tr_new = max((current_data[0]['high'] - current_data[0]['low']),\n68. data['close'].iloc[-1] - current_data[0]['high'],\n69. data['close'].iloc[-1] - current_data[0]['low'])\n70. tr_list.append(tr_new)\n71. context.atr = int(np.floor(np.mean(tr_list)))\n72. context.atr_half = int(np.floor(0.5 * context.atr))\n\n74. # 计算唐奇安通道\n75. context.don_open = np.max(data['high'].values[-context.n:])\n76. context.don_close = np.min(data['low'].values[-context.n:])\n\n78. # 计算加仓点和止损点\n79. context.long_add_point = context.don_open + context.atr_half\n80. context.long_stop_loss = context.don_open - context.atr_half\n81. context.short_add_point = context.don_close - context.atr_half\n82. context.short_stop_loss = context.don_close + context.atr_half\n\n\n85. def on_bar(context, bars):\n86. # 提取数据\n87. symbol = bars[0]['symbol']\n88. recent_data = context.data(symbol=context.symbol, frequency='60s', count=2, fields='close,high,low')\n89. close = recent_data['close'].values[-1]\n\n91. # 账户仓位情况\n92. position_long = context.account().position(symbol=symbol, side=PositionSide_Long)\n93. position_short = context.account().position(symbol=symbol, side=PositionSide_Short)\n\n95. # 当无持仓时\n96. if not position_long and not position_short:\n97. # 如果向上突破唐奇安通道，则开多\n98. if close > context.don_open:\n99. order_volume(symbol=symbol, side=OrderSide_Buy, volume=context.atr, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n100. print('开多仓atr')\n\n102. # 如果向下突破唐奇安通道，则开空\n103. if close < context.don_close:\n104. order_volume(symbol=symbol, side=OrderSide_Sell, volume=context.atr, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n105. print('开空仓atr')\n\n107. # 有持仓时\n108. # 持多仓，继续突破（加仓）\n109. if position_long:\n110. # 当突破1/2atr时加仓\n111. if close > context.long_add_point:\n112. order_volume(symbol=symbol, volume=context.atr_half, side=OrderSide_Buy, order_type=OrderType_Market,position_effect=PositionEffect_Open)\n113. print('继续加仓0.5atr')\n114. context.long_add_point += context.atr_half\n115. context.long_stop_loss += context.atr_half\n116. # 持多仓，止损位计算\n117. if close < context.long_stop_loss:\n118. volume_hold = position_long['volume']\n119. if volume_hold >= context.atr_half:\n120. order_volume(symbol=symbol, volume=context.atr_half, side=OrderSide_Sell, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n121. else:\n122. order_volume(symbol=symbol, volume=volume_hold, side=OrderSide_Sell, order_type=OrderType_Market,position_effect=PositionEffect_Close)\n123. print('平多仓0.5atr')\n124. context.long_add_point -= context.atr_half\n125. context.long_stop_loss -= context.atr_half\n\n127. # 持空仓，继续突破（加仓）\n128. if position_short:\n129. # 当跌破加仓点时加仓\n130. if close < context.short_add_point:\n131. order_volume(symbol = symbol, volume=context.atr_half, side=OrderSide_Sell, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n132. print('继续加仓0.5atr')\n133. context.short_add_point -= context.atr_half\n134. context.short_stop_loss -= context.atr_half\n\n136. # 持多仓，止损位计算\n137. if close > context.short_stop_loss:\n138. volume_hold = position_short['volume']\n139. if volume_hold >= context.atr_half:\n140. order_volume(symbol=symbol, volume=context.atr_half, side=OrderSide_Buy, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n141. else:\n142. order_volume(symbol=symbol, volume=volume_hold, side=OrderSide_Buy, order_type=OrderType_Market,position_effect=PositionEffect_Close)\n143. print('平空仓0.5atr')\n144. context.short_add_point += context.atr_half\n145. context.short_stop_loss += context.atr_half\n\n\n148. if __name__ == '__main__':\n149. '''\n150. strategy_id策略ID,由系统生成\n151. filename文件名,请与本文件名保持一致\n152. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n153. token绑定计算机的ID,可在系统设置-密钥管理中生成\n154. backtest_start_time回测开始时间\n155. backtest_end_time回测结束时间\n156. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n157. backtest_initial_cash回测初始资金\n158. backtest_commission_ratio回测佣金比例\n159. backtest_slippage_ratio回测滑点比例\n160. '''\n161. run(strategy_id='strategy_id',\n162. filename='main.py',\n163. mode=MODE_BACKTEST,\n164. token='token',\n165. backtest_start_time='2020-02-15 09:15:00',\n166. backtest_end_time='2020-09-01 15:00:00',\n167. backtest_adjust=ADJUST_PREV,\n168. backtest_initial_cash=1000000,\n169. backtest_commission_ratio=0.0001,\n170. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 行业轮动(股票)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. from gm.api import *\n5. '''\n6. 本策略每隔1个月定时触发计算SHSE.000910.SHSE.000909.SHSE.000911.SHSE.000912.SHSE.000913.SHSE.000914\n7. (300工业.300材料.300可选.300消费.300医药.300金融)这几个行业指数过去\n8. 20个交易日的收益率并选取了收益率最高的指数的成份股获取并获取了他们的市值数据\n9. 随后把仓位调整至市值最大的5只股票上\n10. 回测数据为:SHSE.000910.SHSE.000909.SHSE.000911.SHSE.000912.SHSE.000913.SHSE.000914和他们的成份股\n11. 回测时间为:2017-07-01 08:00:00到2017-10-01 16:00:00\n12. '''\n13. def init(context):\n14. # 每月第一个交易日的09:40 定时执行algo任务（仿真和实盘时不支持该频率）\n15. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\n16. # 用于筛选的行业指数\n17. context.index = ['SHSE.000910', 'SHSE.000909', 'SHSE.000911', 'SHSE.000912', 'SHSE.000913', 'SHSE.000914']\n18. # 用于统计数据的天数\n19. context.date = 20\n20. # 最大下单资金比例\n21. context.ratio = 0.8\n\n23. def algo(context):\n24. # 获取当天的日期\n25. today = context.now\n26. # 获取上一个交易日\n27. last_day = get_previous_trading_date(exchange='SHSE', date=today)\n28. return_index = []\n\n30. # 获取并计算行业指数收益率\n31. for i in context.index:\n32. return_index_his = history_n(symbol=i, frequency='1d', count=context.date, fields='close,bob',\n33. fill_missing='Last', adjust=ADJUST_PREV, end_time=last_day, df=True)\n34. return_index_his = return_index_his['close'].values\n35. return_index.append(return_index_his[-1] / return_index_his[0] - 1)\n\n37. # 获取指定数内收益率表现最好的行业\n38. sector = context.index[np.argmax(return_index)]\n39. print('最佳行业指数是: ', sector)\n\n41. # 获取最佳行业指数成份股\n42. symbols = get_history_constituents(index=sector, start_date=last_day, end_date=last_day)[0]['constituents'].keys()\n\n44. # 获取当天有交易的股票\n45. not_suspended_info = get_history_instruments(symbols=symbols, start_date=today, end_date=today)\n46. not_suspended_symbols = [item['symbol'] for item in not_suspended_info if not item['is_suspended']]\n\n48. # 获取最佳行业指数成份股的市值，从大到小排序并选取市值最大的5只股票\n49. fin = get_fundamentals(table='trading_derivative_indicator', symbols=not_suspended_symbols, start_date=last_day,\n50. end_date=last_day, limit=5, fields='NEGOTIABLEMV', order_by='-NEGOTIABLEMV', df=True)\n51. fin.index = fin['symbol']\n\n53. # 计算权重\n54. percent = 1.0 / len(fin.index) * context.ratio\n\n56. # 获取当前所有仓位\n57. positions = context.account().positions()\n\n59. # 如标的池有仓位,平不在标的池的仓位\n60. for position in positions:\n61. symbol = position['symbol']\n62. if symbol not in fin.index:\n63. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n64. position_side=PositionSide_Long)\n65. print('市价单平不在标的池的', symbol)\n\n67. # 对标的池进行操作\n68. for symbol in fin.index:\n69. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\n70. position_side=PositionSide_Long)\n71. print(symbol, '以市价单调整至仓位', percent)\n\n73. if __name__ == '__main__':\n74. '''\n75. strategy_id策略ID,由系统生成\n76. filename文件名,请与本文件名保持一致\n77. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n78. token绑定计算机的ID,可在系统设置-密钥管理中生成\n79. backtest_start_time回测开始时间\n80. backtest_end_time回测结束时间\n81. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n82. backtest_initial_cash回测初始资金\n83. backtest_commission_ratio回测佣金比例\n84. backtest_slippage_ratio回测滑点比例\n85. '''\n86. run(strategy_id='strategy_id',\n87. filename='main.py',\n88. mode=MODE_BACKTEST,\n89. token='token_id',\n90. backtest_start_time='2017-07-01 08:00:00',\n91. backtest_end_time='2017-10-01 16:00:00',\n92. backtest_adjust=ADJUST_PREV,\n93. backtest_initial_cash=10000000,\n94. backtest_commission_ratio=0.0001,\n95. backtest_slippage_ratio=0.0001)"}
{"query": "请生成一个# 机器学习(股票)策略代码", "base_model_response": "", "lora_model_response": "", "original_response": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from datetime import datetime\n4. import numpy as np\n5. from gm.api import *\n6. import sys\n7. try:\n8. from sklearn import svm\n9. except:\n10. print('请安装scikit-learn库和带mkl的numpy')\n11. sys.exit(-1)\n12. '''\n13. 本策略选取了七个特征变量组成了滑动窗口长度为15天的训练集,随后训练了一个二分类(上涨/下跌)的支持向量机模型.\n14. 若没有仓位则在每个星期一的时候输入标的股票近15个交易日的特征变量进行预测,并在预测结果为上涨的时候购买标的.\n15. 若已经持有仓位则在盈利大于10%的时候止盈,在星期五损失大于2%的时候止损.\n16. 特征变量为:1.收盘价/均值2.现量/均量3.最高价/均价4.最低价/均价5.现量6.区间收益率7.区间标准差\n17. 训练数据为:SHSE.600000浦发银行,时间从2016-04-01到2017-07-30\n18. 回测时间为:2017-07-01 09:00:00到2017-10-01 09:00:00\n19. '''\n\n21. def init(context):\n22. # 订阅浦发银行的分钟bar行情\n23. context.symbol = 'SHSE.600000'\n24. subscribe(symbols=context.symbol, frequency='60s')\n25. start_date = '2016-04-01'  # SVM训练起始时间\n26. end_date = '2017-07-30'  # SVM训练终止时间\n\n28. # 用于记录工作日\n29. # 获取目标股票的daily历史行情\n30. recent_data = history(context.symbol, frequency='1d', start_time=start_date, end_time=end_date, fill_missing='last',\n31. df=True)\n32. days_value = recent_data['bob'].values\n33. days_close = recent_data['close'].values\n34. days = []\n\n36. # 获取行情日期列表\n37. print('准备数据训练SVM')\n38. for i in range(len(days_value)):\n39. days.append(str(days_value[i])[0:10])\n40. x_all = []\n41. y_all = []\n42. for index in range(15, (len(days) - 5)):\n43. # 计算三星期共15个交易日相关数据\n44. start_day = days[index - 15]\n45. end_day = days[index]\n46. data = history(context.symbol, frequency='1d', start_time=start_day, end_time=end_day, fill_missing='last',\n47. df=True)\n48. close = data['close'].values\n49. max_x = data['high'].values\n50. min_n = data['low'].values\n51. amount = data['amount'].values\n52. volume = []\n53. for i in range(len(close)):\n54. volume_temp = amount[i] / close[i]\n55. volume.append(volume_temp)\n56. close_mean = close[-1] / np.mean(close)  # 收盘价/均值\n57. volume_mean = volume[-1] / np.mean(volume)  # 现量/均量\n58. max_mean = max_x[-1] / np.mean(max_x)  # 最高价/均价\n59. min_mean = min_n[-1] / np.mean(min_n)  # 最低价/均价\n60. vol = volume[-1]  # 现量\n61. return_now = close[-1] / close[0]  # 区间收益率\n62. std = np.std(np.array(close), axis=0)  # 区间标准差\n\n64. # 将计算出的指标添加到训练集X\n65. # features用于存放因子\n66. features = [close_mean, volume_mean, max_mean, min_mean, vol, return_now, std]\n67. x_all.append(features)\n\n69. # 准备算法需要用到的数据\n70. for i in range(len(days_close) - 20):\n71. if days_close[i + 20] > days_close[i + 15]:\n72. label = 1\n73. else:\n74. label = 0\n75. y_all.append(label)\n76. x_train = x_all[: -1]\n77. y_train = y_all[: -1]\n\n79. # 训练SVM\n80. context.clf = svm.SVC(C=0.6, kernel='rbf', gamma=0.001)\n81. context.clf.fit(x_train, y_train)\n82. print('训练完成!')\n\n84. def on_bar(context, bars):\n85. bar = bars[0]\n\n87. # 获取当前年月日\n88. today = bar.bob.strftime('%Y-%m-%d')\n\n90. # 获取数据并计算相应的因子\n91. # 于星期一的09:31:00进行操作\n92. # 当前bar的工作日\n93. weekday = datetime.strptime(today, '%Y-%m-%d').isoweekday()\n\n95. # 获取模型相关的数据\n96. # 获取持仓\n97. position = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n\n99. # 如果bar是新的星期一且没有仓位则开始预测\n100. if not position and weekday == 1:\n101. # 获取预测用的历史数据\n102. data = history_n(symbol=context.symbol, frequency='1d', end_time=today, count=15,\n103. fill_missing='last', df=True)\n104. close = data['close'].values\n105. train_max_x = data['high'].values\n106. train_min_n = data['low'].values\n107. train_amount = data['amount'].values\n108. volume = []\n109. for i in range(len(close)):\n110. volume_temp = train_amount[i] / close[i]\n111. volume.append(volume_temp)\n112. close_mean = close[-1] / np.mean(close)\n113. volume_mean = volume[-1] / np.mean(volume)\n114. max_mean = train_max_x[-1] / np.mean(train_max_x)\n115. min_mean = train_min_n[-1] / np.mean(train_min_n)\n116. vol = volume[-1]\n117. return_now = close[-1] / close[0]\n118. std = np.std(np.array(close), axis=0)\n\n120. # 得到本次输入模型的因子\n121. features = [close_mean, volume_mean, max_mean, min_mean, vol, return_now, std]\n122. features = np.array(features).reshape(1, -1)\n123. prediction = context.clf.predict(features)[0]\n\n125. # 若预测值为上涨则开仓\n126. if prediction == 1:\n127. # 获取昨收盘价\n128. context.price = close[-1]\n129. # 把浦发银行的仓位调至95%\n130. order_target_percent(symbol=context.symbol, percent=0.95, order_type=OrderType_Market,\n131. position_side=PositionSide_Long)\n132. print('SHSE.600000以市价单开多仓到仓位0.95')\n\n134. # 当涨幅大于10%,平掉所有仓位止盈\n135. elif position and bar.close / context.price >= 1.10:\n136. order_close_all()\n137. print('SHSE.600000以市价单全平多仓止盈')\n\n139. # 当时间为周五并且跌幅大于2%时,平掉所有仓位止损\n140. elif position and bar.close / context.price < 1.02 and weekday == 5:\n141. order_close_all()\n142. print('SHSE.600000以市价单全平多仓止损')\n\n144. if __name__ == '__main__':\n145. '''\n146. strategy_id策略ID,由系统生成\n147. filename文件名,请与本文件名保持一致\n148. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n149. token绑定计算机的ID,可在系统设置-密钥管理中生成\n150. backtest_start_time回测开始时间\n151. backtest_end_time回测结束时间\n152. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n153. backtest_initial_cash回测初始资金\n154. backtest_commission_ratio回测佣金比例\n155. backtest_slippage_ratio回测滑点比例\n156. '''\n157. run(strategy_id='strategy_id',\n158. filename='main.py',\n159. mode=MODE_BACKTEST,\n160. token='token_id',\n161. backtest_start_time='2017-07-01 09:00:00',\n162. backtest_end_time='2017-10-01 09:00:00',\n163. backtest_adjust=ADJUST_PREV,\n164. backtest_initial_cash=10000000,\n165. backtest_commission_ratio=0.0001,\n166. backtest_slippage_ratio=0.0001)"}
