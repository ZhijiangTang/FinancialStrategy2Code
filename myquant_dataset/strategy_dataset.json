[
  {
    "strategy_id": "myquant_001",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. from gm.api import *\n4. import talib\n\n\n7. '''\n8. 本策略以SHFE.rb2101为交易标的，根据其一分钟(即60s频度）bar数据建立双均线模型，\n9. 短周期为20，长周期为60，当短期均线由上向下穿越长期均线时做空，\n10. 当短期均线由下向上穿越长期均线时做多,每次开仓前先平掉所持仓位，再开仓。\n11. 注：为了适用于仿真和实盘，在策略中增加了一个“先判断是否平仓成功再开仓”的判断逻辑，以避免出现未平仓成功，可用资金不足的情况。\n12. 回测数据为:SHFE.rb2101的60s频度bar数据\n13. 回测时间为:2020-04-01 09:00:00到2020-05-31 15:00:00\n14. '''\n\n\n17. def init(context):\n18. context.short = 20                                             # 短周期均线\n19. context.long = 60                                              # 长周期均线\n20. context.symbol = 'SHFE.rb2101'                                 # 订阅交易标的\n21. context.period = context.long + 1                              # 订阅数据滑窗长度\n22. context.open_long = False                                      # 开多单标记\n23. context.open_short = False                                     # 开空单标记\n24. subscribe(context.symbol, '60s', count=context.period)         # 订阅行情\n\n\n27. def on_bar(context, bars):\n28. # 获取通过subscribe订阅的数据\n29. prices = context.data(context.symbol, '60s', context.period, fields='close')\n\n31. # 利用talib库计算长短周期均线\n32. short_avg = talib.SMA(prices.values.reshape(context.period), context.short)\n33. long_avg = talib.SMA(prices.values.reshape(context.period), context.long)\n\n35. # 查询持仓\n36. position_long = context.account().position(symbol=context.symbol, side=1)\n37. position_short = context.account().position(symbol=context.symbol, side=2)\n\n39. # 短均线下穿长均线，做空(即当前时间点短均线处于长均线下方，前一时间点短均线处于长均线上方)\n40. if long_avg[-2] < short_avg[-2] and long_avg[-1] >= short_avg[-1]:\n\n42. # 无多仓情况下，直接开空\n43. if not position_long:\n44. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell, position_effect=PositionEffect_Open,\n45. order_type=OrderType_Market)\n46. print(context.symbol, '以市价单调空仓到仓位')\n\n48. # 有多仓情况下，先平多，再开空(开空命令放在on_order_status里面)\n49. else:\n50. context.open_short = True\n\n52. # 以市价平多仓\n53. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell, position_effect=PositionEffect_Close,\n54. order_type=OrderType_Market)\n55. print(context.symbol, '以市价单平多仓')\n\n57. # 短均线上穿长均线，做多（即当前时间点短均线处于长均线上方，前一时间点短均线处于长均线下方）\n58. if short_avg[-2] < long_avg[-2] and short_avg[-1] >= long_avg[-1]:\n\n60. # 无空仓情况下，直接开多\n61. if not position_short:\n62. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy, position_effect=PositionEffect_Open,\n63. order_type=OrderType_Market)\n64. print(context.symbol, '以市价单调多仓到仓位')\n\n66. # 有空仓的情况下，先平空，再开多(开多命令放在on_order_status里面)\n67. else:\n68. context.open_long = True\n\n70. # 以市价平空仓\n71. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n72. position_effect=PositionEffect_Close, order_type=OrderType_Market)\n73. print(context.symbol, '以市价单平空仓')\n\n\n76. def on_order_status(context, order):\n\n78. # 查看下单后的委托状态\n79. status = order['status']\n\n81. # 成交命令的方向\n82. side = order['side']\n\n84. # 交易类型\n85. effect = order['position_effect']\n\n87. # 当平仓委托全成后，再开仓\n88. if status == 3:\n\n90. # 以市价开空仓，需等到平仓成功无仓位后再开仓\n91. # 如果无多仓且side=2（说明平多仓成功），开空仓\n92. if effect == 2 and side == 2 and context.open_short:\n93. context.open_short = False\n94. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell, position_effect=PositionEffect_Open,\n95. order_type=OrderType_Market)\n96. print(context.symbol, '以市价单调空仓到仓位')\n\n98. # 以市价开多仓,需等到平仓成功无仓位后再开仓\n99. # 如果无空仓且side=1（说明平空仓成功），开多仓\n100. if effect == 2 and side == 1 and context.open_long:\n101. context.open_long = False\n102. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy, position_effect=PositionEffect_Open,\n103. order_type=OrderType_Market)\n104. print(context.symbol, '以市价单调多仓到仓位')\n\n\n107. if __name__ == '__main__':\n108. '''\n109. strategy_id策略ID,由系统生成\n110. filename文件名,请与本文件名保持一致\n111. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n112. token绑定计算机的ID,可在系统设置-密钥管理中生成\n113. backtest_start_time回测开始时间\n114. backtest_end_time回测结束时间\n115. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n116. backtest_initial_cash回测初始资金\n117. backtest_commission_ratio回测佣金比例\n118. backtest_slippage_ratio回测滑点比例\n119. '''\n120. run(strategy_id='strategy_id',\n121. filename='main.py',\n122. mode=MODE_BACKTEST,\n123. token='token_id',\n124. backtest_start_time='2020-04-01 09:00:00',\n125. backtest_end_time='2020-05-31 15:00:00',\n126. backtest_adjust=ADJUST_NONE,\n127. backtest_initial_cash=10000000,\n128. backtest_commission_ratio=0.0001,\n129. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 双均线策略(期货)\n\n分享\n\n阅读 567308\n 更新 2022-05-09 16:56:48\n\n* [双均线策略](#512c387f42bd8bbb)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [均线的“前世今生”](#8739be5a3b750087)\n    - [均线理论为什么有效？](#10b66049c43202c8)\n    - [均线理论的缺陷](#bb02b6da783b762a)\n    - [均线理论的改进](#bfb608c318c7a05d)\n  + [2. 策略逻辑](#fdd18c620885abac)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\n\n# 双均线策略\n\n## 1. 原理\n\n### 均线的“前世今生”\n\n均线，一个进行形态分析时总也绕不过去的指标。\n\n均线最早由美国投资专家Joseph E.Granville(格兰威尔)于20世纪中期提出，现在仍然广泛为人们使用，成为判断买卖信号的一大重要指标。从统计角度来说，均线就是历史价格的平均值，可以代表过去N日股价的平均走势。\n\n1962年7月，Joseph E.Granville在他的书中提出了著名的Granville八大买卖法则。只利用股价和均线即可进行择时，方法简单有效，一经提出，迅速受到市场追捧。尤其是其中的金叉和死叉信号，更是沿用至今。\n\nGranville 八大法则其中有四条是用于判断买进时机，另外四条是用于判断卖出时机。买进和卖出法则一一对应，分布在高点的左右两侧（除买4和卖4以外）。法则内容如下所示：\n\n买1：均线整体上行，股价由下至上上穿均线，此为黄金交叉，形成第一个买点。  \n买2：股价出现下跌迹象，但尚未跌破均线，此时均线变成支撑线，形成第二个买点。  \n买3：股价仍处于均线上方，但呈现急剧下跌趋势。当跌破均线时，出现第三个买点。  \n买4：（右侧）股价和均线都处于下降通道，且股价处于均线下方，严重远离均线，出现第四个买点。\n\n卖1：均线由上升状态变为缓慢下降的状态，股价也开始下降。当股价跌破均线时，此为死亡交叉，形成第一个卖点。  \n卖2：股价仍处于均线之下，但股价开始呈现上涨趋势，当股价无限接近均线但尚未突破时，此时均线变成阻力线，形成第二个卖点。  \n卖3：股价终于突破均线，处于均线上方。但持续时间不长，股价开始下跌，直至再一次跌破均线，此为第三个卖点。  \n卖4：（左侧）股价和均线都在上涨，股价上涨的速度远快于均线上涨的速度。当股价严重偏离均线时，出现第四个卖点。  \n(部分资料来源于百度百科)\n\n![](/uploads/202010/attach_16402fcc49ff5d9b.jpg)  \n（图片来源于网络）\n\n### 均线理论为什么有效？\n\nShiller（1981）在研究中发现，资产的长期价格呈现均值回复的特征，即从长期来看，资产的价格会回归均值。这也是均线理论被广泛应用的前提。\n\n### 均线理论的缺陷\n\n均线归根到底是一种平均值，平均值在应用过程中存在最大的问题就是其**滞后性**。当出现买入卖出信号时，最佳时机早已过去。举例来说，如果A股票最新价格出现了较大的涨幅，股价和均线都上涨，但均线的速度慢于股价上涨速度。此时，从形态上来看，金叉出现，为买入信号。次日，股价回调，股价下降的速度快于均线下降的速度，形成死叉，为卖点。这样一买一卖不仅没有盈利，反而出现亏损。\n\n### 均线理论的改进\n\n针对均线的缺点，市场上提出了各种各样的改进方法。\n\n1.对均线的计算方法进行改正。\n\n加权移动平均线是在移动平均线的基础上按照时间进行加权。越靠近当前日期的价格对未来价格的影响越大，赋予更大的权重；越远离当前日期价格，赋予越小的权重。\n\n2.调整均线周期\n\n利用不同周期均线得到的结果也不同。许多有经验的投资者发现，在不同的市场中，有些均线的效果显著优于其他周期均线。有些长线投资者还会将股价替换成短周期均线进行趋势判断。\n\n## 2. 策略逻辑\n\n第一步：获取数据，计算长短期均线  \n第二步：设置交易信号\n\n当短期均线由上向下穿越长期均线时做空  \n当短期均线由下向上穿越长期均线时做多\n\n回测数据: SHFE.rb2101的60s频度bar数据  \n回测时间: 2020-04-01 到 2020-05-31  \n回测初始资金：3万\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_002",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. from gm.api import *\n\n\n6. \"\"\"\n7. Dual Thrust是一个趋势跟踪系统\n8. 计算前N天的最高价－收盘价和收盘价－最低价。然后取这2N个价差的最大值，乘以k值。把结果称为触发值。\n9. 在今天的开盘，记录开盘价，然后在价格超过上轨（开盘＋触发值）时马上买入，或者价格低于下轨（开盘－触发值）时马上卖空。\n10. 没有明确止损。这个系统是反转系统，也就是说，如果在价格超过（开盘＋触发值）时手头有空单，则平空开多。\n11. 同理，如果在价格低于（开盘－触发值）时手上有多单，则平多开空。\n12. 选用了SHFE的rb2010 在2020-02-07 15:00:00 到 2020-04-15 15:00:00' 进行回测。\n13. 注意：\n14. 1：为回测方便，本策略使用了on_bar的一分钟来计算，实盘中可能需要使用on_tick。\n15. 2：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交\n16. \"\"\"\n\n\n19. # 策略中必须有init方法\n20. def init(context):\n\n22. # 设置要进行回测的合约（可以在掘金终端的仿真交易中查询标的代码）\n23. context.symbol = 'SHFE.rb2010'  # 订阅&交易标的, 此处订阅的是上期所的螺纹钢 2010\n\n25. # 设置参数\n26. context.N = 5\n27. context.k1 = 0.2\n28. context.k2 = 0.2\n\n30. # 获取当前时间\n31. time = context.now.strftime('%H:%M:%S')\n\n33. # 如果策略执行时间点是交易时间段，则直接执行algo定义buy_line和sell_line，以防直接进入on_bar()导致context.buy_line和context.sell_line未定义\n34. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\n35. algo(context)\n\n37. # 如果是交易时间段，等到开盘时间确保进入algo()\n38. schedule(schedule_func = algo, date_rule = '1d', time_rule = '09:00:00')\n39. schedule(schedule_func = algo, date_rule = '1d', time_rule = '21:00:00')\n\n41. # 只需要最新价，所以只需要订阅一个, 如果用tick，次数太多，用一分钟线代替\n42. subscribe(symbols=context.symbol, frequency='60s', count = 1)\n\n\n45. def algo(context):\n46. # 取历史数据\n47. data = history_n(symbol=context.symbol, frequency='1d', end_time=context.now,\n48. fields='symbol,open,high,low,close', count=context.N + 1, df=True)\n49. # 取开盘价\n50. # 回测模式下，开盘价可以直接用history_n取到\n51. if context.mode == 2:\n52. # 获取当天的开盘价\n53. current_open = data['open'].loc[context.N]\n54. # 去掉当天的实时数据\n55. data.drop(context.N, inplace = True)\n56. # 如果是实时模式，开盘价需要用current取到\n57. else:\n58. # 获取当天的开盘价\n59. current_open = current(context.symbol)[0]['open']\n\n61. # 计算Dual Thrust 的上下轨\n62. HH = data['high'].max()\n63. HC = data['close'].max()\n64. LC = data['close'].min()\n65. LL = data['low'].min()\n66. range = max(HH - LC, HC - LL)\n67. context.buy_line = current_open + range * context.k1  # 上轨\n68. context.sell_line = current_open - range * context.k2  # 下轨\n\n\n71. def on_bar(context, bars):\n72. # 取出订阅的这一分钟的bar\n73. bar = bars[0]\n74. # 取出买卖线\n75. buy_line =  context.buy_line\n76. sell_line = context.sell_line\n\n78. # 获取现有持仓\n79. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n80. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\n\n82. # 交易逻辑部分\n83. # 如果超过range的上界\n84. if bar.close > buy_line:\n85. if position_long:  # 已经持有多仓，直接返回\n86. return\n87. elif position_short:  # 已经持有空仓，平仓再做多。\n88. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n89. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n90. print('市价单平空仓', context.symbol)\n91. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n92. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n93. print('市价单开多仓', context.symbol)\n94. else:  # 没有持仓时，市价开多。\n95. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n96. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n97. print('市价单开多仓', context.symbol)\n98. # 如果低于range的下界\n99. elif bar.close < sell_line:\n100. if position_long:  # 已经持有多仓， 平多再开空。\n101. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n102. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n103. print('市价单平多仓', context.symbol)\n104. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n105. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n106. print('市价单开空仓', context.symbol)\n107. elif position_short:  # 已经持有空仓，直接返回。\n108. return\n109. else:  # 没有持仓，直接开空\n110. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n111. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n112. print('市价单开空仓', context.symbol)\n\n\n115. if __name__ == '__main__':\n116. '''\n117. strategy_id策略ID,由系统生成\n118. filename文件名,请与本文件名保持一致\n119. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n120. token绑定计算机的ID,可在系统设置-密钥管理中生成\n121. backtest_start_time回测开始时间\n122. backtest_end_time回测结束时间\n123. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n124. backtest_initial_cash回测初始资金\n125. backtest_commission_ratio回测佣金比例\n126. backtest_slippage_ratio回测滑点比例\n127. '''\n128. run(strategy_id='strategy_id',\n129. filename='main.py',\n130. mode=MODE_BACKTEST,\n131. token='token_id',\n132. backtest_start_time='2020-02-07 15:00:00',\n133. backtest_end_time='2020-04-15 15:00:00',\n134. backtest_initial_cash= 30000,\n135. backtest_commission_ratio=0.0001,\n136. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# Dual Thrust(期货)\n\n分享\n\n阅读 72976\n 更新 2022-05-09 16:56:48\n\n* [Dual Thrust](#b48a0f5838e23bf3)\n  + [1. 原理](#4d68e06c45acd2a2)\n  + [2. 策略逻辑](#fdd18c620885abac)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\n\n# Dual Thrust\n\n## 1. 原理\n\n由Michael Chalek在20世纪80年代开发的Dual Thrust策略是一个趋势跟踪策略。\n\n其核心思想是定义一个区间，区间的上界和下界分别为支撑线和阻力线。当价格超过上界时，如果持有空仓，先平再开多；如果没有仓位，直接开多。当价格跌破下界时，如果持有多仓，则先平仓，再开空仓；如果没有仓位，直接开空仓。\n\n上下界的设定是交易策略的核心部分。在计算上下界时共用到：最高价、最低价、收盘价、开盘价四个参数。\n\n公式如下：\n\n **Range = Max(HH-LC,HC-LL)** \n\n上限：Open + K1  *Range  \n下限：Open + k2*  Range\n\nK1 和 K2一般根据自己经验以及回测结果进行优化。\n\n## 2. 策略逻辑\n\n第一步：设置参数N、k1、k2  \n第二步：计算HH、LC、HC、LL  \n第三步：计算range  \n第四步：设定做多和做空信号\n\n回测标的：SHFE.rb2010  \n回测期：2020-02-07 15:00:00 到 2020-04-15 15:00:00  \n回测初始资金：3万\n\n**注意：若修改回测期，需要修改对应的回测标的。**\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_003",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. import pandas as pd\n4. from gm.api import *\n5. from datetime import datetime, timedelta\n\n\n8. \"\"\"\n9. R-Breaker是一种短线日内交易策略\n10. 根据前一个交易日的收盘价、最高价和最低价数据通过一定方式计算出六个价位，从大到小依次为：\n11. 突破买入价、观察卖出价、反转卖出价、反转买入、观察买入价、突破卖出价。以此来形成当前交易\n12. 日盘中交易的触发条件。\n13. 追踪盘中价格走势，实时判断触发条件。具体条件如下：\n14. 突破\n15. 在空仓条件下，如果盘中价格超过突破买入价，则采取趋势策略，即在该点位开仓做多。\n16. 在空仓条件下，如果盘中价格跌破突破卖出价，则采取趋势策略，即在该点位开仓做空。\n17. 反转\n18. 持多单，当日内最高价超过观察卖出价后，盘中价格出现回落，且进一步跌破反转卖出价构成的支撑线时，采取反转策略，即在该点位反手做空。\n19. 持空单，当日内最低价低于观察买入价后，盘中价格出现反弹，且进一步超过反转买入价构成的阻力线时，采取反转策略，即在该点位反手做多。\n20. 设定止损条件。当亏损达到设定值后，平仓。\n\n22. 注意：\n23. 1：为回测方便，本策略使用了on_bar的一分钟来计算，实盘中可能需要使用on_tick。\n24. 2：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交。\n25. 3：本策略使用在15点收盘时全平的方式来处理不持有隔夜单的情况，实际使用中15点是无法平仓的。\n26. \"\"\"\n\n\n29. def init(context):\n30. # 设置交易品种\n31. context.symbol = 'SHFE.ag'\n32. # 设置止损点数\n33. context.stopLossPrice = 50\n\n35. # 获取前一交易日的主力合约\n36. startDate = get_previous_trading_date(exchange='SHFE', date=context.now.date())\n37. continuous_contract = get_continuous_contracts(context.symbol, startDate, startDate)\n38. context.mainContract = continuous_contract[0]['symbol']\n\n40. # 获取当前时间\n41. time = context.now.strftime('%H:%M:%S')\n\n43. # 如果当前时间是非交易时间段，则直接执行algo,以防直接进入on_bar()导致context.bBreak等未定义\n44. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\n45. algo(context)\n\n47. # 如果是交易时间段，等到开盘时间确保进入algo()\n48. schedule(schedule_func = algo, date_rule = '1d', time_rule = '09:00:00')\n49. schedule(schedule_func = algo, date_rule = '1d', time_rule = '21:00:00')\n\n51. # 订阅行情\n52. subscribe(continuous_contract[0]['symbol'], frequency='60s', count=1)\n\n\n55. def algo(context):\n56. # 检查主力和约，发生变化则更换订阅\n57. # 由于主力合约在盘后才公布，为了防止未来函数，选择上一交易日的主力合约。\n58. startDate = get_previous_trading_date(exchange='SHFE', date=context.now.date())\n59. contractInfo = get_continuous_contracts(context.symbol, startDate, startDate)\n60. if context.mainContract != contractInfo[0]['symbol']:\n61. context.mainContract = contractInfo[0]['symbol']\n62. subscribe(context.mainContract, frequency='60s', count=1, unsubscribe_previous=True)\n\n64. # 获取历史数据\n65. data = history_n(symbol=context.mainContract, frequency='1d',\n66. end_time=context.now, fields='high,low,open,symbol,close', count=2, df=True)\n67. high = data['high'].iloc[0]  # 前一日的最高价\n68. low = data['low'].iloc[0]  # 前一日的最低价\n69. close = data['close'].iloc[0]  # 前一日的收盘价\n70. pivot = (high + low + close) / 3  # 枢轴点\n71. context.bBreak = high + 2 * (pivot - low)  # 突破买入价\n72. context.sSetup = pivot + (high - low)  # 观察卖出价\n73. context.sEnter = 2 * pivot - low  # 反转卖出价\n74. context.bEnter = 2 * pivot - high  # 反转买入价\n75. context.bSetup = pivot - (high - low)  # 观察买入价\n76. context.sBreak = low - 2 * (high - pivot)  # 突破卖出价\n77. context.data = data\n\n\n80. def on_bar(context, bars):\n\n82. # 获取止损价\n83. STOP_LOSS_PRICE = context.stopLossPrice\n\n85. # 设置参数\n86. bBreak = context.bBreak\n87. sSetup = context.sSetup\n88. sEnter = context.sEnter\n89. bEnter = context.bEnter\n90. bSetup = context.bSetup\n91. sBreak = context.sBreak\n92. data = context.data\n\n94. # 获取现有持仓\n95. position_long = context.account().position(symbol=context.mainContract, side=PositionSide_Long)\n96. position_short = context.account().position(symbol=context.mainContract, side=PositionSide_Short)\n\n98. # 突破策略:\n99. if not position_long and not position_short:  # 空仓条件下\n100. if bars[0].close > bBreak:\n101. # 在空仓的情况下，如果盘中价格超过突破买入价，则采取趋势策略，即在该点位开仓做多\n102. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Buy,\n103. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做多\n104. print(\"空仓,盘中价格超过突破买入价: 开仓做多\")\n105. context.open_position_price = bars[0].close\n106. elif bars[0].close < sBreak:\n107. # 在空仓的情况下，如果盘中价格跌破突破卖出价，则采取趋势策略，即在该点位开仓做空\n108. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Sell,\n109. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做空\n110. print(\"空仓,盘中价格跌破突破卖出价: 开仓做空\")\n111. context.open_position_price = bars[0].close\n\n113. # 设置止损条件\n114. else:  # 有持仓时\n115. # 开仓价与当前行情价之差大于止损点则止损\n116. if (position_long and context.open_position_price - bars[0].close >= STOP_LOSS_PRICE) or \\\n117. (position_short and bars[0].close - context.open_position_price >= STOP_LOSS_PRICE):\n118. print('达到止损点，全部平仓')\n119. order_close_all()  # 平仓\n\n121. # 反转策略:\n122. if position_long:  # 多仓条件下\n123. if data.high.iloc[1] > sSetup and bars[0].close < sEnter:\n124. # 多头持仓,当日内最高价超过观察卖出价后，\n125. # 盘中价格出现回落，且进一步跌破反转卖出价构成的支撑线时，\n126. # 采取反转策略，即在该点位反手做空\n127. order_close_all()  # 平仓\n128. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Sell,\n129. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做空\n130. print(\"多头持仓,当日内最高价超过观察卖出价后跌破反转卖出价: 反手做空\")\n131. context.open_position_price = bars[0].close\n132. elif position_short:  # 空头持仓\n133. if data.low.iloc[1] < bSetup and bars[0].close > bEnter:\n134. # 空头持仓，当日内最低价低于观察买入价后，\n135. # 盘中价格出现反弹，且进一步超过反转买入价构成的阻力线时，\n136. # 采取反转策略，即在该点位反手做多\n137. order_close_all()  # 平仓\n138. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Buy,\n139. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做多\n140. print(\"空头持仓,当日最低价低于观察买入价后超过反转买入价: 反手做多\")\n141. context.open_position_price = bars[0].close\n\n143. if context.now.hour == 14 and context.now.minute == 59:\n144. order_close_all()\n145. print('全部平仓')\n\n\n148. if __name__ == '__main__':\n149. run(strategy_id='strategy_id',\n150. filename='main.py',\n151. mode=MODE_BACKTEST,\n152. token='token_id',\n153. backtest_start_time='2019-10-1 15:00:00',\n154. backtest_end_time='2020-04-16 15:00:00',\n155. backtest_initial_cash=1000000,\n156. backtest_commission_ratio=0.0001,\n157. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# R-Breaker(期货)\n\n分享\n\n阅读 62146\n 更新 2022-05-09 16:56:48\n\n* [R Breaker](#95e32de9cbc3c066)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [1.1 原理](#6a0fbf342f63eb77)\n    - [1.2 触发条件](#cee22b7a4e233343)\n    - [1.3 背后逻辑解析](#3984987f6bbb6f35)\n  + [2、策略逻辑](#b8a3058d88bf3ad2)\n  + [3、策略代码](#caba9bac1a6a5be2)\n  + [4、回测结果与稳健性分析](#017ce2183a41051c)\n\n# R Breaker\n\n## 1. 原理\n\n### 1.1 原理\n\nR Breaker是一种日内回转交易策略，属于短线交易。日内回转交易是指当天买入或卖出标的后于当日再卖出或买入标的。日内回转交易通过标的短期波动盈利，低买高卖，时间短、投机性强，适合短线投资者。\n\nR Breaker主要分为分为反转和趋势两部分。空仓时进行趋势跟随，持仓时等待反转信号反向开仓。\n\n由于我国A股采用的是“T+1”交易制度，为了方便起见，以期货为例演示R Breaker策略。\n\n反转和趋势突破的价位点根据前一交易日的收盘价、最高价和最低价数据计算得出，分别为：突破买入价、观察卖出价、反转卖出价、反转买入价、观察买入价和突破卖出价。计算方法如下：\n\n| 指标计算方法 |\n| --- |\n| 中心价位P = （H + C + L）/3 |\n| 突破买入价 = H + 2P -2L |\n| 观察卖出价 = P + H - L |\n| 反转卖出价 = 2P - L |\n| 反转买入价 = 2P - H |\n| 观察买入价 = P - (H - L) |\n| 突破卖出价 = L - 2(H - P) |\n\n### 1.2 触发条件\n\n空仓时：突破策略  \n空仓时，当盘中价格>突破买入价，则认为上涨的趋势还会继续，开仓做多；  \n空仓时，当盘中价格<突破卖出价，则认为下跌的趋势还会继续，开仓做空。\n\n持仓时：反转策略  \n持多单时：当日内最高价>观察卖出价后，盘中价格回落，跌破反转卖出价构成的支撑线时，采取反转策略，即做空；  \n持空单时：当日内最低价<观察买入价后，盘中价格反弹，超过反转买入价构成的阻力线时，采取反转策略，即做多。\n\n如下图所示：  \n![](/uploads/202010/attach_16417be280731bd9.png)\n\n### 1.3 背后逻辑解析\n\n首先看一下这6个价格与前一日价格之间的关系。\n\n* 反转卖出价和反转买入价  \n  根据公式推导，发现这两个价格和前一日最高最低价没有确定的大小关系。\n* 观察卖出价和观察买入价。  \n  用观察卖出价 - 前一交易日最高价发现，(H+P-L)-H = P - L >0,说明观察卖出价>前一交易日最高价；同理可证，观察买入价<前一交易日最低价。\n* 突破买入价和突破卖出价  \n  突破买入价>观察卖出价>前一交易日最高价，可以说明突破买入价>>前一交易日最高价。做差后可以发现，突破买入价 - 前一交易日最高价 = 2[(C-L)+(H-L)]/3。\n\n用K线形态表示：\n\n前一交易日K线越长，下影线越长，突破买入价越高。  \n前一交易日K线越长，上影线越长，突破卖入价越高。  \n这样一来就可以解释R Breaker背后的逻辑了。\n\n当今日的价格突破前一交易日的最高点，形态上来看会是上涨趋势，具备一定的开多仓条件，但还不够。若前一交易日的下影线越长，说明多空方博弈激烈，多方力量强大。因此可以设置更高的突破买入价，一旦突破说明多方力量稳稳地占据了上风，那么就有理由相信未来会继续上涨。同理可解释突破卖出价背后的逻辑。\n\n持有多仓时，若标的价格持续走高，则在当天收盘之前平仓获利离场。若价格不升反降，跌破观察卖出价时，此时价格仍处于前一交易日最高价之上，继续观望。若继续下跌，直到跌破反转卖出价时，平仓止损。\n\n持有空仓时，若标的价格持续走低，则在当天收盘之前平仓获利离场。若价格不降反升，升至观察买入价时，此时价格仍处于前一交易日最低价之下，继续观望。若继续上涨，直到升至反转买入价时，平仓止损。\n\n## 2、策略逻辑\n\n第一步：根据收盘价、最高价和最低价数据计算六个价位。  \n第二步：如果是空仓条件下，如果价格超过突破买入价，则开多仓；如果价格跌破突破卖出价，则开空仓。  \n第三步：在持仓条件下:\n\n **持多单时，当最高价超过观察卖出价，盘中价格进一步跌破反转卖出价，反手做多；  \n持空单时，当最低价低于观察买入价，盘中价格进一步超过反转买入价，反手做空。**  \n第四步：接近收盘时，全部平仓。\n\n回测标的：SHFE.rb2010  \n回测期：2019-10-1 15:00:00 到 2020-04-16 15:00:00  \n回测初始资金：100万  \n**注意：若修改回测期，需要修改对应的回测标的。**\n\n## 3、策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_004",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. from gm.api import *\n\n\n6. \"\"\"\n7. 上轨=昨日最高点；\n8. 下轨=昨日最低点；\n9. 止损=今日开盘价;\n10. 如果没有持仓，且现价大于了昨天最高价做多，小于昨天最低价做空。\n11. 如果有多头持仓，当价格跌破了开盘价止损。\n12. 如果有空头持仓，当价格上涨超过开盘价止损。\n13. 选取 进行了回测。\n14. 注意：\n15. 1：为回测方便，本策略使用了on_bar的一分钟来计算，实盘中可能需要使用on_tick。\n16. 2：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交。\n17. \"\"\"\n\n\n20. def init(context):\n21. # 设置标的\n22. context.symbol = 'SHFE.rb2010'\n23. # 订阅一分钟线\n24. subscribe(symbols = context.symbol,frequency = '60s',count = 1)\n25. # 记录开仓次数，保证一天只开仓一次\n26. context.count = 0\n27. # 记录当前时间\n28. time = context.now.strftime('%H:%M:%S')\n\n30. # 如果当前时间点是交易时间段，则直接执行algo获取历史数据，以防直接进入on_bar()导致context.history_data未定义\n31. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\n32. algo(context)\n\n34. # 如果是非交易时间段，等到上午9点或晚上21点再执行algo()\n35. schedule(schedule_func = algo, date_rule = '1d', time_rule = '09:00:00')\n36. schedule(schedule_func = algo, date_rule = '1d', time_rule = '21:00:00')\n\n\n39. def algo(context):\n40. # 获取历史的n条信息\n41. context.history_data = history_n(symbol=context.symbol, frequency = '1d', end_time = context.now,\n42. fields='symbol,open,high,low',count=2, df=True)\n\n\n45. def on_bar(context,bars):\n46. # 取出订阅的一分钟bar\n47. bar = bars[0]\n48. # 提取数据\n49. data = context.history_data\n50. # 现有持仓情况\n51. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n52. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\n\n54. # 如果是回测模式\n55. if context.mode == 2:\n56. # 开盘价直接在data最后一个数据里取到,前一交易日的最高和最低价为history_data里面的倒数第二条中取到\n57. open = data.loc[1, 'open']\n58. high = data.loc[0, 'high']\n59. low = data.loc[0, 'low']\n\n61. # 如果是实时模式\n62. else:\n63. # 开盘价通过current取到\n64. open = current(context.symbol)[0]['open']\n65. # 实时模式不会返回当天的数据，所以history_data里面的最后一条数据是前一交易日的数据\n66. high = data.loc[-1, 'high']\n67. low = data.loc[-1, 'low']\n\n\n70. # 交易逻辑部分\n71. if position_long:  # 多头持仓小于开盘价止损。\n72. if bar.close < open:\n73. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n74. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n75. print('以市价单平多仓')\n76. elif position_short: # 空头持仓大于开盘价止损。\n77. if bar.close > open:\n78. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n79. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n80. print('以市价单平空仓')\n\n82. else:  # 没有持仓。\n83. if bar.close > high and not context.count:  # 当前的最新价大于了前一天的最高价\n84. # 开多\n85. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\n86. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n87. print('以市价单开多仓')\n88. context.count = 1\n89. elif bar.close < low and not context.count:  # 当前最新价小于了前一天的最低价\n90. # 开空\n91. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\n92. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n93. print('以市价单开空仓')\n94. context.count = 1\n\n96. # 每天收盘前一分钟平仓\n97. if context.now.hour == 14 and context.now.minute == 59:\n98. order_close_all()\n99. print('全部平仓')\n100. context.count = 0\n\n\n103. if __name__ == '__main__':\n104. '''\n105. strategy_id策略ID,由系统生成\n106. filename文件名,请与本文件名保持一致\n107. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n108. token绑定计算机的ID,可在系统设置-密钥管理中生成\n109. backtest_start_time回测开始时间\n110. backtest_end_time回测结束时间\n111. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n112. backtest_initial_cash回测初始资金\n113. backtest_commission_ratio回测佣金比例\n114. backtest_slippage_ratio回测滑点比例\n115. '''\n116. run(strategy_id='strategy_id',\n117. filename='main.py',\n118. mode=MODE_BACKTEST,\n119. token='token_id',\n120. backtest_start_time='2020-01-01 15:00:00',\n121. backtest_end_time='2020-09-01 16:00:00',\n122. backtest_adjust=ADJUST_PREV,\n123. backtest_initial_cash=100000,\n124. backtest_commission_ratio=0.0001,\n125. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 菲阿里四价(期货)\n\n分享\n\n阅读 61350\n 更新 2022-05-09 16:56:48\n\n* [菲阿里四价](#bd04006eb998c5e4)\n  + [1. 原理](#4d68e06c45acd2a2)\n  + [2. 策略逻辑](#fdd18c620885abac)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\n\n# 菲阿里四价\n\n## 1. 原理\n\n菲阿里四价同R Breaker一样，也是一种日内策略交易，适合短线投资者。\n\n菲阿里四价指的是：昨日高点、昨日低点、昨天收盘、今天开盘四个价格。\n\n菲阿里四价上下轨的计算非常简单。昨日高点为上轨，昨日低点为下轨。当价格突破上轨时，买入开仓；当价格突破下轨时，卖出开仓。\n\n## 2. 策略逻辑\n\n第一步：获取昨日最高价、最低价、收盘价、开盘价四个数据。  \n第二步：计算上轨和下轨。当价格上穿上轨时，买入开仓；当价格下穿下轨时，卖出开仓。  \n第三步：当日平仓。\n\n回测标的：SHFE.rb2010  \n回测期：2020-02-07 至 2020-04-15  \n回测初始资金：200万  \n**注意：若修改回测期，需要修改对应的回测标的。**\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_005",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from gm.api import *\n4. from datetime import timedelta\n\n\n7. \"\"\"\n8. 小市值策略\n9. 本策略每个月触发一次，计算当前沪深市场上市值最小的前30只股票，并且等权重方式进行买入。\n10. 对于不在前30的有持仓的股票直接平仓。\n11. 回测时间为：2005-01-01 08:00:00 到 2020-10-01 16:00:00\n12. \"\"\"\n\n\n15. def init(context):\n16. # 每月第一个交易日的09:40 定时执行algo任务（仿真和实盘时不支持该频率）\n17. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\n18. # 使用多少的资金来进行开仓。\n19. context.ratio = 0.8\n20. # 定义股票池数量\n21. context.num = 30\n22. # 通过get_instruments获取所有的上市股票代码\n23. context.all_stock = get_instruments(exchanges='SHSE, SZSE', sec_types=[1], skip_suspended=False,\n24. skip_st=False, fields='symbol, listed_date, delisted_date',\n25. df=True)\n\n\n28. def algo(context):\n29. # 获取筛选时间：date1表示当前日期之前的100天，date2表示当前时间\n30. date1 = (context.now - timedelta(days=100)).strftime(\"%Y-%m-%d %H:%M:%S\")\n31. date2 = context.now.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n33. # 上市不足100日的新股和退市股和B股\n34. code = context.all_stock[(context.all_stock['listed_date'] < date1) & (context.all_stock['delisted_date'] > date2) &\n35. (context.all_stock['symbol'].str[5] != '9') & (context.all_stock['symbol'].str[5] != '2')]\n36. # 剔除停牌和st股\n37. df_code = get_history_instruments(symbols=code['symbol'].to_list(), start_date=date2, end_date=date2, df=True)\n38. df_code = df_code[(df_code['is_suspended'] == 0) & (df_code['sec_level'] == 1)]\n\n40. # 获取所有股票市值\n41. fundamental = get_fundamentals_n('trading_derivative_indicator', df_code['symbol'].to_list(),\n42. context.now, fields='TOTMKTCAP', order_by='TOTMKTCAP', count=1, df=True)\n\n44. # 对市值进行排序（升序），并且获取前30个。 最后将这个series 转化成为一个list即为标的池\n45. trade_symbols = fundamental.reset_index(\n46. drop=True).loc[:context.num - 1, 'symbol'].to_list()\n47. print('本次股票池有股票数目: ', len(trade_symbols))\n\n49. # 计算每个个股应该在持仓中的权重\n50. percent = 1.0 / len(trade_symbols) * context.ratio\n\n52. # 获取当前所有仓位\n53. positions = context.account().positions()\n\n55. # 平不在标的池的仓位\n56. for position in positions:\n57. symbol = position['symbol']\n58. if symbol not in trade_symbols:\n59. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n60. position_side=PositionSide_Long)\n61. print('市价单平不在标的池的', symbol)\n\n63. # 将标中已有持仓的和还没有持仓的都调整到计算出来的比例。\n64. for symbol in trade_symbols:\n65. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\n66. position_side=PositionSide_Long)\n67. print(symbol, '以市价单调整至权重', percent)\n\n\n70. if __name__ == '__main__':\n71. '''\n72. strategy_id策略ID,由系统生成\n73. filename文件名,请与本文件名保持一致\n74. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n75. token绑定计算机的ID,可在系统设置-密钥管理中生成\n76. backtest_start_time回测开始时间\n77. backtest_end_time回测结束时间\n78. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n79. backtest_initial_cash回测初始资金\n80. backtest_commission_ratio回测佣金比例\n81. backtest_slippage_ratio回测滑点比例\n82. '''\n83. run(strategy_id='13a64e72-e900-11eb-b05f-309c2322ba62',\n84. filename='main.py',\n85. mode=MODE_BACKTEST,\n86. token='2b62e7651c9897d0cdd4a6cd818a7ba8488af710',\n87. backtest_start_time='2005-01-01 08:00:00',\n88. backtest_end_time='2020-10-01 16:00:00',\n89. backtest_adjust=ADJUST_PREV,\n90. backtest_initial_cash=1000000,\n91. backtest_commission_ratio=0.0001,\n92. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 小市值(股票)\n\n分享\n\n阅读 63504\n 更新 2022-05-09 16:56:48\n\n* [小市值策略（股票）](#8a41beb7b7d129a3)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [1.1 因子投资](#2bb5d63b71d8bf05)\n    - [1.2 规模因子](#b6a57aa95deebd34)\n  + [2. 策略逻辑](#fdd18c620885abac)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果和稳健性分析](#e8b0a560bf110088)\n\n# 小市值策略（股票）\n\n（以下部分内容参考《因子投资：方法与实践》一书）\n\n## 1. 原理\n\n### 1.1 因子投资\n\n提到量化策略，总是绕不开因子投资。自CAPM模型提出以来，因子投资不断发展壮大，成为市场广泛关注的领域。市面上的策略很大一部分都是基于各种各样的因子创造的，因子在股票和债券市场上的应用也取得了不小的成就。\n\n**到底什么是因子投资?**\n\n20世纪60年代，资本资产定价模型（Capital Asset Pricing Model）提出，揭示了资产的预期收益率（预期超额收益率）与风险之间的关系，第一次给出了资本资产定价的直观表达式。\n\n![](/uploads/202010/attach_16421d0004a68320.png)  \n其中Rm表示市场预期收益率，β表示市场的风险暴露。\n\n该公式指出资产的预期超额收益率由资产对市场风险的暴露大小决定，也就是说，资产的超额预期收益率可以完全由**市场因子**解释。\n\n随着市场异象不断出现，人们发现资产的收益率并非只由市场因子决定，还受到其他因子的影响。1976年，Ross提出了无套利定价理论，构建了多因子定价模型，表达式为：  \n![](/uploads/202010/attach_16421d095591da46.png)  \n其中λ是因子预期收益率，β是对应的因子暴露，α表示误差项。\n\n该公式指出资产的预期收益率是由**一系列因子**及其因子暴露加上误差项决定的。而因子投资的目的就是寻找到能够解释资产收益率的因子。\n\n**既然资产预期收益率是由众多因子决定的，什么是因子？怎么寻找因子？**\n\n根据《因子投资方法与实践》一书中的定义，“一个因子描述了众多资产共同暴露的某种系统性风险，该风险是资产收益率背后的驱动力，因子收益率正式这种系统性风险的风险溢价或风险补偿，它是这些资产的共性收益。”翻译过来就是，想要作为因子，必须能够解释多个资产的收益情况，并且能够带来正收益。\n\n再来看式2，可以发现，资产预期收益率是由两部分组成的，除了λ以外，还有一个α项，称之为误差项，表示资产预期收益率中λ无法解释的部分。α的出现可能有以下两个原因，一种是因为模型设定错误，右侧遗漏了重要的因子；一种是由于选用样本数据可能存在一定偏差，导致在该样本数据下出现了α项。\n\n为了确定α的出现是哪种原因，需要利用统计检验进行判断。\n\n**如果α显著为零，说明α的出现只是偶然，并不能说明定价模型存在错误；  \n如果α显著为零，说明α的出现只是偶然，并不能说明定价模型存在错误；**\n\n如果α显著不为零，说明资产预期收益里尚存在定价模型未能完全解释的部分。这种情况，就成为**异象**。  \n因此，因子大体上可分为两种，一种是**定价因子**，也就是λ部分；一种是**异象因子**，也就是α部分。\n\n### 1.2 规模因子\n\n1981年Banz基于纽交所长达40年的数据发现，小市值股票月均收益率比其他股票高0.4%。其背后的原因可能是投资者普遍不愿意持有小公司股票，使得这些小公司价格普遍偏低，甚至低于成本价，因此会有较高的预期收益率。由此产生了小市值策略，即投资于市值较小的股票。市值因子也被纳入进大名鼎鼎的Fama三因子模型和五因子模型之中。\n\nA股市场上规模因子是否有效？研究发现，2016年以前，A股市场上规模因子的显著性甚至超过了欧美等发达国家市场。但到了2017-2018年期间，大市值股票的表现明显优于小市值股票，使得规模因子在A股市场上的有效性存疑。\n\n## 2. 策略逻辑\n\n第一步：确定调仓频率，以每月第一天调仓为例  \n第二步：确定股票池股票数量，这里假设有30支  \n第三步：调仓日当天获取前一个月的历史数据，并按照市值由小到大排序  \n第四步：买入前30支股票\n\n回测期：2005-01-01 到 2020-10-01  \n股票池：所有A股股票  \n回测初始资金：100万\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_006",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import\n3. from gm.api import *\n\n\n6. \"\"\"\n7. 本策略采用布林线进行均值回归交易。当价格触及布林线上轨的时候进行卖出，当触及下轨的时候，进行买入。\n8. 使用600004在 2009-09-17 13:00:00 到 2020-03-21 15:00:00 进行了回测。\n9. 注意：\n10. 1：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交。\n11. \"\"\"\n\n13. # 策略中必须有init方法\n14. def init(context):\n15. # 设置布林线的三个参数\n16. context.maPeriod = 26  # 计算BOLL布林线中轨的参数\n17. context.stdPeriod = 26  # 计算BOLL 标准差的参数\n18. context.stdRange = 1  # 计算BOLL 上下轨和中轨距离的参数\n\n20. # 设置要进行回测的合约\n21. context.symbol = 'SHSE.600004'  # 订阅&交易标的, 此处订阅的是600004\n22. context.period = max(context.maPeriod, context.stdPeriod, context.stdRange) + 1  # 订阅数据滑窗长度\n\n24. # 订阅行情\n25. subscribe(symbols= context.symbol, frequency='1d', count=context.period)\n\n\n28. def on_bar(context, bars):\n29. # 获取数据滑窗，只要在init里面有订阅，在这里就可以取的到，返回值是pandas.DataFrame\n30. data = context.data(symbol=context.symbol, frequency='1d', count=context.period, fields='close')\n\n32. # 计算boll的上下界\n33. bollUpper = data['close'].rolling(context.maPeriod).mean() \\\n34. + context.stdRange * data['close'].rolling(context.stdPeriod).std()\n35. bollBottom = data['close'].rolling(context.maPeriod).mean() \\\n36. - context.stdRange * data['close'].rolling(context.stdPeriod).std()\n37. # 获取现有持仓\n38. pos = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n\n40. # 交易逻辑与下单\n41. # 当有持仓，且股价穿过BOLL上界的时候卖出股票。\n42. if data.close.values[-1] > bollUpper.values[-1] and data.close.values[-2] < bollUpper.values[-2]:\n43. if pos:  # 有持仓就市价卖出股票。\n44. order_volume(symbol=context.symbol, volume=100, side=OrderSide_Sell,\n45. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n46. print('以市价单卖出一手')\n\n48. # 当没有持仓，且股价穿过BOLL下界的时候买出股票。\n49. elif data.close.values[-1] < bollBottom.values[-1] and data.close.values[-2] > bollBottom.values[-2]:\n50. if not pos:  # 没有持仓就买入一百股。\n51. order_volume(symbol=context.symbol, volume=100, side=OrderSide_Buy,\n52. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n53. print('以市价单买入一手')\n\n\n56. if __name__ == '__main__':\n57. '''\n58. strategy_id策略ID,由系统生成\n59. filename文件名,请与本文件名保持一致\n60. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n61. token绑定计算机的ID,可在系统设置-密钥管理中生成\n62. backtest_start_time回测开始时间\n63. backtest_end_time回测结束时间\n64. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n65. backtest_initial_cash回测初始资金\n66. backtest_commission_ratio回测佣金比例\n67. backtest_slippage_ratio回测滑点比例\n68. '''\n69. run(strategy_id='strategy_id',\n70. filename='main.py',\n71. mode=MODE_BACKTEST,\n72. token='token_id',\n73. backtest_start_time='2009-09-17 13:00:00',\n74. backtest_end_time='2020-03-21 15:00:00',\n75. backtest_adjust=ADJUST_PREV,\n76. backtest_initial_cash=1000,\n77. backtest_commission_ratio=0.0001,\n78. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 布林线均值回归(股票)\n\n分享\n\n阅读 69471\n 更新 2022-05-09 16:56:48\n\n* [布林线均值回归策略](#b1b49dfea4506938)\n  + [1. 原理](#4d68e06c45acd2a2)\n  + [2. 策略思路](#cf0127fe1bcb3311)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\n\n# 布林线均值回归策略\n\n## 1. 原理\n\n提起布林线均值回归策略，就不得不提布林带这个概念。布林带是利用统计学中的均值和标准差联合计算得出的，分为均线，上轨线和下轨线。布林线均值回归策略认为，标的价格在上轨线和下轨线围成的范围内浮动，即使短期内突破上下轨，但长期内仍然会回归到布林带之中。因此，一旦突破上下轨，即形成买卖信号。\n\n当股价向上突破上界时，为卖出信号，当股价向下突破下界时，为买入信号。\n\nBOLL线的计算公式：\n\n中轨线 = N日移动平均线  \n上轨线 = 中轨线 + k  *标准差  \n下轨线 = 中轨线 - k*  标准差\n\n## 2. 策略思路\n\n第一步：根据数据计算BOLL线的上下界  \n第二步：获得持仓信号  \n第三步：回测分析\n\n回测标的：SHSE.600004  \n回测期：2009-09-17 13:00:00 到 2020-03-21 15:00:00  \n回测初始资金：1000元\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_007",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from gm.api import *\n\n\n6. '''\n7. 本策略每隔1个月定时触发计算SHSE.000300成份股的过去一天EV/EBITDA值并选取30只EV/EBITDA值最小且大于零的股票\n8. 对不在股票池的股票平仓并等权配置股票池的标的\n9. 并用相应的CFFEX.IF对应的真实合约等额对冲\n10. 回测数据为:SHSE.000300和他们的成份股和CFFEX.IF对应的真实合约\n11. 回测时间为:2017-07-01 08:00:00到2017-10-01 16:00:00\n12. 注意：本策略仅供参考，实际使用中要考虑到期货和股票处于两个不同的账户，需要人为的保证两个账户的资金相同。\n13. '''\n\n\n16. def init(context):\n17. # 每月第一个交易日09:40:00的定时执行algo任务（仿真和实盘时不支持该频率）\n18. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\n19. # 设置开仓在股票和期货的资金百分比(期货在后面自动进行杠杆相关的调整)\n20. context.percentage_stock = 0.4\n21. context.percentage_futures = 0.4\n\n\n24. def algo(context):\n25. # 获取当前时刻\n26. now = context.now\n\n28. # 获取上一个交易日\n29. last_day = get_previous_trading_date(exchange='SHSE', date=now)\n\n31. # 获取沪深300成份股的股票代码\n32. stock300 = get_history_constituents(index='SHSE.000300', start_date=last_day,\n33. end_date=last_day)[0]['constituents'].keys()\n\n35. # 获取上一个工作日的CFFEX.IF对应的合约\n36. index_futures = get_continuous_contracts(csymbol='CFFEX.IF', start_date=last_day, end_date=last_day)[-1]['symbol']\n\n38. # 获取当天有交易的股票\n39. not_suspended_info = get_history_instruments(symbols=stock300, start_date=now, end_date=now)\n40. not_suspended_symbols = [item['symbol'] for item in not_suspended_info if not item['is_suspended']]\n\n42. # 获取成份股EV/EBITDA大于0并为最小的30个\n43. fin = get_fundamentals(table='trading_derivative_indicator', symbols=not_suspended_symbols,\n44. start_date=now, end_date=now, fields='EVEBITDA',\n45. filter='EVEBITDA>0', order_by='EVEBITDA', limit=30, df=True)\n46. fin.index = fin.symbol\n\n48. # 获取当前仓位\n49. positions = context.account().positions()\n\n51. # 平不在标的池或不为当前股指期货主力合约对应真实合约的标的\n52. for position in positions:\n53. symbol = position['symbol']\n54. sec_type = get_instrumentinfos(symbols=symbol)[0]['sec_type']\n\n56. # 若类型为期货且不在标的池则平仓\n57. if sec_type == SEC_TYPE_FUTURE and symbol != index_futures:\n58. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n59. position_side=PositionSide_Short)\n60. print('市价单平不在标的池的', symbol)\n61. elif symbol not in fin.index:\n62. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n63. position_side=PositionSide_Long)\n64. print('市价单平不在标的池的', symbol)\n\n66. # 获取股票的权重\n67. percent = context.percentage_stock / len(fin.index)\n\n69. # 买在标的池中的股票\n70. for symbol in fin.index:\n71. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\n72. position_side=PositionSide_Long)\n73. print(symbol, '以市价单调多仓到仓位', percent)\n\n75. # 获取股指期货的保证金比率\n76. ratio = get_history_instruments(symbols=index_futures, start_date=last_day, end_date=last_day)[0]['margin_ratio']\n\n78. # 更新股指期货的权重\n79. percent = context.percentage_futures * ratio\n\n81. # 买入股指期货对冲\n82. # 注意：股指期货的percent参数是按照期货的保证金来算比例，不是按照合约价值， 比如说0.1就是用0.1的仓位的资金全部买入期货。\n83. order_target_percent(symbol=index_futures, percent=percent, order_type=OrderType_Market,\n84. position_side=PositionSide_Short)\n85. print(index_futures, '以市价单调空仓到仓位', percent)\n\n\n88. if __name__ == '__main__':\n89. '''\n90. strategy_id策略ID,由系统生成\n91. filename文件名,请与本文件名保持一致\n92. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n93. token绑定计算机的ID,可在系统设置-密钥管理中生成\n94. backtest_start_time回测开始时间\n95. backtest_end_time回测结束时间\n96. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n97. backtest_initial_cash回测初始资金\n98. backtest_commission_ratio回测佣金比例\n99. backtest_slippage_ratio回测滑点比例\n100. '''\n101. run(strategy_id='strategy_id',\n102. filename='main.py',\n103. mode=MODE_BACKTEST,\n104. token='token_id',\n105. backtest_start_time='2017-07-01 08:00:00',\n106. backtest_end_time='2017-10-01 16:00:00',\n107. backtest_adjust=ADJUST_PREV,\n108. backtest_initial_cash=10000000,\n109. backtest_commission_ratio=0.0001,\n110. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# alpha对冲(股票+期货)\n\n分享\n\n阅读 143126\n 更新 2022-05-09 16:56:48\n\n* [Alpha对冲策略](#d4f501d529728393)\n  + [1. 策略原理](#c4a1bed1475f07da)\n    - [何为alpha？](#f27fbfaa13560440)\n    - [什么是alpha对冲策略？](#04a1252f01719cb4)\n    - [怎么对冲？](#cec42677286aab15)\n    - [策略收益情况](#28b65952cc2121da)\n    - [策略要点](#32fbd110ec5d9a83)\n  + [2. 策略实现](#90594d462f3ea350)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\n\n# Alpha对冲策略\n\n## 1. 策略原理\n\n### 何为alpha？\n\n提到Alpha策略，首先要理解什么是CAPM模型。\n\nCAPM模型于1964年被Willian Sharpe等人提出。Sharpe等人认为，假设市场是均衡的，资产的预期超额收益率就由市场收益超额收益和风险暴露决定的。如下式所示。  \n![](/uploads/202010/attach_1642f606dd5564c6.png)  \n其中rm为市场组合，rf为无风险收益率。\n\n根据CAPM模型可知，投资组合的预期收益由两部分组成，一部分为无风险收益率rf，另一部分为风险收益率。\n\nCAPM模型一经推出就受到了市场的追捧。但在应用过程中发现，CAPM模型表示的是在均衡状态下市场的情况，但市场并不总是处于均衡状态，个股总会获得超出市场基准水平的收益，即在CAPM模型的右端总是存在一个alpha项。\n\n为了解决这个问题，1968年，美国经济学家迈克·詹森（Michael Jensen）提出了詹森指数来描述这个alpha，因此又称alpha指数。计算方式如式2所示。  \n![](/uploads/202010/attach_1642f609cc4ce9bf.png)  \n因此，投资组合的收益可以改写成  \n![](/uploads/202010/attach_1642f60c9ff81fb5.png)  \n可将投资组合的收益拆分为alpha收益和beta收益。其中beta的计算公式为  \n![](/uploads/202010/attach_1642f610efd39a5a.png)  \nβ是由市场决定的，属于系统性风险，与投资者管理能力无关，只与投资组合与市场的关系有关。当市场整体下跌时，β对应的收益也会随着下跌（假设beta为正）。alpha收益与市场无关，是投资者自身能力的体现。投资者通过自身的经验进行选股择时，得到超过市场的收益。\n\n### 什么是alpha对冲策略？\n\n所谓的alpha对冲不是将alpha收益对冲掉，恰恰相反，alpha对冲策略是将β收益对冲掉，只获取alpha收益，如下图所示。\n\n![](/uploads/202010/attach_1642f61acc4df4ad.png)\n\nalpha对冲策略将市场性风险对冲掉，只剩下alpha收益，整体收益完全取决于投资者自身的能力水平，与市场无关。目前，有许多私募基金采用alpha对冲策略。\n\n### 怎么对冲？\n\nalpha对冲策略常采用股指期货做对冲。在股票市场上做多头，在期货市场上做股指期货空头。当股票现货市场亏损时，可以通过期货市场弥补亏损；当期货市场亏损时，可以通过股票现货市场弥补亏损。\n\n### 策略收益情况\n\n目前alpha对冲策略主要用于各类基金中。国际上比较知名的桥水基金、AQR基金等都采用过这种策略。国内也有许多利用alpha对冲策略的基金，比如海富通阿尔法对冲混合、华宝量化对冲混合等，近一年平均收益率约为36.70%。\n\n### 策略要点\n\nalpha策略能否成功，主要包括以下几个要点\n\n* 获取到的alpha收益是否足够高，能否超过无风险利率以及指数.\n* 期货和现货之间的基差变化.\n* 期货合约的选择.\n\nalpha对冲只是一种对冲市场风险的方法，在创建策略时需要结合其他理论一起使用，怎样获取到较高的alpha收益才是决定策略整体收益的关键。\n\n## 2. 策略实现\n\n第一步：制定一个选股策略，构建投资组合，使其同时拥有alpha和beta收益。  \n（本策略选取过去一天EV/EBITDA值并选取30只EV/EBITDA值最小且大于零的股票）  \n第二步：做空股指期货，将投资组合的beta抵消，只剩alpha部分。  \n第三步：进行回测。\n\n股票池：沪深300指数  \n期货标的：CFFEX.IF对应的真实合约  \n回测时间：2017-07-01 08:00:00 至 2017-10-01 16:00:00  \n回测初始资金：1000万\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_008",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. from gm.api import *\n5. from pandas import DataFrame\n6. '''\n7. 本策略每隔1个月定时触发,根据Fama-French三因子模型对每只股票进行回归，得到其alpha值。\n8. 假设Fama-French三因子模型可以完全解释市场，则alpha为负表明市场低估该股，因此应该买入。\n9. 策略思路：\n10. 计算市场收益率、个股的账面市值比和市值,并对后两个进行了分类,\n11. 根据分类得到的组合分别计算其市值加权收益率、SMB和HML.\n12. 对各个股票进行回归(假设无风险收益率等于0)得到alpha值.\n13. 选取alpha值小于0并为最小的10只股票进入标的池\n14. 平掉不在标的池的股票并等权买入在标的池的股票\n15. 回测数据:SHSE.000300的成份股\n16. 回测时间:2017-07-01 08:00:00到2017-10-01 16:00:00\n17. '''\n18. def init(context):\n19. # 每月第一个交易日的09:40 定时执行algo任务（仿真和实盘时不支持该频率）\n20. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\n21. # 数据滑窗\n22. context.date = 20\n23. # 设置开仓的最大资金量\n24. context.ratio = 0.8\n25. # 账面市值比的大/中/小分类\n26. context.BM_BIG = 3.0\n27. context.BM_MID = 2.0\n28. context.BM_SMA = 1.0\n29. # 市值大/小分类\n30. context.MV_BIG = 2.0\n31. context.MV_SMA = 1.0\n\n33. # 计算市值加权的收益率的函数,MV为市值的分类对应的组别,BM为账目市值比的分类对应的组别\n34. def market_value_weighted(stocks, MV, BM):\n35. select = stocks[(stocks['NEGOTIABLEMV'] == MV) & (stocks.['BM'] == BM)] # 选出市值为MV，账目市值比为BM的所有股票数据\n36. market_value = select['mv'].values     # 对应组的全部市值数据\n37. mv_total = np.sum(market_value)        # 市值求和\n38. mv_weighted = [mv / mv_total for mv in market_value]   # 市值加权的权重\n39. stock_return = select['return'].values\n\n41. # 返回市值加权的收益率的和\n42. return_total = []\n43. for i in range(len(mv_weighted)):\n44. return_total.append(mv_weighted[i] * stock_return[i])\n45. return_total = np.sum(return_total)\n46. return return_total\n\n48. def algo(context):\n49. # 获取上一个交易日的日期\n50. last_day = get_previous_trading_date(exchange='SHSE', date=context.now)\n51. # 获取沪深300成份股\n52. context.stock300 = get_history_constituents(index='SHSE.000300', start_date=last_day,\n53. end_date=last_day)[0]['constituents'].keys()\n54. # 获取当天有交易的股票\n55. not_suspended = get_history_instruments(symbols=context.stock300, start_date=last_day, end_date=last_day)\n56. not_suspended = [item['symbol'] for item in not_suspended if not item['is_suspended']]\n57. fin = get_fundamentals(table='trading_derivative_indicator', symbols=not_suspended,\n58. start_date=last_day, end_date=last_day,fields='PB,NEGOTIABLEMV', df=True)  # 获取P/B和市值数据\n\n60. # 计算账面市值比,为P/B的倒数\n61. fin['PB'] = (fin['PB'] ** -1)\n62. # 计算市值的50%的分位点,用于后面的分类\n63. size_gate = fin['NEGOTIABLEMV'].quantile(0.50)\n64. # 计算账面市值比的30%和70%分位点,用于后面的分类\n65. bm_gate = [fin['PB'].quantile(0.30), fin['PB'].quantile(0.70)]\n66. fin.index = fin.symbol\n67. # 设置存放股票收益率的list\n68. x_return = []\n\n70. # 对未停牌的股票进行处理\n71. for symbol in not_suspended:\n72. # 计算收益率，存放到x_return里面\n73. close = history_n(symbol=symbol, frequency='1d', count=context.date + 1, end_time=last_day, fields='close',\n74. skip_suspended=True, fill_missing='Last', adjust=ADJUST_PREV, df=True)['close'].values\n75. stock_return = close[-1] / close[0] - 1\n76. pb = fin['PB'][symbol]\n77. market_value = fin['NEGOTIABLEMV'][symbol]\n78. # 获取[股票代码， 股票收益率, 账面市值比的分类, 市值的分类, 流通市值]\n79. # 其中账面市值比的分类为：大（3）、中（2）、小（1）\n80. # 流通市值的分类：大（2）、小（1）\n81. if pb < bm_gate[0]:\n82. if market_value < size_gate:\n83. label = [symbol, stock_return, context.BM_SMA, context.MV_SMA, market_value]\n84. else:\n85. label = [symbol, stock_return, context.BM_SMA, context.MV_BIG, market_value]\n86. elif pb < bm_gate[1]:\n87. if market_value < size_gate:\n88. label = [symbol, stock_return, context.BM_MID, context.MV_SMA, market_value]\n89. else:\n90. label = [symbol, stock_return, context.BM_MID, context.MV_BIG, market_value]\n91. elif market_value < size_gate:\n92. label = [symbol, stock_return, context.BM_BIG, context.MV_SMA, market_value]\n93. else:\n94. label = [symbol, stock_return, context.BM_BIG, context.MV_BIG, market_value]\n95. if len(x_return) == 0:\n96. x_return = label\n97. else:\n98. x_return = np.vstack([x_return, label])\n\n100. # 将股票代码、 股票收益率、 账面市值比的分类、 市值的分类、 流通市值存为数据表\n101. stocks = DataFrame(data=x_return, columns=['symbol', 'return', 'BM', 'NEGOTIABLEMV', 'mv'])\n102. stocks.index = stocks.symbol\n103. columns = ['return', 'BM', 'NEGOTIABLEMV', 'mv']\n104. for column in columns:\n105. stocks[column] = stocks[column].astype(np.float64)\n\n107. # 计算SMB.HML和市场收益率（市值加权法）\n108. smb_s = (market_value_weighted(stocks, context.MV_SMA, context.BM_SMA) +\n109. market_value_weighted(stocks, context.MV_SMA, context.BM_MID) +\n110. market_value_weighted(stocks, context.MV_SMA, context.BM_BIG)) / 3\n\n112. # 获取大市值组合的市值加权组合收益率\n113. smb_b = (market_value_weighted(stocks, context.MV_BIG, context.BM_SMA) +\n114. market_value_weighted(stocks, context.MV_BIG, context.BM_MID) +\n115. market_value_weighted(stocks, context.MV_BIG, context.BM_BIG)) / 3\n116. smb = smb_s - smb_b\n\n118. # 获取大账面市值比组合的市值加权组合收益率\n119. hml_b = (market_value_weighted(stocks, context.MV_SMA, 3) +\n120. market_value_weighted(stocks, context.MV_BIG, context.BM_BIG)) / 2\n\n122. # 获取小账面市值比组合的市值加权组合收益率\n123. hml_s = (market_value_weighted(stocks, context.MV_SMA, context.BM_SMA) +\n124. market_value_weighted(stocks, context.MV_BIG, context.BM_SMA)) / 2\n125. hml = hml_b - hml_s\n\n127. # 获取市场收益率\n128. close = history_n(symbol='SHSE.000300', frequency='1d', count=context.date + 1,\n129. end_time=last_day, fields='close', skip_suspended=True,\n130. fill_missing='Last', adjust=ADJUST_PREV, df=True)['close'].values\n131. market_return = close[-1] / close[0] - 1\n132. coff_pool = []\n\n134. # 对每只股票进行回归获取其alpha值\n135. for stock in stocks.index:\n136. x_value = np.array([[market_return], [smb], [hml], [1.0]])\n137. y_value = np.array([stocks['return'][stock]])\n138. # OLS估计系数\n139. coff = np.linalg.lstsq(x_value.T, y_value)[0][3]\n140. coff_pool.append(coff)\n\n142. # 获取alpha最小并且小于0的10只的股票进行操作(若少于10只则全部买入)\n143. stocks['alpha'] = coff_pool\n144. stocks = stocks[stocks.alpha < 0].sort_values(by='alpha').head(10)\n145. symbols_pool = stocks.index.tolist()\n146. positions = context.account().positions()\n\n148. # 平不在标的池的股票\n149. for position in positions:\n150. symbol = position['symbol']\n151. if symbol not in symbols_pool:\n152. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n153. position_side=PositionSide_Long)\n154. print('市价单平不在标的池的', symbol)\n\n156. # 获取股票的权重\n157. percent = context.ratio / len(symbols_pool)\n\n159. # 买在标的池中的股票\n160. for symbol in symbols_pool:\n161. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\n162. position_side=PositionSide_Long)\n163. print(symbol, '以市价单调多仓到仓位', percent)\n\n165. if __name__ == '__main__':\n166. '''\n167. strategy_id策略ID,由系统生成\n168. filename文件名,请与本文件名保持一致\n169. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n170. token绑定计算机的ID,可在系统设置-密钥管理中生成\n171. backtest_start_time回测开始时间\n172. backtest_end_time回测结束时间\n173. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n174. backtest_initial_cash回测初始资金\n175. backtest_commission_ratio回测佣金比例\n176. backtest_slippage_ratio回测滑点比例\n177. '''\n178. run(strategy_id='strategy_id',\n179. filename='main.py',\n180. mode=MODE_BACKTEST,\n181. token='token_id',\n182. backtest_start_time='2017-07-01 08:00:00',\n183. backtest_end_time='2017-10-01 16:00:00',\n184. backtest_adjust=ADJUST_PREV,\n185. backtest_initial_cash=10000000,\n186. backtest_commission_ratio=0.0001,\n187. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 多因子选股(股票)\n\n分享\n\n阅读 187817\n 更新 2022-05-09 16:56:48\n\n* [多因子策略](#9999705c4a097b93)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [Fama-French三因子模型](#f2fdebfcb64333d9)\n    - [策略设计思路（假设三因子模型是完全有效的）](#713a39754db63f0b)\n  + [2. 策略步骤](#c306d1ad1c8a5699)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性检验](#8fb635bf3a219945)\n\n# 多因子策略\n\n（注：以下部分内容引用自《因子投资：方法与实践》一书）\n\n## 1. 原理\n\n多因子策略是最广泛应用的策略之一。CAPM模型的提出为股票的收益提供了解释，但随着各种市场异象的出现，使得人们发现股票存在超额收益，这种收益不能为市场因子所解释，因此，出现了多因子模型。\n\n多因子模型最早是由Fama-French提出，包括三因子和五因子模型。Fama认为，股票的超额收益可以由市场因子、市值因子和账面价值比因子共同解释。随着市场的发展，出现许多三因子模型难以解释的现象。因此，Fama又提出了五因子模型，加入了盈利水平、投资水平因子。\n\n此后，陆续出现了六因子模型、八因子模型等，目前多少个因子是合适的尚无定论。\n\n市场上常用的多因子模型包括如下几个。\n\n| 模型 | 出处 | 所含因子 |\n| --- | --- | --- |\n| Fama-French三因子 | Fama and Farench(1993) | 市场、规模、价值 |\n| Carhart四因子 | Carhart（1997） | 市场、规模、价值、动量 |\n| Novy-Marx四因子 | Novy-Marx（2013） | 市场、规模、价值、盈利 |\n| Fama-French五因子 | Fama and Farench(2015) | 市场、规模、价值、盈利、投资 |\n| Hou-Xue-Zhang四因子 | Hou et al | 市场、规模、盈利、投资 |\n| Stambaugh-Yuan四因子 | Stambaugh and Yuan(2017) | 市场、规模、管理、表现 |\n| Daniel-Hirshleifer-Sun三因子 | Daniel et al（2020） | 市场、长周期行为、短周期行为 |\n\n本策略以Fama提出的三因子模型作为基础。\n\n### Fama-French三因子模型\n\n在多因子模型出现以前，CAPM模型被奉为典型，几乎所有定价均是按照CAPM模型计算的。后来学者们发现了各种异象，这些异象无法用CAPM模型解释。较为典型的有Basu发现的盈利市值比效应和Banz发现的小市值效应。遗憾的是，虽然单一异象被发现后都对CAPM提出了挑战，但并没有形成合力，直到Fama三因子模型出现。\n\nFama等人在CAPM的基础上，Fama加入了HML和SMB两个因子，提出了三因子模型，也是多因子模型的基础。\n\n![](/uploads/202011/attach_1646221cab7ec002.png)  \n其中E[R\\_i]代表股票i的预期收益率，R\\_f代表无风险收益率，E[R\\_m]为市场组合预期收益率，E[R\\_SMB]和E[R\\_HML]分别为规模因子收益率和价值因子预期收益率。  \n  \n为构建价值因子和规模因子，Fama选择BM和市值两个指标进行双重排序，将股票分为大市值组B和小市值组S；按照账面市值比将股票分为BM高于70%分位数的H组，BM低于30%分位数的L组，BM处于二者之间的记为M组。如表所示。  \n![](/uploads/202011/attach_1646223b74c77c26.png)  \n得到上述分组以后，就可以构建规模和价值两个因子。  \n![](/uploads/202011/attach_16462244e23ef82a.png)\n\n上述式子解释一下可以发现，规模因子是三个小市值组合的等权平均减去三个大市值组合的等权平均；价值因子是两个高BM组合的等权平均减去两个低BM组合的等权平均。\n\n### 策略设计思路（假设三因子模型是完全有效的）\n\n在用三因子模型估算股票预期收益率时，经常会发现并非每只股票都能严格吻合式1，大部分股票都会存在一个alpha截距项。当存在alpha截距项时，说明股票当前价格偏离均衡价格。基于此，可以设计套利策略。\n\nalpha < 0时，说明股票收益率低于均衡水平，股票价格被低估，应该买入。  \nalpha > 0时，说明股票收益率高于均衡水平，股票价格被高估，应该卖出。\n\n因此，可以获取alpha最小并且小于0的10只的股票买入开仓。\n\n## 2. 策略步骤\n\n第一步：获取股票市值以及账面市值比数据。  \n第二步：将股票按照各个因子进行排序分组，分组方法如上表所示。  \n第三步：依据式2式3，计算SMB、HML因子。  \n第四步：因子回归，计算alpha值。获取alpha最小并且小于0的10只的股票买入开仓。\n\n回测期：2017-07-01 8:00:00 至 2017-10-01 16:00:00  \n回测初始资金：1000万  \n回测标的：沪深300成分股\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_009",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. import pandas as pd\n5. from gm.api import *\n\n7. '''\n8. 本策略标的为：SHFE.rb1901\n9. 价格中枢设定为：前一交易日的收盘价\n10. 从阻力位到压力位分别为：1.03 * open、1.02 * open、1.01 * open、open、0.99 * open、0.98 * open、0.97 * open\n11. 每变动一个网格，交易量变化100个单位\n12. 回测数据为:SHFE.rb1901的1min数据\n13. 回测时间为:2017-07-01 08:00:00到2017-10-01 16:00:00\n14. '''\n\n\n17. def init(context):\n18. # 策略标的为SHFE.rb1901\n19. context.symbol = 'SHFE.rb1901'\n20. # 订阅SHFE.rb1901, bar频率为1min\n21. subscribe(symbols = context.symbol, frequency='60s')\n22. # 设置每变动一格，增减的数量\n23. context.volume = 1\n24. # 储存前一个网格所处区间，用来和最新网格所处区间作比较\n25. context.last_grid = 0\n26. # 以前一日的收盘价为中枢价格\n27. context.center = history_n(symbol= context.symbol,frequency='1d',end_time=context.now,count = 1,fields = 'close')[0]['close']\n28. # 记录上一次交易时网格范围的变化情况（例如从4区到5区，记为4,5）\n29. context.grid_change_last = [0,0]\n\n\n32. def on_bar(context, bars):\n33. bar = bars[0]\n34. # 获取多仓仓位\n35. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n36. # 获取空仓仓位\n37. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\n\n39. # 设置网格和当前价格所处的网格区域\n40. context.band = np.array([0.97, 0.98, 0.99, 1, 1.01, 1.02, 1.03]) * context.center\n41. grid = pd.cut([bar.close], context.band, labels=[1, 2, 3, 4, 5, 6])[0]\n\n43. # 如果价格超出网格设置范围，则提示调节网格宽度和数量\n44. if np.isnan(grid):\n45. print('价格波动超过网格范围，可适当调节网格宽度和数量')\n\n47. # 如果新的价格所处网格区间和前一个价格所处的网格区间不同，说明触碰到了网格线，需要进行交易\n48. # 如果新网格大于前一天的网格，做空或平多\n49. if context.last_grid < grid:\n50. # 记录新旧格子范围（按照大小排序）\n51. grid_change_new = [context.last_grid,grid]\n52. # 几种例外：\n53. # 当last_grid = 0 时是初始阶段，不构成信号\n54. # 如果此时grid = 3，说明当前价格仅在开盘价之下的3区域中，没有突破网格线\n55. # 如果此时grid = 4，说明当前价格仅在开盘价之上的4区域中，没有突破网格线\n56. if context.last_grid == 0:\n57. context.last_grid = grid\n58. return\n59. if context.last_grid != 0:\n60. # 如果前一次开仓是4-5，这一次是5-4，算是没有突破，不成交\n61. if grid_change_new != context.grid_change_last:\n62. # 更新前一次的数据\n63. context.last_grid = grid\n64. context.grid_change_last = grid_change_new\n65. # 如果有多仓，平多\n66. if position_long:\n67. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Sell, order_type=OrderType_Market,\n68. position_effect=PositionEffect_Close)\n69. print('以市价单平多仓{}手'.format(context.volume))\n70. # 否则，做空\n71. if not position_long:\n72. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Sell, order_type=OrderType_Market,\n73. position_effect=PositionEffect_Open)\n74. print('以市价单开空{}手'.format(context.volume))\n\n76. # 如果新网格小于前一天的网格，做多或平空\n77. if context.last_grid > grid:\n78. # 记录新旧格子范围（按照大小排序）\n79. grid_change_new = [grid,context.last_grid]\n80. # 几种例外：\n81. # 当last_grid = 0 时是初始阶段，不构成信号\n82. # 如果此时grid = 3，说明当前价格仅在开盘价之下的3区域中，没有突破网格线\n83. # 如果此时grid = 4，说明当前价格仅在开盘价之上的4区域中，没有突破网格线\n84. if context.last_grid == 0:\n85. context.last_grid = grid\n86. return\n87. if context.last_grid != 0:\n88. # 如果前一次开仓是4-5，这一次是5-4，算是没有突破，不成交\n89. if grid_change_new != context.grid_change_last:\n90. # 更新前一次的数据\n91. context.last_grid = grid\n92. context.grid_change_last = grid_change_new\n93. # 如果有空仓，平空\n94. if position_short:\n95. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Buy,\n96. order_type=OrderType_Market,\n97. position_effect=PositionEffect_Close)\n98. print('以市价单平空仓{}手'.format(context.volume))\n\n100. # 否则，做多\n101. if not position_short:\n102. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Buy,\n103. order_type=OrderType_Market,\n104. position_effect=PositionEffect_Open)\n105. print('以市价单开多{}手'.format(context.volume))\n\n107. # 设计一个止损条件：当持仓量达到10手，全部平仓\n108. if position_short == 10 or position_long == 10:\n109. order_close_all()\n110. print('触发止损，全部平仓')\n\n\n113. if __name__ == '__main__':\n114. '''\n115. strategy_id策略ID,由系统生成\n116. filename文件名,请与本文件名保持一致\n117. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n118. token绑定计算机的ID,可在系统设置-密钥管理中生成\n119. backtest_start_time回测开始时间\n120. backtest_end_time回测结束时间\n121. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n122. backtest_initial_cash回测初始资金\n123. backtest_commission_ratio回测佣金比例\n124. backtest_slippage_ratio回测滑点比例\n125. '''\n126. run(strategy_id='strategy_id',\n127. filename='main.py',\n128. mode=MODE_BACKTEST,\n129. token='token_id',\n130. backtest_start_time='2018-07-01 08:00:00',\n131. backtest_end_time='2018-10-01 16:00:00',\n132. backtest_adjust=ADJUST_PREV,\n133. backtest_initial_cash=100000,\n134. backtest_commission_ratio=0.0001,\n135. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 网格交易(期货)\n\n分享\n\n阅读 174440\n 更新 2022-05-09 16:56:48\n\n* [网格交易法（期货）](#a3a8216fc187c669)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [什么是网格交易法？](#0826fd0b2e938ab7)\n    - [怎样设计网格？](#148bf6919cad712c)\n    - [网格交易法的盈利情况](#e9beafd820a1ba4a)\n    - [核心](#67477ceb50f7c2e9)\n  + [2. 策略思路](#cf0127fe1bcb3311)\n    - [策略难点：](#4a606bba6ea7c206)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果和稳健性分析](#e8b0a560bf110088)\n\n# 网格交易法（期货）\n\n## 1. 原理\n\n### 什么是网格交易法？\n\n网格交易法是一种利用行情震荡进行获利的策略。在标的价格不断震荡的过程中，对标的价格绘制网格，在市场价格触碰到某个网格线时进行加减仓操作尽可能获利。\n\n网格交易法属于左侧交易的一种。与右侧交易不同，网格交易法并非跟随行情，追涨杀跌，而是逆势而为，在价格下跌时买入，价格上涨时卖出。\n\n### 怎样设计网格？\n\n投资者可以随意设置网格的宽度和数量。既可以设置为等宽度，也可以设置为不等宽度的。设置等宽度网格可能会导致买点卖点过早，收益率较低。设置不等宽度网格能够避免这个问题，但如果行情出现不利变动，可能会错失买卖机会。\n\n### 网格交易法的盈利情况\n\n***在行情震荡上涨时：***  \n![](/uploads/202010/attach_1642640f8e2ec613.png)\n\n假设格子之间的差为1元钱，每变化一个格子相应的买入或卖出1手，则通过网格交易当前账户的净收益为6元，持空仓4手，持仓均价为12.5元。\n\n***行情震荡下跌时：***  \n![](/uploads/202010/attach_164264143d608515.png)\n\n同理可知，净收益为8元，持4手多仓，平均成本为7.5元。\n\n可以看到，无论行情上涨还是下跌，已平仓的部分均为正收益，未平仓的部分需要等下一个信号出现再触发交易。\n\n即使网格交易能够获得较为稳定的收益，但也存在一定的风险。如果行情呈现大涨或大跌趋势，会导致不断开仓，增加风险敞口。这也是为什么网格交易更适用震荡行情，不合适趋势性行情。\n\n### 核心\n\n网格交易主要包括以下几个核心要点：\n\n**- 挑选的标的最好是价格变化较大，交易较为活跃**  \n网格交易是基于行情震荡进行获利的策略，如果标的不活跃，价格波动不大，很难触发交易。  \n**- 选出网格的压力位和阻力位**  \n确定适当的压力位和阻力位，使价格大部分时间能够在压力位和阻力位之间波动。如果压力位和阻力位设置范围过大，会导致难以触发交易；如果压力位和阻力位设置范围过小，则会频繁触发交易。  \n**- 设置网格的宽度和数量**  \n设定多少个网格以及网格的宽度可根据投资者自身喜好自行确定。\n\n## 2. 策略思路\n\n第一步：确定价格中枢、压力位和阻力位  \n第二步：确定网格的数量和间隔  \n第三步：当价格触碰到网格线时，若高于买入价，则每上升一格卖出m手；若低于买入价，则每下跌一格买入m手。\n\n回测标的：SHFE.rb1901  \n回测时间：2018-07-01 到 2018-10-01  \n回测初始资金：10万  \n**注意：若修改回测期，需要修改对应的回测标的。**\n\n### 策略难点：\n\n* 怎样记录价格是否突破网格线？\n\n解决方法：有些人可能会想到用当前价格与网格线对应的价格进行比较，但这样操作比较麻烦，步骤繁琐。这里采用区域判断方式。根据网格线划分网格区域为1、2、3、4、5、6.利用pandas库提供的cut函数，将当前价格所处的网格区域表示出来。当网格区域发生变化，说明价格突破了一个网格线。\n\n* 如何避免出现4区-5区开仓一次,5区-4区又平仓一次这种“假突破”？\n\n解决方法：4-5开仓一次和5-4平仓一次实际上突破的是一根线，此时的形态是价格沿着这根线上下波动。只有第一次穿过这条线时才是真正的交易信号，其他的并没有形成突破。因此我们需要一个变量储存每一次交易时网格区域的变化形态(按照从大到小的顺序)，比如5-4可以记为[4,5],4-5记为[4,5]。当新的记录=旧的记录时，信号失效。\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_010",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. from gm.api import *\n5. from pandas import DataFrame\n\n\n8. '''\n9. 本策略以0.8为初始权重跟踪指数标的沪深300中权重大于0.35%的成份股.\n10. 个股所占的百分比为(0.8*成份股权重)*100%.然后根据个股是否:\n11. 1.连续上涨5天 2.连续下跌5天\n12. 来判定个股是否为强势股/弱势股,并对其把权重由0.8调至1.0或0.6\n13. 回测时间为:2017-07-01 08:50:00到2017-10-01 17:00:00\n14. '''\n\n\n17. def init(context):\n18. # 资产配置的初始权重,配比为0.6-0.8-1.0\n19. context.ratio = 0.8\n\n21. # 获取沪深300当时的成份股和相关数据\n22. stock300 = get_history_constituents(index='SHSE.000300', start_date='2017-06-30', end_date='2017-06-30')[0][\n23. 'constituents']\n24. stock300_symbol = []\n25. stock300_weight = []\n26. for key in stock300:\n27. # 保留权重大于0.35%的成份股\n28. if (stock300[key] / 100) > 0.0035:\n29. stock300_symbol.append(key)\n30. stock300_weight.append(stock300[key] / 100)\n31. context.stock300 = DataFrame([stock300_weight], columns=stock300_symbol, index=['weight']).T\n32. print('选择的成分股权重总和为: ', np.sum(stock300_weight))\n33. subscribe(symbols=stock300_symbol, frequency='1d', count=5, wait_group=True)\n\n\n36. def on_bar(context, bars):\n37. # 若没有仓位则按照初始权重开仓\n38. for bar in bars:\n39. symbol = bar['symbol']\n40. position = context.account().position(symbol=symbol, side=PositionSide_Long)\n41. if not position:\n42. buy_percent = context.stock300['weight'][symbol] * context.ratio\n43. order_target_percent(symbol=symbol, percent=buy_percent, order_type=OrderType_Market,\n44. position_side=PositionSide_Long)\n45. print(symbol, '以市价单开多仓至仓位:', buy_percent)\n46. else:\n\n48. # 获取过去5天的价格数据,若连续上涨则为强势股,权重+0.2;若连续下跌则为弱势股,权重-0.2\n49. recent_data = context.data(symbol=symbol, frequency='1d', count=5, fields='close')['close'].tolist()\n50. if all(np.diff(recent_data) > 0):\n51. buy_percent = context.stock300['weight'][symbol] * (context.ratio + 0.2)\n52. order_target_percent(symbol=symbol, percent=buy_percent, order_type=OrderType_Market,\n53. position_side=PositionSide_Long)\n54. print('强势股', symbol, '以市价单调多仓至仓位:', buy_percent)\n55. elif all(np.diff(recent_data) < 0):\n56. buy_percent = context.stock300['weight'][symbol] * (context.ratio - 0.2)\n57. order_target_percent(symbol=symbol, percent=buy_percent, order_type=OrderType_Market,\n58. position_side=PositionSide_Long)\n59. print('弱势股', symbol, '以市价单调多仓至仓位:', buy_percent)\n\n\n62. if __name__ == '__main__':\n63. '''\n64. strategy_id策略ID,由系统生成\n65. filename文件名,请与本文件名保持一致\n66. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n67. token绑定计算机的ID,可在系统设置-密钥管理中生成\n68. backtest_start_time回测开始时间\n69. backtest_end_time回测结束时间\n70. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n71. backtest_initial_cash回测初始资金\n72. backtest_commission_ratio回测佣金比例\n73. backtest_slippage_ratio回测滑点比例\n74. '''\n75. run(strategy_id='strategy_id',\n76. filename='main.py',\n77. mode=MODE_BACKTEST,\n78. token='token_id',\n79. backtest_start_time='2017-07-01 08:00:00',\n80. backtest_end_time='2017-10-01 16:00:00',\n81. backtest_adjust=ADJUST_PREV,\n82. backtest_initial_cash=10000000,\n83. backtest_commission_ratio=0.0001,\n84. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 指数增强(股票)\n\n分享\n\n阅读 94773\n 更新 2022-05-09 16:56:48\n\n* [指数增强策略](#042069c643f068af)\n  + [1. 策略原理](#c4a1bed1475f07da)\n  + [2. 策略步骤](#c306d1ad1c8a5699)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果和稳健性分析](#e8b0a560bf110088)\n\n# 指数增强策略\n\n## 1. 策略原理\n\n说到指数增强，就不得不说指数。\n\n在进行股票投资时，有一种分类方式是将投资分为**主动型投资**和**被动型投资**。被动型投资是指完全复制指数，跟随指数的投资方式。与被动型投资相反，主动型投资是根据投资者的知识结合经验进行主动选股，不是被动跟随指数。主动型投资者期望获得超越市场的收益，被动型投资者满足于市场平均收益率水平。\n\n指数增强是指在跟踪指数的基础上，采用一些判断基准，将不看好的股票权重调低或平仓，将看好的股票加大仓位，以提高收益率的方法。\n\n**既然如此，我已经判断出来哪只是“好股票”，哪只是“一般”的股票，为什么不直接买入？而是要买入指数呢？**\n\n指数增强不同于其他主动投资方式，除了注重获取超越市场的收益，还要兼顾降低组合风险，注重收益的稳定性。如果判断失误，只买入选中股票而非指数会导致投资者承受巨大亏损。\n\n**怎样选择股票？**\n\n和alpha对冲策略类似，指数增强仅仅是一个思路，怎样选择“好股”还需投资者结合自身经验判断。\n\n本策略利用“动量”这一概念，认为过去5天连续上涨的股票具备继续上涨的潜力，属于强势股；过去5天连续下跌的股票未来会继续下跌，属于弱势股。\n\n## 2. 策略步骤\n\n第一步：选择跟踪指数，以权重大于0.35%的成分股为股票池。  \n第二步：根据个股价格动量来判断是否属于优质股，即连续上涨5天则为优势股；间隔连续下跌5天则为劣质股。  \n第三步：将优质股权重调高0.2，劣质股权重调低0.2。\n\n回测时间:2017-07-01 08:00:00 到 2017-10-01 16:00:00  \n回测选股股票池：沪深300成分股  \n回测初始资金：1000万\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_011",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from gm.api import *\n4. import numpy as np\n\n6. def init(context):\n7. # 选择的两个合约\n8. context.symbol = ['DCE.j1901', 'DCE.jm1901']\n9. # 订阅历史数据\n10. subscribe(symbols=context.symbol,frequency='1d',count=11,wait_group=True)\n\n12. def on_bar(context, bars):\n13. # 数据提取\n14. j_close = context.data(symbol=context.symbol[0],frequency='1d',fields='close',count=31).values\n15. jm_close = context.data(symbol=context.symbol[1],frequency='1d',fields='close',count=31).values\n16. # 提取最新价差\n17. new_price = j_close[-1] - jm_close[-1]\n18. # 计算历史价差,上下限，止损点\n19. spread_history = j_close[:-2] -  jm_close[:-2]\n20. context.spread_history_mean = np.mean(spread_history)\n21. context.spread_history_std = np.std(spread_history)\n22. context.up = context.spread_history_mean + 0.75 * context.spread_history_std\n23. context.down = context.spread_history_mean - 0.75 * context.spread_history_std\n24. context.up_stoppoint = context.spread_history_mean + 2 * context.spread_history_std\n25. context.down_stoppoint = context.spread_history_mean - 2 * context.spread_history_std\n26. # 查持仓\n27. position_jm_long = context.account().position(symbol=context.symbol[0],side=1)\n28. position_jm_short = context.account().position(symbol=context.symbol[0],side=2)\n\n30. # 设计买卖信号\n31. # 设计开仓信号\n32. if not position_jm_short and not position_jm_long:\n33. if new_price > context.up:\n34. print('做空价差组合')\n35. order_volume(symbol=context.symbol[0],side=OrderSide_Sell,volume=1,order_type=OrderType_Market,position_effect=1)\n36. order_volume(symbol=context.symbol[1], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n37. if new_price < context.down:\n38. print('做多价差组合')\n39. order_volume(symbol=context.symbol[0], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n40. order_volume(symbol=context.symbol[1], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n\n42. # 设计平仓信号\n43. # 持jm多仓时\n44. if position_jm_long:\n45. if new_price >= context.spread_history_mean:\n46. # 价差回归到均值水平时，平仓\n47. print('价差回归到均衡水平，平仓')\n48. order_volume(symbol=context.symbol[0], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n49. order_volume(symbol=context.symbol[1], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n\n51. if new_price < context.down_stoppoint:\n52. # 价差达到止损位，平仓止损\n53. print('价差超过止损点，平仓止损')\n54. order_volume(symbol=context.symbol[0], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n55. order_volume(symbol=context.symbol[1], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n\n57. # 持jm空仓时\n58. if position_jm_short:\n59. if new_price <= context.spread_history_mean:\n60. # 价差回归到均值水平时，平仓\n61. print('价差回归到均衡水平，平仓')\n62. order_volume(symbol=context.symbol[0], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n63. order_volume(symbol=context.symbol[1], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n\n65. if new_price > context.up_stoppoint:\n66. # 价差达到止损位，平仓止损\n67. print('价差超过止损点，平仓止损')\n68. order_volume(symbol=context.symbol[0], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n69. order_volume(symbol=context.symbol[1], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n\n\n72. if __name__ == '__main__':\n73. '''\n74. strategy_id策略ID,由系统生成\n75. filename文件名,请与本文件名保持一致\n76. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n77. token绑定计算机的ID,可在系统设置-密钥管理中生成\n78. backtest_start_time回测开始时间\n79. backtest_end_time回测结束时间\n80. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n81. backtest_initial_cash回测初始资金\n82. backtest_commission_ratio回测佣金比例\n83. backtest_slippage_ratio回测滑点比例\n84. '''\n85. run(strategy_id='strategy_id',\n86. filename='main.py',\n87. mode=MODE_BACKTEST,\n88. token='token',\n89. backtest_start_time='2018-02-01 08:00:00',\n90. backtest_end_time='2018-12-31 16:00:00',\n91. backtest_adjust=ADJUST_PREV,\n92. backtest_initial_cash=2000000,\n93. backtest_commission_ratio=0.0001,\n94. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 跨品种套利(期货)\n\n分享\n\n阅读 77411\n 更新 2022-05-09 16:56:48\n\n* [跨品种套利](#09193f1e386d702e)\n  + [1. 原理](#4d68e06c45acd2a2)\n  + [2. 策略思路](#cf0127fe1bcb3311)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\n\n# 跨品种套利\n\n## 1. 原理\n\n**什么是套利？**\n\n套利是指在买入或卖出一种金融资产的同时卖出或买入另一种相关的金融资产从中利用价差获得套利的过程。\n\n**什么是跨品种套利？**\n\n当两个合约有很强的相关性时，可能存在相似的变动关系，两种合约之间的价差会维持在一定的水平上。当市场出现变化时，两种合约之间的价差会偏离均衡水平。此时，可以买入其中一份合约同时卖出其中一份合约，当价差恢复到正常水平时平仓，获取收益。\n\n以大商所玉米和淀粉为例，合约分别为DCE.c1801和DCE.cs1801。二者之间相关性为0.7333，价差处于相对稳定合理区间。如图所示。\n\n![](/uploads/202011/attach_16447dccc6e340a8.png)\n\n二者价差整体处于250-350之间。当价差偏离此区间时，可以进行跨品种套利。\n\n**跨品种套利有以下几个特点：**\n\n1.套利的两种资产必须有一定的相关性。  \n2.两种合约标的不同，到期时间相同。  \n3.两种资产之间的价差呈现一定规律。\n\n**怎样确定合约之间有相关性？**\n\n最常用的方法是利用EG两步法对两个序列做协整检验，判断两个序列是否平稳。只有单整阶数相同，二者才有可能存在一定的关系。\n\n以大豆和豆粕为例，选取其在2017年1月1日至2018年1月1日的主力合约价格时间序列，利用statsmodels包进行协整检验。\n\n检验结果为：  \n焦炭的t = -1.7886，1%置信区间的临界值为-3.4576,说明该序列在99%的置信水平下平稳。  \n焦煤的t = -2.0500，1%置信区间的临界值为-3.4576,说明该序列在99%的置信水平下平稳。\n\n因此，二者都为**平稳序列**。\n\n利用OLS回归检残差序列是否平稳，残差的t=-2.3214，临界值为-3.4577，说明残差平稳。因此，可以认为二者之间存在一定关系。\n\n回归后的残差图如下：  \n![](/uploads/202011/attach_16447dd8a2012b87.png)\n\n对残差进行ks检验，检验结果p=0,说明残差分布为正态分布。\n\n**策略设计**\n\n传统利用价差进行跨品种套利的方法是计算出均值和方差，设定开仓、平仓和止损阈值。当新的价格达到阈值时，进行相应的开仓和平仓操作。\n\n**应该怎样确定均值？**\n\n均值的选取主要有两种方法，第一种方法是固定均值。先历史价格计算相应的阈值（比如利用2017年2月-2017年6月的数据计算阈值，在2019年7月进行套利），再用最新价差进行比较，会发现前后均值差异很大。如图所示。  \n![](/uploads/202011/attach_16447de3754242dd.png)  \n因此，常用变动的均值设定阈值。即用过去N天两个标的之间差值的均值和方差。\n\n## 2. 策略思路\n\n第一步：选择相关性较高的两个合约，本例选择大商所的焦炭和焦煤。  \n第二步：以过去30个的1d频率bar的均值正负0.75个标准差作为开仓阈值，以正负2个标准差作为止损阈值。  \n第三步：最新价差上穿上界时做空价差，回归到均值附近平仓；下穿下界时做多价差，回归到均值附近平仓。设定止损点，触发止损点则全部平仓。\n\n回测期：2018-02-01 8:00:00 至 2018-12-31 16:00:00  \n回测标的：DCE.j1901, DCE.jm1901  \n回测初始资金：200万  \n**注意：若修改回测期，需要修改对应的回测标的。**\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_012",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. from gm.api import *\n5. '''\n6. 通过计算两个真实价格序列回归残差的0.9个标准差上下轨,并在价差突破上轨的时候做空价差,价差突破下轨的时候做多价差\n7. 并在回归至标准差水平内的时候平仓\n8. 回测数据为:DCE.m1801和DCE.m1805的1min数据\n9. 回测时间为:2017-09-25 08:00:00到2017-10-01 15:00:00\n10. '''\n11. def init(context):\n12. context.goods = ['DCE.m1801', 'DCE.m1805']\n13. # 订阅品种数据\n14. subscribe(symbols = context.goods,frequency = '1d',count = 31,wait_group = True)\n\n16. def on_bar(context, bars):\n17. # 获取历史数据\n18. close_1801 = context.data(symbol=context.goods[0], frequency='1d', count=31, fields='close')['close'].values\n19. close_1805 = context.data(symbol=context.goods[1], frequency='1d', count=31, fields='close')['close'].values\n20. # 计算上下轨\n21. spread = close_1801[:-2] - close_1805[:-2]\n22. spread_new = close_1801[-1] - close_1805[-1]\n23. up = np.mean(spread) + 0.75 * np.std(spread)\n24. down = np.mean(spread) - 0.75 * np.std(spread)\n25. up_stop = np.mean(spread) + 2 * np.std(spread)\n26. down_stop = np.mean(spread) - 2 * np.std(spread)\n\n28. # 获取仓位\n29. position1801_long = context.account().position(symbol = context.goods[0],side =PositionSide_Long)\n30. position1801_short = context.account().position(symbol = context.goods[0],side =PositionSide_Short)\n\n32. # 没有仓位时\n33. if not position1801_short and not position1801_long:\n34. # 上穿上轨时，买近卖远\n35. if spread_new > up:\n36. order_volume(symbol=context.goods[0], volume=1, order_type=OrderType_Market, side=OrderSide_Buy, position_effect=PositionEffect_Open)\n37. order_volume(symbol=context.goods[1], volume=1, order_type=OrderType_Market, side=OrderSide_Sell, position_effect=PositionEffect_Open)\n38. print('上穿上轨，买近卖远')\n39. # 下穿下轨时，卖近买远\n40. if spread_new < down:\n41. order_volume(symbol=context.goods[0], volume=1, order_type=OrderType_Market, side=OrderSide_Sell, position_effect=PositionEffect_Open)\n42. order_volume(symbol=context.goods[1], volume=1, order_type=OrderType_Market, side=OrderSide_Buy, position_effect=PositionEffect_Open)\n43. print('下穿下轨，卖近买远')\n\n45. # 价差回归到上轨时，平仓\n46. if position1801_long:\n47. if spread_new <= np.mean(spread):\n48. order_close_all()\n49. print('价差回归，平仓')\n50. if spread_new > up_stop:\n51. order_close_all()\n52. print('达到止损点，全部平仓')\n\n54. # 价差回归到下轨时，平仓\n55. if position1801_short:\n56. if spread_new >= np.mean(spread):\n57. order_close_all()\n58. print('价差回归，平全部仓')\n59. if spread_new < down_stop:\n60. order_close_all()\n61. print('达到止损点，全部平仓')\n\n63. if __name__ == '__main__':\n64. '''\n65. strategy_id策略ID,由系统生成\n66. filename文件名,请与本文件名保持一致\n67. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n68. token绑定计算机的ID,可在系统设置-密钥管理中生成\n69. backtest_start_time回测开始时间\n70. backtest_end_time回测结束时间\n71. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n72. backtest_initial_cash回测初始资金\n73. backtest_commission_ratio回测佣金比例\n74. backtest_slippage_ratio回测滑点比例\n75. '''\n76. run(strategy_id='strategy_id',\n77. filename='main.py',\n78. mode=MODE_BACKTEST,\n79. token='token_id',\n80. backtest_start_time='2017-07-01 08:00:00',\n81. backtest_end_time='2017-12-31 16:00:00',\n82. backtest_adjust=ADJUST_PREV,\n83. backtest_initial_cash=2000000,\n84. backtest_commission_ratio=0.0001,\n85. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 跨期套利(期货)\n\n分享\n\n阅读 95767\n 更新 2022-05-09 16:56:48\n\n* [跨期套利策略](#ef9527d0cf571341)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [什么是跨期套利？](#82f7714859e29834)\n    - [套利方法](#a61d5be123b8fa09)\n    - [协整检验](#21efc72039481792)\n  + [2. 策略步骤](#c306d1ad1c8a5699)\n    - [3. 策略代码](#69a3fc437f0227e3)\n    - [4. 回测结果](#7356929dacb239c9)\n\n# 跨期套利策略\n\n## 1. 原理\n\n### 什么是跨期套利？\n\n跨期套利是指在同益市场利用标的相同、交割月份不同的商品期货合约进行长短期套利的策略。跨期套利本质上是一种风险对冲，当价格出现单方向变动时，单边投机者要承担价格反向变动的风险，而跨期套利过滤了大部分的价格波动风险，只承担价差反向变动的风险。\n\n跨期套利相较于跨品种套利而言更复杂一些。跨期套利分为牛市套利、熊市套利、牛熊交换套利。每种套利方式下还有正向套利和反向套利。不管是哪种套利方式，其核心都是认为“价差会向均值回归”。因此，在价差偏离均值水平时，按照判断买入被低估的合约，卖出被高估的合约。\n\n### 套利方法\n\n套利方法可归结为以下几类：\n\n| 价差（近-远） | 未来价 | 原理 | 操作 |\n| --- | --- | --- | --- |\n| 偏大 | 上涨/下跌 | 近月增长 >远月增长 | 买近卖远 |\n| 近月下跌 < 远月下跌 |\n| 偏小 | 上涨/下跌 | 近月增长 < 远月增长 | 卖近买远 |\n| 近月下跌 > 远月下跌 |\n|\n\n### 协整检验\n\n要想判断两个序列之间是否存在关系，需要对序列进行协整检验。以大商所豆粕为例，对DCE.m1701和DCE.m1705进行检验。\n\n1701合约的t值 = -2.1176，临界值为-3.4769，t > 临界值说明序列平稳。  \n1705合约的t值 = -2.5194，临界值为-3.4769，t > 临界值说明序列平稳。\n\n两个序列都为单整序列，残差序列也平稳，说明二者之间存在长期稳定的均衡关系。\n\n## 2. 策略步骤\n\n第一步：选择同一标的不同月份的合约，本策略以豆粕为例。  \n第二步：计算价差的上下轨。  \n第三步：设计信号。价差上穿上轨，买近卖远；价差下穿下轨，卖近买远。  \n价差达到止损点时平仓，价差回归到均值附近时平仓。\n\n回测标的：DCE.m1801、DCE.m1805  \n回测时间:2017-09-25 到 2017-10-01  \n回测初始资金：200万  \n**注意：若修改回测期，需要修改对应的回测标的。**\n\n### 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_013",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import sys\n4. try:\n5. import talib\n6. except:\n7. print('请安装TA-Lib库')\n8. # 安装talib请看文档https://www.myquant.cn/docs/gm3_faq/154?\n9. sys.exit(-1)\n10. from gm.api import *\n\n\n13. def init(context):\n14. # 设置标的股票\n15. context.symbol = 'SHSE.600000'\n16. # 用于判定第一个仓位是否成功开仓\n17. context.first = 0\n18. # 订阅浦发银行, bar频率为1min\n19. subscribe(symbols=context.symbol, frequency='60s', count=35)\n20. # 日内回转每次交易100股\n21. context.trade_n = 100\n22. # 获取昨今天的时间\n23. context.day = [0, 0]\n24. # 用于判断是否到达接近收盘，所以不再交易\n25. context.ending = 1\n\n\n28. def on_bar(context, bars):\n29. bar = bars[0]\n30. # 配置底仓\n31. if context.first == 0:\n32. # 需要保持的总仓位\n33. context.total = 10000\n34. # 购买10000股浦发银行股票\n35. order_volume(symbol=context.symbol, volume=context.total, side=OrderSide_Buy,\n36. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n37. print(context.symbol, '以市价单开多仓10000股')\n38. context.first = 1.\n39. day = bar.bob.strftime('%Y-%m-%d')\n40. context.day[-1] = int(day[-2:])\n41. # 每天的仓位操作\n42. context.turnaround = [0, 0]\n43. return\n\n45. # 更新最新的日期\n46. day = bar.bob.strftime('%Y-%m-%d %H:%M:%S')\n47. context.day[0] = bar.bob.day\n\n49. # 若为新的一天,获取可用于回转的昨仓\n50. if context.day[0] != context.day[-1]:\n51. context.ending = 0\n52. context.turnaround = [0, 0]\n\n54. # 如果接近收盘，则不再交易\n55. if context.ending == 1:\n56. return\n\n58. # 若有可用的昨仓则操作\n59. if context.total >= 0:\n60. # 获取时间序列数据\n61. symbol = bar['symbol']\n62. recent_data = context.data(symbol=symbol, frequency='60s', count=35, fields='close')\n63. # 计算MACD线\n64. macd = talib.MACD(recent_data['close'].values)[0][-1]\n65. # 根据MACD>0则开仓,小于0则平仓\n66. if macd > 0:\n67. # 多空单向操作都不能超过昨仓位,否则最后无法调回原仓位\n68. if context.turnaround[0] + context.trade_n < context.total:\n69. # 计算累计仓位\n70. context.turnaround[0] += context.trade_n\n71. order_volume(symbol=context.symbol, volume=context.trade_n, side=OrderSide_Buy,\n72. order_type=OrderType_Market, position_effect=PositionEffect_Open)\n73. print(symbol, '市价单开多仓', context.trade_n, '股')\n74. elif macd < 0:\n75. if context.turnaround[1] + context.trade_n < context.total:\n76. context.turnaround[1] += context.trade_n\n77. order_volume(symbol=context.symbol, volume=context.trade_n, side=OrderSide_Sell,\n78. order_type=OrderType_Market, position_effect=PositionEffect_Close)\n79. print(symbol, '市价单开空仓', context.trade_n, '股')\n80. # 临近收盘时若仓位数不等于昨仓则回转所有仓位\n81. if day[11:16] == '14:55' or day[11:16] == '14:57':\n82. position = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n83. if position['volume'] != context.total:\n84. order_target_volume(symbol=context.symbol, volume=context.total, order_type=OrderType_Market,\n85. position_side=PositionSide_Long)\n86. print('市价单回转仓位操作...')\n87. context.ending = 1\n88. # 更新过去的日期数据\n89. context.day[-1] = context.day[0]\n\n\n92. if __name__ == '__main__':\n93. '''\n94. strategy_id策略ID,由系统生成\n95. filename文件名,请与本文件名保持一致\n96. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n97. token绑定计算机的ID,可在系统设置-密钥管理中生成\n98. backtest_start_time回测开始时间\n99. backtest_end_time回测结束时间\n100. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n101. backtest_initial_cash回测初始资金\n102. backtest_commission_ratio回测佣金比例\n103. backtest_slippage_ratio回测滑点比例\n104. '''\n105. run(strategy_id='strategy_id',\n106. filename='main.py',\n107. mode=MODE_BACKTEST,\n108. token='token_id',\n109. backtest_start_time='2017-09-01 08:00:00',\n110. backtest_end_time='2017-10-01 16:00:00',\n111. backtest_adjust=ADJUST_PREV,\n112. backtest_initial_cash=2000000,\n113. backtest_commission_ratio=0.0001,\n114. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 日内回转交易(股票)\n\n分享\n\n阅读 89072\n 更新 2022-05-09 16:56:48\n\n* [日内回转策略(股票)](#b47cfad4c6c99652)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [1.1 日内回转交易](#06f595f138bb40a0)\n    - [1.2 股票的日内回转交易](#392304c3971efd73)\n    - [1.3 MACD指标简介](#509702eac2040b89)\n  + [2. 策略思路](#cf0127fe1bcb3311)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\n\n# 日内回转策略(股票)\n\n## 1. 原理\n\n### 1.1 日内回转交易\n\n日内回转交易，顾名思义就是在一天内完成“买”和“卖”两个相反方向的操作（可一次也可多次），也就是“T+0”交易。\n\n日内回转可用于股票和期货。其中期货采用“T+0”交易制度，可以直接进行日内回转交易。由于A股采用的是“T+1”交易制度，无法直接进行日内回转交易，需要先配置一定的底仓再进行回转交易。\n\n### 1.2 股票的日内回转交易\n\n**怎样对股票进行日内回转交易？**\n\n首先，在正式交易的前一个交易日配置一定的底仓。以500股为例，记做total = 500。\n\n然后开始正式的日内回转交易。\n\n配置底仓的作用是利用替代法实现“T+0”。由于当天买入的股票当天不能卖出，但底仓是可以卖出的，用底仓替代新买入的股票进行卖出操作。假设在第二个交易日发生了1次买入，5次卖出交易，每次交易买卖数量为100股。利用turnaround = [0,0]变量记录每次交易的数量，也是当天收盘时需要回转的记录。其中第一个数据表示当日买入数量，第二个数据表示当日卖出数量。下表为单个交易日的买卖信号。\n\n| 信号方向 | 数量 | 交易记录 | 剩余可回转的数量 | 总仓位 |\n| --- | --- | --- | --- | --- |\n| 买 | 100 | [100,0] | 500 | 600 |\n| 卖 | 100 | [100,100] | 400 | 500 |\n| 卖 | 100 | [100,200] | 300 | 400 |\n| 卖 | 100 | [100,300] | 200 | 300 |\n| 卖 | 100 | [100,400] | 100 | 200 |\n\n**假设在表的最后再加一个卖出信号是否可行？**\n\n答案是**不可行**。\n\n因为如果再加一个卖出信号，需要回转的股票数量变为[100,500]，即开多100股，开空500股。这就意味着在当天收盘之前，需要卖出100股，再买入500股进行回转。这个交易日内已经出现5次卖出信号，底仓的500股已经全部卖出，仅有100股今日买入的仓位，这部分股票是不能当日卖出的。所以，不能再添加卖出信号。\n\n因此，在判断买入或卖出信号是否能执行时，隐含一个判断条件。即：\n\n**每次交易的数量 + 当日买入的数量（turnaround的第一位）< 底仓数量（以卖出信号为例）**。\n\n### 1.3 MACD指标简介\n\nMACD又称“异移动平均线”，是根据双指数移动平均线发展而来。由快的指数（常12）减去慢的指数（常26）得到DIF，再用2×（快线DIF-DIF的9日加权移动均线DEA）得到MACD柱。\n\nDIF的计算方法为： DIF = 当天的12日指数移动平均值 - 当天的26日指数应对平均值。  \n***注：上市首日的EMA12和EMA26利用当天的收盘价替代。***\n\n## 2. 策略思路\n\n第一步：设置变量  \n**context.first:底仓配置信号，0表示未配置底仓；1表示配置底仓。  \ncontext.trade\\_n:每次交易数量。  \ncontext.day:用来获取前一交易日的时间和最新交易日的时间，第一位是最新交易日，第二位是前一交易日。当二者不同时，意味着新的一天，需要初始化其他变量。  \ncontext.ending：开始回转信号，0表示未触发；1表示已触发。  \ncontext.turnaround：当日买卖股票操作记录，也是回转记录。第一位代表买入股数，第二位代表卖出股数。**\n\n第二步：计算MACD指标，设计交易信号  \n当 MACD 小于 0 时，买入对应股票100手；  \n当 MACD 大于 0 时，卖出对应股票100手;\n\n第三步：接近收盘时，全部回转\n\n回测标的：SHSE.600000  \n回测期：2017-09-01 8:00:00 到2017-10-01 16:00:00  \n回测初始资金：200万\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_014",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from gm.api import *\n\n\n6. '''\n7. 本策略通过不断对CZCE.CF801进行:\n8. 买(卖)一价现价单开多(空)仓和卖(买)一价平多(空)仓来做市\n9. 并以此赚取差价\n10. 回测数据为:CZCE.CF801的tick数据\n11. 回测时间为:2017-09-29 11:25:00到2017-09-29 11:30:00\n12. 需要特别注意的是:本平台对于回测对限价单固定完全成交,本例子 仅供参考.\n13. 敬请通过适当调整回测参数\n14. 1.backtest_commission_ratio回测佣金比例\n15. 2.backtest_slippage_ratio回测滑点比例\n16. 3.backtest_transaction_ratio回测成交比例\n17. 以及优化策略逻辑来达到更贴近实际的回测效果\n18. 目前只支持最近三个月的tick数据，回测时间和标的需要修改\n19. '''\n\n\n22. def init(context):\n23. # 订阅CZCE.CF801的tick数据\n24. context.symbol = 'CZCE.CF801'\n25. subscribe(symbols=context.symbol, frequency='tick')\n\n\n28. def on_tick(context, tick):\n29. quotes = tick['quotes'][0]\n30. # 获取持有的多仓\n31. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n32. # 获取持有的空仓\n33. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\n34. # 没有仓位则双向开限价单\n35. # 若有仓位则限价单平仓\n36. if not position_long:\n37. # 获取买一价\n38. price = quotes['bid_p']\n39. print('买一价为: ', price)\n40. order_target_volume(symbol=context.symbol, volume=1, price=price, order_type=OrderType_Limit,\n41. position_side=PositionSide_Long)\n42. print('CZCE.CF801开限价单多仓1手')\n43. else:\n44. # 获取卖一价\n45. price = quotes['ask_p']\n46. print('卖一价为: ', price)\n47. order_target_volume(symbol=context.symbol, volume=0, price=price, order_type=OrderType_Limit,\n48. position_side=PositionSide_Long)\n49. print('CZCE.CF801平限价单多仓1手')\n50. if not position_short:\n51. # 获取卖一价\n52. price = quotes['ask_p']\n53. print('卖一价为: ', price)\n54. order_target_volume(symbol=context.symbol, volume=1, price=price, order_type=OrderType_Limit,\n55. position_side=PositionSide_Short)\n56. print('CZCE.CF801卖一价开限价单空仓')\n57. else:\n58. # 获取买一价\n59. price = quotes['bid_p']\n60. print('买一价为: ', price)\n61. order_target_volume(symbol=context.symbol, volume=0, price=price, order_type=OrderType_Limit,\n62. position_side=PositionSide_Short)\n63. print('CZCE.CF801买一价平限价单空仓')\n\n\n66. if __name__ == '__main__':\n67. '''\n68. strategy_id策略ID,由系统生成\n69. filename文件名,请与本文件名保持一致\n70. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n71. token绑定计算机的ID,可在系统设置-密钥管理中生成\n72. backtest_start_time回测开始时间\n73. backtest_end_time回测结束时间\n74. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n75. backtest_initial_cash回测初始资金\n76. backtest_commission_ratio回测佣金比例\n77. backtest_slippage_ratio回测滑点比例\n78. backtest_transaction_ratio回测成交比例\n79. '''\n80. run(strategy_id='strategy_id',\n81. filename='main.py',\n82. mode=MODE_BACKTEST,\n83. token='token_id',\n84. backtest_start_time='2017-09-29 11:25:00',\n85. backtest_end_time='2017-09-29 11:30:00',\n86. backtest_adjust=ADJUST_PREV,\n87. backtest_initial_cash=500000,\n88. backtest_commission_ratio=0.00006,\n89. backtest_slippage_ratio=0.0001,\n90. backtest_transaction_ratio=0.5)",
    "strategy_description": "# 做市商交易(期货)\n\n分享\n\n阅读 63805\n 更新 2022-05-09 16:56:48\n\n* [做市商策略](#453ebf89037b4e6d)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [做市商制度](#618419f38b80684e)\n  + [2. 策略思路](#cf0127fe1bcb3311)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果](#7356929dacb239c9)\n\n# 做市商策略\n\n## 1. 原理\n\n### 做市商制度\n\n做市商制度是一种报价驱动制度。做市商根据自己的判断，不断地报出买入报价和卖出报价，以自有资金与投资者进行交易。做市商获取的收益就是买入价和卖出价的价差。\n\n假设做市商以6344卖出一手合约，同时以6333买入一手合约。如果都成交，做市商可净获利11个点。但如果当时合约价格持续走高或走低，做市商没有对手方能够成交，这时就不得不提高自己的买价或降低自己的卖价进行交易，做市商就会亏损。因此，做市商并不是稳赚不赔的。\n\n## 2. 策略思路\n\n第一步：订阅tick数据（只有最近3个月数据）  \n第二步：获取tick数据中的卖一和买一价格。  \n第三步：以买一价格开多，以卖一价格开空。以卖一价格平多，以买一价格平空。\n\n回测标的：CZCE.CF801  \n回测时间： 2017-09-29 11:25:00 至 2017-09-29 11:30:00  \n回测初始资金：50万  \n**注意：若修改回测期，需要修改对应的回测标的。**\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_015",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. import pandas as pd\n5. from gm.api import *\n\n\n8. '''\n9. 以短期为例：20日线\n10. 第一步：获取历史数据，计算唐奇安通道和ATR\n11. 第二步：当突破唐奇安通道时，开仓。\n12. 第三步：计算加仓和止损信号。\n13. '''\n\n\n16. def init(context):\n17. # 设置计算唐奇安通道的参数\n18. context.n = 20\n19. # 设置合约标的\n20. context.symbol = 'DCE.i2012'\n21. # 设置交易最大资金比率\n22. context.ratio = 0.8\n23. # 订阅数据\n24. subscribe(symbols=context.symbol, frequency='60s', count=2)\n25. # 获取当前时间\n26. time = context.now.strftime('%H:%M:%S')\n27. # 如果策略执行时间点是交易时间段，则直接执行algo定义atr等参数，以防直接进入on_bar()导致atr等未定义\n28. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\n29. algo(context)\n30. # 如果是交易时间段，等到开盘时间确保进入algo()\n31. schedule(schedule_func=algo, date_rule='1d', time_rule='09:00:00')\n32. schedule(schedule_func=algo, date_rule='1d', time_rule='21:00:00')\n\n\n35. def algo(context):\n36. # 计算通道的数据:当日最低、最高、上一交易日收盘\n37. # 注：由于talib库计算ATR的结果与公式求得的结果不符，所以这里利用公式计算ATR\n38. # 如果是回测模式,当天的数据直接用history取到\n39. if context.mode == 2:\n40. data = history_n(symbol=context.symbol, frequency='1d', count=context.n+1, end_time=context.now, fields='close,high,low,bob', df=True) # 计算ATR\n41. tr_list = []\n42. for i in range(0, len(data)-1):\n43. tr = max((data['high'].iloc[i] - data['low'].iloc[i]), data['close'].shift(-1).iloc[i] - data['high'].iloc[i],\n44. data['close'].shift(-1).iloc[i] - data['low'].iloc[i])\n45. tr_list.append(tr)\n46. context.atr = int(np.floor(np.mean(tr_list)))\n47. context.atr_half = int(np.floor(0.5 * context.atr))\n\n\n50. # 计算唐奇安通道\n51. context.don_open = np.max(data['high'].values[-context.n:])\n52. context.don_close = np.min(data['low'].values[-context.n:])\n\n54. # 如果是实时模式，当天的数据需要用current取到\n55. if context.mode == 1:\n56. data = history_n(symbol=context.symbol, frequency='1d', count=context.n, end_time=context.now, fields='close,high,low',\n57. df=True)  # 计算ATR\n58. current_data = current(symbols=context.symbol)   # 最新一个交易日的最高、最低\n59. tr_list = []\n60. for i in range(1, len(data)):\n61. tr = max((data['high'].iloc[i] - data['low'].iloc[i]),\n62. data['close'].shift(-1).iloc[i] - data['high'].iloc[i],\n63. data['close'].shift(-1).iloc[i] - data['low'].iloc[i])\n64. tr_list.append(tr)\n\n66. # 把最新一期tr加入列表中\n67. tr_new = max((current_data[0]['high'] - current_data[0]['low']),\n68. data['close'].iloc[-1] - current_data[0]['high'],\n69. data['close'].iloc[-1] - current_data[0]['low'])\n70. tr_list.append(tr_new)\n71. context.atr = int(np.floor(np.mean(tr_list)))\n72. context.atr_half = int(np.floor(0.5 * context.atr))\n\n74. # 计算唐奇安通道\n75. context.don_open = np.max(data['high'].values[-context.n:])\n76. context.don_close = np.min(data['low'].values[-context.n:])\n\n78. # 计算加仓点和止损点\n79. context.long_add_point = context.don_open + context.atr_half\n80. context.long_stop_loss = context.don_open - context.atr_half\n81. context.short_add_point = context.don_close - context.atr_half\n82. context.short_stop_loss = context.don_close + context.atr_half\n\n\n85. def on_bar(context, bars):\n86. # 提取数据\n87. symbol = bars[0]['symbol']\n88. recent_data = context.data(symbol=context.symbol, frequency='60s', count=2, fields='close,high,low')\n89. close = recent_data['close'].values[-1]\n\n91. # 账户仓位情况\n92. position_long = context.account().position(symbol=symbol, side=PositionSide_Long)\n93. position_short = context.account().position(symbol=symbol, side=PositionSide_Short)\n\n95. # 当无持仓时\n96. if not position_long and not position_short:\n97. # 如果向上突破唐奇安通道，则开多\n98. if close > context.don_open:\n99. order_volume(symbol=symbol, side=OrderSide_Buy, volume=context.atr, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n100. print('开多仓atr')\n\n102. # 如果向下突破唐奇安通道，则开空\n103. if close < context.don_close:\n104. order_volume(symbol=symbol, side=OrderSide_Sell, volume=context.atr, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n105. print('开空仓atr')\n\n107. # 有持仓时\n108. # 持多仓，继续突破（加仓）\n109. if position_long:\n110. # 当突破1/2atr时加仓\n111. if close > context.long_add_point:\n112. order_volume(symbol=symbol, volume=context.atr_half, side=OrderSide_Buy, order_type=OrderType_Market,position_effect=PositionEffect_Open)\n113. print('继续加仓0.5atr')\n114. context.long_add_point += context.atr_half\n115. context.long_stop_loss += context.atr_half\n116. # 持多仓，止损位计算\n117. if close < context.long_stop_loss:\n118. volume_hold = position_long['volume']\n119. if volume_hold >= context.atr_half:\n120. order_volume(symbol=symbol, volume=context.atr_half, side=OrderSide_Sell, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n121. else:\n122. order_volume(symbol=symbol, volume=volume_hold, side=OrderSide_Sell, order_type=OrderType_Market,position_effect=PositionEffect_Close)\n123. print('平多仓0.5atr')\n124. context.long_add_point -= context.atr_half\n125. context.long_stop_loss -= context.atr_half\n\n127. # 持空仓，继续突破（加仓）\n128. if position_short:\n129. # 当跌破加仓点时加仓\n130. if close < context.short_add_point:\n131. order_volume(symbol = symbol, volume=context.atr_half, side=OrderSide_Sell, order_type=OrderType_Market, position_effect=PositionEffect_Open)\n132. print('继续加仓0.5atr')\n133. context.short_add_point -= context.atr_half\n134. context.short_stop_loss -= context.atr_half\n\n136. # 持多仓，止损位计算\n137. if close > context.short_stop_loss:\n138. volume_hold = position_short['volume']\n139. if volume_hold >= context.atr_half:\n140. order_volume(symbol=symbol, volume=context.atr_half, side=OrderSide_Buy, order_type=OrderType_Market, position_effect=PositionEffect_Close)\n141. else:\n142. order_volume(symbol=symbol, volume=volume_hold, side=OrderSide_Buy, order_type=OrderType_Market,position_effect=PositionEffect_Close)\n143. print('平空仓0.5atr')\n144. context.short_add_point += context.atr_half\n145. context.short_stop_loss += context.atr_half\n\n\n148. if __name__ == '__main__':\n149. '''\n150. strategy_id策略ID,由系统生成\n151. filename文件名,请与本文件名保持一致\n152. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n153. token绑定计算机的ID,可在系统设置-密钥管理中生成\n154. backtest_start_time回测开始时间\n155. backtest_end_time回测结束时间\n156. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n157. backtest_initial_cash回测初始资金\n158. backtest_commission_ratio回测佣金比例\n159. backtest_slippage_ratio回测滑点比例\n160. '''\n161. run(strategy_id='strategy_id',\n162. filename='main.py',\n163. mode=MODE_BACKTEST,\n164. token='token',\n165. backtest_start_time='2020-02-15 09:15:00',\n166. backtest_end_time='2020-09-01 15:00:00',\n167. backtest_adjust=ADJUST_PREV,\n168. backtest_initial_cash=1000000,\n169. backtest_commission_ratio=0.0001,\n170. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 海龟交易法(期货)\n\n分享\n\n阅读 192903\n 更新 2022-05-09 16:56:48\n\n* [海龟交易法](#30c4142fd6f8262d)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [1.1 起源](#58896c8f4826f4ef)\n    - [1.2 建仓资金](#f464e09082bb0180)\n    - [1.3 入市信号](#2c623029a9da9f50)\n    - [1.4 加仓和止损](#5e4d162e21ab4eb8)\n    - [1.5 止盈](#6645f9b1b74126ed)\n  + [2. 策略思路](#cf0127fe1bcb3311)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\n\n# 海龟交易法\n\n## 1. 原理\n\n### 1.1 起源\n\n海龟交易思想起源于上世纪八十年代的美国。理查德丹尼斯与好友比尔打赌，主题是一个成功的交易员是天生的还是后天的。理查德用十年时间证明了通过日常系统培训，交易员可以通过后天培训成为一名优秀的交易者。这套培训系统就是海龟交易系统。\n\n海龟交易系统是一个完整的、机械的交易思想，可以系统地完成整个交易过程。它包括了买卖什么、头寸规模、何时买卖、何时退出等一系列交易策略，是一个趋势交易策略。它最显著的特点是捕捉中长期趋势，力求在短期内获得最大的收益。\n\n### 1.2 建仓资金\n\n海龟交易法将建仓资金按照一定比例划分为若干个小部分，每次建仓头寸和加仓规模都与波动量N（又称平均真实波动振幅average true range ATR）有关。ATR是日内指数最大波动的平均振幅，由当日最高、最低价和上一交易日的收盘价决定。\n\n***ATR***\n\n![](/uploads/202011/attach_1644dade59a71009.png)  \n其中PDC是前一交易日的收盘价，ATR就是TR在N天内的均值。  \n  \n***价值波动量***  \n  \n利用N值来体现价值波动量DV：  \n**DV = N \\* 合约每点价值**\n\n其中每点代表的价值量是指每一个指数点数所代表的价格。  \n每一次开仓交易合约数unit的确定是将总资产的1%除以DV得到。\n\n![](/uploads/202011/attach_1644db0e005d0867.png)\n\n### 1.3 入市信号\n\n海龟交易法使用的是以一个理查德唐奇安的通道突破系统为基础的入市系统。唐奇安通道分为系统一和系统二，对应短期突破和中长期突破。其中，短期突破系统是以20日（最高价或最低价）突破为基础，当价格突破20日价格即为入市信号；中长期系统是当盘中价格突破过去55日价格为入市信号。\n\n### 1.4 加仓和止损\n\n海龟交易法的加仓规则是当捕捉到入市信号后建立第一个交易单位的头寸，市价继续向盈利方向突破1/2N时加仓。\n\n止损位为2N,同加仓一样采用平均真实振幅N值为止损单位。每加仓一次，止损位就提高1/2N。\n\n### 1.5 止盈\n\n短期：多头头寸在突破过去10日最低价处止盈离市，空头头寸在突破过去10日最高价处止盈离市。  \n中长期：多头头寸在突破过去20日最低价处止盈离市，空头头寸在突破过去20日最高价处止盈离市。\n\n## 2. 策略思路\n\n第一步：获取历史数据，计算唐奇安通道和ATR  \n第二步：当突破唐奇安通道时，开仓。  \n第三步：计算加仓和止损信号。\n\n回测标的：DCE.i2012  \n回测时间：2020-02-15 至 2020-09-01  \n回测初始资金：100万\n\n**Tips：**  \nATR值是不断变化的，这就会导致在对期货平仓时，可能出现平仓数量 > 持仓数量的现象。比如前一交易日的持仓为10，今日的ATR值为22.假设当前价格触发平仓条件，平仓1/2*ATR。1/2*ATR=11 > 10, 这样就会导致委托失败报错。所以要加入一个变量volume\\_hold用来记录当前持仓量，与1/2\\*ATR作比较。\n\n**注意：若修改回测期，需要修改对应的回测标的。**\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_016",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. import numpy as np\n4. from gm.api import *\n5. '''\n6. 本策略每隔1个月定时触发计算SHSE.000910.SHSE.000909.SHSE.000911.SHSE.000912.SHSE.000913.SHSE.000914\n7. (300工业.300材料.300可选.300消费.300医药.300金融)这几个行业指数过去\n8. 20个交易日的收益率并选取了收益率最高的指数的成份股获取并获取了他们的市值数据\n9. 随后把仓位调整至市值最大的5只股票上\n10. 回测数据为:SHSE.000910.SHSE.000909.SHSE.000911.SHSE.000912.SHSE.000913.SHSE.000914和他们的成份股\n11. 回测时间为:2017-07-01 08:00:00到2017-10-01 16:00:00\n12. '''\n13. def init(context):\n14. # 每月第一个交易日的09:40 定时执行algo任务（仿真和实盘时不支持该频率）\n15. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\n16. # 用于筛选的行业指数\n17. context.index = ['SHSE.000910', 'SHSE.000909', 'SHSE.000911', 'SHSE.000912', 'SHSE.000913', 'SHSE.000914']\n18. # 用于统计数据的天数\n19. context.date = 20\n20. # 最大下单资金比例\n21. context.ratio = 0.8\n\n23. def algo(context):\n24. # 获取当天的日期\n25. today = context.now\n26. # 获取上一个交易日\n27. last_day = get_previous_trading_date(exchange='SHSE', date=today)\n28. return_index = []\n\n30. # 获取并计算行业指数收益率\n31. for i in context.index:\n32. return_index_his = history_n(symbol=i, frequency='1d', count=context.date, fields='close,bob',\n33. fill_missing='Last', adjust=ADJUST_PREV, end_time=last_day, df=True)\n34. return_index_his = return_index_his['close'].values\n35. return_index.append(return_index_his[-1] / return_index_his[0] - 1)\n\n37. # 获取指定数内收益率表现最好的行业\n38. sector = context.index[np.argmax(return_index)]\n39. print('最佳行业指数是: ', sector)\n\n41. # 获取最佳行业指数成份股\n42. symbols = get_history_constituents(index=sector, start_date=last_day, end_date=last_day)[0]['constituents'].keys()\n\n44. # 获取当天有交易的股票\n45. not_suspended_info = get_history_instruments(symbols=symbols, start_date=today, end_date=today)\n46. not_suspended_symbols = [item['symbol'] for item in not_suspended_info if not item['is_suspended']]\n\n48. # 获取最佳行业指数成份股的市值，从大到小排序并选取市值最大的5只股票\n49. fin = get_fundamentals(table='trading_derivative_indicator', symbols=not_suspended_symbols, start_date=last_day,\n50. end_date=last_day, limit=5, fields='NEGOTIABLEMV', order_by='-NEGOTIABLEMV', df=True)\n51. fin.index = fin['symbol']\n\n53. # 计算权重\n54. percent = 1.0 / len(fin.index) * context.ratio\n\n56. # 获取当前所有仓位\n57. positions = context.account().positions()\n\n59. # 如标的池有仓位,平不在标的池的仓位\n60. for position in positions:\n61. symbol = position['symbol']\n62. if symbol not in fin.index:\n63. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\n64. position_side=PositionSide_Long)\n65. print('市价单平不在标的池的', symbol)\n\n67. # 对标的池进行操作\n68. for symbol in fin.index:\n69. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\n70. position_side=PositionSide_Long)\n71. print(symbol, '以市价单调整至仓位', percent)\n\n73. if __name__ == '__main__':\n74. '''\n75. strategy_id策略ID,由系统生成\n76. filename文件名,请与本文件名保持一致\n77. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n78. token绑定计算机的ID,可在系统设置-密钥管理中生成\n79. backtest_start_time回测开始时间\n80. backtest_end_time回测结束时间\n81. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n82. backtest_initial_cash回测初始资金\n83. backtest_commission_ratio回测佣金比例\n84. backtest_slippage_ratio回测滑点比例\n85. '''\n86. run(strategy_id='strategy_id',\n87. filename='main.py',\n88. mode=MODE_BACKTEST,\n89. token='token_id',\n90. backtest_start_time='2017-07-01 08:00:00',\n91. backtest_end_time='2017-10-01 16:00:00',\n92. backtest_adjust=ADJUST_PREV,\n93. backtest_initial_cash=10000000,\n94. backtest_commission_ratio=0.0001,\n95. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 行业轮动(股票)\n\n分享\n\n阅读 91216\n 更新 2022-05-09 16:56:48\n\n* [行业轮动策略](#0154de37d02116fa)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [行业轮动现象](#a8e1628d8676e515)\n    - [行业轮动的原因](#e1d8c185f9839e8e)\n    - [行业轮动下资产配置](#ce741e7a54261bed)\n  + [2. 策略思路](#cf0127fe1bcb3311)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果分析与稳健性检验](#2a39edb4bd1fa9ab)\n\n# 行业轮动策略\n\n## 1. 原理\n\n### 行业轮动现象\n\n在某一段时间内，某一行业或某几个行业组内股票价格共同上涨或下降的现象。\n\n行业轮动策略是根据行业轮动现象做成的策略，利用行业趋势进行获利的方法，属于主动交易策略。其本质是通过一段时期的市场表现，力求抓住表现较好的行业以及投资品种，选择不同时期的强势行业进行获利。\n\n### 行业轮动的原因\n\n***原因1：行业周期***\n\n行业的成长周期可以分为初创期、成长期、成熟期和衰退期，一般行业会按照这个周期运行。初创期属于行业刚刚起步阶段，风险高、收益小。成长期内风险高、收益高。处于成熟期的企业风险低、收益高。处于衰退期的企业风险低、收益低。在一段时间内，不同的行业会处于不同的行业周期，在时间维度上看会呈现行业轮动现象。\n\n***原因2：国家政策***\n\n国家政策对我国资本市场有重大影响。我国每年的财政政策和货币政策都是市场关注的热点，货币政策和财政政策会释放出影响市场的信息，如利率。当政策释放出下调利率的信号，就为资金需求量大、项目周期长的行业缓解了压力，如房地产行业，这时对于这类行业利好，相应的股价就会上涨。\n\n***原因3：重大事件***\n\n资本市场对于消息的反应是迅速的。根据有效市场理论，在半强式有效市场下，一切已公开的信息都会反映在股价当中。以疫情为例，消息一出迅速拉动医疗行业股价水平，带动行业增长。\n\n### 行业轮动下资产配置\n\n**1. 美林时钟：大类资产配置**\n\n根据经济增长和通货膨胀可以将经济分为四个周期：衰退、复苏、过热、滞涨。\n\n美林时钟分析了四个不同时期，并总结出适合投资的资产类别。\n\n| 周期阶段 | 经济增长 | 通货膨胀 | 最优资产类别 | 最优股票板块 |\n| --- | --- | --- | --- | --- |\n| 衰退 | 下降 | 下降 | 债券 | 防御成长 |\n| 复苏 | 上升 | 下降 | 股票 | 周期成长 |\n| 过热 | 上升 | 上升 | 商品 | 周期价值 |\n| 滞涨 | 下降 | 上升 | 现金 | 防御价值 |\n\n研究宏观经济时主要关注两个变量：GDP和CPI。\n\n其中GDP选择不变价（剔除通货膨胀的影响），关心同比值差分后的符号。如果同比值>0，差分后仍然>0，说明GDP在加速上涨；如果同比值<0,差分后仍然<0，说明GDP在加速下跌。\n\n**当经济增长速度加快时，与国家经济联系紧密的行业如钢铁、煤炭、电力等基建利润也会随之增长。**\n\n**当经济增速放缓是，非周期性的行业如医药、基础消费品、基础建设等行业呈现较强的防御性。**\n\n**当通货膨胀处于较低水平时，市场利率水平也处于较低水平。按照股票估值理论，此时的折现率处于低水平，价格相对而言较高。此时，金融行业的股价会呈现明显的上涨。**\n\n**当通货膨胀处于较高水平时，市场利率较高，此时现金为王，原材料价格走高。与此相关的原材料行业就会表现较好，如天然气、石油等。**\n\n**2. 策略设计**\n\n**行业动量策略**\n\n部分研究表明，行业在日、月频率上会存在动量现象，在周频率上会存在反转现象，也就是行业间轮动。因此，在日和月频率上可以利用行业动量设计策略，如果是在周频率上可以利用反转效应设计策略。  \n（引自：武文超. 中国A股市场的行业轮动现象分析——基于动量和反转交易策略的检验[J]. 金融理论与实践, 2014, 000(009):111-114.）\n\n**行业因子策略**\n\n将行业变量作为一个因子放入多因子模型中，利用多因子模型预测各个行业的周期收益率，采用滚动预测方法每次得到一个样本外预测值，根据这些预测值判断该买入哪些行业，卖出哪些行业。  \n（引自：高波, 任若恩. 基于主成分回归模型的行业轮动策略及其业绩评价[J]. 数学的实践与认识, 2016, 46(019):82-92.）\n\n## 2. 策略思路\n\n策略示例采用第一种策略构建方法，利用行业动量设计策略。为了提高策略速度，以6个行业为例进行演示。\n\n第一步：确定行业指数，获取行业指数收益率。  \n第二步：根据行业动量获取最佳行业指数。  \n第三步：在最佳行业中，选择最大市值的5支股票买入。\n\n回测时间：2017-07-01 08:00:00 到 2017-10-01 16:00:00  \n回测标的：SHSE.000910.SHSE.000909.SHSE.000911.SHSE.000912.SHSE.000913.SHSE.000914  \n(300工业.300材料.300可选.300消费.300医药.300金融)  \n回测初始资金：1000万\n\n## 3. 策略代码\n\n```"
  },
  {
    "strategy_id": "myquant_017",
    "strategy_code": "1. # coding=utf-8\n2. from __future__ import print_function, absolute_import, unicode_literals\n3. from datetime import datetime\n4. import numpy as np\n5. from gm.api import *\n6. import sys\n7. try:\n8. from sklearn import svm\n9. except:\n10. print('请安装scikit-learn库和带mkl的numpy')\n11. sys.exit(-1)\n12. '''\n13. 本策略选取了七个特征变量组成了滑动窗口长度为15天的训练集,随后训练了一个二分类(上涨/下跌)的支持向量机模型.\n14. 若没有仓位则在每个星期一的时候输入标的股票近15个交易日的特征变量进行预测,并在预测结果为上涨的时候购买标的.\n15. 若已经持有仓位则在盈利大于10%的时候止盈,在星期五损失大于2%的时候止损.\n16. 特征变量为:1.收盘价/均值2.现量/均量3.最高价/均价4.最低价/均价5.现量6.区间收益率7.区间标准差\n17. 训练数据为:SHSE.600000浦发银行,时间从2016-04-01到2017-07-30\n18. 回测时间为:2017-07-01 09:00:00到2017-10-01 09:00:00\n19. '''\n\n21. def init(context):\n22. # 订阅浦发银行的分钟bar行情\n23. context.symbol = 'SHSE.600000'\n24. subscribe(symbols=context.symbol, frequency='60s')\n25. start_date = '2016-04-01'  # SVM训练起始时间\n26. end_date = '2017-07-30'  # SVM训练终止时间\n\n28. # 用于记录工作日\n29. # 获取目标股票的daily历史行情\n30. recent_data = history(context.symbol, frequency='1d', start_time=start_date, end_time=end_date, fill_missing='last',\n31. df=True)\n32. days_value = recent_data['bob'].values\n33. days_close = recent_data['close'].values\n34. days = []\n\n36. # 获取行情日期列表\n37. print('准备数据训练SVM')\n38. for i in range(len(days_value)):\n39. days.append(str(days_value[i])[0:10])\n40. x_all = []\n41. y_all = []\n42. for index in range(15, (len(days) - 5)):\n43. # 计算三星期共15个交易日相关数据\n44. start_day = days[index - 15]\n45. end_day = days[index]\n46. data = history(context.symbol, frequency='1d', start_time=start_day, end_time=end_day, fill_missing='last',\n47. df=True)\n48. close = data['close'].values\n49. max_x = data['high'].values\n50. min_n = data['low'].values\n51. amount = data['amount'].values\n52. volume = []\n53. for i in range(len(close)):\n54. volume_temp = amount[i] / close[i]\n55. volume.append(volume_temp)\n56. close_mean = close[-1] / np.mean(close)  # 收盘价/均值\n57. volume_mean = volume[-1] / np.mean(volume)  # 现量/均量\n58. max_mean = max_x[-1] / np.mean(max_x)  # 最高价/均价\n59. min_mean = min_n[-1] / np.mean(min_n)  # 最低价/均价\n60. vol = volume[-1]  # 现量\n61. return_now = close[-1] / close[0]  # 区间收益率\n62. std = np.std(np.array(close), axis=0)  # 区间标准差\n\n64. # 将计算出的指标添加到训练集X\n65. # features用于存放因子\n66. features = [close_mean, volume_mean, max_mean, min_mean, vol, return_now, std]\n67. x_all.append(features)\n\n69. # 准备算法需要用到的数据\n70. for i in range(len(days_close) - 20):\n71. if days_close[i + 20] > days_close[i + 15]:\n72. label = 1\n73. else:\n74. label = 0\n75. y_all.append(label)\n76. x_train = x_all[: -1]\n77. y_train = y_all[: -1]\n\n79. # 训练SVM\n80. context.clf = svm.SVC(C=0.6, kernel='rbf', gamma=0.001)\n81. context.clf.fit(x_train, y_train)\n82. print('训练完成!')\n\n84. def on_bar(context, bars):\n85. bar = bars[0]\n\n87. # 获取当前年月日\n88. today = bar.bob.strftime('%Y-%m-%d')\n\n90. # 获取数据并计算相应的因子\n91. # 于星期一的09:31:00进行操作\n92. # 当前bar的工作日\n93. weekday = datetime.strptime(today, '%Y-%m-%d').isoweekday()\n\n95. # 获取模型相关的数据\n96. # 获取持仓\n97. position = context.account().position(symbol=context.symbol, side=PositionSide_Long)\n\n99. # 如果bar是新的星期一且没有仓位则开始预测\n100. if not position and weekday == 1:\n101. # 获取预测用的历史数据\n102. data = history_n(symbol=context.symbol, frequency='1d', end_time=today, count=15,\n103. fill_missing='last', df=True)\n104. close = data['close'].values\n105. train_max_x = data['high'].values\n106. train_min_n = data['low'].values\n107. train_amount = data['amount'].values\n108. volume = []\n109. for i in range(len(close)):\n110. volume_temp = train_amount[i] / close[i]\n111. volume.append(volume_temp)\n112. close_mean = close[-1] / np.mean(close)\n113. volume_mean = volume[-1] / np.mean(volume)\n114. max_mean = train_max_x[-1] / np.mean(train_max_x)\n115. min_mean = train_min_n[-1] / np.mean(train_min_n)\n116. vol = volume[-1]\n117. return_now = close[-1] / close[0]\n118. std = np.std(np.array(close), axis=0)\n\n120. # 得到本次输入模型的因子\n121. features = [close_mean, volume_mean, max_mean, min_mean, vol, return_now, std]\n122. features = np.array(features).reshape(1, -1)\n123. prediction = context.clf.predict(features)[0]\n\n125. # 若预测值为上涨则开仓\n126. if prediction == 1:\n127. # 获取昨收盘价\n128. context.price = close[-1]\n129. # 把浦发银行的仓位调至95%\n130. order_target_percent(symbol=context.symbol, percent=0.95, order_type=OrderType_Market,\n131. position_side=PositionSide_Long)\n132. print('SHSE.600000以市价单开多仓到仓位0.95')\n\n134. # 当涨幅大于10%,平掉所有仓位止盈\n135. elif position and bar.close / context.price >= 1.10:\n136. order_close_all()\n137. print('SHSE.600000以市价单全平多仓止盈')\n\n139. # 当时间为周五并且跌幅大于2%时,平掉所有仓位止损\n140. elif position and bar.close / context.price < 1.02 and weekday == 5:\n141. order_close_all()\n142. print('SHSE.600000以市价单全平多仓止损')\n\n144. if __name__ == '__main__':\n145. '''\n146. strategy_id策略ID,由系统生成\n147. filename文件名,请与本文件名保持一致\n148. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\n149. token绑定计算机的ID,可在系统设置-密钥管理中生成\n150. backtest_start_time回测开始时间\n151. backtest_end_time回测结束时间\n152. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\n153. backtest_initial_cash回测初始资金\n154. backtest_commission_ratio回测佣金比例\n155. backtest_slippage_ratio回测滑点比例\n156. '''\n157. run(strategy_id='strategy_id',\n158. filename='main.py',\n159. mode=MODE_BACKTEST,\n160. token='token_id',\n161. backtest_start_time='2017-07-01 09:00:00',\n162. backtest_end_time='2017-10-01 09:00:00',\n163. backtest_adjust=ADJUST_PREV,\n164. backtest_initial_cash=10000000,\n165. backtest_commission_ratio=0.0001,\n166. backtest_slippage_ratio=0.0001)",
    "strategy_description": "# 机器学习(股票)\n\n分享\n\n阅读 104353\n 更新 2022-05-09 16:56:48\n\n* [机器学习](#fd355596e307767d)\n  + [1. 原理](#4d68e06c45acd2a2)\n    - [什么是机器学习？](#04cfa6b561edc499)\n    - [什么是支持向量机？](#275d1ccb0824bc2f)\n    - [利用支持向量机预测股票涨跌](#e6a2445e80d3389e)\n    - [参数优化](#c1d8043bae5414dc)\n  + [2. 策略思路](#cf0127fe1bcb3311)\n  + [3. 策略代码](#69a3fc437f0227e3)\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\n\n# 机器学习\n\n## 1. 原理\n\n### 什么是机器学习？\n\n随着计算机技术的发展，投资者不再只局限于传统投资策略，机器学习在资本市场得到广泛应用。机器学习的核心是通过机器模仿人类的思考过程以及思维习惯，通过对现有数据的学习，对问题进行预测和决策。目前，机器学习已在人脸识别、智能投顾、自然语言处理等方面得到广泛应用。\n\n机器学习可以分为两类，一类是无监督学习，另一类是监督学习。监督学习是指按照已有的标记进行学习，即已经有准确的分类信息。比如二分类问题，一类是“好”，另一类是“不好”，这种明确地指出分类基准的问题。这类模型包括：神经网络、决策树、支持向量机等。\n\n无监督学习是指针对未标记过的数据集进行学习。比如聚类问题，没有准确的标准说明应该聚成几类，只有相对概念。这类模型包括：K\\_means聚类、层次聚类法等。\n\n### 什么是支持向量机？\n\n支持向量机是最典型的一类机器学习模型，常用于解决二分类问题。支持向量机的原理是在一个样本空间内，找到一个平面，将样本数据分为两个部分，即两个分类，这个平面就叫做超平面。\n\n**怎样确定超平面？**\n\n假设有一个线性可分的二分类问题如图所示。  \n![](/uploads/202011/attach_16461d0521da1346.png)\n\n已知A、B、C三条线均可以将样本空间分为两类，那么问题来了，应该选择哪一个？\n\nSVM模型指出，如果超平面能够将训练样本没有错误地分开，并且两类训练样本中离超平面最近的样本与超平面之间的距离是最大的，则把这个超平面称作最优超平面，即上图中的B平面。两类样本中距离最优超平面的点成为支持向量，支持向量机模型的名字由此得出。  \n![](/uploads/202011/attach_16461d0732d39ead.png)\n\n支持向量机背后的数学原理十分优美，但由于推导过程过于复杂，这里不再赘述。总之，支持向量机的核心就是寻找最优超平面。\n\n支持向量机不仅可以解决线性可分问题，也可以解决非线性可分问题。其核心思想是将原始样本点映射到高维空间上，将非线性转化为线性可分，在高维空间中找到满足条件的最优超平面，再映射到低维空间中。\n\n### 利用支持向量机预测股票涨跌\n\n在利用支持向量机进行预测之前，先将数据集分为训练集和测试集。常用的分类方法是将数据及进行8:2分解，0.8部分是训练集，0.2部分是测试集。用训练集训练模型，再用测试集评价模型的准确率等指标。\n\n在利用支持向量机预测时，还有很重要的一步是进行参数优化。SVM的参数包括以下几个。\n\n| 参数符号 | 参数说明 |\n| --- | --- |\n| C | 罚函数，错误项的惩罚系数，默认为1。C越大，对错误样本的惩罚力度越大，准确度越高但泛化能力越低（泛化能力是指拓展到测试集中的准确率）。C越小，允许样本增加一点错误，使泛化能力提高。 |\n| Kernel | 核函数，包括linear(线型核函数)、poly(多项式核函数)、rbf(高斯核函数)、sigmod(sigmod核函数)。 |\n| degree | 当核函数选成多项式核函数时对应的阶数。 |\n| Gamma | 核函数系数。 |\n\n还有一些其他的参数，因为本示例不对其进行优化，所以这里不再赘述了。\n\n### 参数优化\n\n本示例采用网格搜索算法优化参数，训练好的参数为C = 0.6, gamma = 0.001,训练后的准确率为 0.50。（这个准确率虽然看起来很低，但在现实生活中准确率都处于较低水平，这里暂时用这个优化后的参数进行建模。）\n\n## 2. 策略思路\n\n第一步：获取原始数据，这里获取2016-04-01到2017-07-30的数据。  \n第二步：计算SVM模型的输入变量。\n\n**x 表示输入的特征值，共7个，分别为：**\n\n| 参数符号 | 计算方法 |\n| --- | --- |\n| x1 | 最新收盘价/15日收盘价均值 |\n| x2 | 现量/15日均量 |\n| x3 | 最新最高价/15日均价 |\n| x4 | 最新最低价/15日均价 |\n| x5 | 现量 |\n| x6 | 15日区间收益率 |\n| x7 | 15日区间标准差 |\n\n**y 表示5个交易日后收盘价是否上涨，**\n\n| 参数符号 | 含义 |\n| --- | --- |\n| y = 1 | 表示股价上涨 |\n| y = 0 | 表示股价下跌 |\n\n第三步：利用训练好的模型预测股价未来走向。若上涨(y=1)则开仓。\n\n第四步：设置止损止盈点。  \n若已经持有仓位则在盈利大于10%的时候止盈，在星期五损失大于2%的时候止损。\n\n回测时间：2017-07-01 09:00:00 到 2017-10-01 09:00:00  \n回测初始资金：1000万  \n回测标的：SHSE.600000\n\n## 3. 策略代码\n\n```"
  }
]