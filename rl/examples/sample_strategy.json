{
    "strategy_id": "turtle_trading",
    "strategy_description": "海龟交易法\n1. 原理\n1.1 起源\n海龟交易思想起源于上世纪八十年代的美国。理查德丹尼斯与好友比尔打赌，主题是一个成功的交易员是天生的还是后天的。理查德用十年时间证明了通过日常系统培训，交易员可以通过后天培训成为一名优秀的交易者。这套培训系统就是海龟交易系统。\n\n海龟交易系统是一个完整的、机械的交易思想，可以系统地完成整个交易过程。它包括了买卖什么、头寸规模、何时买卖、何时退出等一系列交易策略，是一个趋势交易策略。它最显著的特点是捕捉中长期趋势，力求在短期内获得最大的收益。\n\n1.2 建仓资金\n海龟交易法将建仓资金按照一定比例划分为若干个小部分，每次建仓头寸和加仓规模都与波动量N（又称平均真实波动振幅average true range ATR）有关。ATR是日内指数最大波动的平均振幅，由当日最高、最低价和上一交易日的收盘价决定。\n\nATR计算公式：\nTR = max[(当日最高价 - 当日最低价), |当日最高价 - 前一日收盘价|, |当日最低价 - 前一日收盘价|]\nATR = TR在N天内的均值\n\n价值波动量\nDV = N * 合约每点价值\n其中每点代表的价值量是指每一个指数点数所代表的价格。\n每一次开仓交易合约数unit的确定是将总资产的1%除以DV得到。\n\n1.3 入市信号\n海龟交易法使用的是以一个理查德唐奇安的通道突破系统为基础的入市系统。唐奇安通道分为系统一和系统二，对应短期突破和中长期突破。其中，短期突破系统是以20日（最高价或最低价）突破为基础，当价格突破20日价格即为入市信号；中长期系统是当盘中价格突破过去55日价格为入市信号。\n\n1.4 加仓和止损\n海龟交易法的加仓规则是当捕捉到入市信号后建立第一个交易单位的头寸，市价继续向盈利方向突破1/2N时加仓。\n\n止损位为2N,同加仓一样采用平均真实振幅N值为止损单位。每加仓一次，止损位就提高1/2N。\n\n1.5 止盈\n短期：多头头寸在突破过去10日最低价处止盈离市，空头头寸在突破过去10日最高价处止盈离市。\n中长期：多头头寸在突破过去20日最低价处止盈离市，空头头寸在突破过去20日最高价处止盈离市。\n\n回测标的：DCE.i2012\n回测时间：2020-02-15 至 2020-09-01\n回测初始资金：100万\n\nTips：\nATR值是不断变化的，这就会导致在对期货平仓时，可能出现平仓数量 > 持仓数量的现象。比如前一交易日的持仓为10，今日的ATR值为22.假设当前价格触发平仓条件，平仓1/2ATR。1/2ATR=11 > 10, 这样就会导致委托失败报错。所以要加入一个变量volume_hold用来记录当前持仓量，与1/2*ATR作比较。",
    "code": "import pandas as pd\ndef calculate_turtle_signals(data, atr_window=20, unit_risk_percent=0.01, initial_capital=1e6):\n    \"\"\"\n    计算海龟交易法交易信号\n    \n    参数:\n        data: 包含价格数据的DataFrame\n        atr_window: ATR计算窗口大小\n        unit_risk_percent: 单位风险百分比（通常为总资产的1%）\n        initial_capital: 初始资金\n    \n    返回:\n        包含交易信号的DataFrame\n    \"\"\"\n    signals = pd.DataFrame(index=data.index)\n    signals['signal'] = 0.0\n    signals['position'] = 0.0\n    signals['volume_hold'] = 0.0\n    \n    # 计算唐奇安通道\n    signals['short_upper'] = data['Close'].rolling(window=20).max()  # 短期突破通道\n    signals['long_upper'] = data['Close'].rolling(window=55).max()  # 长期突破通道\n    signals['short_lower'] = data['Close'].rolling(window=20).min()  # 短期跌破通道\n    signals['long_lower'] = data['Close'].rolling(window=55).min()  # 长期跌破通道\n    \n    # 计算ATR\n    data['tr'] = np.maximum.reduce([\n        data['High'] - data['Low'],\n        (data['High'] - data['Close'].shift(1)).abs(),\n        (data['Close'].shift(1) - data['Low']).abs()\n    ])\n    data['atr'] = data['tr'].rolling(window=atr_window).mean()\n    \n    # 计算每点价值\n    contract_value_per_point = 100  # 示例值，实际应根据合约特性调整\n    \n    # 计算交易单位\n    dv = data['atr'].iloc[-1] * contract_value_per_point\n    unit_size = int((initial_capital * unit_risk_percent) / dv)\n    \n    # 初始化持仓信息\n    position = 0\n    volume_hold = 0\n    \n    # 生成交易信号\n    for i in range(1, len(data)):\n        if position == 0:  # 无持仓\n            # 短期突破做多\n            if data['Close'].iloc[i] > signals['short_upper'].iloc[i-1]:\n                position = 1\n                volume_hold = unit_size\n            # 短期跌破做空\n            elif data['Close'].iloc[i] < signals['short_lower'].iloc[i-1]:\n                position = -1\n                volume_hold = unit_size\n        else:  # 有持仓\n            # 加仓逻辑（当价格继续向盈利方向突破1/2N）\n            if (position == 1 and data['Close'].iloc[i] >= signals['positions'].iloc[i-1] + 0.5 * data['atr'].iloc[i]) or \\\n               (position == -1 and data['Close'].iloc[i] <= signals['positions'].iloc[i-1] - 0.5 * data['atr'].iloc[i]):\n                volume_hold += unit_size\n            \n            # 止损逻辑（止损位为2N，每加仓一次提高1/2N）\n            if (position == 1 and data['Close'].iloc[i] <= signals['positions'].iloc[i-1] - 2 * data['atr'].iloc[i]) or \\\n               (position == -1 and data['Close'].iloc[i] >= signals['positions'].iloc[i-1] + 2 * data['atr'].iloc[i]):\n                position = 0\n                volume_hold = 0\n            \n            # 止盈逻辑\n            if position == 1:  # 多头头寸\n                # 短期止盈（10日最低价）\n                if data['Close'].iloc[i] < data['Low'].rolling(window=10).min().iloc[i-1]:\n                    position = 0\n                    volume_hold = 0\n                # 中长期止盈（20日最低价）\n                elif data['Close'].iloc[i] < data['Low'].rolling(window=20).min().iloc[i-1]:\n                    position = 0\n                    volume_hold = 0\n            elif position == -1:  # 空头头寸\n                # 短期止盈（10日最高价）\n                if data['Close'].iloc[i] > data['High'].rolling(window=10).max().iloc[i-1]:\n                    position = 0\n                    volume_hold = 0\n                # 中长期止盈（20日最高价）\n                elif data['Close'].iloc[i] > data['High'].rolling(window=20).max().iloc[i-1]:\n                    position = 0\n                    volume_hold = 0\n        \n        signals['position'].iloc[i] = position\n        signals['volume_hold'].iloc[i] = volume_hold\n    \n    return signals"
}