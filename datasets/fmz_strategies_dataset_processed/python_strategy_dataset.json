[
    {
        "strategy_id": "1_BSC-Transaction",
        "strategy_code": "python\n\nfrom web3 import Web3\nimport json\nimport time\nimport urllib.request\n\ndef transaction(my_address, to_address, contract_address, private_key, send, gas):\n    Log(\"start trans \" + contract_coin)\n    bsc = \"https://bsc-dataseed.binance.org/\"\n    web3 = Web3(Web3.HTTPProvider(bsc))\n\n    Log(web3.isConnected())\n\n    balance = web3.eth.get_balance(my_address)\n    humanReadalbe = web3.fromWei(balance, 'ether')\n    Log(humanReadalbe)\n\n    abi = json.loads('[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]')\n\n    nonce = web3.eth.getTransactionCount(my_address)\n\n    contract_address = web3.toChecksumAddress(contract_address)\n    contract = web3.eth.contract(address=contract_address, abi=abi)\n\n    amount = web3.toWei(send, 'ether')\n    Log(amount)\n\n    token_tx = contract.functions.transfer(to_address, amount).buildTransaction({\n        'chainId':56, 'gas': 150000,'gasPrice': web3.toWei(gas,'gwei'), 'nonce':nonce\n    })\n    sign_txn = web3.eth.account.signTransaction(token_tx, private_key=private_key)\n    web3.eth.sendRawTransaction(sign_txn.rawTransaction)\n    Log(\"Transaction has been sent to \" + to_address)\n\ndef transaction_bnb(my_address, to_address, private_key, send, gas):\n    Log(\"start trans \" + contract_coin)\n    bsc = \"https://bsc-dataseed.binance.org/\"\n    web3 = Web3(Web3.HTTPProvider(bsc))\n\n    Log(web3.isConnected())\n\n    balance = web3.eth.get_balance(my_address)\n    humanReadalbe = web3.fromWei(balance, 'ether')\n    Log(humanReadalbe)\n\n    nonce = web3.eth.getTransactionCount(my_address)\n\n    tx = {\n        'nonce': nonce,\n        'to': to_address,\n        'value': web3.toWei(send, 'ether'),\n        'gas': 150000,\n        'gasPrice': web3.toWei(gas, 'gwei')\n    }\n\n    try:\n        signed_tx = web3.eth.account.signTransaction(tx, private_key)\n        tx_hash = web3.eth.sendRawTransaction(signed_tx.rawTransaction)\n        trans = web3.toHex(tx_hash)\n        Log(trans)\n        transaction = web3.eth.get_transaction(trans)\n        Log(\"get \" + trans + \" status!!\")\n    except IOError:\n        Sleep(100)\n        signed_tx = web3.eth.account.signTransaction(tx, private_key)\n        tx_hash = web3.eth.sendRawTransaction(signed_tx.rawTransaction)\n        trans = web3.toHex(tx_hash)\n        Log(\"get hash error retry!!\")\n        transaction = web3.eth.get_transaction(trans)\n        Log(\"get \" + trans + \" status!!\")\n    else:\n        trans_reslut = web3.eth.waitForTransactionReceipt(tx_hash, timeout=30, poll_latency=0.1)\n        trans_reslut = web3.toJSON(trans_reslut)\n        Log(trans_reslut)\n        trans_reslut_status = json.loads(trans_reslut)['status']\n        Log(trans_reslut_status)\n        if trans_reslut_status == 0:\n            Log(\"trans failed retry!!\")\n            transaction_bnb(my_address, to_address, private_key, send, gas)\n\n\ndef doAction():\n    Log(\"Start trasaction!!!\")\n    if contract_coin != 'BNB':\n        transaction(my_address, to_address, contract_address, private_key, send, gas)\n    else:\n        transaction_bnb(my_address, to_address, private_key, send, gas)\n    pass\n    Log(\"trasaction Done!!!\")\n\ndef main():\n    LogReset()\n    while 1:\n        if time.time() > transaction_time:\n            Log(\"Is time to gogogo !!!\")\n            Log(_D(time.time()))\n            doAction()\n            exit(\"End!!!\")\n        pass",
        "strategy_description": "策略名称: BSC-Transaction\n\n未找到描述"
    },
    {
        "strategy_id": "2_BTC-V反策略",
        "strategy_code": "python\n# encoding: utf-8\n\nimport os\nfrom time import time, sleep\nfrom threading import Thread\nfrom socket import socket, AF_INET, SOCK_DGRAM, gethostname, timeout, error\n\nprct = 0.1\npassword = 'test888'\nreq = {}\npos = {}\nrecv = True\ndata = ''\nn=60 #减数触发器，减到零触发\n\ndef trade(req):\n    \"\"\"测试交易\"\"\"\n    for symbol, mpos in req.items():\n        if symbol not in pos.keys():\n            pos[symbol] = 0.0\n        targetPos=round(mpos*prct, 4)\n        Log('targetPos =', targetPos)\n        if targetPos == pos[symbol]:\n            #Log(\"No Trade Operation! client Pos %s is %.3f\" % (symbol, pos[symbol]))\n            continue\n        tick = exchange.GetTicker();\n        if targetPos > pos[symbol]:\n            vol = round(targetPos-pos[symbol], 4)\n            type = 'buy-market'\n            #Log(' Buy btcusdt', vol)\n            id = exchange.Buy(tick.Sell+10, vol)\n            #Log(' Buy btcusdt at %s = %s' %(tick.Sell, vol))\n            Log(\"Order id:\", id);\n        elif targetPos < pos[symbol]:\n            vol = round(pos[symbol]-targetPos, 4)\n            type = 'sell-market'\n            #Log(' Sell btcusdt', vol)\n            id = exchange.Sell(-1, vol)\n            #Log(' Sell btcusdt at %s = %s' %(tick.Buy, vol))\n            Log(\"Order id:\", id);\n        \n        account = exchange.GetAccount()\n        Log(\"账户信息，Balance:\", account.Balance, \"FrozenBalance:\", account.FrozenBalance, \"Stocks:\",\n        account.Stocks, \"FrozenStocks:\", account.FrozenStocks)\n        pos[symbol] = round(account.Stocks, 4)\n        Log('Now Client %s POS = %s' % (symbol, pos[symbol]))\n        \nclass recServer(object):\n    \"\"\"recServer is receving Signal from SigServer\"\"\"\n    def __init__(self, c):\n        self.rcv = True\n        self.t = Thread(target = self.recSig, args = (c,))\n        self.t.start()\n        \n    def recSig(self, c):\n        while self.rcv:\n            try:\n                data, addr = c.recvfrom(1024)\n                #Log('n=',n)\n            except timeout:\n                continue\n            except error:\n                msg = traceback.format_exc()\n                Log(msg)\n                continue\n            if data == 'ok':        \n                #Log('SigServer is alive! Receving \"ok\" from', addr)\n                pass\n            elif 'send password' in data:\n                Log('The client not login, press any key to exit and restart!')\n                self.rcv = False\n            elif not data:\n                Log(\"SigServer is stopped, press any Key to exit SigClient!\")\n                self.rcv = False\n            else:\n                try:\n                    c.sendto('ack', addr)\n                    Log('send ack to ', addr)\n                except error:\n                    Log('Send ack error!')\n                    \n                req = eval(data)\n                Log(req, 'from', addr)\n                trade(req)\n        else:\n            Log('RecSig Thread is Exiting...')\n        return None\n            \n    def heart(self, c, ADDR):      \n        try:\n            c.sendto('live', ADDR)\n        except error:\n            Log('Send keepAlive error!')\n            return None\n                    \n    def close(self):\n        self.rcv = False\n        self.t.join()   \n\ndef main():\n    account = exchange.GetAccount()\n    Log(\"账户信息，Balance:\", account.Balance, \"FrozenBalance:\", account.FrozenBalance, \"Stocks:\",\n        account.Stocks, \"FrozenStocks:\", account.FrozenStocks)\n    pos['btcusdt'] = round(account.Stocks, 4)\n    Log(pos)\n    # 启动UDP客户端\n    c = socket(AF_INET, SOCK_DGRAM)\n    host = '47.98.130.139'\n    port = 1234\n    ADDR = (host, port)\n    c.settimeout(5)\n    try:\n        c.sendto(password, ADDR)\n        data, addr = c.recvfrom(256)\n        Log(data+' from ', addr)\n    except timeout, error:\n        Log('SigServer is not active, client is aborting!')\n        c.close()\n        return None         \n    if 'invalid' in data:\n        Log('\\nYou failed to Login! SigClient is Exiting...')\n        c.close()\n        return None\n\n    # 如果密码正确，开启接收信号模式\n    rc = recServer(c)       \n    sleep(1)\n    global n\n    while recv:\n        n -= 1\n        if not n:\n            rc.heart(c, ADDR)\n            account = exchange.GetAccount()\n            pos['btcusdt'] = round(account.Stocks, 4)\n            #Log(pos)\n            n = 60\n        sleep(1)\n    else:\n        rc.close()\n        Log('Program is End!')",
        "strategy_description": "策略名称: BTC-V反策略\n\nimport os\nfrom time import time, sleep\nfrom threading import Thread\nfrom socket import socket, AF_INET, SOCK_DGRAM, gethostname, timeout, error\n\nprct = 0.1\npassword = 'test888'\nreq = {}\npos = {}\nrecv = True\ndata = ''\nn=60 #减数触发器，减到零触发\n\ndef trade(req):\n    \"\"\"测试交易\"\"\"\n    for symbol, mpos in req.items():\n        if symbol not in pos.keys():\n            pos[symbol] = 0.0\n        targetPos=round(mpos*prct, 4)\n        Log('targetPos =', targetPos)\n        if targetPos == pos[symbol]:\n            #Log(\"No Trade Operation! client Pos %s is %.3f\" % (symbol, pos[symbol]))\n            continue\n        tick = exchange.GetTicker();\n        if targetPos > pos[symbol]:\n            vol = round(targetPos-pos[symbol], 4)\n            type = 'buy-market'\n            #Log(' Buy btcusdt', vol)\n            id = exchange.Buy(tick.Sell+10, vol)\n            #Log(' Buy btcusdt at %s = %s' %(tick.Sell, vol))\n            Log(\"Order id:\", id);\n        elif targetPos < pos[symbol]:\n            vol = round(pos[symbol]-targetPos, 4)\n            type = 'sell-market'\n            #Log(' Sell btcusdt', vol)\n            id = exchange.Sell(-1, vol)\n            #Log(' Sell btcusdt at %s = %s' %(tick.Buy, vol))\n            Log(\"Order id:\", id);\n        \n        account = exchange.GetAccount()\n        Log(\"账户信息，Balance:\", account.Balance, \"FrozenBalance:\", account.FrozenBalance, \"Stocks:\",\n        account.Stocks, \"FrozenStocks:\", account.FrozenStocks)\n        pos[symbol] = round(account.Stocks, 4)\n        Log('Now Client %s POS = %s' % (symbol, pos[symbol]))\n        \nclass recServer(object):\n    \"\"\"recServer is receving Signal from SigServer\"\"\"\n    def __init__(self, c):\n        self.rcv = True\n        self.t = Thread(target = self.recSig, args = (c,))\n        self.t.start()\n        \n    def recSig(self, c):\n        while self.rcv:\n            try:\n                data, addr = c.recvfrom(1024)\n                #Log('n=',n)\n            except timeout:\n                continue\n            except error:\n                msg = traceback.format_exc()\n                Log(msg)\n                continue\n            if data == 'ok':        \n                #Log('SigServer is alive! Receving \"ok\" from', addr)\n                pass\n            elif 'send password' in data:\n                Log('The client not login, press any key to exit and restart!')\n                self.rcv = False\n            elif not data:\n                Log(\"SigServer is stopped, press any Key to exit SigClient!\")\n                self.rcv = False\n            else:\n                try:\n                    c.sendto('ack', addr)\n                    Log('send ack to ', addr)\n                except error:\n                    Log('Send ack error!')\n                    \n                req = eval(data)\n                Log(req, 'from', addr)\n                trade(req)\n        else:\n            Log('RecSig Thread is Exiting...')\n        return None\n            \n    def heart(self, c, ADDR):      \n        try:\n            c.sendto('live', ADDR)\n        except error:\n            Log('Send keepAlive error!')\n            return None\n                    \n    def close(self):\n        self.rcv = False\n        self.t.join()   \n\ndef main():\n    account = exchange.GetAccount()\n    Log(\"账户信息，Balance:\", account.Balance, \"FrozenBalance:\", account.FrozenBalance, \"Stocks:\",\n        account.Stocks, \"FrozenStocks:\", account.FrozenStocks)\n    pos['btcusdt'] = round(account.Stocks, 4)\n    Log(pos)\n    # 启动UDP客户端\n    c = socket(AF_INET, SOCK_DGRAM)\n    host = '47.98.130.139'\n    port = 1234\n    ADDR = (host, port)\n    c.settimeout(5)\n    try:\n        c.sendto(password, ADDR)\n        data, addr = c.recvfrom(256)\n        Log(data+' from ', addr)\n    except timeout, error:\n        Log('SigServer is not active, client is aborting!')\n        c.close()\n        return None         \n    if 'invalid' in data:\n        Log('\\nYou failed to Login! SigClient is Exiting...')\n        c.close()\n        return None\n\n    # 如果密码正确，开启接收信号模式\n    rc = recServer(c)       \n    sleep(1)\n    global n\n    while recv:\n        n -= 1\n        if not n:\n            rc.heart(c, ADDR)\n            account = exchange.GetAccount()\n            pos['btcusdt'] = round(account.Stocks, 4)\n            #Log(pos)\n            n = 60\n        sleep(1)\n    else:\n        rc.close()\n        Log('Program is End!')\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/117202\n\n> Last Modified\n\n2018-09-27 21:45:01"
    },
    {
        "strategy_id": "3_BTCUSDT量化交易执行体",
        "strategy_code": "python\nfrom okex.trade import trade,pos_info,acc_info,select_last\nimport okex.api as api\nimport okex.Trade_api as Trade\nimport time\nimport json\nfrom okex.log import log\n\n# 策略源码完整版下载地址 https://github.com/Find-Dream/BTCUSDT\n\ndef main():\n    nowtime = time.time()\n    st = time.localtime(nowtime)\n    update = time.strftime('%Y-%m-%d',st)\n    filenamedate = time.strftime('%Y%m%d',st)\n    logfilename = 'mark_'+ str(filenamedate)\n\n    log(logfilename,'========================【获取基础信息开始】========================')\n\n    btcusdt_api_data = api.btcusdt_api()\n\n    log(logfilename,'btcusdt_api_data：'+str(btcusdt_api_data))\n\n    btcusdt_api = btcusdt_api_data['rule']\n    log(logfilename,'btcusdt_api'+str(btcusdt_api))\n\n    pos_api = btcusdt_api_data['pos']\n    log(logfilename,'pos_api'+str(pos_api))\n\n    pos_okex = {}\n    acc_okex = {}\n    try:\n        acc_api = api.select_acc()\n        log(logfilename,'读取本地保存的账户信息'+str(acc_api))\n    except:\n        acc_okex['lever'] = 1\n\n\n    acc_info_data = acc_info()[0]['details']\n\n\n    for i in acc_info_data:\n        if i['ccy'] == 'USDT':\n            acc_okex['ccy'] = i['cashBal']\n            log(logfilename,'读取接口账户余额'+str(i['cashBal']))\n\n    for i in pos_info():\n        if i['mgnMode'] == 'cross' and i['posSide'] == 'long':\n            pos_okex['long'] = i['pos']\n            if i['pos'] != '0':\n                acc_okex['lever'] = i['lever']\n                log(logfilename,'读取接口long账户杠杆倍数：'+str(i['lever']))\n            else:\n                acc_okex['lever'] = acc_api['lever']\n                log(logfilename,'读取本地long账户杠杆倍数：'+str(acc_api['lever']))\n        elif i['mgnMode'] == 'cross' and i['posSide'] == 'short':\n            pos_okex['short'] = i['pos']\n            if i['pos'] != '0':\n                acc_okex['lever'] = i['lever']\n                log(logfilename,'读取接口short账户杠杆倍数：'+str(i['lever']))\n            \n\n    api.set_acc(json.dumps(acc_okex))\n    log(logfilename,'写入本地账户信息：'+str(acc_okex))\n    last = float(select_last())\n    log(logfilename,'读取当前价格：'+str(last))\n\n    max_sz = int(float(acc_okex['ccy']) * float(acc_okex['lever']) / last * 100)\n    log(logfilename,'最大交易量：'+str(max_sz))\n\n    sz_r = max_sz / 20\n    log(logfilename,'交易量系数：'+str(sz_r))\n\n    pos_api_id = int(btcusdt_api['id'])\n    pos_api_posSide = btcusdt_api['posside']\n    pos_api_side = btcusdt_api['side']\n    pos_api_sz = int(int(btcusdt_api['sz']) * sz_r)\n    pos_api_uptime = int(btcusdt_api['uptime'])\n    pos_api_long = int(int(pos_api['long']) * sz_r)\n    pos_api_short = int(int(pos_api['short']) * sz_r)\n\n    log(logfilename,'pos_api_long：'+str(pos_api_long)+',pos_api_short:'+str(pos_api_short)+',pos_api_sz:'+str(pos_api_sz))\n    log(logfilename,'本地仓位信息pos_okex：'+str(pos_okex))\n\n\n    try:\n        pos_log_done = int(api.pos_log_done())\n    except:\n        pos_log_done = api.pos_log_done()\n    \n    log(logfilename,'pos_log_done:'+str(pos_log_done))\n\n    log(logfilename,'========================【获取基础信息结束】========================')\n    log(logfilename,'========================【mark任务开始】========================')\n    log(logfilename,'判断pos_log_done_id是否为int型:'+str(type(pos_log_done)))\n    if isinstance(pos_log_done,int):\n        log(logfilename,'pos_log_done_id为int型，判断pos_log_done_id与pos_log_id,pos_api_id:'+str(pos_api_id)+',pos_log_done:'+str(pos_log_done))\n        if pos_api_id > pos_log_done:\n            log(logfilename,'API的pos_log_id大于pos_log_done_id，判断API更新时间是否在10秒以内,nowtime:'+str(nowtime)+',pos_api_uptime:'+str(pos_api_uptime))\n            if nowtime < (pos_api_uptime + 13):\n                log(logfilename,'api更新时间在10秒内，判断api交易方向,pos_api_posSide'+str(pos_api_posSide)+',pos_api_side:'+str(pos_api_side))\n                if pos_api_posSide == 'long' and pos_api_side == 'buy':\n                    log(logfilename,'api交易方向：long-buy，判断当前持仓信息与api是否一致')\n                    if int(pos_okex['long']) + int(pos_api_sz) == int(pos_api_long):\n                        log(logfilename,'当前持仓信息与api一致，执行交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_long)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    elif int(pos_okex['long']) + int(pos_api_sz) < int(pos_api_long):\n                        log(logfilename,'当前持仓信息与api一致，执行交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_long)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    else:\n                        log(logfilename,'long仓信息不一致，请将long仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_long)+',API交易数量：'+str(pos_api_sz))\n\n                elif pos_api_posSide == 'long' and pos_api_side == 'sell':\n                    log(logfilename,'api交易方向：long-sell，判断是否符合平仓条件')\n                    if int(pos_okex['long']) > 0:\n                        log(logfilename,'符合平仓条件，当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,int(pos_okex['long']),pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    else:\n                        log(logfilename,'long仓信息不一致，请将long仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n\n                elif pos_api_posSide == 'short' and pos_api_side == 'sell':\n                    log(logfilename,'api交易方向：short-sell，判断当前持仓信息与api是否一致')\n                    if int(pos_okex['short']) + int(pos_api_sz) == int(pos_api_short):\n                        log(logfilename,'符合开仓条件，执行交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    elif int(pos_okex['short']) + int(pos_api_sz) < int(pos_api_short):\n                        log(logfilename,'符合开仓条件，执行交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    else:\n                        log(logfilename,'short仓信息不一致，请将short仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n\n                elif pos_api_posSide == 'short' and pos_api_side == 'buy':\n                    log(logfilename,'api交易方向：short-buy，判断是否符合平仓条件')\n                    if int(pos_okex['short']) > 0:\n                        log(logfilename,'符合平仓条件，当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_okex['short'],pos_api_id)\n                        log(logfilename,'执行结果：'+str(trade_ok))\n                    else:\n                        log(logfilename,'short仓信息不一致，请将short仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\n            else:\n                log(logfilename,'api更新时间超过10秒内，已错过最佳交易时间,nowtime:'+str(nowtime)+',pos_api_uptime:'+str(pos_api_uptime))\n        else:\n            log(logfilename,'API的pos_log_id不大于pos_log_done_id，api无新数据，继续执行监控,pos_api_id:'+str(pos_api_id)+',pos_log_done:'+str(pos_log_done))\n    else:\n        log(logfilename,'pos_log_done_id不为int型')\n        api.set_pos_log_done(pos_api_id)\n    log(logfilename,'========================【mark任务结束】========================')",
        "strategy_description": "策略名称: BTCUSDT量化交易执行体\n\n- 如果你不是运行在固定IP的云主机上的话，请不要设置绑定IP，否则无法使用；\n- 为了你的账号安全申请API时，请勾选只读和交易权限，请勿勾选提现权限；\n- `okex_api.json`中的flag为交易盘选项，0为真实盘，1为模拟盘；"
    },
    {
        "strategy_id": "4_BitMEX-高级API功能-V110-期货批量下单编辑订单冰山订单一键撤单定时撤单-Python2-3",
        "strategy_code": "python\n\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n# BitMEX Advanced API Interface for FMZ.com.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# GNU General Public License v3.0\n#\n\nimport json\nimport math\nimport decimal\n\ndef toNearest(num, tickSize):\n    tickDec = decimal.Decimal(str(tickSize))\n    return float((decimal.Decimal(round(num / tickSize, 0)) * tickDec))\n\nQUOTES = {}\nQUOTES['ZH'] = {\n    'GREET' : '[BitMEX 接口已初始化]  合约: %s. %s',\n    'INITF' : '使用的交易所不正确，当前交易所: %s',\n    'PARAMERR' : '***传的参数不对 检查你的代码*** %s',\n    'NEWORDER' : '[添加订单]  合约: %s 方向: %s 价格: %.8f 数量: %d 张. %s',\n    'MODORDER' : '[修改订单]  orderID/clOrdID: %s 新价格: %.8f 新数量: %d. %s',\n    'MODORDERP' : '[修改订单]  orderID/clOrdID: %s 新价格: %.8f. %s',\n    'MODORDERA' : '[修改订单]  orderID/clOrdID: %s 新数量: %d. %s',\n    'ORDCOUNT' : '[本次批量发送订单]  总计: %d 条. %s',\n    'THISBATCH' : '[信息]  正在处理 合约: %s 条数: %d. %s',\n    'CLEARALL' : '[信息]  已清除所有本地订单. %s',\n    'CLEAR' : '[信息]  已清除所有 %s 本地订单. %s',\n    'CA' : '[订单计划取消]  所有订单都将在 %d 毫秒 后取消. %s'\n}\n\nCOLORS = {\n    'DEEPBLUE' : '#1F618D',\n    'BLUE' : '#0000FF',\n    'LIGHTBLUE' : '#5DADE2',\n    'DEEPGREEN' : '#27AE60',\n    'GREEN' : '#00FF00',\n    'LIGHTGREEN' : '#58D68D',\n    'LAPIS' : '#26619C',\n    'DEEPRED' : '#CB4335',\n    'RED' : '#FF0000',\n    'LIGHTRED' : '#EC7063'\n}\n\n\nclass BitMEX:\n\n    def __init__(self, exchange, silent=False):\n        self.silent = silent\n        exchange.GetCurrency()\n        if isinstance(exchange.GetCurrency(), bytes):\n            self.symbol = str(exchange.GetCurrency(), \"utf-8\").lower()\n            name = str(exchange.GetName(), \"utf-8\")\n        else:\n            self.symbol = exchange.GetCurrency()\n            name = exchange.GetName()\n        self.IO = exchange.IO\n        self.bulks = []\n        self.amends = []\n        if 'BitMEX' in str(name):\n            self.Log(QUOTES[LANG]['GREET'] % (self.symbol.upper(),COLORS['LAPIS']))\n        else:\n            Log(QUOTES[LANG]['INITF'] % (name))\n            \n    def Log(self, *args):\n        if self.silent:\n            return \n        Log(*args)\n\n    def BulkAdd(self, side=None, price=None, amount=None, symbol=None, ordType='Limit', displayQty=None, clOrdID=None, execInst=None):\n        if type is None or price is None or amount is None:\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n            return False\n        side = side.lower()\n        if 'sell' in side:\n            side = 'Sell'\n            cl = COLORS['DEEPRED']\n        else:\n            side = 'Buy'\n            cl = COLORS['DEEPGREEN']\n        if symbol is None:\n            symbol = self.symbol\n\n        # Order structure\n        order = {}\n        order['symbol'] = symbol.upper()            # Symbol\n        order['price'] = price                      # Price\n        order['side'] = side                        # Buy/Sell\n        order['orderQty'] = int(amount)             # Amount\n\n        # Valid order types\n        # Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched, MarketWithLeftOverAsLimit, Pegged\n        # Limit: The default order type. Specify an orderQty and price.\n        # Market: A traditional Market order. A Market order will execute until filled or your bankruptcy price is reached, at which point it will cancel.\n        # MarketWithLeftOverAsLimit: A market order that, after eating through the order book as far as permitted by available margin, will become a limit order. The difference between this type and Market only affects the behavior in thin books. Upon reaching the deepest possible price, if there is quantity left over, a Market order will cancel the remaining quantity. MarketWithLeftOverAsLimit will keep the remaining quantity in the books as a Limit.\n        # Stop: A Stop Market order. Specify an orderQty and stopPx. When the stopPx is reached, the order will be entered into the book.\n        ## On sell orders, the order will trigger if the triggering price is lower than the stopPx. On buys, higher.\n        ## Note: Stop orders do not consume margin until triggered. Be sure that the required margin is available in your account so that it may trigger fully.\n        ## Close Stops don't require an orderQty. See Execution Instructions below.\n        # StopLimit: Like a Stop Market, but enters a Limit order instead of a Market order. Specify an orderQty, stopPx, and price.\n        # MarketIfTouched: Similar to a Stop, but triggers are done in the opposite direction. Useful for Take Profit orders.\n        # LimitIfTouched: As above; use for Take Profit Limit orders.\n        order['ordType'] = ordType\n        # If you want to keep track of order IDs yourself, set a unique clOrdID per order. This clOrdID will come back as a property on the order and any related executions (including on the WebSocket), and can be used to get or cancel the order. Max length is 36 characters.\n        if clOrdID is not None:\n            order['clOrdID'] = clOrdID\n        # The following execInsts are supported. If using multiple, separate with a comma (e.g. LastPrice,Close).\n        # ParticipateDoNotInitiate, MarkPrice, LastPrice, IndexPrice, ReduceOnly, Close\n        # ParticipateDoNotInitiate: Also known as a Post-Only order. If this order would have executed on placement, it will cancel instead.\n        # MarkPrice, LastPrice, IndexPrice: Used by stop and if-touched orders to determine the triggering price. Use only one. By default, 'MarkPrice' is used. Also used for Pegged orders to define the value of 'LastPeg'.\n        # ReduceOnly: A 'ReduceOnly' order can only reduce your position, not increase it. If you have a 'ReduceOnly' limit order that rests in the order book while the position is reduced by other orders, then its order quantity will be amended down or canceled. If there are multiple 'ReduceOnly' orders the least aggressive will be amended first.\n        # Close: 'Close' implies 'ReduceOnly'. A 'Close' order will cancel other active limit orders with the same side and symbol if the open quantity exceeds the current position. This is useful for stops: by canceling these orders, a 'Close' Stop is ensured to have the margin required to execute, and can only execute up to the full size of your position. If orderQty is not specified, a 'Close' order has an orderQty equal to your current position's size.\n        ## Note that a Close order without an orderQty requires a side, so that BitMEX knows if it should trigger above or below the stopPx.\n        if execInst is not None:\n            order['execInst'] = execInst\n            if 'Close' in execInst:\n                del order['orderQty']\n        # Optional quantity to display in the book. Use 0 for a fully hidden order. (Iceberg Order)\n        if displayQty is not None:\n            order['displayQty'] = displayQty\n\n        self.bulks.append(order)\n\n        self.Log(QUOTES[LANG]['NEWORDER'] % (symbol.upper(),side.upper(),price,amount,cl))\n\n        return True\n\n    def BulkClear(self, symbol=None, notify=True):\n        ret = []\n        if symbol is None:\n            ret = self.bulks\n            self.bulks = []\n            if notify:\n                self.Log(QUOTES[LANG]['CLEARALL'] % (COLORS['RED']))\n        else:\n            new = []\n            for i in self.bulks:\n                if i['symbol'] != symbol:\n                    new.append(i)\n                else:\n                    ret.append(i)\n            self.bulks = new\n            self.Log(QUOTES[LANG]['CLEAR'] % (symbol.encode().upper(), COLORS['RED']))\n\n        return ret\n\n    def BulkPost(self, symbol=None):\n        orders = []\n        if symbol is None:\n            orders = self.BulkClear(notify=False)\n        else:\n            orders = self.BulkClear(symbol=symbol, notify=False)\n            \n        if len(orders) == 0:\n            return True\n\n        ret = self.IO(\"api\", \"POST\", \"/api/v1/order/bulk\", 'orders=%s' % json.dumps(orders))\n\n        self.Log(QUOTES[LANG]['ORDCOUNT'] % (len(orders),COLORS['LAPIS']))\n        return ret\n\n    def BulkOrders(self):\n        return self.bulks\n\n    def Amend(self, symbol=None, orderID=None, clOrdID=None, price=None, amount=None):\n        if symbol is None:\n            symbol = self.symbol\n\n        order = {}\n        order['symbol'] = symbol\n        if orderID is None:\n            if clOrdID is None:\n                Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n                return False\n            else:\n                order['clOrdID'] = clOrdID\n        else:\n            order['orderID'] = orderID\n\n        if price is not None:\n            order['price'] = price\n        if amount is not None:\n            order['orderQty'] = amount\n\n        if price is None and amount is None:\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n            return False\n\n        ret = self.IO(\"api\", \"PUT\", \"/api/v1/order/bulk\", 'orders=%s' % json.dumps([order]))\n        if ret == False:\n            return False\n\n        try:\n            id = order['orderID']\n        except:\n            id = order['clOrdID']\n\n        if price is None:\n            self.Log(QUOTES[LANG]['MODORDERA'] % (id, amount, COLORS['LAPIS']))\n            return ret\n        elif amount is None:\n            self.Log(QUOTES[LANG]['MODORDERP'] % (id, price, COLORS['LAPIS']))\n            return ret\n        else:\n            self.Log(QUOTES[LANG]['MODORDER'] % (id, price, amount, COLORS['LAPIS']))\n            return ret\n\n    def AmendAdd(self, symbol=None, orderID=None, clOrdID=None, price=None, amount=None):\n        if symbol is None:\n            symbol = self.symbol\n\n        order = {}\n        order['symbol'] = symbol\n        if orderID is None:\n            if clOrdID is None:\n                Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n                return False\n            else:\n                order['clOrdID'] = clOrdID\n        else:\n            order['orderID'] = orderID\n\n        if price is not None:\n            order['price'] = price\n        if amount is not None:\n            order['orderQty'] = amount\n\n        if price is None and amount is None:\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n            return False\n\n        self.amends.append(order)\n\n        try:\n            id = order['orderID']\n        except:\n            id = order['clOrdID']\n\n        if price is None:\n            self.Log(QUOTES[LANG]['MODORDERA'] % (id, amount, COLORS['LAPIS']))\n            return True\n        elif amount is None:\n            self.Log(QUOTES[LANG]['MODORDERP'] % (id, price, COLORS['LAPIS']))\n            return True\n        else:\n            self.Log(QUOTES[LANG]['MODORDER'] % (id, price, amount, COLORS['LAPIS']))\n            return True\n\n    def AmendClear(self, symbol=None, notify=True):\n        ret = []\n        if symbol is None:\n            ret = self.amends\n            self.amends = []\n            if notify:\n                self.Log(QUOTES[LANG]['CLEARALL'] % (COLORS['RED']))\n        else:\n            new = []\n            for i in self.amends:\n                if i['symbol'] != symbol:\n                    new.append(i)\n                else:\n                    ret.append(i)\n            self.self.amends = new\n            self.Log(QUOTES[LANG]['CLEAR'] % (symbol.encode().upper(), COLORS['RED']))\n\n        return ret\n\n    def AmendPost(self, symbol=None):\n        if symbol is None:\n            symbol = self.symbol\n        orders = self.AmendClear(symbol=symbol, notify=False)\n        if len(orders) == 0:\n            return True\n        param = \"orders=\" + json.dumps(orders)\n        self.Log(QUOTES[LANG]['ORDCOUNT'] % (len(orders),COLORS['LAPIS']))\n        return self.IO(\"api\", \"PUT\", \"/api/v1/order/bulk\", param)\n\n    def AmendOrders(self):\n        return self.amends\n\n    def CancelAllOrders(self, symbol=None, filters=None):\n        param = ''\n        if symbol is not None:\n            param = param + 'symbol=' + symbol\n        if filters is not None:\n            param = param + 'filters=' + json.dumps(filters)\n        return self.IO(\"api\",\"DELETE\",\"/api/v1/order/all\", param)\n\n    def CancelAllAfter(self, timeout=0, notify=True):\n        param = 'timeout=' + str(timeout)\n        if notify:\n            self.Log(QUOTES[LANG]['CA'] % (timeout,COLORS['LAPIS']))\n        return self.IO(\"api\",\"POST\",\"/api/v1/order/cancelAllAfter\", param)\n\n    def GetInstrument(self, symbol='XBTUSD'):\n        try:\n            import requests\n        except ModuleNotFoundError:\n            Log('pip安装requests以使用GetInstrument()函数.')\n            return {}\n        return requests.get('https://www.bitmex.com/api/v1/instrument?symbol=%s&count=1&reverse=false' % symbol).json()[0]\n\next.BitMEXPlus = BitMEX # 导出BitMEX Class, 主策略可以通过BitMEXPlus = ext.BitMEXPlus(exchange)调用\next.toNearest = toNearest\n\n# 模块功能测试\ndef main():\n    LogReset()\n    Log(exchange.GetAccount())\n    BitMEXPlus = ext.BitMEXPlus(exchange)\n    exchange.SetContractType(exchange.GetCurrency())\n    base_price = exchange.GetTicker()['Last']\n    _toNearest = ext.toNearest\n    BitMEXPlus.BulkAdd('sell', _toNearest(base_price*1.4, 0.5), 30)\n    BitMEXPlus.BulkAdd('buy', _toNearest(base_price*0.7, 0.5), 30)\n    Log(BitMEXPlus.BulkOrders())\n    Log(BitMEXPlus.BulkPost())\n    Log(exchange.GetOrders())\n    Log(BitMEXPlus.CancelAllAfter(5000))\n    Sleep(8000)\n    Log(exchange.GetOrders())\n    Log(BitMEXPlus.BulkOrders())",
        "strategy_description": "策略名称: BitMEX-高级API功能-V110-期货批量下单编辑订单冰山订单一键撤单定时撤单-Python2-3\n\n### 初始化\n这个库整合了一些高级的 BitMEX API 功能，使用前需要进行初始化。\n```"
    },
    {
        "strategy_id": "5_Bn-获取精度最小变动单位-稳定交易系统必备",
        "strategy_code": "python\n#!Python3\n\n\"\"\"\n《策略代写》 与 （此程序帮助），致信QQ：35787501\n\n币安合约，可用于解决开单 因精度而产生异常 的问题，获取最小变动单位，用于稳定交易系统的运行\n\"\"\"\n\nimport requests\n\n\ndef get_min_size(symbol: str, host=\"https://www.binancezh.jp\"):\n    \n    \"\"\"\n    获取最小变动单位\n    Args:\n        symbol: 交易对(str)\n                例如: ETHUSDT 等\n        host: 域名将影响访问超时\n              国外地址: https://fapi.binance.com\n              国内地址（变动后需要替换）: https://www.binancezh.jp\n    Returns:\n        最小变动价格(str)，最小变动数量(str)\n    \"\"\"\n    \n    tick_size, step_size = None, None\n    symbols_info = requests.get(f\"{host}/fapi/v1/exchangeInfo\", timeout=5).json()[\"symbols\"]\n    \n    for info in symbols_info:\n        if symbol == info[\"symbol\"]:\n            tick_size, step_size = info[\"filters\"][0][\"tickSize\"], info[\"filters\"][1][\"stepSize\"]\n            break\n            \n    return tick_size, step_size\n\n\ndef main():\n    tick_size, step_size = get_min_size(\"ETHUSDT\")\n    Log(tick_size, step_size)",
        "strategy_description": "策略名称: Bn-获取精度最小变动单位-稳定交易系统必备\n\n未找到描述"
    },
    {
        "strategy_id": "6_CoinPark交易所通用协议-627-1600-更新-关闭了SSL验证",
        "strategy_code": "python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n'''\nCoinPark通用协议,使用Python2.7\n运行地址：http://127.0.0.1:6667，端口可指定\n由于账户没资产，未作详细测试，欢迎反馈Bug\nQQ:1051804485\n反馈地址：https://www.botvs.com/bbs-topic/1963\n2018.6.26 15:57 更新，修改了Bug\n可以把通用协议当成普通机器人，运行在BotVs模拟盘即可，不收取费用\n为了使用IO函数，需要重载exchange里的rpc方法，js的例子如下：\nexchange.rpc = function(path, obj) {\n    return exchange.IO(\"api\",\"POST\", path, \"obj=\"+escape(JSON.stringify(obj)));\n}\nfunction main() {\n\tLog(exchange.rpc(\"/transfer\", {cmd: \"transfer/assets\", body: {select:1}}));\n}\n'''\nfrom BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\nimport json\nimport urllib\nimport urllib2\nimport time\nimport hmac\nimport hashlib\nimport random\nimport ssl\nssl._create_default_https_context = ssl._create_unverified_context\n\ndef httpGet(url):\n    headers = {'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'}\n    req = urllib2.Request(url,headers=headers)\n    response = urllib2.urlopen(req)\n    return json.loads(response.read())\n\ndef getsign(data,secret):\n    result = hmac.new(secret.encode(\"utf-8\"), data.encode(\"utf-8\"), hashlib.md5).hexdigest()\n    return result\n\ndef httpPostWithSign(url, cmds, api_key, api_secret):\n    headers = {'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'}\n    s_cmds = json.dumps(cmds)\n    sign = getsign(s_cmds,api_secret)\n    req = urllib2.Request(url, urllib.urlencode({'cmds': s_cmds, 'apikey': api_key,'sign':sign}), headers=headers)\n    response = urllib2.urlopen(req)\n    return json.loads(response.read())\n\nclass MyExchange:\n\n    market_url = \"https://api.coinpark.cc/v1/mdata\"\n    trade_url = \"https://api.coinpark.cc/v1\"\n    kline_period = {1:'1min', 3:'3min', 5:'5min', 15:'15min', 30:'30min',\\\n                    60:'1hour', 120:'2hour', 240:'4hour', 360:'6hour', \\\n                    60*12:'12hour', 60*24:'day', 60*24*7:'week'}\n    @staticmethod\n    def GetTicker(symbol):\n        url = MyExchange.market_url + \"?cmd=ticker&pair=\" + symbol\n        raw_data = httpGet(url)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\": {\"time\": raw_data['result']['timestamp'], \"buy\": raw_data['result']['buy'],\\\n                    \"sell\": raw_data['result']['sell'], \"last\": raw_data['result']['last'],\\\n                    \"high\": raw_data['result']['high'], \"low\": raw_data['result']['low'],\\\n                    \"vol\": raw_data['result']['vol']}}\n        return ret_data\n    @staticmethod\n    def GetDepth(symbol):\n        url = MyExchange.market_url + \"?cmd=depth&size=10&pair=\" + symbol\n        raw_data = httpGet(url)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\" : {\"time\" : raw_data['result']['update_time'], \"asks\" : [], \"bids\" : []}}\n        for bid in raw_data['result']['bids']:\n            ret_data['data']['bids'].append([bid['price'],bid['volume']])\n        for ask in raw_data['result']['asks']:\n            ret_data['data']['asks'].append([ask['price'],ask['volume']])\n        return ret_data\n    @staticmethod\n    def GetRecords(symbol, period):\n        url = MyExchange.market_url + \"?cmd=kline&size=200&period=%s&pair=\"%MyExchange.kline_period[period] + symbol\n        raw_data = httpGet(url)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\": []}\n        for kline in raw_data['result']:\n            ret_data['data'].append([kline['time'], kline['open'], kline['high'],\\\n            kline['low'], kline['close'], kline['vol']])\n        return ret_data\n    @staticmethod\n    def GetTrades(symbol):\n        url = MyExchange.market_url + \"?cmd=deals&size=50&pair=\" + symbol\n        raw_data = httpGet(url)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\":[]}\n        for trade in raw_data[\"result\"]:\n            ret_data[\"data\"].append({\"id\":trade[\"id\"], \"time\":trade[\"time\"], \\\n            \"price\":trade[\"price\"], \"amount\":trade[\"amount\"],\"type\":\"buy\" if int(trade[\"side\"])==1 else \"sell\"})\n        return ret_data\n    @staticmethod\n    def GetAccount(api_key, api_secret):\n        url = MyExchange.trade_url + \"/transfer\"\n        cmds = [{\"cmd\": \"transfer/assets\", \"body\": {\"select\":1}}]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\": []}\n        if \"assets_list\" in raw_data[\"result\"][0][\"result\"].keys():\n            for asset in raw_data[\"result\"][0][\"result\"][\"assets_list\"]:\n                ret_data[\"data\"].append({\"currency\":asset[\"coin_symbol\"], \\\n                \"free\":asset[\"balance\"], \"frozen\":asset[\"freeze\"]})\n        ret_data[\"raw\"] = raw_data[\"result\"]\n        return ret_data\n    @staticmethod\n    def Trade(api_key, api_secret, pair, order_type, order_side, price, amount):\n        url = MyExchange.trade_url + \"/orderpending\"\n        cmds = [{\n                'cmd':\"orderpending/trade\",\n                'index': random.randint(0,2000), \n                'body':{\n                    'pair':pair,\n                    'account_type':0,\n                    'order_type':order_type,\n                    'order_side':order_side,\n                    'price':price,\n                    'amount':amount,\n                    }\n                }]\n        if order_type==1:\n            cmds['money'] = amount\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\": {'id':raw_data['result'][0]['result']}}\n        return ret_data\n    @staticmethod\n    def CancelOrder(api_key, api_secret, orders_id):\n        url = MyExchange.trade_url + \"/orderpending\"\n        cmds = [{\n                'cmd':\"orderpending/cancelTrade\",\n                'index': random.randint(0,2000), \n                'body':{'orders_id':orders_id}\n                }]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\":True}\n        try:\n            result = raw_data['result'].encode('utf8')\n        except:\n            ret_data = {\"data\":False}\n        ret_data['raw'] = raw_data\n        return ret_data\n    @staticmethod\n    def GetOrder(api_key, api_secret, orders_id):\n        url = MyExchange.trade_url + \"/orderpending\"\n        cmds = [{\n                'cmd':\"orderpending/order\",\n                'index': random.randint(0,2000), \n                'body':{'id':orders_id}\n                }]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        status = 'open'\n        if not raw_data['result'][0]['result']:\n            return {\"error\":'Id not found'}\n        if int(raw_data['result'][0]['result']['status'])==3:\n            status = 'closed'\n        if int(raw_data['result'][0]['result']['status'])==5:\n            status = 'canceled'\n        ret_data = { \n                    \"data\": {\n                        \"id\": raw_data['result'][0]['result']['id'],\n                        \"amount\": raw_data['result'][0]['result']['amount'],\n                        \"price\": raw_data['result'][0]['result']['price'],\n                        \"status\": status,\n                        \"deal_amount\": raw_data['result'][0]['result']['deal_amount'],\n                        \"type\": \"buy\" if raw_data['result'][0]['result']['order_side']==1 else \"sell\", \n                        \"avg_price\": 0,\n                    }\n                }\n        ret_data['raw'] = raw_data\n        return ret_data\n    @staticmethod\n    def GetOrders(api_key, api_secret, pair):\n        url = MyExchange.trade_url + \"/orderpending\"\n        cmds = [{\n                'cmd':\"orderpending/orderPendingList\",\n                'body':{\n                    'pair':pair, \n                    'page':1, \n                    'size':50\n                    }\n                }]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        ret_data = {\"data\":[]}\n        for order in raw_data[\"result\"][0][\"result\"][\"items\"]:\n            status = 'open'\n            if int(order['status'])==3:\n                status = 'closed'\n            if int(order['status'])==5:\n                status = 'canceled'\n            ret_data[\"data\"].append(\n                {\n                    \"id\": order['id'],\n                    \"amount\": order['amount'],\n                    \"price\": order['price'],\n                    \"status\": status,\n                    \"deal_amount\": order['deal_amount'],\n                    \"type\": \"buy\" if order['order_side']==1 else \"sell\", \n                }\n            )\n        ret_data['raw'] = raw_data\n        return ret_data\n    @staticmethod\n    def IO(api_key, api_secret, path, params):\n        url = MyExchange.trade_url + path\n        cmds = [json.loads(str(urllib.unquote(params['obj'])))]\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\n        if 'error' in raw_data.keys():\n            return {'error':json.dumps(raw_data['error'],encoding=\"utf8\", ensure_ascii=False)}\n        return {\"data\":raw_data}\n\nclass Server(BaseHTTPRequestHandler):\n\n    def do_HEAD(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'application/json')\n        self.end_headers()\n        \n    def do_POST(self):\n\n        self.data_string = self.rfile.read(int(self.headers['Content-Length']))\n        data =json.loads(self.data_string.replace(\"'\", '\"'))\n        sent_data = {}\n        if data['method'] == \"ticker\":\n            symbol = data['params']['symbol'].upper()\n            sent_data = MyExchange.GetTicker(symbol)\n        elif data['method'] == \"depth\":\n            symbol = data['params']['symbol'].upper()\n            sent_data = MyExchange.GetDepth(symbol)\n        elif data['method'] == \"records\":\n            symbol = data['params']['symbol'].upper()\n            period = data['params']['period']\n            sent_data = MyExchange.GetRecords(symbol, int(period))\n        elif data['method'] == \"trades\":\n            symbol = data['params']['symbol'].upper()\n            sent_data = MyExchange.GetTrades(symbol)\n        elif data['method'] == \"accounts\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            sent_data = MyExchange.GetAccount(access_key, secret_key)\n        elif data['method'] == \"trade\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            pair = data['params']['symbol'].upper()\n            order_side = 1 if data['params']['type'] == 'buy' else 2\n            price = data['params']['price']\n            order_type = 2 if price > 0 else 1\n            amount = data['params']['amount']\n            sent_data = MyExchange.Trade(access_key, secret_key, pair, order_type, order_side, price, amount)\n        elif data['method'] == \"cancel\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            orders_id = int(data['params']['id'])\n            sent_data = MyExchange.CancelOrder(access_key, secret_key, orders_id)\n        elif data['method'] == \"order\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            orders_id = int(data['params']['id'])\n            sent_data = MyExchange.GetOrder(access_key, secret_key, orders_id)\n        elif data['method'] == \"orders\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            pair = data['params']['symbol'].upper()\n            sent_data = MyExchange.GetOrders(access_key, secret_key, pair)\n        elif data['method'][:2] == \"__\":\n            access_key = data[\"access_key\"]\n            secret_key = data[\"secret_key\"]\n            path = data[\"method\"].split('_')[-1]\n            params = data[\"params\"]\n            sent_data = MyExchange.IO(access_key, secret_key, path, params)\n\n        self.do_HEAD()\n        self.wfile.write(json.dumps(sent_data))\n        \ndef run(server_class=HTTPServer, handler_class=Server, port=6667):\n    server_address = ('', port)\n    httpd = server_class(server_address, handler_class)\n    print 'Starting http server...'\n    httpd.serve_forever()\n\nif __name__ == \"__main__\":\n    from sys import argv\n    if len(argv) == 2:\n        run(port=int(argv[1]))\n    else:\n        run()",
        "strategy_description": "策略名称: CoinPark交易所通用协议-627-1600-更新-关闭了SSL验证\n\n用途：可以使BotVs支持coinpark.cc交易所\n代码公开地址：https://www.fmz.com/strategy/101399\n运行地址 \n\n    http://127.0.0.1:6667"
    },
    {
        "strategy_id": "7_FMZ实盘机器人自动检测重启程序微信推送",
        "strategy_code": "python\n'''\n代码可以直接放到本地运行，\n不过需要一直开启电脑，也可以放到自己的服务器上运行\n'''\n\nimport time\nimport json\nimport ssl\nimport requests\nssl._create_default_https_context = ssl._create_unverified_context\n\ntry:\n    import md5\n    import urllib2\n    from urllib import urlencode\nexcept:\n    import hashlib as md5\n    import urllib.request as urllib2\n    from urllib.parse import urlencode\n\naccessKey = '48xxxxxxxxxxxxxxxxxxxxxxxxxxxxde'\nsecretKey = '91xxxxxxxxxxxxxxxxxxxxxxxxxxxx84'\n\ndef api(method, *args):\n    d = {\n        'version': '1.0',\n        'access_key': accessKey,\n        'method': method,\n        'args': json.dumps(list(args)),\n        'nonce': int(time.time() * 1000),\n        }\n\n    d['sign'] = md5.md5(('%s|%s|%s|%d|%s' % (d['version'], d['method'], d['args'], d['nonce'], secretKey)).encode('utf-8')).hexdigest()\n    # 注意： urllib2.urlopen 函数，超时问题，可以设置超时时间，urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8'), timeout=10) 设置超时 10秒\n    return json.loads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\n\ndef send_wechat(msg):\n    token = '93xxxxxxxxxxxxxxxxxxxxxxxxxxxx57'  # 前边复制到那个token\n    title = '【Waring】 策略信息'\n    content = msg\n    template = 'html'\n    url = f\"https://www.pushplus.plus/send?token={token}&title={title}&content={content}&template={template}\"\n    #print(url)\n    r = requests.get(url=url)\n    print(json.loads(r.text)['msg'])\n\nrobotId = [xxx,xxx,xxx]    #需要监视的机器人代码\n\n\nwhile True:\n    for j in range(len(robotId)):\n        detail = api('GetRobotDetail', robotId[j])\n        if detail['data']['result']['robot']['status'] == 1 and detail['data']['result']['robot']['wd'] == 1:\n            print(f\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视已打开 wd = {detail['data']['result']['robot']['wd']}\")\n            pass\n        elif detail['data']['result']['robot']['status'] == 1 :\n            print(f\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视未打开 wd = {detail['data']['result']['robot']['wd']}\")\n            pass\n        else:\n            print(f\"实盘{robotId[j]}状态异常 status = {detail['data']['result']['robot']['status']}\")\n            #尝试重启实盘   尝试次数 = 4    每5s 尝试一次\n            status = False\n            for i in range(4):\n                api('RestartRobot', robotId[j])\n                robotDetail = api('GetRobotDetail', robotId[j])\n                print(f\"尝试重启实盘{robotId[j]}第 {i+1} 次\")\n                if robotDetail['data']['result']['robot']['status'] == 1 :\n                    mess = api('GetRobotLogs',robotId[j],0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                    print(f\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\n\"\n                          f\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\n\"\n                          f\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\n\")\n                    send_wechat(f\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\n\"\n                                f\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\n\"\n                                f\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\n\")\n                    status = True\n                    break\n                else:\n                    print(f\"第 {i+1} 次 重启失败!!\")\n                time.sleep(5)\n            if status == False :\n                print(f\"尝试 4 次重启实盘{robotId[j]}失败，发送警告信息！！\")\n                send_wechat(f\"尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\n\")\n    time.sleep(60*10)",
        "strategy_description": "策略名称: FMZ实盘机器人自动检测重启程序微信推送\n\nreturn json.loads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\n\ndef send_wechat(msg):\n    token = '93xxxxxxxxxxxxxxxxxxxxxxxxxxxx57'  # 前边复制到那个token\n    title = '【Waring】 策略信息'\n    content = msg\n    template = 'html'\n    url = f\"https://www.pushplus.plus/send?token={token}&title={title}&content={content}&template={template}\"\n    #print(url)\n    r = requests.get(url=url)\n    print(json.loads(r.text)['msg'])\n\nrobotId = [xxx,xxx,xxx]    #需要监视的机器人代码\n\n\nwhile True:\n    for j in range(len(robotId)):\n        detail = api('GetRobotDetail', robotId[j])\n        if detail['data']['result']['robot']['status'] == 1 and detail['data']['result']['robot']['wd'] == 1:\n            print(f\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视已打开 wd = {detail['data']['result']['robot']['wd']}\")\n            pass\n        elif detail['data']['result']['robot']['status'] == 1 :\n            print(f\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视未打开 wd = {detail['data']['result']['robot']['wd']}\")\n            pass\n        else:\n            print(f\"实盘{robotId[j]}状态异常 status = {detail['data']['result']['robot']['status']}\")\n            #尝试重启实盘   尝试次数 = 4    每5s 尝试一次\n            status = False\n            for i in range(4):\n                api('RestartRobot', robotId[j])\n                robotDetail = api('GetRobotDetail', robotId[j])\n                print(f\"尝试重启实盘{robotId[j]}第 {i+1} 次\")\n                if robotDetail['data']['result']['robot']['status'] == 1 :\n                    mess = api('GetRobotLogs',robotId[j],0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                    print(f\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\n\"\n                          f\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\n\"\n                          f\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\n\")\n                    send_wechat(f\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\n\"\n                                f\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\n\"\n                                f\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\n\")\n                    status = True\n                    break\n                else:\n                    print(f\"第 {i+1} 次 重启失败!!\")\n                time.sleep(5)\n            if status == False :\n                print(f\"尝试 4 次重启实盘{robotId[j]}失败，发送警告信息！！\")\n                send_wechat(f\"尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\n\")\n    time.sleep(60*10)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/383695\n\n> Last Modified\n\n2022-09-22 18:27:23"
    },
    {
        "strategy_id": "8_FMZ教程-Python速成手册",
        "strategy_code": "python\n# 单行注释\n\"\"\" 多行字符串可以用\n    三个引号包裹，不过这也可以被当做\n    多行注释\n\"\"\"\n\n####################################################\n## 1. 原始数据类型和操作符\n####################################################\n\n# 数字类型\n3  # => 3\n\n# 简单的算数\n1 + 1  # => 2\n8 - 1  # => 7\n10 * 2  # => 20\n35 / 5  # => 7\n\n# 整数的除法会自动取整\n5 / 2  # => 2\n\n# 要做精确的除法，我们需要引入浮点数\n2.0     # 浮点数\n11.0 / 4.0  # => 2.75 精确多了\n\n# 括号具有最高优先级\n(1 + 3) * 2  # => 8\n\n# 布尔值也是基本的数据类型\nTrue\nFalse\n\n# 用 not 来取非\nnot True  # => False\nnot False  # => True\n\n# 相等\n1 == 1  # => True\n2 == 1  # => False\n\n# 不等\n1 != 1  # => False\n2 != 1  # => True\n\n# 更多的比较操作符\n1 < 10  # => True\n1 > 10  # => False\n2 <= 2  # => True\n2 >= 2  # => True\n\n# 比较运算可以连起来写！\n1 < 2 < 3  # => True\n2 < 3 < 2  # => False\n\n# 字符串通过 \" 或 ' 括起来\n\"This is a string.\"\n'This is also a string.'\n\n# 字符串通过加号拼接\n\"Hello \" + \"world!\"  # => \"Hello world!\"\n\n# 字符串可以被视为字符的列表\n\"This is a string\"[0]  # => 'T'\n\n# % 可以用来格式化字符串\n\"%s can be %s\" % (\"strings\", \"interpolated\")\n\n# 也可以用 format 方法来格式化字符串\n# 推荐使用这个方法\n\"{0} can be {1}\".format(\"strings\", \"formatted\")\n# 也可以用变量名代替数字\n\"{name} wants to eat {food}\".format(name=\"Bob\", food=\"lasagna\")\n\n# None 是对象\nNone  # => None\n\n# 不要用相等 `==` 符号来和None进行比较\n# 要用 `is`\n\"etc\" is None  # => False\nNone is None  # => True\n\n# 'is' 可以用来比较对象的相等性\n# 这个操作符在比较原始数据时没多少用，但是比较对象时必不可少\n\n# None, 0, 和空字符串都被算作 False\n# 其他的均为 True\n0 == False  # => True\n\"\" == False  # => True\n\n\n####################################################\n## 2. 变量和集合\n####################################################\n\n# 很方便的输出\nprint \"I'm Python. Nice to meet you!\"\n\n\n# 给变量赋值前不需要事先声明\nsome_var = 5    # 一般建议使用小写字母和下划线组合来做为变量名\nsome_var  # => 5\n\n# 访问未赋值的变量会抛出异常\n# 可以查看控制流程一节来了解如何异常处理\nsome_other_var  # 抛出 NameError\n\n# if 语句可以作为表达式来使用\n\"yahoo!\" if 3 > 2 else 2  # => \"yahoo!\"\n\n# 列表用来保存序列\nli = []\n# 可以直接初始化列表\nother_li = [4, 5, 6]\n\n# 在列表末尾添加元素\nli.append(1)    # li 现在是 [1]\nli.append(2)    # li 现在是 [1, 2]\nli.append(4)    # li 现在是 [1, 2, 4]\nli.append(3)    # li 现在是 [1, 2, 4, 3]\n# 移除列表末尾元素\nli.pop()        # => 3 li 现在是 [1, 2, 4]\n# 重新加进去\nli.append(3)    # li is now [1, 2, 4, 3] again.\n\n# 像其他语言访问数组一样访问列表\nli[0]  # => 1\n# 访问最后一个元素\nli[-1]  # => 3\n\n# 越界会抛出异常\nli[4]  # 抛出越界异常\n\n# 切片语法需要用到列表的索引访问\n# 可以看做数学之中左闭右开区间\nli[1:3]  # => [2, 4]\n# 省略开头的元素\nli[2:]  # => [4, 3]\n# 省略末尾的元素\nli[:3]  # => [1, 2, 4]\n\n# 删除特定元素\ndel li[2]  # li 现在是 [1, 2, 3]\n\n# 合并列表\nli + other_li  # => [1, 2, 3, 4, 5, 6] - 并不会不改变这两个列表\n\n# 通过拼接来合并列表\nli.extend(other_li)  # li 是 [1, 2, 3, 4, 5, 6]\n\n# 用 in 来返回元素是否在列表中\n1 in li  # => True\n\n# 返回列表长度\nlen(li)  # => 6\n\n\n# 元组类似于列表，但它是不可改变的\ntup = (1, 2, 3)\ntup[0]  # => 1\ntup[0] = 3  # 类型错误\n\n# 对于大多数的列表操作，也适用于元组\nlen(tup)  # => 3\ntup + (4, 5, 6)  # => (1, 2, 3, 4, 5, 6)\ntup[:2]  # => (1, 2)\n2 in tup  # => True\n\n# 你可以将元组解包赋给多个变量\na, b, c = (1, 2, 3)     # a 是 1，b 是 2，c 是 3\n# 如果不加括号，将会被自动视为元组\nd, e, f = 4, 5, 6\n# 现在我们可以看看交换两个数字是多么容易的事\ne, d = d, e     # d 是 5，e 是 4\n\n\n# 字典用来储存映射关系\nempty_dict = {}\n# 字典初始化\nfilled_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\n\n# 字典也用中括号访问元素\nfilled_dict[\"one\"]  # => 1\n\n# 把所有的键保存在列表中\nfilled_dict.keys()  # => [\"three\", \"two\", \"one\"]\n# 键的顺序并不是唯一的，得到的不一定是这个顺序\n\n# 把所有的值保存在列表中\nfilled_dict.values()  # => [3, 2, 1]\n# 和键的顺序相同\n\n# 判断一个键是否存在\n\"one\" in filled_dict  # => True\n1 in filled_dict  # => False\n\n# 查询一个不存在的键会抛出 KeyError\nfilled_dict[\"four\"]  # KeyError\n\n# 用 get 方法来避免 KeyError\nfilled_dict.get(\"one\")  # => 1\nfilled_dict.get(\"four\")  # => None\n# get 方法支持在不存在的时候返回一个默认值\nfilled_dict.get(\"one\", 4)  # => 1\nfilled_dict.get(\"four\", 4)  # => 4\n\n# setdefault 是一个更安全的添加字典元素的方法\nfilled_dict.setdefault(\"five\", 5)  # filled_dict[\"five\"] 的值为 5\nfilled_dict.setdefault(\"five\", 6)  # filled_dict[\"five\"] 的值仍然是 5\n\n\n# 集合储存无顺序的元素\nempty_set = set()\n# 初始化一个集合\nsome_set = set([1, 2, 2, 3, 4])  # some_set 现在是 set([1, 2, 3, 4])\n\n# Python 2.7 之后，大括号可以用来表示集合\nfilled_set = {1, 2, 2, 3, 4}  # => {1 2 3 4}\n\n# 向集合添加元素\nfilled_set.add(5)  # filled_set 现在是 {1, 2, 3, 4, 5}\n\n# 用 & 来计算集合的交\nother_set = {3, 4, 5, 6}\nfilled_set & other_set  # => {3, 4, 5}\n\n# 用 | 来计算集合的并\nfilled_set | other_set  # => {1, 2, 3, 4, 5, 6}\n\n# 用 - 来计算集合的差\n{1, 2, 3, 4} - {2, 3, 5}  # => {1, 4}\n\n# 用 in 来判断元素是否存在于集合中\n2 in filled_set  # => True\n10 in filled_set  # => False\n\n\n####################################################\n## 3. 控制流程\n####################################################\n\n# 新建一个变量\nsome_var = 5\n\n# 这是个 if 语句，在 python 中缩进是很重要的。\n# 下面的代码片段将会输出 \"some var is smaller than 10\"\nif some_var > 10:\n    print \"some_var is totally bigger than 10.\"\nelif some_var < 10:    # 这个 elif 语句是不必须的\n    print \"some_var is smaller than 10.\"\nelse:           # 这个 else 也不是必须的\n    print \"some_var is indeed 10.\"\n\n\n\"\"\"\n用for循环遍历列表\n输出:\n    dog is a mammal\n    cat is a mammal\n    mouse is a mammal\n\"\"\"\nfor animal in [\"dog\", \"cat\", \"mouse\"]:\n    # 你可以用 % 来格式化字符串\n    print \"%s is a mammal\" % animal\n\n\"\"\"\n`range(number)` 返回从0到给定数字的列表\n输出:\n    0\n    1\n    2\n    3\n\"\"\"\nfor i in range(4):\n    print i\n\n\"\"\"\nwhile 循环\n输出:\n    0\n    1\n    2\n    3\n\"\"\"\nx = 0\nwhile x < 4:\n    print x\n    x += 1  #  x = x + 1 的简写\n\n# 用 try/except 块来处理异常\n\n# Python 2.6 及以上适用:\ntry:\n    # 用 raise 来抛出异常\n    raise IndexError(\"This is an index error\")\nexcept IndexError as e:\n    pass    # pass 就是什么都不做，不过通常这里会做一些恢复工作\n\n\n####################################################\n## 4. 函数\n####################################################\n\n# 用 def 来新建函数\ndef add(x, y):\n    print \"x is %s and y is %s\" % (x, y)\n    return x + y    # 通过 return 来返回值\n\n# 调用带参数的函数\nadd(5, 6)  # => 输出 \"x is 5 and y is 6\" 返回 11\n\n# 通过关键字赋值来调用函数\nadd(y=6, x=5)   # 顺序是无所谓的\n\n# 我们也可以定义接受多个变量的函数，这些变量是按照顺序排列的\ndef varargs(*args):\n    return args\n\nvarargs(1, 2, 3)  # => (1,2,3)\n\n\n# 我们也可以定义接受多个变量的函数，这些变量是按照关键字排列的\ndef keyword_args(**kwargs):\n    return kwargs\n\n# 实际效果：\nkeyword_args(big=\"foot\", loch=\"ness\")  # => {\"big\": \"foot\", \"loch\": \"ness\"}\n\n# 你也可以同时将一个函数定义成两种形式\ndef all_the_args(*args, **kwargs):\n    print args\n    print kwargs\n\"\"\"\nall_the_args(1, 2, a=3, b=4) prints:\n    (1, 2)\n    {\"a\": 3, \"b\": 4}\n\"\"\"\n\n# 当调用函数的时候，我们也可以进行相反的操作，把元组和字典展开为参数\nargs = (1, 2, 3, 4)\nkwargs = {\"a\": 3, \"b\": 4}\nall_the_args(*args)  # 等价于 foo(1, 2, 3, 4)\nall_the_args(**kwargs)  # 等价于 foo(a=3, b=4)\nall_the_args(*args, **kwargs)  # 等价于 foo(1, 2, 3, 4, a=3, b=4)\n\n# 函数在 python 中是一等公民\ndef create_adder(x):\n    def adder(y):\n        return x + y\n    return adder\n\nadd_10 = create_adder(10)\nadd_10(3)  # => 13\n\n# 匿名函数\n(lambda x: x > 2)(3)  # => True\n\n# 内置高阶函数\nmap(add_10, [1, 2, 3])  # => [11, 12, 13]\nfilter(lambda x: x > 5, [3, 4, 5, 6, 7])  # => [6, 7]\n\n# 可以用列表方法来对高阶函数进行更巧妙的引用\n[add_10(i) for i in [1, 2, 3]]  # => [11, 12, 13]\n[x for x in [3, 4, 5, 6, 7] if x > 5]  # => [6, 7]\n\n####################################################\n## 5. 类\n####################################################\n\n# 我们新建的类是从 object 类中继承的\nclass Human(object):\n\n     # 类属性，由所有类的对象共享\n    species = \"H. sapiens\"\n\n    # 基本构造函数\n    def __init__(self, name):\n        # 将参数赋给对象成员属性\n        self.name = name\n\n    # 成员方法，参数要有 self\n    def say(self, msg):\n        return \"%s: %s\" % (self.name, msg)\n\n    # 类方法由所有类的对象共享\n    # 这类方法在调用时，会把类本身传给第一个参数\n    @classmethod\n    def get_species(cls):\n        return cls.species\n\n    # 静态方法是不需要类和对象的引用就可以调用的方法\n    @staticmethod\n    def grunt():\n        return \"*grunt*\"\n\n\n# 实例化一个类\ni = Human(name=\"Ian\")\nprint i.say(\"hi\")     # 输出 \"Ian: hi\"\n\nj = Human(\"Joel\")\nprint j.say(\"hello\")  # 输出 \"Joel: hello\"\n\n# 访问类的方法\ni.get_species()  # => \"H. sapiens\"\n\n# 改变共享属性\nHuman.species = \"H. neanderthalensis\"\ni.get_species()  # => \"H. neanderthalensis\"\nj.get_species()  # => \"H. neanderthalensis\"\n\n# 访问静态变量\nHuman.grunt()  # => \"*grunt*\"\n\n\n####################################################\n## 6. 模块\n####################################################\n\n# 我们可以导入其他模块\nimport math\nprint math.sqrt(16)  # => 4\n\n# 我们也可以从一个模块中导入特定的函数\nfrom math import ceil, floor\nprint ceil(3.7)   # => 4.0\nprint floor(3.7)  # => 3.0\n\n# 从模块中导入所有的函数\n# 警告：不推荐使用\nfrom math import *\n\n# 简写模块名\nimport math as m\nmath.sqrt(16) == m.sqrt(16)  # => True\n\n# Python的模块其实只是普通的python文件\n# 你也可以创建自己的模块，并且导入它们\n# 模块的名字就和文件的名字相同\n\n# 也可以通过下面的方法查看模块中有什么属性和方法\nimport math\ndir(math)",
        "strategy_description": "策略名称: FMZ教程-Python速成手册\n\n\"\"\" 多行字符串可以用\n    三个引号包裹，不过这也可以被当做\n    多行注释\n\"\"\""
    },
    {
        "strategy_id": "9_Fomo3D-智能合约监控-Fomo3D-Smart-Contract-Monitoring",
        "strategy_code": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n# \n# Fomo3D Smart Contract Monitoring\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\nimport requests\nimport re\nimport json\nimport time\nimport datetime\n\nLogReset()\n\nif TG == 1:\n    TG_ENABLE = True \nelse:\n    TG_ENABLE = False\nif WECHAT == 1:\n    WC_ENABLE = True \nelse:\n    WC_ENABLE = False\n    \nTG_BOT_KEY = TGKEY\n\nTGURL = 'https://api.telegram.org/bot%s/sendMessage' % TG_BOT_KEY\nTGPARAM = {}\nTGPARAM['chat_id'] = TGID\n\ndef Send(message):\n    if TG_ENABLE == False:\n        return\n    try:\n        TGPARAM['text'] = message\n        res = requests.post(TGURL, data = TGPARAM)\n        return\n    except IOError as e:\n        print(e)\n        return\n\n\ndef Refresh():\n    URL = 'https://mainnet.infura.io/%s' % INFURAKEY\n    HEADER = {'Content-Type': 'application/json'}\n    PARAM = '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"eth_call\", \"params\": [{\"data\":\"0x747dff42\",\"to\":\"%s\"},\"latest\"]}' % CONTRACT\n    data = requests.post(URL,data=PARAM,headers=HEADER).json()\n    HEX = re.sub('(0{2,})','X',data['result']).split('X')[3]\n    print(HEX)\n    INT = int(HEX, 16)\n    NOW = int(time.time())\n    LEFT = INT - NOW\n    return LEFT\n\ndef main():\n    Log('Started!')\n    Log('ContractAddress: ' + CONTRACT)\n    Log('Telegram Enabled: ' + str(TG_ENABLE))\n    Log('WeChat Enabled: ' + str(WC_ENABLE))\n    while True:\n        try:\n            DATE = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            TIMELEFT = Refresh()\n            message = 'Time before FOMO ENDING : %d' % TIMELEFT\n            if TIMELEFT < 0:\n                TIMELEFT = THRESHOLD + 10\n            if TIMELEFT <= THRESHOLD:\n                Send(message)\n                if WC_ENABLE == True:\n                    message = message + ' !@'\n                    \n                Log(message)\n            else:\n                Log(message)\n\n        except IOError as e:\n            print(e)\n            time.sleep(REFRESH_DELAY)\n            pass\n\n        time.sleep(REFRESH_DELAY)",
        "strategy_description": "策略名称: Fomo3D-智能合约监控-Fomo3D-Smart-Contract-Monitoring\n\n# encoding: utf-8"
    },
    {
        "strategy_id": "10_Keltner通道突破止损加盈利10即长期持有策略-v23-dev-多周期",
        "strategy_code": "python\n'''\nstart: 2020-01-01 00:00:00\nend: 2020-04-24 00:00:00\nperiod: 1h\nexchanges: [{\"eid\":\"huobi\",\"currency\":\"BTC_USDT\",\"stocks\":0,\"meta\":{\"AccessKey\":\"7yngd7gh5g-a7ed9b1a-c05064c3-bab33\",\"SecretKey\":\"553c2cd1-e229e1d2-25a536cb-db7d3\"}}]\n'''\n\nimport talib as ta\nimport pandas as pd\nfrom datetime import datetime\nfrom datetime import timedelta\nimport math\n#coding:utf8\nimport sys\n\neid = -1\nlast_price = -1\n\ndef main():\n    global eid\n    global last_price\n    global ma\n\n    while True:\n\n        records = exchange.GetRecords(1*60*60)\n        e = exchange\n        kline1 = pd.DataFrame(records)\n        kline1['Time'] = kline1['Time'].map(lambda x: datetime.utcfromtimestamp(x/1000)+timedelta(hours=8))\n        kline1.columns = ['time','open','high','low','close','volume','oi']\n       \n        r = kline1\n        #Log('最新k线时间',r.iloc[-1].time, ' 最新价格收盘价', r.iloc[-1].close)\n    \n        leadLine1 = ta.EMA(r.close, 30)\n        leadLine2 = ta.SMA(r.close, 30)\n        UT=leadLine2 < leadLine1\n        DT=leadLine2 > leadLine1\n    \n        # keltner channel\n        ma  = ta.EMA(kline1.close, 80)\n        # 真实的范围函数\n        range1 = ta.TRANGE(kline1.high, kline1.low, kline1.close)\n        rangema = ta.EMA(range1, 80)\n        upper = ma + 3*rangema\n        lower = ma - 3*rangema\n       \n        # minus and plus of adx/dmi\n        minus = ta.MINUS_DI(kline1.high,kline1.low, kline1.close,14) \n        plus = ta.PLUS_DI(kline1.high, kline1.low, kline1.close ,14)\n                   \n        volume0 = r.iloc[-1].volume\n        volume1 = r.iloc[-2].volume\n        rn = r.iloc[-1]\n       \n        entry_long = rn.close > upper.iloc[-1] and (r.iloc[-1].volume+ r.iloc[-2].volume) >1.5 *(r.iloc[-4].volume+ r.iloc[-5].volume)\n        long = entry_long\n        exit_long = (rn.close < ma.iloc[-1] )\n        account = exchange.GetAccount()\n        amount = account.Stocks\n        #Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n        # 如果处于空仓状态\n        if (account['Balance'] >= 600 and amount < 0.001):\n            if long==True and account['Balance'] < 400 and amount<0.01:\n                Log('balance is ', account['Balance'], ' 余额不足400，退出！')\n                return\n            elif long== True  and account['Balance'] >= 600: #第一次开多仓\n                Log('balance is ', account['Balance'])\n                Log('多仓位时间: ', rn.time, ' open is ', rn.open , ' close is ', rn.close, ' upper is ', upper.iloc[-1], ' volume 0\\1 is', volume0 , 'volume 1 is ', volume1 , \n                ' plus is ',plus.iloc[-1], ' minus is ', minus.iloc[-1], '@')\n                exchange.Buy(-1,600)\n                last_price = rn.close + 10\n                Sleep(1000*60*15)\n        # 如果处于持仓状态\n        if  amount>0.001 :\n            if  amount > 0.0001 and rn.close <= last_price*0.94: \n                Log('止损平仓事件: ','balance is ', account['Balance'], rn.time, ' rn.close is ', rn.close, ' @')\n                id = exchange.Sell(-1, amount);\n                account = exchange.GetAccount()\n                amount = account.Stocks\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n                eid = -1\n       #如果处于一直持仓又大跌状态，才卖出\n            elif  amount > 0.0001 and rn.close >= last_price * 1.1 and rn.close <= r.iloc[-24].close*0.9:\n                Log('持仓周期内的大跌止损平仓事件: ', rn.time, ' rn.close is ', rn.close, ' @')\n                id = exchange.Sell(-1, amount);\n                eid = -1\n                account = exchange.GetAccount()\n                amount = account.Stocks\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n            elif amount > 0.0001 and exit_long == True :\n                if rn.close <= last_price:\n                    Log('位置下滑平仓位事件,亏损:  amount is ',amount ,' time is ', rn.time, ' 价格是：',rn.close,' ma is ', ma.iloc[-1], ' 开仓价格',last_price,' 亏损幅度：',100*(last_price -rn.close)/last_price ,'% @')\n                    eid = exchange.Sell(-1, amount)\n#                print(r.tail(10))\n#                print('ma is ' ,ma)\n                    account = exchange.GetAccount()\n                    amount = account.Stocks\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n                elif rn.close > last_price*1.1 :\n                    Log('超出10%盈利继续持仓')\n                    account = exchange.GetAccount()\n                    amount = account.Stocks\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n                    return \n                elif rn.close > last_price  and rn.close <=last_price*1.1:\n                    eid = exchange.Sell(-1, amount);\n                    account = exchange.GetAccount()\n                    amount = account.Stocks\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n                    Log('位置下滑平仓位事件,赚钱啦: amount is ',amount, ' time is ', rn.time, ' 价格是： ',rn.close,' ma is ', ma.iloc[-1],' 开仓价格',last_price,' 盈利幅度：',100*(rn.close-last_price )/last_price ,'% @' )\n                else:\n                    id = exchange.Sell(-1, amount);\n                    Log('最终位置下滑平仓位事件,赚钱啦: amount is ',amount, ' time is ', rn.time, ' 价格是： ',rn.close,' ma is ', ma.iloc[-1],' 开仓价格',last_price,' 盈利幅度：',100*(rn.close-last_price )/last_price ,'% @' )\n                    eid = -1\n                    account = exchange.GetAccount()\n                    amount = account.Stocks\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n            Sleep(1000*60*15)",
        "strategy_description": "策略名称: Keltner通道突破止损加盈利10即长期持有策略-v23-dev-多周期\n\nma  = ta.EMA(kline1.close, 80)\n        # 真实的范围函数\n        range1 = ta.TRANGE(kline1.high, kline1.low, kline1.close)\n        rangema = ta.EMA(range1, 80)\n        upper = ma + 3*rangema\n        lower = ma - 3*rangema\n       \n        # minus and plus of adx/dmi\n        minus = ta.MINUS_DI(kline1.high,kline1.low, kline1.close,14) \n        plus = ta.PLUS_DI(kline1.high, kline1.low, kline1.close ,14)\n                   \n        volume0 = r.iloc[-1].volume\n        volume1 = r.iloc[-2].volume\n        rn = r.iloc[-1]\n       \n        entry_long = rn.close > upper.iloc[-1] and (r.iloc[-1].volume+ r.iloc[-2].volume) >1.5 *(r.iloc[-4].volume+ r.iloc[-5].volume)\n        long = entry_long\n        exit_long = (rn.close < ma.iloc[-1] )\n        account = exchange.GetAccount()\n        amount = account.Stocks\n        #Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n        # 如果处于空仓状态\n        if (account['Balance'] >= 600 and amount < 0.001):\n            if long==True and account['Balance'] < 400 and amount<0.01:\n                Log('balance is ', account['Balance'], ' 余额不足400，退出！')\n                return\n            elif long== True  and account['Balance'] >= 600: #第一次开多仓\n                Log('balance is ', account['Balance'])\n                Log('多仓位时间: ', rn.time, ' open is ', rn.open , ' close is ', rn.close, ' upper is ', upper.iloc[-1], ' volume 0\\1 is', volume0 , 'volume 1 is ', volume1 , \n                ' plus is ',plus.iloc[-1], ' minus is ', minus.iloc[-1], '@')\n                exchange.Buy(-1,600)\n                last_price = rn.close + 10\n                Sleep(1000*60*15)\n        # 如果处于持仓状态\n        if  amount>0.001 :\n            if  amount > 0.0001 and rn.close <= last_price*0.94: \n                Log('止损平仓事件: ','balance is ', account['Balance'], rn.time, ' rn.close is ', rn.close, ' @')\n                id = exchange.Sell(-1, amount);\n                account = exchange.GetAccount()\n                amount = account.Stocks\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n                eid = -1\n       #如果处于一直持仓又大跌状态，才卖出\n            elif  amount > 0.0001 and rn.close >= last_price * 1.1 and rn.close <= r.iloc[-24].close*0.9:\n                Log('持仓周期内的大跌止损平仓事件: ', rn.time, ' rn.close is ', rn.close, ' @')\n                id = exchange.Sell(-1, amount);\n                eid = -1\n                account = exchange.GetAccount()\n                amount = account.Stocks\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\n            elif amount > 0.0001 and exit_long == True :\n                if rn.close <= last_price:\n                    Log('位置下滑平仓位事件,亏损:  amount is ',amount ,' time is ', rn.time, ' 价格是：',rn.close,' ma is ', ma.iloc[-1], ' 开仓价格',last_price,' 亏损幅度：',100*(last_price -rn.close)/last_price ,'% @')\n                    eid = exchange.Sell(-1, amount)"
    },
    {
        "strategy_id": "11_Lbuy_Hsell-低买高卖",
        "strategy_code": "python\n'''backtest\nstart: 2020-05-31 00:00:00\nend: 2020-08-28 00:00:00\nperiod: 1day\nexchanges: [{\"eid\":\"huobi\",\"currency\":\"BTC_USDT\"}]\n'''\n\nratio = 0.01\nacc = 0\nminStock = 0.01\n\ndef main():\n    global ratio,acc,minStock\n    exchanges[0].SetPrecision(2, 3)\n    Log('hello sltrain@')\n    #Log(exchanges[0].GetAccount())\n    tickers = _C(exchanges[0].GetTicker)\n    #Log(tickers)   \n    while(True):\n        tickers_new = _C(exchanges[0].GetTicker)\n        if tickers_new.Last > tickers.Last * (1 + ratio):\n            acc = _C(exchanges[0].GetAccount)\n            id = exchanges[0].Sell(tickers_new.Last, acc.Stocks * ratio)\n            Log(\"id:\", id)\n        elif tickers_new.Last < tickers.Last * (1 + ratio):\n            acc = _C(exchanges[0].GetAccount)\n            id = exchanges[0].Buy(tickers_new.Last, (acc.Balance * ratio)/tickers_new.Last)\n            Log(\"id:\", id)\n        if tickers_new.Last == tickers.Last:\n            continue\n        tickers = tickers_new \n        Sleep(20*60*1000)",
        "strategy_description": "策略名称: Lbuy_Hsell-低买高卖\n\n未找到描述"
    },
    {
        "strategy_id": "12_MACD逃顶策略",
        "strategy_code": "python\n'''backtest\nstart: 2023-01-01 00:00:00\nend: 2023-05-12 00:00:00\nperiod: 1d\nbasePeriod: 1h\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\",\"stocks\":10}]\n'''\n\n\n# from matplotlib import pyplot as plt\n# plt.figure()\n\nclass ExitTop(object):\n    def __init__(self,index):\n        self.index = index \n        self.totestlist = [] # MACD数据\n        self.klist = [] # k线数据\n        self.toplus = []\n        self.tocpn = []\n        self.Sell = False\n    \n    # 获取k线及MACD数据\n    def GetRecord(self) -> bool:\n        self.totestlist = []\n        self.klist = []\n        self.toplus = []\n        self.tocpn = []\n        records = exchanges[self.index].GetRecords()\n        macd = TA.MACD(records, 12, 26, 9)\n        # 判断DIF是否大于DEA\n        if not macd[0][-2] > macd[1][-2] and macd[0][-3] < macd[1][-3] or not macd[0][-2] > macd[1][-2] and macd[0][-4] < macd[1][-4]:\n            return False\n        self.totestlist = macd[0][len(macd[0])-80:]\n        # 封装k线数据\n        for get in range(len(records)):\n            self.klist.append(records[get][\"Close\"])\n        self.klist = self.klist[len(self.klist)-80:]\n        return True\n    \n    def mepath(self):\n        if not self.GetRecord():\n            return False\n        # 向前遍历发现最大值\n        maxsign = -1000000000000\n        for i in range(len(self.totestlist)-1,-1,-1):\n            if self.totestlist[i] > maxsign:\n                maxsign = self.totestlist[i]\n                self.tocpn.append([1,i])\n            else:\n                if len(self.tocpn) > 0:\n                    self.tocpn[-1][0] = self.tocpn[-1][0]+1\n            self.toplus.insert(0,maxsign)\n        sign = False\n        shorttime = [0,0] # 步长 , 索引\n        for i in range(len(self.tocpn)):\n            if self.tocpn[i][0] > 15 and sign == False:\n                shorttime = [self.tocpn[i][0],self.tocpn[i][1]]\n                sign = True\n        # 如果最大索引不是自己\n        if shorttime[1] < len(self.klist)-4:\n            # 锁定区域内最高价格\n            are = max(self.klist[shorttime[1]:-4])\n            # 判断是否存在大于当前macd值,如果当前价格大于区域内最高价格\n            if self.totestlist[-2]+300 < self.totestlist[shorttime[1]] and self.klist[-2] >= are:\n                return True\n            return False\n        return False\n    \n    def main(self):\n        result = self.mepath()\n        if result == True and self.Sell == False:\n            exchanges[self.index].Sell(-1, num)\n            self.Sell = True\n        elif result == False:\n            if self.Sell == True:\n                self.Sell = False\n        # plt.plot(self.totestlist)\n        # plt.plot(self.toplus)\n        # LogStatus(plt)\n\n\ndef main():\n    transaction = []\n    for index in range(len(exchanges)):\n        transaction.append(ExitTop(index))\n    while True:\n        for tran in range(len(transaction)):\n            transaction[tran].main()\n            Sleep(1000*60)",
        "strategy_description": "策略名称: MACD逃顶策略\n\n# plt.figure()\n\nclass ExitTop(object):\n    def __init__(self,index):\n        self.index = index \n        self.totestlist = [] # MACD数据\n        self.klist = [] # k线数据\n        self.toplus = []\n        self.tocpn = []\n        self.Sell = False\n    \n    # 获取k线及MACD数据\n    def GetRecord(self) -> bool:\n        self.totestlist = []\n        self.klist = []\n        self.toplus = []\n        self.tocpn = []\n        records = exchanges[self.index].GetRecords()\n        macd = TA.MACD(records, 12, 26, 9)\n        # 判断DIF是否大于DEA\n        if not macd[0][-2] > macd[1][-2] and macd[0][-3] < macd[1][-3] or not macd[0][-2] > macd[1][-2] and macd[0][-4] < macd[1][-4]:\n            return False\n        self.totestlist = macd[0][len(macd[0])-80:]\n        # 封装k线数据\n        for get in range(len(records)):\n            self.klist.append(records[get][\"Close\"])\n        self.klist = self.klist[len(self.klist)-80:]\n        return True\n    \n    def mepath(self):\n        if not self.GetRecord():\n            return False\n        # 向前遍历发现最大值\n        maxsign = -1000000000000\n        for i in range(len(self.totestlist)-1,-1,-1):\n            if self.totestlist[i] > maxsign:\n                maxsign = self.totestlist[i]\n                self.tocpn.append([1,i])\n            else:\n                if len(self.tocpn) > 0:\n                    self.tocpn[-1][0] = self.tocpn[-1][0]+1\n            self.toplus.insert(0,maxsign)\n        sign = False\n        shorttime = [0,0] # 步长 , 索引\n        for i in range(len(self.tocpn)):\n            if self.tocpn[i][0] > 15 and sign == False:\n                shorttime = [self.tocpn[i][0],self.tocpn[i][1]]\n                sign = True\n        # 如果最大索引不是自己\n        if shorttime[1] < len(self.klist)-4:\n            # 锁定区域内最高价格\n            are = max(self.klist[shorttime[1]:-4])\n            # 判断是否存在大于当前macd值,如果当前价格大于区域内最高价格\n            if self.totestlist[-2]+300 < self.totestlist[shorttime[1]] and self.klist[-2] >= are:\n                return True\n            return False\n        return False\n    \n    def main(self):\n        result = self.mepath()\n        if result == True and self.Sell == False:\n            exchanges[self.index].Sell(-1, num)\n            self.Sell = True\n        elif result == False:\n            if self.Sell == True:\n                self.Sell = False\n        # plt.plot(self.totestlist)\n        # plt.plot(self.toplus)\n        # LogStatus(plt)\n\n\ndef main():\n    transaction = []\n    for index in range(len(exchanges)):\n        transaction.append(ExitTop(index))\n    while True:\n        for tran in range(len(transaction)):\n            transaction[tran].main()\n            Sleep(1000*60)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/356399\n\n> Last Modified\n\n2023-05-13 21:21:01"
    },
    {
        "strategy_id": "13_OKEX-V5-K线数据分页查询例子-Python版",
        "strategy_code": "js\nfunction main() {\n    // 访问接口获取数据\n    var r = GetRecords(\"ETH-USDT-SWAP\", \"1H\")   // 例如获取ETH U本位永续合约的1小时K线数据\n\n    // 输出数据\n    Log(\"K线数据：\", r)\n    Log(\"K线数据数量：\", r.length)\n\n    // 画图输出\n    $.PlotRecords(r, \"K\")\n\n    // 简单验证\n    for (var i = 0 ; i < r.length - 1 ; i++) {\n        if (r[i + 1].Time - r[i].Time != 1000 * 60 * 60) {\n            Log(_D(r[i + 1].Time), _D(r[i].Time), r[i + 1].Time - r[i].Time)\n        }\n    }\n}\n\n# ==========================================\n\npython\nimport json\nimport urllib.request\n\ndef encodeParams(params):\n    ret = \"\"\n    index = 0 \n    for key in params:\n        if index == 0:\n            ret += key + \"=\" + str(params[key])\n        else :\n            ret += \"&\" + key + \"=\" + str(params[key])\n        index += 1\n    return ret \n\ndef GetRecords(symbol, period):\n    arr = []\n    after = 0\n    while True:\n        params = {\n            \"instId\": symbol,\n            \"bar\": period,\n            \"limit\": 100,\n        }\n        if after != 0 :\n            params[\"after\"] = after\n        query = encodeParams(params)        \n        try :\n            headers = {\n                'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\n                'Accept-Language':'zh-CN,zh;q=0.9',\n                'Connection':'keep-alive',\n                'Cookie':'uuid_tt_dd=10_35489889920-1563497330616-876822; ...... ',\n                'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'\n            }           \n\n            url = \"https://www.okex.com/api/v5/market/candles?\" + query\n            req = urllib.request.Request(url=url,headers=headers)\n            r = json.loads(urllib.request.urlopen(req).read().decode('utf-8'))[\"data\"]\n            for i in range(len(r)):\n                record = {}\n                record[\"Time\"] = int(r[i][0])\n                record[\"High\"] = float(r[i][2])\n                record[\"Open\"] = float(r[i][1])\n                record[\"Low\"] = float(r[i][3])\n                record[\"Close\"] = float(r[i][4])\n                record[\"Volume\"] = float(r[i][5])\n                arr.append(record)\n                after = record[\"Time\"]\n            if len(arr) >= 1440 or len(r) == 0:\n                break\n        except Exception as e:\n            Log(e)\n            return \n        Sleep(1000)\n    arr.reverse()    \n    return arr \n    \ndef main():\n    r = GetRecords(\"ETH-USDT-SWAP\", \"1H\")\n    \n    Log(\"K线数据：\", r)\n    Log(\"K线数据数量：\", len(r))\n    \n    ext.PlotRecords(r, \"K\")\n    \n    for i in range(len(r) - 1):\n        if r[i + 1][\"Time\"] - r[i][\"Time\"] != 1000 * 60 * 60:\n            Log(_D(r[i + 1][\"Time\"] / 1000), _D(r[i][\"Time\"] / 1000), r[i + 1][\"Time\"] - r[i][\"Time\"])",
        "strategy_description": "策略名称: OKEX-V5-K线数据分页查询例子-Python版\n\n由于OKEX V5接口一次调用最多只有100根，需要分页查询。所以封装了一个例子，如何分页查询K线接口，获取1440根K线数据。\n\n```js\nfunction main() {\n    // 访问接口获取数据\n    var r = GetRecords(\"ETH-USDT-SWAP\", \"1H\")   // 例如获取ETH U本位永续合约的1小时K线数据\n\n    // 输出数据\n    Log(\"K线数据：\", r)\n    Log(\"K线数据数量：\", r.length)\n\n    // 画图输出\n    $.PlotRecords(r, \"K\")\n\n    // 简单验证\n    for (var i = 0 ; i < r.length - 1 ; i++) {\n        if (r[i + 1].Time - r[i].Time != 1000 * 60 * 60) {\n            Log(_D(r[i + 1].Time), _D(r[i].Time), r[i + 1].Time - r[i].Time)\n        }\n    }\n}\n```\n\n![IMG](https://www.fmz.com/upload/asset/16d33bb293b09726b5dc.png) \n\n```main```函数是使用例子，其它函数可以摘出来直接使用。\n\n\n\n> Source (python)\n\n``` python\nimport json\nimport urllib.request\n\ndef encodeParams(params):\n    ret = \"\"\n    index = 0 \n    for key in params:\n        if index == 0:\n            ret += key + \"=\" + str(params[key])\n        else :\n            ret += \"&\" + key + \"=\" + str(params[key])\n        index += 1\n    return ret \n\ndef GetRecords(symbol, period):\n    arr = []\n    after = 0\n    while True:\n        params = {\n            \"instId\": symbol,\n            \"bar\": period,\n            \"limit\": 100,\n        }\n        if after != 0 :\n            params[\"after\"] = after\n        query = encodeParams(params)        \n        try :\n            headers = {\n                'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\n                'Accept-Language':'zh-CN,zh;q=0.9',\n                'Connection':'keep-alive',\n                'Cookie':'uuid_tt_dd=10_35489889920-1563497330616-876822; ...... ',\n                'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'\n            }           \n\n            url = \"https://www.okex.com/api/v5/market/candles?\" + query\n            req = urllib.request.Request(url=url,headers=headers)\n            r = json.loads(urllib.request.urlopen(req).read().decode('utf-8'))[\"data\"]\n            for i in range(len(r)):\n                record = {}\n                record[\"Time\"] = int(r[i][0])\n                record[\"High\"] = float(r[i][2])\n                record[\"Open\"] = float(r[i][1])\n                record[\"Low\"] = float(r[i][3])\n                record[\"Close\"] = float(r[i][4])\n                record[\"Volume\"] = float(r[i][5])\n                arr.append(record)\n                after = record[\"Time\"]\n            if len(arr) >= 1440 or len(r) == 0:\n                break\n        except Exception as e:\n            Log(e)\n            return \n        Sleep(1000)\n    arr.reverse()    \n    return arr \n    \ndef main():\n    r = GetRecords(\"ETH-USDT-SWAP\", \"1H\")\n    \n    Log(\"K线数据：\", r)\n    Log(\"K线数据数量：\", len(r))\n    \n    ext.PlotRecords(r, \"K\")\n    \n    for i in range(len(r) - 1):\n        if r[i + 1][\"Time\"] - r[i][\"Time\"] != 1000 * 60 * 60:\n            Log(_D(r[i + 1][\"Time\"] / 1000), _D(r[i][\"Time\"] / 1000), r[i + 1][\"Time\"] - r[i][\"Time\"])\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/316746\n\n> Last Modified\n\n2021-09-16 11:35:10"
    },
    {
        "strategy_id": "14_OKX部分交易封装示例",
        "strategy_code": "python\n#!/usr/bin/python\n# coding=UTF-8\n\nimport hmac\nimport base64\nimport urllib\nfrom hashlib import sha256\nimport datetime\nimport json\nimport requests\nfrom logger import logger\n\n\nclass Okex(object):\n\n    def __init__(self, api_key, secret_key, passphrase):\n        self.api_key = api_key\n        self.secret_key = secret_key\n        self.passphrase = passphrase\n        self.host = 'https://www.okex.com'\n        self.timestamp = ''\n        self.method = ''\n        self.request_path = ''\n\n    # 下单\n    def trade_order(self, symbol, pos_side, trade_side, sz, client_id, ord_type=\"market\", px=None):\n        self.request_path = '/api/v5/trade/order'\n        self.method = 'POST'\n        inst_id = symbol.upper() + '-USDT-SWAP'\n        post_data = {\n            'instId': inst_id,\n            'tdMode': 'cross',\n            'side': trade_side,\n            'ordType': ord_type,\n            'posSide': pos_side,\n            'sz': str(sz),\n            'tag': 'BrokerCode',\n            'clOrdId': '4dc650bdb59cBCDE' + str(client_id)\n        }\n        if ord_type == 'limit':\n            post_data['px'] = str(px)\n        try:\n            # 0 成功 1暂停几秒 2忽略此次交易 3 用户停止策略\n            order = self.send(post_data)\n            # print(order)\n            if len(order['data']) == 0:\n                return {\"code\": 2, \"msg\": 'OKEX下单接口返回数据错误', \"data\": {}}\n            order_info = order['data'][0]\n            if order['code'] == '0' and order_info['sCode'] == '0':\n                return {\"code\": 0, \"msg\": 'success', \"data\": order_info}\n\n            if order_info['sCode'] == '50004' or order_info['sCode'] == '51029' or order_info['sCode'] == '51030':\n                #  失败, 稍后可重试\n                return {\"code\": 1, \"msg\": order_info['sMsg'], \"data\": {}}\n            if order_info['sCode'] == '51008':\n                # 失败, 暂停买入\n                return {\"code\": 3, \"msg\": order_info['sMsg'], \"data\": {}}\n        except Exception as e:\n            return {\"code\": 2, \"msg\": str(e), \"data\": {}}\n        # 失败, 暂停运行\n        return {\"code\": 2, \"msg\": order_info['sMsg'], \"data\": {}}\n\n    # 撤单\n    def cancel_order(self, data):\n        self.request_path = '/api/v5/trade/cancel-batch-orders'\n        self.method = 'POST'\n        try:\n            order = self.send(data)\n            if len(order['data']) == 0:\n                return {\"code\": 3, \"msg\": 'OKEX撤单接口返回数据错误', \"data\": {}}\n            if order['code'] == '0':\n                return {\"code\": 0, \"msg\": 'success', \"data\": order}\n\n        except Exception as e:\n            # logger.error(e)\n            return {\"code\": 3, \"msg\": str(e), \"data\": {}}\n        # 失败, 暂停运行\n        return {\"code\": 3, \"msg\": order['msg'], \"data\": {}}\n\n    # 获取挂单列表\n    def get_open_order(self):\n        self.request_path = '/api/v5/trade/orders-pending'\n        self.method = 'GET'\n        post_data = {\n            'instType': 'SWAP',\n        }\n        order = self.send(post_data)\n        if order['code'] != '0':\n            raise ValueError(order['msg'])\n        return order['data']\n\n    # 获取持仓列表\n    def get_positions(self, symbol=None):\n        self.request_path = '/api/v5/account/positions'\n        self.method = 'GET'\n        post_data = {\n            'instType': 'SWAP',\n        }\n        if symbol:\n            post_data['instId'] = symbol.upper() + '-USDT-SWAP'\n\n        order = self.send(post_data)\n        if order['code'] != '0':\n            raise ValueError(order['msg'])\n        return order['data']\n\n    # 获取k线\n    def get_kline(self, symbol, limit, interval, after=None):\n        self.request_path = '/api/v5/market/history-candles'\n        self.method = 'GET'\n\n        post_data = {\n            'instId': symbol.upper() + '-USDT-SWAP',\n            'bar': interval,\n            'limit': limit,\n        }\n        if after:\n            post_data['after'] = after\n        order = self.send(post_data)\n        if order['code'] != '0':\n            raise ValueError(order['msg'])\n        return order['data']\n\n    # 签名\n    def generate_sign(self, data):\n        if self.method == 'GET':\n            self.request_path = self.request_path + '?' + urllib.parse.urlencode(data)\n        req_str = self.timestamp + self.method + self.request_path\n\n        if self.method == 'POST':\n            req_str = (req_str + json.dumps(data))\n\n        req_strs = req_str.encode('utf-8')\n        signature = base64.b64encode(hmac.new(self.secret_key.encode('utf-8'), req_strs, digestmod=sha256).digest())\n        return signature\n\n    # 时间戳\n    def set_timestamp(self):\n        utc_t = datetime.datetime.utcnow().isoformat()\n        self.timestamp = utc_t[:-3] + 'Z'\n\n    # 请求\n    def send(self, data):\n        self.set_timestamp()\n        headers = {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json',\n            'OK-ACCESS-KEY': self.api_key,\n            'OK-ACCESS-SIGN': self.generate_sign(data),\n            'OK-ACCESS-TIMESTAMP': self.timestamp,\n            'OK-ACCESS-PASSPHRASE': self.passphrase,\n        }\n        if self.method == 'GET':\n            response = requests.get(self.host + self.request_path, headers=headers, timeout=30)\n        else:\n            post_data = json.dumps(data)\n            response = requests.post(self.host + self.request_path, headers=headers, data=post_data, timeout=30)\n        # logger.info('okex请求信息')\n        # logger.info(data)\n        # logger.info(response.text)\n        return json.loads(response.text)",
        "strategy_description": "策略名称: OKX部分交易封装示例\n\nimport hmac\nimport base64\nimport urllib\nfrom hashlib import sha256\nimport datetime\nimport json\nimport requests\nfrom logger import logger\n\n\nclass Okex(object):\n\n    def __init__(self, api_key, secret_key, passphrase):\n        self.api_key = api_key\n        self.secret_key = secret_key\n        self.passphrase = passphrase\n        self.host = 'https://www.okex.com'\n        self.timestamp = ''\n        self.method = ''\n        self.request_path = ''\n\n    # 下单\n    def trade_order(self, symbol, pos_side, trade_side, sz, client_id, ord_type=\"market\", px=None):\n        self.request_path = '/api/v5/trade/order'\n        self.method = 'POST'\n        inst_id = symbol.upper() + '-USDT-SWAP'\n        post_data = {\n            'instId': inst_id,\n            'tdMode': 'cross',\n            'side': trade_side,\n            'ordType': ord_type,\n            'posSide': pos_side,\n            'sz': str(sz),\n            'tag': 'BrokerCode',\n            'clOrdId': '4dc650bdb59cBCDE' + str(client_id)\n        }\n        if ord_type == 'limit':\n            post_data['px'] = str(px)\n        try:\n            # 0 成功 1暂停几秒 2忽略此次交易 3 用户停止策略\n            order = self.send(post_data)\n            # print(order)\n            if len(order['data']) == 0:\n                return {\"code\": 2, \"msg\": 'OKEX下单接口返回数据错误', \"data\": {}}\n            order_info = order['data'][0]\n            if order['code'] == '0' and order_info['sCode'] == '0':\n                return {\"code\": 0, \"msg\": 'success', \"data\": order_info}\n\n            if order_info['sCode'] == '50004' or order_info['sCode'] == '51029' or order_info['sCode'] == '51030':\n                #  失败, 稍后可重试\n                return {\"code\": 1, \"msg\": order_info['sMsg'], \"data\": {}}\n            if order_info['sCode'] == '51008':\n                # 失败, 暂停买入\n                return {\"code\": 3, \"msg\": order_info['sMsg'], \"data\": {}}\n        except Exception as e:\n            return {\"code\": 2, \"msg\": str(e), \"data\": {}}\n        # 失败, 暂停运行\n        return {\"code\": 2, \"msg\": order_info['sMsg'], \"data\": {}}\n\n    # 撤单\n    def cancel_order(self, data):\n        self.request_path = '/api/v5/trade/cancel-batch-orders'\n        self.method = 'POST'\n        try:\n            order = self.send(data)\n            if len(order['data']) == 0:\n                return {\"code\": 3, \"msg\": 'OKEX撤单接口返回数据错误', \"data\": {}}\n            if order['code'] == '0':\n                return {\"code\": 0, \"msg\": 'success', \"data\": order}\n\n        except Exception as e:\n            # logger.error(e)\n            return {\"code\": 3, \"msg\": str(e), \"data\": {}}\n        # 失败, 暂停运行\n        return {\"code\": 3, \"msg\": order['msg'], \"data\": {}}\n\n    # 获取挂单列表\n    def get_open_order(self):\n        self.request_path = '/api/v5/trade/orders-pending'\n        self.method = 'GET'\n        post_data = {\n            'instType': 'SWAP',\n        }\n        order = self.send(post_data)\n        if order['code'] != '0':\n            raise ValueError(order['msg'])\n        return order['data']\n\n    # 获取持仓列表\n    def get_positions(self, symbol=None):\n        self.request_path = '/api/v5/account/positions'\n        self.method = 'GET'\n        post_data = {\n            'instType': 'SWAP',\n        }\n        if symbol:\n            post_data['instId'] = symbol.upper() + '-USDT-SWAP'\n\n        order = self.send(post_data)\n        if order['code'] != '0':\n            raise ValueError(order['msg'])\n        return order['data']\n\n    # 获取k线\n    def get_kline(self, symbol, limit, interval, after=None):\n        self.request_path = '/api/v5/market/history-candles'\n        self.method = 'GET'\n\n        post_data = {\n            'instId': symbol.upper() + '-USDT-SWAP',\n            'bar': interval,\n            'limit': limit,\n        }\n        if after:\n            post_data['after'] = after\n        order = self.send(post_data)\n        if order['code'] != '0':\n            raise ValueError(order['msg'])\n        return order['data']\n\n    # 签名\n    def generate_sign(self, data):\n        if self.method == 'GET':\n            self.request_path = self.request_path + '?' + urllib.parse.urlencode(data)\n        req_str = self.timestamp + self.method + self.request_path\n\n        if self.method == 'POST':\n            req_str = (req_str + json.dumps(data))\n\n        req_strs = req_str.encode('utf-8')\n        signature = base64.b64encode(hmac.new(self.secret_key.encode('utf-8'), req_strs, digestmod=sha256).digest())\n        return signature\n\n    # 时间戳\n    def set_timestamp(self):\n        utc_t = datetime.datetime.utcnow().isoformat()\n        self.timestamp = utc_t[:-3] + 'Z'\n\n    # 请求\n    def send(self, data):\n        self.set_timestamp()\n        headers = {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json',\n            'OK-ACCESS-KEY': self.api_key,\n            'OK-ACCESS-SIGN': self.generate_sign(data),\n            'OK-ACCESS-TIMESTAMP': self.timestamp,\n            'OK-ACCESS-PASSPHRASE': self.passphrase,\n        }\n        if self.method == 'GET':\n            response = requests.get(self.host + self.request_path, headers=headers, timeout=30)\n        else:\n            post_data = json.dumps(data)\n            response = requests.post(self.host + self.request_path, headers=headers, data=post_data, timeout=30)\n        # logger.info('okex请求信息')\n        # logger.info(data)\n        # logger.info(response.text)\n        return json.loads(response.text)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/417576\n\n> Last Modified\n\n2023-06-14 17:57:16"
    },
    {
        "strategy_id": "15_OkEX-Websocket-Realtime-v3",
        "strategy_code": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n# \n# Market Real-time Subscription v3\n#\n# Copyright 2019 FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\n\nimport time\nimport ssl\nimport sys\nimport code\nimport json\nimport hashlib\nimport hmac\nimport urllib\nimport threading\nimport websocket\nimport zlib\nimport string\n\ntry:\n    import readline\nexcept ImportError:\n    pass\n\npong = time.time()\n\nclass WSSubscription:\n\n    def __init__(self, instrument_id='BTC-USD-190517', market='futures', on_message=None):\n        self.__iid = instrument_id\n        self.__market = market\n        self.__Depth = {}\n        \n        if on_message is not None:\n            self.__callbackEnabled = True\n            self.__callback = on_message\n        else:\n            self.__callbackEnabled = False\n\n        thread = threading.Thread(target=self.sub, args=())\n        thread.daemon = True\n        thread.start()\n\n    def GetDepth(self):\n        return self.__Depth\n\n    def subscribe(self, ws):\n        \n        def operator(op, args):\n            message = {\n                'op': op,\n                'args': args\n            }\n            ws.send(json.dumps(message))\n\n        def run(*args):\n            operator('subscribe', ['%s/depth5:%s' % (self.__market, self.__iid)])\n            operator('subscribe', ['%s/trade:%s' % (self.__market, self.__iid)])\n\n            while True:\n                ws.send(\"ping\")\n                time.sleep(30)\n\n        threading.Thread(target=run).start()\n\n    def sub(self):\n\n        websocket.enableTrace(False)\n        URL = \"wss://real.okex.com:10442/ws/v3\"\n        ws = websocket.WebSocketApp(URL,\n                                    on_message=self.incoming,\n                                    on_error=self.error_handling,\n                                    on_close=self.closing)\n\n        ws.on_open = self.subscribe\n\n        while True:\n            try:\n                ws.run_forever()\n            except:\n                pass\n\n        pass\n\n    def incoming(self,ws,message):\n        message = zlib.decompress(message, -zlib.MAX_WBITS)\n        message = message.decode('utf-8')\n        global pong\n        if 'pong' in message:\n            pong = time.time()\n        if 'asks' in message and 'bids' in message:\n            d = json.loads(message)\n            self.__Depth = d['data'][0]\n            \n        if self.__callbackEnabled:\n            self.__callback(message)\n    \n\n    def error_handling(self,ws,error):\n        print(str(error))\n\n    def closing(self,ws):\n        print(\"WebSocket Closing...\")\n        \next.OkEXWS = WSSubscription\n\n# 模块测试\ndef main():\n    OkEX = ext.OkEXWS('BTC-USD-190517', 'futures')\n    while (True):\n        Log(OkEX.GetDepth())\n        time.sleep(1)",
        "strategy_description": "策略名称: OkEX-Websocket-Realtime-v3\n\n因为 `websocket-client` 新版的各种大脑降级设计 很多功能无法使用\n需要安装老版本websocket-client的包才能正常使用 `pip3 install websocket-client==0.46.0`\n\n\n\n> Source (python)\n\n``` python"
    },
    {
        "strategy_id": "16_OkEX-高级API功能-V110-期货批量下单现货TBD-Python2-3",
        "strategy_code": "python\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n# OkEX Advanced API Interface for FMZ.com.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# GNU General Public License v3.0\n#\n\nimport json\nimport time\n\nQUOTES = {}\nQUOTES['ZH'] = {\n    'GREET' : '[OkEX 接口已初始化]  币种: %s 合约: %s. %s',\n    'INITF' : '使用的交易所不正确，当前交易所: %s',\n    'PARAMERR' : '***传的参数不对 检查你的代码*** %s',\n    'NEWORDER' : '[添加订单]  币种: %s 合约: %s 方向: %s 价格: %.4f 数量: %d 张. %s',\n    'ORDCOUNT' : '[本次批量发送订单]  总计: %d 条. %s',\n    'THISBATCH' : '[信息]  正在处理 币种: %s 合约: %s 条数: %d. %s',\n    'ORDSENT' : '[已发送订单]  币种: %s 合约: %s 条数: %d. %s',\n    'NEEDSPLIT' : '[信息]  由于单合约单量大于5条 需要进行分片处理. %s',\n    'CLEARALL' : '[信息]  已清除所有本地订单. %s',\n    'CLEARS' : '[信息]  已清除所有 %s 本地订单. %s',\n    'CLEAR' : '[信息]  已清除所有 %s %s 本地订单. %s'\n}\n\nCOLORS = {\n    'DEEPBLUE' : '#1F618D',\n    'BLUE' : '#0000FF',\n    'LIGHTBLUE' : '#5DADE2',\n    'DEEPGREEN' : '#27AE60',\n    'GREEN' : '#00FF00',\n    'LIGHTGREEN' : '#58D68D',\n    'LAPIS' : '#26619C',\n    'DEEPRED' : '#CB4335',\n    'RED' : '#FF0000',\n    'LIGHTRED' : '#EC7063'\n}\n\n\nclass OkEXFuture:\n\n    def __init__(self, exchange, future='this_week'):\n        self.QUOTES = {}\n        exchange.GetCurrency()\n        if isinstance(exchange.GetCurrency(), bytes):\n            self.symbol = str(exchange.GetCurrency(), \"utf-8\").lower()\n            name = str(exchange.GetName(), \"utf-8\")\n        else:\n            self.symbol = exchange.GetCurrency()\n            name = exchange.GetName()\n        self.IO = exchange.IO\n        self.future = future\n        self.bulks = {}\n        self.bulks[self.symbol] = {}\n        self.bulks[self.symbol][self.future] = []\n        if 'OKCoin' in str(name):\n            Log(QUOTES[LANG]['GREET'] % (self.symbol.upper(),self.future.upper(),COLORS['LAPIS']))\n        else:\n            Log(QUOTES[LANG]['INITF'] % (name))\n\n    def BulkAdd(self, side=None, price=None, amount=None, matchPrice=False, symbol=None, future=None):\n        if type is None or price is None or amount is None:\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\n            return False\n        side = side.lower()\n        if side == 'buy':\n            tp = 1\n            cl = COLORS['DEEPGREEN']\n        if side == 'sell':\n            tp = 2\n            cl = COLORS['DEEPRED']\n        if side == 'closebuy':\n            tp = 3\n            cl = COLORS['LIGHTRED']\n        if side == 'closesell':\n            tp = 4\n            cl = COLORS['LIGHTGREEN']\n        if symbol is None:\n            symbol = self.symbol\n        if future is None:\n            future = self.future\n\n        order = {}\n        order['price'] = price\n        order['amount'] = amount\n        order['type'] = tp\n\n        if matchPrice:\n            order['matchPrice'] = 1\n\n        try:\n            self.bulks[symbol]\n        except KeyError:\n            self.bulks[symbol] = {}\n        try:\n            self.bulks[symbol][future]\n        except KeyError:\n            self.bulks[symbol][future] = []\n\n        self.bulks[symbol][future].append(order)\n\n        Log(QUOTES[LANG]['NEWORDER'] % (symbol.upper(),future.upper(),side.upper(),price,amount,cl))\n\n        return True\n\n    def BulkOrders(self, symbol=None, future=None):\n        if symbol is None:\n            return self.bulks\n        else:\n            if future is None:\n                return self.bulks[symbol]\n            else:\n                return self.bulks[symbol][future]\n\n    def BulkClear(self, symbol=None, future=None, notify=True):\n        if symbol is None:\n            self.bulks = {}\n            if notify:\n                Log(QUOTES[LANG]['CLEARALL'] % (COLORS['RED']))\n        else:\n            if future is None:\n                self.bulks[symbol] = {}\n                if notify:\n                     Log(QUOTES[LANG]['CLEARS'] % (symbol.encode().upper(), COLORS['RED']))\n            else:\n                self.bulks[symbol][future] = []\n                if notify:\n                    Log(QUOTES[LANG]['CLEAR'] % (symbol.encode().upper(), future.encode().upper(), COLORS['RED']))\n                    #Log(QUOTES[LANG]['CLEAR'] % (symbol.upper(), future.upper(), COLORS['RED']))\n\n        return True\n\n    #exchange.IO(\"api\", \"POST\", \"/api/v1/future_batch_trade.do\", \"symbol=etc_usd&contract_type=this_week&orders_data=\"+json.dumps(orders))\n    def __post(self, symbol='', future=''):\n        count = len(self.bulks[symbol][future])\n        orders = self.bulks[symbol][future]\n        ret = []\n        if count == 0:\n            return\n        Log(QUOTES[LANG]['THISBATCH'] % (symbol.upper(),future.upper(),count,COLORS['LAPIS']))\n        if count <= 5:\n            params = 'symbol=%s&contract_type=%s&orders_data=%s' % (symbol, future, json.dumps(orders))\n            res = self.IO(\"api\", \"POST\", \"/api/v1/future_batch_trade.do\", params)\n            ret+=res['order_info']\n            Log(QUOTES[LANG]['ORDSENT'] % (symbol.upper(),future.upper(),len(orders),COLORS['LAPIS']))\n        if count > 5:\n            Log(QUOTES[LANG]['NEEDSPLIT'] % (COLORS['LAPIS']))\n            batch = []\n            for item in orders:\n                batch.append(item)\n                if len(batch) == 5:\n                    params = 'symbol=%s&contract_type=%s&orders_data=%s' % (symbol, future, json.dumps(batch))\n                    res = self.IO(\"api\", \"POST\", \"/api/v1/future_batch_trade.do\", params)\n                    try:\n                        ret+=res['order_info']\n                    except:\n                        pass\n                    Log(QUOTES[LANG]['ORDSENT'] % (symbol.upper(),future.upper(),len(batch),COLORS['LAPIS']))\n                    batch = []\n                    time.sleep(0.3)               # OkEX限制每秒只能进行三个请求\n\n            params = 'symbol=%s&contract_type=%s&orders_data=%s' % (symbol, future, json.dumps(batch))\n            res = self.IO(\"api\", \"POST\", \"/api/v1/future_batch_trade.do\", params)\n            try:\n                ret+=res['order_info']\n            except:\n                pass\n            Log(QUOTES[LANG]['ORDSENT'] % (symbol.upper(),future.upper(),len(batch),COLORS['LAPIS']))\n\n        return ret\n\n    def BulkPost(self, symbol=None, future=None):\n        ret = []\n        count = 0\n        if symbol is None:\n            symbols = self.bulks.keys()\n            for s in symbols:\n                futures = self.bulks[s].keys()\n                for f in futures:\n                    count+=len(self.bulks[s][f])\n                    ret+=self.__post(s, f)\n                    time.sleep(0.3)               # OkEX限制每秒只能进行三个请求\n\n            self.BulkClear(notify=False)\n        else:\n            if future is None:\n                futures = self.bulks[symbol].keys()\n                for f in futures:\n                    count+=len(self.bulks[symbol][f])\n                    ret+=self.__post(symbol, f)\n                    time.sleep(0.3)               # OkEX限制每秒只能进行三个请求\n\n                self.BulkClear(symbol=symbol, notify=False)\n            else:\n                count+=len(self.bulks[symbol][future])\n                ret+=self.__post(symbol, future)\n\n                self.BulkClear(symbol=symbol, future=future, notify=False)\n\n        Log(QUOTES[LANG]['ORDCOUNT'] % (count,COLORS['LAPIS']))\n        return ret\n\nclass OkEXSpot:\n\n    def __init__(self, exchange):\n        self.IO = exchange.IO\n\n    #TBD\n\next.OkEXFuturePlus = OkEXFuture # 导出OkEXFuture Class, 主策略可以通过FuturePlus = ext.OkEXFuturePlus(exchange, future)调用\next.OkEXSpotPlus = OkEXSpot # 导出OkEXSpot Class, 主策略可以通过SpotPlus = ext.OkEXSpotPlus(exchange)调用\n\n# 模块功能测试\ndef main():\n    LogReset()\n    Log(exchange.GetAccount())\n    OKEXPlus = ext.OkEXFuturePlus(exchange)\n    # 4 Buy 2 Sell 1 next_week\n    base_price = exchange.GetTicker()['Last']\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"closebuy\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.3, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.7, 1, future='next_week')\n\n    OKEXPlus.BulkClear()\n\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.8, 1)\n    OKEXPlus.BulkAdd(\"closebuy\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.3, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.7, 1, future='next_week')\n\n    OKEXPlus.BulkClear(symbol=(exchange.GetCurrency()).lower(),future='this_week')\n    OKEXPlus.BulkClear(symbol=(exchange.GetCurrency()).lower(),future='next_week')\n\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.8, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.7, 1, future='next_week')\n    OKEXPlus.BulkClear(symbol=(exchange.GetCurrency()).lower())\n\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.8, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.81, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.82, 1)\n    OKEXPlus.BulkAdd(\"closesell\", base_price*0.8, 1)\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"closebuy\", base_price*1.2, 1)\n    OKEXPlus.BulkAdd(\"sell\", base_price*1.3, 1)\n    OKEXPlus.BulkAdd(\"buy\", base_price*0.7, 1, future='next_week')\n\n    Log(OKEXPlus.BulkOrders())\n    for item in OKEXPlus.BulkPost():\n        Log(str(item))\n    Log(OKEXPlus.BulkOrders())",
        "strategy_description": "策略名称: OkEX-高级API功能-V110-期货批量下单现货TBD-Python2-3\n\n### 初始化\n这个库整合了一些 OkEX 高级API 功能，使用前需要进行初始化。"
    },
    {
        "strategy_id": "17_OkEX合约-仓位管理系统",
        "strategy_code": "python\n\nimport time\nimport math\nimport threading\nimport decimal\nfrom uuid import uuid4 as _uuid\n\ndef genUUID():\n    return str(_uuid())\n\nclass PositionManager:\n\n    def __init__(self, exchange, symbol, contract, getDepth, tickSize=0.01):\n        self.okex = exchange\n        self.symbol = symbol\n        self.contract = contract\n        self.tickSize = tickSize\n        self.isFMZ = False\n        if 'Asks' in getDepth().keys():\n            self.isFMZ = True\n        self.okexGetDepth = getDepth\n        self.orderLock = threading.Lock()\n        self.orderLocks = {}\n        self.orders = {}\n        self.cancels = []\n        self.completeds = []\n        self.init()\n\n    def init(self):\n        self.okex.IO(\"currency\", self.symbol.upper())\n        self.okex.SetContractType(self.contract)\n        self.order_logs = {\n            'buySent': 0,\n            'buyCanceled': 0,\n            'sellSent': 0,\n            'sellCanceled': 0\n        }\n\n    def toNearest(self, num):\n        tickDec = decimal.Decimal(str(self.tickSize))\n        return float((decimal.Decimal(round(num / self.tickSize, 0)) * tickDec))\n\n    def getDepth(self):\n        depth = self.okexGetDepth()\n        if self.isFMZ:\n            depth['asks'] = [[x['Price'], x['Amount']] for x in depth['Asks']]\n            depth['bids'] = [[x['Price'], x['Amount']] for x in depth['Bids']]\n        return depth\n\n    def getOrderLogs(self):\n        return self.order_logs\n\n    def getBestPrices(self):\n        bestPrices = {}\n        depth = self.getDepth()\n        ask, bid = depth['asks'][0][0], depth['bids'][0][0]\n        spread = ask - bid\n        if spread <= self.tickSize*2:\n            bestPrices['ask'] = ask\n            bestPrices['bid'] = bid\n        elif spread <= self.tickSize*6:\n            bestPrices['ask'] = ask-self.tickSize\n            bestPrices['bid'] = bid+self.tickSize\n        elif spread >= self.tickSize*20:\n            bestPrices['ask'] = ask-self.tickSize*5\n            bestPrices['bid'] = bid+self.tickSize*5\n        else:\n            midPrice = self.toNearest((ask+bid)/2)\n            bestPrices['ask'] = midPrice+self.tickSize*2\n            bestPrices['bid'] = midPrice-self.tickSize*2\n        return {\n            'ask': self.toNearest(bestPrices['ask']),\n            'bid': self.toNearest(bestPrices['bid'])\n        }\n\n    def getPositions(self, noRetry=False, maxRetries=10):\n        if noRetry:\n            return self.okex.GetPosition()\n        attempts = 0\n        while True:\n            time.sleep(0.4)\n            positions = self.okex.GetPosition()\n            attempts+=1\n            if len(positions) != 0:\n                return positions\n            if attempts == maxRetries:\n                return False\n\n    def havePosition(self, type=None, noRetry=True, maxRetries=10):\n        positions = self.getPositions(noRetry=True)\n        if not positions:\n            positions = []\n        if type == None:\n            pass\n        elif type == 'buy':\n            key = 'buy_amount'\n        elif type == 'sell':\n            key = 'sell_amount'\n        for position in positions:\n            if type is not None:\n                if position['Info'][key] != 0:\n                    return positions\n            else:\n                return positions\n        if noRetry:\n            return False\n        attempts = 0\n        while True:\n            time.sleep(0.4)\n            positions = self.getPositions(noRetry=True)\n            if not positions:\n                positions = []\n            attempts+=1\n            for position in positions:\n                if type is not None:\n                    if position['Info'][key] != 0:\n                        return positions\n                else:\n                    return positions\n            if attempts == maxRetries:\n                return False\n\n    def orderDone(self, orderID):\n        orders = self.okex.GetOrders()\n        for order in orders:\n            if order['Info']['order_id'] == orderID:\n                return order['Info']['price'], order['Info']['amount']-order['Info']['deal_amount']\n        return True\n\n    def getOrder(self, uuid):\n        try:\n            self.orders[uuid]\n        except KeyError:\n            Log('不存在订单 %s' % uuid)\n            return 0\n        return self.orders[uuid]\n\n    def getOrderInfo(self, uuid):\n        return self.okex.GetOrder(self.getOrder(uuid))\n\n    def awaitOrder(self, uuid, timeout=None):\n        start = time.time()\n        try:\n            self.orderLocks[uuid]\n        except KeyError:\n            return False\n        while True:\n            if self.orderLocks[uuid].acquire(False):\n                del self.orderLocks[uuid]\n                return self.getOrder(uuid)\n            else:\n                if timeout is not None:\n                    if time.time()-timeout>start:\n                        Log('等待订单成交已超时.')\n                        return\n            time.sleep(0.001)\n\n    def isDone(self, uuid):\n        if uuid in self.completeds:\n            return True\n        return False\n\n    def cancel(self, uuid):\n        self.cancels.append(uuid)\n        _cancel = self.okex.CancelOrder(self.getOrder(uuid))\n        self.orderLocks[uuid].acquire()\n        self.orderLocks[uuid].release()\n        if _cancel:\n            Log(uuid, str(self.getOrder(uuid)), '已取消.')\n            return True\n        Log(uuid, str(self.getOrder(uuid)), '取消失败.', str(self.okex.GetRawJSON()))\n        return False\n\n    def trade(self, type, price, amount, matchPrice=False, noRetry=False, uuid=None):\n        if type == 'buy' or type == 'closesell':\n            _trader = self.okex.Buy\n            _side = 'buy'\n            __side = 'bid'\n        else:\n            _trader = self.okex.Sell\n            _side = 'sell'\n            __side = 'ask'\n        def trader(price, amount):\n            self.orderLock.acquire()\n            self.okex.SetDirection(type)\n            order = _trader(price, amount)\n            self.orders[uuid] = order\n            self.orderLock.release()\n            self.order_logs['%sSent' % _side]+=1\n            return order\n        def isBestPrice(currentPrice, depth):\n            ret = False\n            if _side == 'buy':\n                if currentPrice > depth['bids'][1][0]:\n                    ret = True\n            else:\n                if currentPrice < depth['asks'][1][0]:\n                    ret = True\n            return ret\n        if price is None:\n            price = self.getBestPrices()[__side]\n        if matchPrice:\n            price = -1\n        order = trader(price, amount)\n        if noRetry:\n            self.completeds.append(uuid)\n            self.orderLocks[uuid].release()\n            return\n        if order == False:\n            if 20016 in str(self.okex.GetRawJSON()):\n                order = trader(price, amount)\n            if order == False:\n                Log('%s 返回值: %s', (uuid, str(self.okex.GetRawJSON())))\n                self.completeds.append(uuid)\n                self.orderLocks[uuid].release()\n                return\n        time.sleep(1)\n        while True:\n            if uuid in self.cancels:\n                Log('%s 已停止下单尝试.' % uuid)\n                self.completeds.append(uuid)\n                self.orderLocks[uuid].release()\n                return\n            time.sleep(1)\n            depth = self.getDepth()\n            isDone = self.orderDone(order)\n            if isDone == True:\n                self.completeds.append(uuid)\n                self.orderLocks[uuid].release()\n                return\n            if isBestPrice(isDone[0], depth):\n                continue\n            if not self.okex.CancelOrder(order):\n                time.sleep(1)\n                if self.orderDone(order):\n                    self.completeds.append(uuid)\n                    self.orderLocks[uuid].release()\n                    return\n            self.order_logs['%sCanceled' % _side]+=1\n            time.sleep(1)\n            if price != -1:\n                price = self.getBestPrices()[__side]\n            if uuid in self.cancels:\n                Log('%s 已停止下单尝试.' % uuid)\n                self.completeds.append(uuid)\n                self.orderLocks[uuid].release()\n                return\n            order = trader(price, isDone[1])\n\n    def openLong(self, amount, price=None, matchPrice=False, noRetry=False):\n        uuid = genUUID()\n        Log('%s 买入做多 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'buy',\n                                                        'price': price,\n                                                        'amount': amount,\n                                                        'matchPrice': matchPrice,\n                                                        'noRetry': noRetry,\n                                                        'uuid': uuid}), daemon=True).start()\n        self.orderLocks[uuid] = threading.Lock()\n        self.orderLocks[uuid].acquire()\n        return uuid\n\n    def openShort(self, amount, price=None, matchPrice=False, noRetry=False):\n        uuid = genUUID()\n        Log('%s 卖出做空 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'sell',\n                                                        'price': price,\n                                                        'amount': amount,\n                                                        'matchPrice': matchPrice,\n                                                        'noRetry': noRetry,\n                                                        'uuid': uuid}), daemon=True).start()\n        self.orderLocks[uuid] = threading.Lock()\n        self.orderLocks[uuid].acquire()\n        return uuid\n\n    def coverLong(self, amount, price=None, matchPrice=False, noRetry=False):\n        uuid = genUUID()\n        Log('%s 卖出平多 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'closebuy',\n                                                        'price': price,\n                                                        'amount': amount,\n                                                        'matchPrice': matchPrice,\n                                                        'noRetry': noRetry,\n                                                        'uuid': uuid}), daemon=True).start()\n        self.orderLocks[uuid] = threading.Lock()\n        self.orderLocks[uuid].acquire()\n        return uuid\n\n    def coverShort(self, amount, price=None, matchPrice=False, noRetry=False):\n        uuid = genUUID()\n        Log('%s 买入平空 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'closesell',\n                                                        'price': price,\n                                                        'amount': amount,\n                                                        'matchPrice': matchPrice,\n                                                        'noRetry': noRetry,\n                                                        'uuid': uuid}), daemon=True).start()\n        self.orderLocks[uuid] = threading.Lock()\n        self.orderLocks[uuid].acquire()\n        return uuid\n\next.okexPositionManager = PositionManager",
        "strategy_description": "策略名称: OkEX合约-仓位管理系统\n\n未找到描述"
    },
    {
        "strategy_id": "18_Paul-The-Gambler-Lévy-Gold-Edition",
        "strategy_code": "python\n\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n#  Paul \"The Gambler\" Lévy.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\nimport random\nimport talib\nimport numpy as np\nfrom math import *\n\nAccount = {}\nTicker = {}\nRecords = {}\nLPosition = 0\nSPosition = 0\nPositions = {}\nTotalLoss = 0\nTotalWin = 0\nFullLoss = 0\nMaxPosition = 0\nTotalLongs = 0\nTotalShorts = 0\n\ndef cancelAllOrders():\n    orders = exchange.GetOrders()\n    for order in orders:\n        exchange.CancelOrder(order['Id'], order)\n    return True\n\ndef updateMarket():\n    global Ticker\n    global Records\n\n    Ticker = exchange.GetTicker()\n    Records = exchange.GetRecords()\n\n    return True\n\ndef getTAFormat(Records):\n    Close = []\n    for item in Records:\n        Close.append(item['Close'])\n\n    return np.array(Close)\n\ndef updateAccount():\n    global Account\n    global LPosition\n    global SPosition\n    global Positions\n    global MaxPosition\n\n    LPosition = 0\n    SPosition = 0\n    Positions = {}\n    for item in exchange.GetPosition():\n        if item['MarginLevel'] == LEVERAGE_RATE:\n            if item['Type'] == 1:\n                Positions['Short'] = item\n                SPosition += item['Amount']\n            else:\n                Positions['Long'] = item\n                LPosition += item['Amount']\n        MaxPosition = max(MaxPosition, SPosition, LPosition)\n\n    Account = exchange.GetAccount()\n\n    return True\n\ndef updatePositions():\n    global TotalWin\n    global TotalLoss\n    global FullLoss\n\n    opened = False\n\n    try:\n        Long = Positions['Long']['Amount']\n        LongEntry = Positions['Long']['Price']\n        Current = Ticker['Sell']\n\n        StopLoss = LongEntry * (1-STOP_LOSS)\n        TakeProfit = LongEntry * (1+TAKE_PROFIT)\n\n        if Current > TakeProfit:\n            Risked = True\n            Log('多仓达到预设止盈价位. #0000FF')\n            TotalWin+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverLong(Long, True)\n        if Current < StopLoss:\n            Risked = True\n            Log('多仓达到预设止损价位. #FF0000')\n            TotalLoss+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverLong(Long, True)\n            if Long*AMP < RISK_LIMIT:\n                openShort(Long*AMP, True)\n            else:\n                FullLoss+=1\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n\n        opened = True\n    except KeyError:\n        pass\n\n    try:\n        Short = Positions['Short']['Amount']\n        ShortEntry = Positions['Short']['Price']\n        Current = Ticker['Buy']\n\n        StopLoss = ShortEntry * (1+STOP_LOSS)\n        TakeProfit = ShortEntry * (1-TAKE_PROFIT)\n\n        if Current < TakeProfit:\n            Risked = True\n            Log('空仓达到预设止盈价位. #0000FF')\n            TotalWin+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverShort(Short, True)\n        if Current > StopLoss:\n            Risked = True\n            Log('空仓达到预设止损价位. #FF0000')\n            TotalLoss+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverShort(Short, True)\n            if Short*AMP < RISK_LIMIT:\n                openLong(Short*AMP, True)\n            else:\n                FullLoss+=1\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n\n        opened = True\n    except KeyError:\n        pass\n\n    if not opened:\n        Log('还没开仓，随便开个仓位.')\n        RSI = talib.RSI(getTAFormat(Records), timeperiod=14)\n        if RSI[-2]<RSI[-1]:\n            Log('RSI14: ', RSI[-1],' 正在开多.')\n            openLong(START_SIZE, True)\n        else:\n            Log('RSI14: ', RSI[-1],' 正在开空.')\n            openShort(START_SIZE, True)\n\n    return True\n\ndef openLong(Amount=0, marketPrice=False):\n    global TotalLongs\n\n    Amount = floor(Amount)\n\n    TotalLongs+=Amount\n\n    exchange.SetDirection('buy')\n\n    if marketPrice:\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\n    else:\n        exchange.Buy(Ticker['Sell'], Amount)\n\n    return True\n\ndef coverLong(Amount=0, marketPrice=False):\n    exchange.SetDirection('closebuy')\n\n    if marketPrice:\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\n    else:\n        exchange.Sell(Ticker['Buy'], Amount)\n\n    return True\n\ndef openShort(Amount=0, marketPrice=False):\n    global TotalShorts\n\n    Amount = floor(Amount)\n\n    TotalShorts+=Amount\n\n    exchange.SetDirection('sell')\n\n    if marketPrice:\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\n    else:\n        exchange.Sell(Ticker['Buy'], Amount)\n\n    return True\n\ndef coverShort(Amount=0, marketPrice=False):\n    exchange.SetDirection('closesell')\n\n    if marketPrice:\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\n    else:\n        exchange.Buy(Ticker['Sell'], Amount)\n\n    return True\n\ndef onTick():\n    cancelAllOrders()\n    updateMarket()\n    updateAccount()\n    updatePositions()\n\n    return True\n\ndef main():\n    exchange.SetContractType(CONTRACT_TYPE)\n    exchange.SetMarginLevel(LEVERAGE_RATE)\n\n    while True:\n        onTick()\n        Sleep(DELAY*1000)",
        "strategy_description": "策略名称: Paul-The-Gambler-Lévy-Gold-Edition\n\n##### 方向做错了就自动反向翻倍开仓"
    },
    {
        "strategy_id": "19_Paul-The-Gambler-Lévy",
        "strategy_code": "python\n\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n#  Paul \"The Gambler\" Lévy.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\nimport random\nfrom math import *\n\nAccount = {}\nTicker = {}\nLPosition = 0\nSPosition = 0\nPositions = {}\nTotalLoss = 0\nTotalWin = 0\nFullLoss = 0\nMaxPosition = 0\nTotalLongs = 0\nTotalShorts = 0\n\ndef cancelAllOrders():\n    orders = exchange.GetOrders()\n    for order in orders:\n        exchange.CancelOrder(order['Id'], order)\n    return True\n\ndef updateMarket():\n    global Ticker\n\n    Ticker = exchange.GetTicker()\n\n    return True\n\ndef updateAccount():\n    global Account\n    global LPosition\n    global SPosition\n    global Positions\n    global MaxPosition\n\n    LPosition = 0\n    SPosition = 0\n    Positions = {}\n    for item in exchange.GetPosition():\n        if item['MarginLevel'] == LEVERAGE_RATE:\n            if item['Type'] == 1:\n                Positions['Short'] = item\n                SPosition += item['Amount']\n            else:\n                Positions['Long'] = item\n                LPosition += item['Amount']\n        MaxPosition = max(MaxPosition, SPosition, LPosition)\n\n    Account = exchange.GetAccount()\n\n    return True\n\ndef updatePositions():\n    global TotalWin\n    global TotalLoss\n    global FullLoss\n\n    opened = False\n\n    try:\n        Long = Positions['Long']['Amount']\n        LongEntry = Positions['Long']['Price']\n        Current = Ticker['Sell']\n\n        StopLoss = LongEntry * (1-STOP_LOSS)\n        TakeProfit = LongEntry * (1+TAKE_PROFIT)\n\n        if Current > TakeProfit:\n            Risked = True\n            Log('多仓达到预设止盈价位. #0000FF')\n            TotalWin+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverLong(Long, True)\n        if Current < StopLoss:\n            Risked = True\n            Log('多仓达到预设止损价位. #FF0000')\n            TotalLoss+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverLong(Long, True)\n            if Long*AMP < RISK_LIMIT:\n                openShort(Long*AMP, True)\n            else:\n                FullLoss+=1\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n\n        opened = True\n    except KeyError:\n        pass\n\n    try:\n        Short = Positions['Short']['Amount']\n        ShortEntry = Positions['Short']['Price']\n        Current = Ticker['Buy']\n\n        StopLoss = ShortEntry * (1+STOP_LOSS)\n        TakeProfit = ShortEntry * (1-TAKE_PROFIT)\n\n        if Current < TakeProfit:\n            Risked = True\n            Log('空仓达到预设止盈价位. #0000FF')\n            TotalWin+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverShort(Short, True)\n        if Current > StopLoss:\n            Risked = True\n            Log('空仓达到预设止损价位. #FF0000')\n            TotalLoss+=1\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n            coverShort(Short, True)\n            if Short*AMP < RISK_LIMIT:\n                openLong(Short*AMP, True)\n            else:\n                FullLoss+=1\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\n\n        opened = True\n    except KeyError:\n        pass\n\n    if not opened:\n        Log('还没开仓，随便开个仓位.')\n        rand = random.choice([1,2,3,4,5,6])\n        if rand in [1,3,5]:\n            Log('骰子抛到了: ',rand,' 正在开多.')\n            openLong(START_SIZE, True)\n        else:\n            Log('骰子抛到了: ',rand,' 正在开空.')\n            openShort(START_SIZE, True)\n\n    return True\n\ndef openLong(Amount=0, marketPrice=False):\n    global TotalLongs\n\n    Amount = floor(Amount)\n\n    TotalLongs+=Amount\n\n    exchange.SetDirection('buy')\n\n    if marketPrice:\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\n    else:\n        exchange.Buy(Ticker['Sell'], Amount)\n\n    return True\n\ndef coverLong(Amount=0, marketPrice=False):\n    exchange.SetDirection('closebuy')\n\n    if marketPrice:\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\n    else:\n        exchange.Sell(Ticker['Buy'], Amount)\n\n    return True\n\ndef openShort(Amount=0, marketPrice=False):\n    global TotalShorts\n\n    Amount = floor(Amount)\n\n    TotalShorts+=Amount\n\n    exchange.SetDirection('sell')\n\n    if marketPrice:\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\n    else:\n        exchange.Sell(Ticker['Buy'], Amount)\n\n    return True\n\ndef coverShort(Amount=0, marketPrice=False):\n    exchange.SetDirection('closesell')\n\n    if marketPrice:\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\n    else:\n        exchange.Buy(Ticker['Sell'], Amount)\n\n    return True\n\ndef onTick():\n    cancelAllOrders()\n    updateMarket()\n    updateAccount()\n    updatePositions()\n\n    return True\n\ndef main():\n    exchange.SetContractType(CONTRACT_TYPE)\n    exchange.SetMarginLevel(LEVERAGE_RATE)\n\n    while True:\n        onTick()\n        Sleep(DELAY*1000)",
        "strategy_description": "策略名称: Paul-The-Gambler-Lévy\n\n##### 方向做错了就自动反向翻倍开仓"
    },
    {
        "strategy_id": "20_Python-API-测试",
        "strategy_code": "python\n\n'''backtest\nstart: 2019-09-14 00:00:00\nend: 2019-10-13 00:00:00\nperiod: 1h\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport sys\nimport time\nimport talib\nimport json\nimport traceback\nimport matplotlib\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport mpl_toolkits.mplot3d\n\ndef main():\n    testGlobal = [\n            'Version', ['Log', 'ok', 3.5, True], ['Sleep', 100], ['LogProfit', 10.5],\n            'LogProfitReset', ['LogProfit', 10.8], 'GetCommand', 'LogReset', ['LogStatus', 'x', True], ['EnableLog', True], \n            ['SetErrorFilter', 'xxx'], 'GetPid', 'GetLastError', ['_G', 'x', 10], ['_G', 'x'], ['_G', 'x', None], '_G',\n        ]\n    g = globals()\n    for item in testGlobal:\n        if isinstance(item, list):\n            ret = g[item[0]](*item[1:])\n        else:\n            ret = g[item]()\n        Log('%s => %s' % (item, ret))\n    Log(sys.version)\n    testExchanges = [\n            'GetName', 'GetUSDCNY', 'GetRate', ['SetRate', 1.0], 'GetAccount', 'GetCurrency', 'GetLabel', 'GetMinStock', 'GetMinPrice', 'GetFee',\n            'GetRecords',\n            ['Buy', 100, 0.1, \"OK\"],\n            'GetOrders',\n            ['GetOrder', 1],\n            'GetAccount',\n            'GetRawJSON',\n            ['CancelOrder', 1],\n            ['Buy', -1, 1000.0],\n            'GetAccount',\n            ['Sell', -1, 1],\n            'GetAccount',\n            ['Sell', 9999.9, 0.2, \"OK\"],\n            'GetOrders',\n            'GetAccount',\n            ['CancelOrder', 2],\n            ['Go', 'GetAccount'],\n            ['IO', 'status'],\n        ]\n    for item in testExchanges:\n        try:\n            if isinstance(item, list):\n                ret = getattr(exchange, item[0])(*item[1:])\n            else:\n                ret = getattr(exchange, item)()\n        except:\n            ret = traceback.format_exc()\n        Log('exchange.%s => %s' % (item, ret))\n    \n    # test market order\n    exchange.Buy(-1, 1000)\n    exchange.Buy(-1, 200, \"buy 200 \")\n    exchange.Sell(-1, exchange.GetAccount().Stocks)\n    # test Go\n    ret, ok = exchange.Go(\"GetTicker\").wait()\n    if ok:\n        Log(\"Go GetTicker\", ret)\n    Log(\"EMA\", len(TA.EMA(exchange.GetRecords())))\n    Log(\"EMA H1\", len(TA.EMA(exchange.GetRecords(PERIOD_H1))))\n    \n\n    # test plot image\n    plt.plot([3,6,2,4,7,1])\n    Log('支持直接打印plt图片 ', plt)\n    \n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    t = ax.scatter(np.random.rand(20), np.random.rand(20))\n    Log(fig)\n    \n    x = np.linspace(0, 10, 1000)\n    y = np.sin(x)\n    z = np.cos(x**2)\n\n    plt.figure(figsize=(8,4))\n    plt.plot(x,y,label=\"$sin(x)$\",color=\"red\",linewidth=2)\n    plt.plot(x,z,\"b--\",label=\"$cos(x^2)$\")\n    plt.xlabel(\"Time(s)\")\n    plt.ylabel(\"Volt\")\n    plt.title(\"PyPlot Example\")\n    plt.ylim(-1.2,1.2)\n    plt.legend()\n    Log(plt)\n\n    x,y=np.mgrid[-2:2:20j,-2:2:20j]\n    z=x*np.exp(-x**2-y**2)\n    ax=plt.subplot(111,projection='3d')\n    ax.plot_surface(x,y,z,rstride=2,cstride=1,cmap=plt.cm.coolwarm,alpha=0.8)\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n    ax.set_zlabel('z')\n    # plot image to status bar\n    LogStatus(plt)\n    \n    # test plot chart\n    x = Chart({\n        'title' : { 'text' : 'test chart'},\n        'xAxis': { 'type': 'datetime'},\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\n        })\n    x.reset()\n    for i in range(100):\n        ts = int(time.time() * 1000)\n        ticker = _C(exchange.GetTicker)\n        x.add(0, [ts, ticker.Buy])\n        x.add(1, [ts, ticker.Sell])\n        Sleep(10000)",
        "strategy_description": "策略名称: Python-API-测试\n\nexchange.Buy(-1, 1000)\n    exchange.Buy(-1, 200, \"buy 200 \")\n    exchange.Sell(-1, exchange.GetAccount().Stocks)\n    # test Go\n    ret, ok = exchange.Go(\"GetTicker\").wait()\n    if ok:\n        Log(\"Go GetTicker\", ret)\n    Log(\"EMA\", len(TA.EMA(exchange.GetRecords())))\n    Log(\"EMA H1\", len(TA.EMA(exchange.GetRecords(PERIOD_H1))))\n    \n\n    # test plot image\n    plt.plot([3,6,2,4,7,1])\n    Log('支持直接打印plt图片 ', plt)\n    \n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    t = ax.scatter(np.random.rand(20), np.random.rand(20))\n    Log(fig)\n    \n    x = np.linspace(0, 10, 1000)\n    y = np.sin(x)\n    z = np.cos(x**2)\n\n    plt.figure(figsize=(8,4))\n    plt.plot(x,y,label=\"$sin(x)$\",color=\"red\",linewidth=2)\n    plt.plot(x,z,\"b--\",label=\"$cos(x^2)$\")\n    plt.xlabel(\"Time(s)\")\n    plt.ylabel(\"Volt\")\n    plt.title(\"PyPlot Example\")\n    plt.ylim(-1.2,1.2)\n    plt.legend()\n    Log(plt)\n\n    x,y=np.mgrid[-2:2:20j,-2:2:20j]\n    z=x*np.exp(-x**2-y**2)\n    ax=plt.subplot(111,projection='3d')\n    ax.plot_surface(x,y,z,rstride=2,cstride=1,cmap=plt.cm.coolwarm,alpha=0.8)\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n    ax.set_zlabel('z')\n    # plot image to status bar\n    LogStatus(plt)\n    \n    # test plot chart\n    x = Chart({\n        'title' : { 'text' : 'test chart'},\n        'xAxis': { 'type': 'datetime'},\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\n        })\n    x.reset()\n    for i in range(100):\n        ts = int(time.time() * 1000)\n        ticker = _C(exchange.GetTicker)\n        x.add(0, [ts, ticker.Buy])\n        x.add(1, [ts, ticker.Sell])\n        Sleep(10000)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/21365\n\n> Last Modified\n\n2019-10-14 12:35:16"
    },
    {
        "strategy_id": "21_Python-KLineChart",
        "strategy_code": "python\n'''backtest\nstart: 2022-03-30 09:00:00\nend: 2022-06-30 15:00:00\nperiod: 1h\nbasePeriod: 15m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\"}]\n'''\n\n\nimport sys\ndef main():\n    Log(sys.version)\n    c = KLineChart()\n    c.reset(0)\n\n    bars = exchange.GetRecords()\n    for bar in bars:\n        c.begin(bar)\n        c.barcolor('rgba(255, 0, 0, 0.2)' if bar.Close > bar.Open else 'rgba(0, 0, 0, 0.2)')\n        if bar.Close > bar.Open:\n            c.bgcolor('rgba(0, 255, 0, 0.5)')\n        \n        h = c.plot(bar.High, 'high')\n        l = c.plot(bar.Low, 'low')\n        c.fill(h, l, 'rgba(255, 0, 0, 1)' if bar.Close > bar.Open else '#000000')\n        c.hline(bar.High)\n        c.plotarrow(bar.Close - bar.Open)\n        c.plotshape(bar.Low, style = 'diamond')\n        c.plotchar(bar.Close, char = 'X')\n        c.plotcandle(bar.Open*0.9, bar.High*0.9, bar.Low*0.9, bar.Close*0.9)\n        if bar.Close > bar.Open:\n            c.signal(\"long\", bar.High, 1.5, \"LONG\")\n        elif bar.Close < bar.Open:\n            c.signal(\"closelong\", bar.Low, 1.5)\n        c.close()",
        "strategy_description": "策略名称: Python-KLineChart\n\n未找到描述"
    },
    {
        "strategy_id": "22_Python-机器学习之-SVM-预测买卖",
        "strategy_code": "python\n'''backtest\nstart: 2019-09-06 00:00:00\nend: 2019-10-05 00:00:00\nperiod: 1h\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\"}]\n'''\n\nfrom sklearn import svm\nimport numpy as np\n\ndef main():\n    preTime = 0\n    n = 0\n    success = 0\n    predict = None\n    pTime = None\n    marketPosition = 0\n    initAccount = exchange.GetAccount()\n    Log(\"Running...\")\n    while True:\n        r = exchange.GetRecords()\n        if len(r) < 60:\n            continue\n        bar = r[len(r)-1]\n        if bar.Time > preTime:\n            preTime = bar.Time\n            if pTime is not None and r[len(r)-2].Time == pTime:\n                diff = r[len(r)-2].Close - r[len(r)-3].Close\n                if diff > SpreadVal:\n                    success += 1 if predict == 0 else 0\n                elif diff < -SpreadVal:\n                    success += 1 if predict == 1 else 0\n                else:\n                    success += 1 if predict == 2 else 0\n                pTime = None\n                LogStatus(\"预测次数\", n, \"成功次数\", success, \"准确率:\", '%.3f %%' % round(float(success) * 100 / n, 2))\n        else:\n            Sleep(1000)\n            continue\n        inputs_X, output_Y = [], []\n        sets = [None, None, None]\n        for i in xrange(1, len(r)-2, 1):\n            inputs_X.append([r[i].Open, r[i].Close])\n            Y = 0\n            diff = r[i+1].Close - r[i].Close\n            if diff > SpreadVal:\n                Y = 0\n                sets[0] = True\n            elif diff < -SpreadVal:\n                Y = 1\n                sets[1] = True\n            else:\n                Y = 2\n                sets[2] = True\n            output_Y.append(Y)\n        if None in sets:\n            Log(\"样本不足, 无法预测 ...\")\n            continue\n        n += 1\n        clf = svm.LinearSVC()\n        clf.fit(inputs_X, output_Y)\n        predict = clf.predict(np.array([bar.Open, bar.Close]).reshape((1, -1)))[0]\n        pTime = bar.Time\n        Log(\"预测当前Bar结束:\", bar.Time, ['涨', '跌', '横'][predict])\n        if marketPosition == 0:\n            if predict == 0:\n                exchange.Buy(-1, initAccount.Balance/2)\n                marketPosition = 1\n            elif predict == 1:\n                exchange.Sell(-1, initAccount.Stocks/2)\n                marketPosition = -1\n        else:\n            nowAccount = exchange.GetAccount()\n            if marketPosition > 0 and predict != 0:\n                exchange.Sell(-1, nowAccount.Stocks - initAccount.Stocks)\n                nowAccount = exchange.GetAccount()\n                marketPosition = 0\n            elif marketPosition < 0 and predict != 1:\n                while True:\n                    dif = initAccount.Stocks - nowAccount.Stocks\n                    if dif < 0.01:\n                        break\n                    ticker = exchange.GetTicker()\n                    exchange.Buy(ticker.Sell + (ticker.Sell-ticker.Buy)*2, dif)\n                    while True:\n                        Sleep(1000)\n                        orders = exchange.GetOrders()\n                        for order in orders:\n                            exchange.CancelOrder(order.Id)\n                        if len(orders) == 0:\n                            break\n                    nowAccount = exchange.GetAccount()\n                marketPosition = 0\n            if marketPosition == 0:\n                LogProfit(_N(nowAccount.Balance - initAccount.Balance, 4), nowAccount)",
        "strategy_description": "策略名称: Python-机器学习之-SVM-预测买卖\n\n未找到描述"
    },
    {
        "strategy_id": "23_Python版-TableTemplet-测试版Python-Version-TableTemplet-Beta-Version",
        "strategy_code": "python\n# TableTemplet\nimport json\nlistener = {}\n\nclass Table():\n    \"\"\"docstring for Table\"\"\"\n    def __init__(self):\n        self.tb = {\n            \"type\" : \"table\",\n            \"title\" : \"Table\",\n            \"cols\" : [],\n            \"rows\" : []\n        }\n\n    def SetColRow(self, col_index, row_index, row):\n        if (type(col_index) is int) and (type(row_index) is int) :\n            if (col_index > len(self.tb[\"cols\"])) or (row_index > len(self.tb[\"rows\"])) :\n                Log(\"索引超出范围！col_index:\", col_index, \"row_index:\", row_index)\n            else :\n                self.tb[\"rows\"][row_index - 1][col_index - 1] = row\n        else :\n            Log(\"col_index:\", col_index, \"row_index:\", row_index)\n            raise \"SetColRow 参数错误!\"\n\n    def SetBtn(self, col_index, row_index, cmd, name, callback):\n        global listener\n        if (type(col_index) is int) and (type(row_index) is int) :\n            if (col_index > len(self.tb[\"cols\"])) or (row_index > len(self.tb[\"rows\"])) :\n                Log(\"索引超出范围！col_index:\", col_index, \"row_index:\", row_index)\n            else :\n                self.tb[\"rows\"][row_index - 1][col_index - 1] = {\"type\" : \"button\", \"cmd\" : cmd, \"name\" : name}\n                listener[cmd] = callback\n        else :\n            Log(\"col_index:\", col_index, \"row_index:\", row_index)\n            raise \"SetColRow 参数错误!\"\n    \n    def SetRows(self, row_index, Rows):\n        pass\n\n    def SetCols(self, Cols):\n        self.tb[\"cols\"] = Cols\n\n    def GetRows(self, row_index):\n        if (type(row_index) is int) and (row_index < len(self.tb[\"rows\"])) :\n            return self.tb[\"rows\"][row_index - 1]\n        else :\n            Log(\"参数错误！ 或者 参数索引超出范围！\")\n\n    def Init(self, title, col_length, row_length):  \n        self.tb[\"title\"] = title\n        for i in range(1, row_length + 1) :\n            if i == 1 :\n                for n in range(1, col_length + 1) :\n                    self.tb[\"cols\"].append(n)\n            self.tb[\"rows\"].append([])\n            for m in range(1, col_length + 1) :\n                self.tb[\"rows\"][i - 1].append(str(i) + \"/\" + str(m))\n\n\nclass CreateTableManager():\n    \"\"\"docstring for CreateTableManager\"\"\"\n    def __init__(self):        # CreateTableManager 构造函数\n        self.tables = []       # 用于储存 table 对象\n    \n    def GetTable(self, index):\n        if type(index) is int :\n            return self.tables[index]\n        elif type(index) is str :\n            for i in range(len(self.tables)) :\n                if self.tables[i][\"title\"] == index:\n                    return self.tables[i]\n        else :\n            Log(\"GetTable参数:\", index)\n            raise \"GetTable 参数错误！\"\n    \n    def AddTable(self, title, col_length, row_length):    # cols, rows\n        tb = Table()\n        tb.Init(title, col_length, row_length)\n        self.tables.append(tb.tb)\n        return tb\n\n    def UpdateCMD(self):\n        global listener\n        cmd = GetCommand()\n        if cmd :\n            cmdList = cmd.split(\":\")\n            if len(cmdList) == 2 :                                         # 增加了 对于 主策略 交互的 冲突 检测。\n                Log(\"接收到 TableTemplet 模板以外的 交互命令！\", cmdList)     \n                return\n            if listener[cmd] :\n                listener[cmd](cmd)\n            else :\n                Log(\"TableTemplet 模板中找不到名为：\" + cmd + \"的命令\")\n    \n    def LogStatus(self, before, end):\n        self.UpdateCMD()\n        LogStatus(before + '\\n`' + json.dumps(self.tables) + '`\\n' + end)\n\n# 导出函数\next.CreateTableManager = CreateTableManager\n\n# 测试代码\n\ndef test1(cmd):        # 用作函数回调\n    Log(_D(), cmd)\n\ndef main():\n    account = exchange.GetAccount()\n    array1 = [\"aa\", \"bb\", \"cc\"]\n    array2 = [1, 2, 4, 55]\n\n    TbM = ext.CreateTableManager()\n    tb1 = TbM.AddTable(\"tb1\", 6, 7)\n    \n    tb1.SetColRow(3, 4, \"hello\")\n    tb1.SetColRow(3, 5, 12)\n    tb1.SetColRow(3, 6, account)\n    tb1.SetColRow(3, 7, array1)\n    tb1.SetColRow(3, 2, array2)\n    tb1.SetBtn(3, 1, \"Cover\", \"平仓\", test1)    # 由于 python 没有多行 匿名函数（如JS 的 function(){...}）所以可以声明普通函数传入。\n    tb_1 = TbM.GetTable(0)\n    tb_2 = TbM.GetTable(\"tb1\")\n    Log(tb_1)\n    Log(tb_2, \"#FF0000\")\n    tb1_row1 = tb1.GetRows(1)\n    Log(tb1_row1)\n    tb1_row1[0] = \"修改\"\n    x = 0\n    \n    # tb2\n    tb2 = TbM.AddTable(\"tb2\", 4, 4)\n\n    while True :\n        x = x + 1\n        tb1_row1[0] = _D()\n        tb1.SetCols([x + 1, x + 2, x + 3, x + 4, x + 5, x + 6])\n        TbM.LogStatus(\"begin\", \"end\")\n        Sleep(1000)",
        "strategy_description": "策略名称: Python版-TableTemplet-测试版Python-Version-TableTemplet-Beta-Version\n\nimport json\nlistener = {}\n\nclass Table():\n    \"\"\"docstring for Table\"\"\"\n    def __init__(self):\n        self.tb = {\n            \"type\" : \"table\",\n            \"title\" : \"Table\",\n            \"cols\" : [],\n            \"rows\" : []\n        }\n\n    def SetColRow(self, col_index, row_index, row):\n        if (type(col_index) is int) and (type(row_index) is int) :\n            if (col_index > len(self.tb[\"cols\"])) or (row_index > len(self.tb[\"rows\"])) :\n                Log(\"索引超出范围！col_index:\", col_index, \"row_index:\", row_index)\n            else :\n                self.tb[\"rows\"][row_index - 1][col_index - 1] = row\n        else :\n            Log(\"col_index:\", col_index, \"row_index:\", row_index)\n            raise \"SetColRow 参数错误!\"\n\n    def SetBtn(self, col_index, row_index, cmd, name, callback):\n        global listener\n        if (type(col_index) is int) and (type(row_index) is int) :\n            if (col_index > len(self.tb[\"cols\"])) or (row_index > len(self.tb[\"rows\"])) :\n                Log(\"索引超出范围！col_index:\", col_index, \"row_index:\", row_index)\n            else :\n                self.tb[\"rows\"][row_index - 1][col_index - 1] = {\"type\" : \"button\", \"cmd\" : cmd, \"name\" : name}\n                listener[cmd] = callback\n        else :\n            Log(\"col_index:\", col_index, \"row_index:\", row_index)\n            raise \"SetColRow 参数错误!\"\n    \n    def SetRows(self, row_index, Rows):\n        pass\n\n    def SetCols(self, Cols):\n        self.tb[\"cols\"] = Cols\n\n    def GetRows(self, row_index):\n        if (type(row_index) is int) and (row_index < len(self.tb[\"rows\"])) :\n            return self.tb[\"rows\"][row_index - 1]\n        else :\n            Log(\"参数错误！ 或者 参数索引超出范围！\")\n\n    def Init(self, title, col_length, row_length):  \n        self.tb[\"title\"] = title\n        for i in range(1, row_length + 1) :\n            if i == 1 :\n                for n in range(1, col_length + 1) :\n                    self.tb[\"cols\"].append(n)\n            self.tb[\"rows\"].append([])\n            for m in range(1, col_length + 1) :\n                self.tb[\"rows\"][i - 1].append(str(i) + \"/\" + str(m))\n\n\nclass CreateTableManager():\n    \"\"\"docstring for CreateTableManager\"\"\"\n    def __init__(self):        # CreateTableManager 构造函数\n        self.tables = []       # 用于储存 table 对象\n    \n    def GetTable(self, index):\n        if type(index) is int :\n            return self.tables[index]\n        elif type(index) is str :\n            for i in range(len(self.tables)) :\n                if self.tables[i][\"title\"] == index:\n                    return self.tables[i]\n        else :\n            Log(\"GetTable参数:\", index)\n            raise \"GetTable 参数错误！\"\n    \n    def AddTable(self, title, col_length, row_length):    # cols, rows\n        tb = Table()\n        tb.Init(title, col_length, row_length)\n        self.tables.append(tb.tb)\n        return tb\n\n    def UpdateCMD(self):\n        global listener\n        cmd = GetCommand()\n        if cmd :\n            cmdList = cmd.split(\":\")\n            if len(cmdList) == 2 :                                         # 增加了 对于 主策略 交互的 冲突 检测。\n                Log(\"接收到 TableTemplet 模板以外的 交互命令！\", cmdList)     \n                return\n            if listener[cmd] :\n                listener[cmd](cmd)\n            else :\n                Log(\"TableTemplet 模板中找不到名为：\" + cmd + \"的命令\")\n    \n    def LogStatus(self, before, end):\n        self.UpdateCMD()\n        LogStatus(before + '\\n`' + json.dumps(self.tables) + '`\\n' + end)"
    },
    {
        "strategy_id": "24_Python版MACD指标画图范例",
        "strategy_code": "python\n'''backtest\nstart: 2020-01-28 00:00:00\nend: 2020-02-26 00:00:00\nperiod: 1d\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\"}]\n'''\n\nChartCfg = {\n    '__isStock': True,\n    'title': {\n        'text': 'Python画图'\n    },\n    'yAxis': [{\n        'title': {'text': 'K线'},\n        'style': {'color': '#4572A7'},\n        'opposite': False\n    }, {\n        'title': {'text': '指标轴'},\n        'opposite': True\n    }],\n    'series': [{\n        'type': 'candlestick',\n        'name': '当前周期',\n        'id': 'primary',\n        'data': []\n    }, {\n        'type': 'line',\n        'id': 'dif',\n        'name': 'DIF',\n        \"yAxis\" : 1,\n        'data': []\n    }, {\n        'type': 'line',\n        'id': 'dea',\n        'name': 'DEA',\n        \"yAxis\" : 1,\n        'data': []\n    }, {\n        'type': 'line',\n        'id': 'macd',\n        'name': 'MACD',\n        \"yAxis\" : 1,\n        'data': []\n    }]\n}\n\ndef main():\n    global ChartCfg\n    preTime = 0\n    chart = Chart(ChartCfg)\n    chart.reset()\n    while True:\n        while True:\n            r = _C(exchange.GetRecords)\n            if len(r) > 50:\n                break\n        # 计算指标\n        macd = TA.MACD(r)\n        \n        LogStatus(_D(), len(r))\n        \n        # 画图\n        for i in range(len(r)):\n            if r[i][\"Time\"] == preTime:\n                chart.add(0, [r[i][\"Time\"], r[i][\"Open\"], r[i][\"High\"], r[i][\"Low\"], r[i][\"Close\"]], -1)\n                chart.add(1, [r[i][\"Time\"], macd[0][i]], -1)\n                chart.add(2, [r[i][\"Time\"], macd[1][i]], -1)\n                chart.add(3, [r[i][\"Time\"], macd[2][i]], -1)\n            elif r[i][\"Time\"] > preTime:\n                chart.add(0, [r[i][\"Time\"], r[i][\"Open\"], r[i][\"High\"], r[i][\"Low\"], r[i][\"Close\"]])\n                chart.add(1, [r[i][\"Time\"], macd[0][i]])\n                chart.add(2, [r[i][\"Time\"], macd[1][i]])\n                chart.add(3, [r[i][\"Time\"], macd[2][i]])\n                preTime = r[i][\"Time\"]\n        Sleep(500)",
        "strategy_description": "策略名称: Python版MACD指标画图范例\n\nmacd = TA.MACD(r)\n        \n        LogStatus(_D(), len(r))\n        \n        # 画图\n        for i in range(len(r)):\n            if r[i][\"Time\"] == preTime:\n                chart.add(0, [r[i][\"Time\"], r[i][\"Open\"], r[i][\"High\"], r[i][\"Low\"], r[i][\"Close\"]], -1)\n                chart.add(1, [r[i][\"Time\"], macd[0][i]], -1)\n                chart.add(2, [r[i][\"Time\"], macd[1][i]], -1)\n                chart.add(3, [r[i][\"Time\"], macd[2][i]], -1)\n            elif r[i][\"Time\"] > preTime:\n                chart.add(0, [r[i][\"Time\"], r[i][\"Open\"], r[i][\"High\"], r[i][\"Low\"], r[i][\"Close\"]])\n                chart.add(1, [r[i][\"Time\"], macd[0][i]])\n                chart.add(2, [r[i][\"Time\"], macd[1][i]])\n                chart.add(3, [r[i][\"Time\"], macd[2][i]])\n                preTime = r[i][\"Time\"]\n        Sleep(500)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/187379\n\n> Last Modified\n\n2020-02-27 19:02:49"
    },
    {
        "strategy_id": "25_Python版冰山委托-买入",
        "strategy_code": "python\nimport random\n\ndef CancelPendingOrders():\n    while True:\n        orders = _C(exchange.GetOrders)\n        if len(orders) == 0 :\n            return \n\n        for j in range(len(orders)):\n            exchange.CancelOrder(orders[j][\"Id\"])\n            if j < len(orders) - 1:\n                Sleep(Interval)\n\nLastBuyPrice = 0\nInitAccount = None\n\ndef dispatch():\n    global InitAccount, LastBuyPrice\n    account = None\n    ticker = _C(exchange.GetTicker)\n    LogStatus(_D(), \"ticker:\", ticker)\n    if LastBuyPrice > 0:\n        if len(_C(exchange.GetOrders)) > 0:\n            if ticker[\"Last\"] > LastBuyPrice  and ((ticker[\"Last\"] - LastBuyPrice) / LastBuyPrice) > (2 * (EntrustDepth / 100)): \n                Log(\"偏离过多, 最新成交价:\", ticker[\"Last\"], \"委托价\", LastBuyPrice)\n                CancelPendingOrders()\n            else :\n                return True\n        else :\n            account = _C(exchange.GetAccount)\n            Log(\"买单完成, 累计花费:\", _N(InitAccount[\"Balance\"] - account[\"Balance\"]), \"平均买入价:\", _N((InitAccount[\"Balance\"] - account[\"Balance\"]) / (account[\"Stocks\"] - InitAccount[\"Stocks\"])))\n        LastBuyPrice = 0\n\n    BuyPrice = _N(ticker[\"Buy\"] * (1 - EntrustDepth / 100))\n    if BuyPrice > MaxBuyPrice:\n        return True\n\n    if not account:\n        account = _C(exchange.GetAccount)\n\n    if (InitAccount[\"Balance\"] - account[\"Balance\"]) >= TotalBuyNet:\n        return False\n\n    RandomAvgBuyOnce = (AvgBuyOnce * ((100.0 - FloatPoint) / 100.0)) + (((FloatPoint * 2) / 100.0) * AvgBuyOnce * random.random())   # 随机数 0~1\n    UsedMoney = min(account[\"Balance\"], RandomAvgBuyOnce, TotalBuyNet - (InitAccount[\"Balance\"] - account[\"Balance\"]))\n\n    BuyAmount = _N(UsedMoney / BuyPrice)\n    if BuyAmount < MinStock:\n        return False \n    LastBuyPrice = BuyPrice\n    exchange.Buy(BuyPrice, BuyAmount, \"花费：￥\", _N(UsedMoney), \"上次成交价\", ticker[\"Last\"])\n    return True\n\ndef main():\n    global LoopInterval, InitAccount\n    CancelPendingOrders()\n    InitAccount = _C(exchange.GetAccount)\n    Log(InitAccount)\n    if InitAccount[\"Balance\"] < TotalBuyNet:\n        raise Exception(\"账户余额不足\")\n    LoopInterval = max(LoopInterval, 1)\n    while dispatch():\n        Sleep(LoopInterval * 1000)\n    Log(\"委托全部完成\", _C(exchange.GetAccount))",
        "strategy_description": "策略名称: Python版冰山委托-买入\n\nUsedMoney = min(account[\"Balance\"], RandomAvgBuyOnce, TotalBuyNet - (InitAccount[\"Balance\"] - account[\"Balance\"]))\n\n    BuyAmount = _N(UsedMoney / BuyPrice)\n    if BuyAmount < MinStock:\n        return False \n    LastBuyPrice = BuyPrice\n    exchange.Buy(BuyPrice, BuyAmount, \"花费：￥\", _N(UsedMoney), \"上次成交价\", ticker[\"Last\"])\n    return True\n\ndef main():\n    global LoopInterval, InitAccount\n    CancelPendingOrders()\n    InitAccount = _C(exchange.GetAccount)\n    Log(InitAccount)\n    if InitAccount[\"Balance\"] < TotalBuyNet:\n        raise Exception(\"账户余额不足\")\n    LoopInterval = max(LoopInterval, 1)\n    while dispatch():\n        Sleep(LoopInterval * 1000)\n    Log(\"委托全部完成\", _C(exchange.GetAccount))\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/188435\n\n> Last Modified\n\n2020-03-07 16:58:07"
    },
    {
        "strategy_id": "26_Python版冰山委托-卖出",
        "strategy_code": "python\nimport random\n\ndef CancelPendingOrders():\n    while True:\n        orders = _C(exchange.GetOrders)\n        if len(orders) == 0:\n            return\n        \n        for j in range(len(orders)):\n            exchange.CancelOrder(orders[j][\"Id\"])\n            if j < len(orders) - 1:\n                Sleep(Interval)\n\nLastSellPrice = 0\nInitAccount = None\n\ndef dispatch():\n    global LastSellPrice, InitAccount\n    account = None\n    ticker = _C(exchange.GetTicker)\n    LogStatus(_D(), \"ticker:\", ticker)\n    if LastSellPrice > 0:\n        if len(_C(exchange.GetOrders)) > 0:\n            if ticker[\"Last\"] < LastSellPrice and ((LastSellPrice - ticker[\"Last\"]) / ticker[\"Last\"]) > (2 * (EntrustDepth / 100)):\n                Log(\"偏离过多，最新成交价：\", ticker[\"Last\"], \"委托价\", LastSellPrice)\n                CancelPendingOrders()\n            else :\n                return True\n        else :\n            account = _C(exchange.GetAccount)\n            Log(\"买单完成，累计卖出：\", _N(InitAccount[\"Stocks\"] - account[\"Stocks\"]), \"平均卖出价：\", _N((account[\"Balance\"] - InitAccount[\"Balance\"]) / (InitAccount[\"Stocks\"] - account[\"Stocks\"])))\n            LastSellPrice = 0\n\n    SellPrice = _N(ticker[\"Sell\"] * (1 + EntrustDepth / 100))\n    if SellPrice < MinSellPrice:\n        return True\n\n    if not account:\n        account = _C(exchange.GetAccount)\n\n    if (InitAccount[\"Stocks\"] - account[\"Stocks\"]) >= TotalSellStocks:\n        return False \n\n    RandomAvgSellOnce = (AvgSellOnce * ((100.0 - FloatPoint) / 100.0)) + (((FloatPoint * 2) / 100.0) * AvgSellOnce * random.random())\n    SellAmount = min(TotalSellStocks - (InitAccount[\"Stocks\"] - account[\"Stocks\"]), RandomAvgSellOnce)\n    if SellAmount < MinStock:\n        return False \n\n    LastSellPrice = SellPrice\n    exchange.Sell(SellPrice, SellAmount, \"上次成交价\", ticker[\"Last\"])\n    return True\n\ndef main():\n    global InitAccount, LoopInterval\n    CancelPendingOrders()\n    InitAccount = _C(exchange.GetAccount)\n    Log(InitAccount)\n    if InitAccount[\"Stocks\"] < TotalSellStocks:\n        raise Exception(\"账户币数不足\")\n    LoopInterval = max(LoopInterval, 1)\n    while dispatch():\n        Sleep(LoopInterval)\n    Log(\"委托全部完成\", _C(exchange.GetAccount))",
        "strategy_description": "策略名称: Python版冰山委托-卖出\n\n未找到描述"
    },
    {
        "strategy_id": "27_Python版单平台均衡策略教学",
        "strategy_code": "python\n'''backtest\nstart: 2019-12-01 00:00:00\nend: 2020-02-01 11:00:00\nperiod: 1m\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\",\"stocks\":1}]\n'''\n\nInitAccount = None\n\ndef CancelPendingOrders():\n    ret = False\n    while True:\n        orders = _C(exchange.GetOrders)\n        if len(orders) == 0 :\n            return ret\n\n        for j in range(len(orders)):\n            exchange.CancelOrder(orders[j].Id)\n            ret = True\n            if j < len(orders) - 1:\n                Sleep(Interval)\n    return ret \n\ndef onTick():\n    acc = _C(exchange.GetAccount)\n    ticker = _C(exchange.GetTicker)\n    spread = ticker.Sell - ticker.Buy\n    diffAsset = (acc.Balance - (acc.Stocks * ticker.Sell)) / 2\n    ratio = diffAsset / acc.Balance\n    LogStatus(\"ratio:\", ratio, _D())\n    if abs(ratio) < threshold:\n        return False\n    if ratio > 0 :\n        buyPrice = _N(ticker.Sell + spread, ZPrecision)\n        buyAmount = _N(diffAsset / buyPrice, XPrecision)\n        if buyAmount < MinStock:\n            return False\n        exchange.Buy(buyPrice, buyAmount, diffAsset, ratio)\n    else :\n        sellPrice = _N(ticker.Buy - spread, ZPrecision)\n        sellAmount = _N(-diffAsset / sellPrice, XPrecision)\n        if sellAmount < MinStock:\n            return False \n        exchange.Sell(sellPrice, sellAmount, diffAsset, ratio)\n    return True\n\ndef main():\n    global InitAccount, LoopInterval\n    InitAccount = _C(exchange.GetAccount)\n    LoopInterval = max(LoopInterval, 1)\n    while True:\n        if onTick():\n            Sleep(1000)\n            CancelPendingOrders()\n            Log(_C(exchange.GetAccount))\n        Sleep(LoopInterval * 1000)",
        "strategy_description": "策略名称: Python版单平台均衡策略教学\n\n未找到描述"
    },
    {
        "strategy_id": "28_Python版多品种追涨杀跌策略教学",
        "strategy_code": "python\n'''backtest\nstart: 2019-02-20 00:00:00\nend: 2020-01-10 00:00:00\nperiod: 1m\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\"},{\"eid\":\"OKEX\",\"currency\":\"ETH_USDT\",\"stocks\":30},{\"eid\":\"OKEX\",\"currency\":\"LTC_USDT\",\"stocks\":100}]\n'''\n\nimport time\nimport json\n\nparams = {\n    \"arrBasePrice\": [-1, -1, -1],     # -1\n    \"arrRatio\": [0.05, 0.05, 0.05],         # 0.05\n    \"arrAcc\": [],           # _C(exchange.GetAccount)\n    \"arrLastCancelAll\": [0, 0, 0], # 0\n    \"arrMinStocks\": [0.01, 0.01, 0.01],     # 0.01\n    \"arrPricePrecision\": [2, 2, 2], # 2\n    \"arrAmountPrecision\": [3, 2, 2], # 2\n    \"arrTick\":[]\n}\n\ndef CancelAll(e):\n    while True : \n        orders = _C(e.GetOrders)\n        for i in range(len(orders)) :\n            e.CancelOrder(orders[i][\"Id\"], orders[i])\n        if len(orders) == 0 :\n            break\n        Sleep(1000)\n\ndef process(e, index):\n    global params\n    ticker = _C(e.GetTicker)\n    params[\"arrTick\"][index] = ticker\n    if params[\"arrBasePrice\"][index] == -1 :\n        params[\"arrBasePrice\"][index] = ticker.Last\n    if ticker.Last - params[\"arrBasePrice\"][index] > 0 and (ticker.Last - params[\"arrBasePrice\"][index]) / params[\"arrBasePrice\"][index] > params[\"arrRatio\"][index]:\n        params[\"arrAcc\"][index] = _C(e.GetAccount)\n        if params[\"arrAcc\"][index].Balance * params[\"arrRatio\"][index] / ticker.Last > params[\"arrMinStocks\"][index]:\n            e.Buy(ticker.Last, params[\"arrAcc\"][index].Balance * params[\"arrRatio\"][index] / ticker.Last)\n            params[\"arrBasePrice\"][index] = ticker.Last\n    if ticker.Last - params[\"arrBasePrice\"][index] < 0 and (params[\"arrBasePrice\"][index] - ticker.Last) / params[\"arrBasePrice\"][index] > params[\"arrRatio\"][index]: \n        params[\"arrAcc\"][index] = _C(e.GetAccount)\n        if params[\"arrAcc\"][index].Stocks * params[\"arrRatio\"][index] > params[\"arrMinStocks\"][index]:\n            e.Sell(ticker.Last, params[\"arrAcc\"][index].Stocks * params[\"arrRatio\"][index])\n            params[\"arrBasePrice\"][index] = ticker.Last\n    ts = time.time()\n    if ts - params[\"arrLastCancelAll\"][index] > 60 * 5 :\n        CancelAll(e)\n        params[\"arrLastCancelAll\"][index] = ts \n\ndef main():\n    global params\n    \n    for i in range(len(exchanges)) :    \n        params[\"arrAcc\"].append(_C(exchanges[i].GetAccount))\n        params[\"arrTick\"].append(_C(exchanges[i].GetTicker))\n        exchanges[i].SetPrecision(params[\"arrPricePrecision\"][i], params[\"arrAmountPrecision\"][i])\n\n    for key in params :\n        if len(params[key]) < len(exchanges):\n            raise \"params error!\"\n\n    while True:\n        tblAcc = {\n            \"type\" : \"table\",\n            \"title\": \"account\",\n            \"cols\": [\"账户信息\"], \n            \"rows\": []\n        }        \n\n        tblTick = {\n            \"type\" : \"table\",\n            \"title\": \"ticker\",\n            \"cols\": [\"行情信息\"], \n            \"rows\": []\n        }\n        for i in range(len(exchanges)): \n            process(exchanges[i], i)\n\n        for i in range(len(exchanges)):\n            tblAcc[\"rows\"].append([json.dumps(params[\"arrAcc\"][i])])\n            tblTick[\"rows\"].append([json.dumps(params[\"arrTick\"][i])])\n\n        LogStatus(_D(), \"\\n`\" + json.dumps([tblAcc, tblTick]) + \"`\")\n        Sleep(500)",
        "strategy_description": "策略名称: Python版多品种追涨杀跌策略教学\n\n\"arrRatio\": [0.05, 0.05, 0.05],         # 0.05\n    \"arrAcc\": [],           # _C(exchange.GetAccount)\n    \"arrLastCancelAll\": [0, 0, 0], # 0\n    \"arrMinStocks\": [0.01, 0.01, 0.01],     # 0.01\n    \"arrPricePrecision\": [2, 2, 2], # 2\n    \"arrAmountPrecision\": [3, 2, 2], # 2\n    \"arrTick\":[]\n}\n\ndef CancelAll(e):\n    while True : \n        orders = _C(e.GetOrders)\n        for i in range(len(orders)) :\n            e.CancelOrder(orders[i][\"Id\"], orders[i])\n        if len(orders) == 0 :\n            break\n        Sleep(1000)\n\ndef process(e, index):\n    global params\n    ticker = _C(e.GetTicker)\n    params[\"arrTick\"][index] = ticker\n    if params[\"arrBasePrice\"][index] == -1 :\n        params[\"arrBasePrice\"][index] = ticker.Last\n    if ticker.Last - params[\"arrBasePrice\"][index] > 0 and (ticker.Last - params[\"arrBasePrice\"][index]) / params[\"arrBasePrice\"][index] > params[\"arrRatio\"][index]:\n        params[\"arrAcc\"][index] = _C(e.GetAccount)\n        if params[\"arrAcc\"][index].Balance * params[\"arrRatio\"][index] / ticker.Last > params[\"arrMinStocks\"][index]:\n            e.Buy(ticker.Last, params[\"arrAcc\"][index].Balance * params[\"arrRatio\"][index] / ticker.Last)\n            params[\"arrBasePrice\"][index] = ticker.Last\n    if ticker.Last - params[\"arrBasePrice\"][index] < 0 and (params[\"arrBasePrice\"][index] - ticker.Last) / params[\"arrBasePrice\"][index] > params[\"arrRatio\"][index]: \n        params[\"arrAcc\"][index] = _C(e.GetAccount)\n        if params[\"arrAcc\"][index].Stocks * params[\"arrRatio\"][index] > params[\"arrMinStocks\"][index]:\n            e.Sell(ticker.Last, params[\"arrAcc\"][index].Stocks * params[\"arrRatio\"][index])\n            params[\"arrBasePrice\"][index] = ticker.Last\n    ts = time.time()\n    if ts - params[\"arrLastCancelAll\"][index] > 60 * 5 :\n        CancelAll(e)\n        params[\"arrLastCancelAll\"][index] = ts \n\ndef main():\n    global params\n    \n    for i in range(len(exchanges)) :    \n        params[\"arrAcc\"].append(_C(exchanges[i].GetAccount))\n        params[\"arrTick\"].append(_C(exchanges[i].GetTicker))\n        exchanges[i].SetPrecision(params[\"arrPricePrecision\"][i], params[\"arrAmountPrecision\"][i])\n\n    for key in params :\n        if len(params[key]) < len(exchanges):\n            raise \"params error!\"\n\n    while True:\n        tblAcc = {\n            \"type\" : \"table\",\n            \"title\": \"account\",\n            \"cols\": [\"账户信息\"], \n            \"rows\": []\n        }        \n\n        tblTick = {\n            \"type\" : \"table\",\n            \"title\": \"ticker\",\n            \"cols\": [\"行情信息\"], \n            \"rows\": []\n        }\n        for i in range(len(exchanges)): \n            process(exchanges[i], i)\n\n        for i in range(len(exchanges)):\n            tblAcc[\"rows\"].append([json.dumps(params[\"arrAcc\"][i])])\n            tblTick[\"rows\"].append([json.dumps(params[\"arrTick\"][i])])\n\n        LogStatus(_D(), \"\\n`\" + json.dumps([tblAcc, tblTick]) + \"`\")\n        Sleep(500)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/182268\n\n> Last Modified\n\n2020-01-20 17:44:33"
    },
    {
        "strategy_id": "29_Python版多图表范例",
        "strategy_code": "python\n'''backtest\nstart: 2019-01-22 00:00:00\nend: 2019-01-23 00:00:00\nperiod: 30m\nexchanges: [{\"eid\":\"OKCoin_EN\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport random\nimport time\ndef main():\n    cfgA = {\n        \"extension\" : {\n            \"layout\" : \"single\", \n            \"height\" : 300,\n            \"col\" : 8\n        }, \n        \"title\" : {\n            \"text\" : \"盘口图表\"\n        },\n        \"xAxis\" : {\n            \"type\" : \"datetime\" \n        }, \n        \"series\" : [{\n            \"name\" : \"买一\",\n            \"data\" : []\n        }, {\n            \"name\" : \"卖一\", \n            \"data\" : []\n        }]\n    }    \n\n    cfgB = {\n        \"title\" : {\n            \"text\" : \"差价图\"\n        }, \n        \"xAxis\" : {\n            \"type\" : \"datetime\",\n        }, \n        \"series\" : [{\n            \"name\" : \"差价\", \n            \"type\" : \"column\", \n            \"data\" : []\n        }]\n    }    \n\n    cfgC = {\n        \"__isStock\" : False,\n        \"title\" : {\n            \"text\" : \"饼图\"\n        }, \n        \"series\" : [{\n            \"type\" : \"pie\", \n            \"name\" : \"one\", \n            \"data\" : [\n                [\"A\", 25],\n                [\"B\", 25],\n                [\"C\", 25],\n                [\"D\", 25],\n            ]\n        }]\n    }    \n\n    cfgD = {\n        \"extension\" : {\n            \"layout\" : \"single\",\n            \"col\" : 8,\n            \"height\" : \"300px\"\n        }, \n        \"title\" : {\n            \"text\" : \"盘口图表\"\n        }, \n        \"series\" : [{\n            \"name\" : \"买一\", \n            \"data\" : []\n        }, {\n            \"name\" : \"卖一\",\n            \"data\" : []\n        }]\n    }    \n\n    cfgE = {\n        \"__isStock\" : False, \n        \"extension\" : {\n            \"layout\" : \"single\", \n            \"col\" : 4,\n            \"height\" : \"300px\"\n        }, \n        \"title\" : {\n            \"text\" : \"饼图2\"\n        },\n        \"series\" : [{\n            \"type\" : \"pie\",\n            \"name\" : \"one\", \n            \"data\" : [\n                [\"A\", 25], \n                [\"B\", 25], \n                [\"C\", 25], \n                [\"D\", 25]\n            ]\n        }]\n    }\n    \n    chart = Chart([cfgA, cfgB, cfgC, cfgD, cfgE])\n    chart.reset()\n    chart.add(3, {\n        \"name\" : \"ZZ\",\n        \"y\" : random.random() * 100\n    })\n    \n    while True:\n        Sleep(1000)\n        ticker = exchange.GetTicker()\n        if not ticker :\n            continue\n        diff = ticker[\"Sell\"] - ticker[\"Buy\"]\n        cfgA[\"subtitle\"] = {\n            \"text\" : \"买一\" + str(ticker[\"Buy\"]) + \"卖一\" + str(ticker[\"Sell\"])\n        }\n        cfgB[\"subtitle\"] = {\n            \"text\" : \"价差 \" + str(diff)\n        }\n        \n        chart.add(0, [time.time() * 1000, ticker[\"Buy\"]])\n        chart.add(1, [time.time() * 1000, ticker[\"Sell\"]])\n        chart.add(2, [time.time() * 1000, diff])\n        chart.add(4, [time.time() * 1000, ticker[\"Buy\"]])\n        chart.add(5, [time.time() * 1000, ticker[\"Buy\"]])\n        cfgC[\"series\"][0][\"data\"][0][1] = random.random() * 100\n        cfgE[\"series\"][0][\"data\"][0][1] = random.random() * 100",
        "strategy_description": "策略名称: Python版多图表范例\n\n未找到描述"
    },
    {
        "strategy_id": "30_Python版简单网格策略教学",
        "strategy_code": "python\n'''backtest\nstart: 2019-07-01 00:00:00\nend: 2020-01-03 00:00:00\nperiod: 1m\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\"}]\n'''\n\nimport json\n\n# 参数\nbeginPrice = 5000\nendPrice = 8000\ndistance = 20\npointProfit = 50\namount = 0.01\nminBalance = 300\n\n# 全局变量\narrNet = []\narrMsg = []\nacc = None\n\ndef findOrder (orderId, NumOfTimes, ordersList = []) :\n    for j in range(NumOfTimes) :\n        orders = None\n        if len(ordersList) == 0:\n            orders = _C(exchange.GetOrders)\n        else :\n            orders = ordersList\n        for i in range(len(orders)):\n            if orderId == orders[i][\"Id\"]:\n                return True\n        Sleep(1000)\n    return False\n\ndef cancelOrder (price, orderType) :\n    orders = _C(exchange.GetOrders)\n    for i in range(len(orders)) : \n        if price == orders[i][\"Price\"] and orderType == orders[i][\"Type\"]: \n            exchange.CancelOrder(orders[i][\"Id\"])\n            Sleep(500)\n\ndef checkOpenOrders (orders, ticker) :\n    global arrNet, arrMsg\n    for i in range(len(arrNet)) : \n        if not findOrder(arrNet[i][\"id\"], 1, orders) and arrNet[i][\"state\"] == \"pending\" :\n            orderId = exchange.Sell(arrNet[i][\"coverPrice\"], arrNet[i][\"amount\"], arrNet[i], ticker)\n            if orderId :\n                arrNet[i][\"state\"] = \"cover\"\n                arrNet[i][\"id\"] = orderId                \n            else :\n                # 撤销\n                cancelOrder(arrNet[i][\"coverPrice\"], ORDER_TYPE_SELL)\n                arrMsg.append(\"挂单失败!\" + json.dumps(arrNet[i]) + \", time:\" + _D())\n\ndef checkCoverOrders (orders, ticker) :\n    global arrNet, arrMsg\n    for i in range(len(arrNet)) : \n        if not findOrder(arrNet[i][\"id\"], 1, orders) and arrNet[i][\"state\"] == \"cover\" :\n            arrNet[i][\"id\"] = -1\n            arrNet[i][\"state\"] = \"idle\"\n            Log(arrNet[i], \"节点平仓，重置为空闲状态。\", \"#FF0000\")\n\n\ndef onTick () :\n    global arrNet, arrMsg, acc\n\n    ticker = _C(exchange.GetTicker)\n    for i in range(len(arrNet)):\n        if i != len(arrNet) - 1 and arrNet[i][\"state\"] == \"idle\" and ticker.Sell > arrNet[i][\"price\"] and ticker.Sell < arrNet[i + 1][\"price\"]:\n            acc = _C(exchange.GetAccount)\n            if acc.Balance < minBalance :\n                arrMsg.append(\"资金不足\" + json.dumps(acc) + \"！\" + \", time:\" + _D())\n                break\n\n            orderId = exchange.Buy(arrNet[i][\"price\"], arrNet[i][\"amount\"], arrNet[i], ticker)\n            if orderId : \n                arrNet[i][\"state\"] = \"pending\"\n                arrNet[i][\"id\"] = orderId\n            else :\n                # 撤单\n                cancelOrder(arrNet[i][\"price\"], ORDER_TYPE_BUY)\n                arrMsg.append(\"挂单失败!\" + json.dumps(arrNet[i]) + \", time:\" + _D())\n    Sleep(1000)\n    orders = _C(exchange.GetOrders)\n    checkOpenOrders(orders, ticker)\n    Sleep(1000)\n    orders = _C(exchange.GetOrders)\n    checkCoverOrders(orders, ticker)\n\n    tbl = {\n        \"type\" : \"table\", \n        \"title\" : \"网格状态\",\n        \"cols\" : [\"节点索引\", \"详细信息\"], \n        \"rows\" : [], \n    }    \n\n    for i in range(len(arrNet)) : \n        tbl[\"rows\"].append([i, json.dumps(arrNet[i])])\n\n    errTbl = {\n        \"type\" : \"table\", \n        \"title\" : \"记录\",\n        \"cols\" : [\"节点索引\", \"详细信息\"], \n        \"rows\" : [], \n    }\n\n    orderTbl = {\n     \t\"type\" : \"table\", \n        \"title\" : \"orders\",\n        \"cols\" : [\"节点索引\", \"详细信息\"], \n        \"rows\" : [],    \n    }\n\n    while len(arrMsg) > 20 : \n        arrMsg.pop(0)\n\n    for i in range(len(arrMsg)) : \n        errTbl[\"rows\"].append([i, json.dumps(arrMsg[i])])    \n\n    for i in range(len(orders)) : \n        orderTbl[\"rows\"].append([i, json.dumps(orders[i])])\n\n    LogStatus(_D(), \"\\n\", acc, \"\\n\", \"arrMsg length:\", len(arrMsg), \"\\n\", \"`\" + json.dumps([tbl, errTbl, orderTbl]) + \"`\")\n\n\ndef main ():\n    global arrNet\n    for i in range(int((endPrice - beginPrice) / distance)):\n        arrNet.append({\n            \"price\" : beginPrice + i * distance,\n            \"amount\" : amount,\n            \"state\" : \"idle\",    # pending / cover / idle\n            \"coverPrice\" : beginPrice + i * distance + pointProfit,\n            \"id\" : -1,\n        })\n        \n    while True:\n        onTick()\n        Sleep(500)",
        "strategy_description": "策略名称: Python版简单网格策略教学\n\nbeginPrice = 5000\nendPrice = 8000\ndistance = 20\npointProfit = 50\namount = 0.01\nminBalance = 300"
    },
    {
        "strategy_id": "31_Python版追涨杀跌策略教学",
        "strategy_code": "python\n'''backtest\nstart: 2019-02-20 00:00:00\nend: 2020-01-10 00:00:00\nperiod: 1m\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\"}]\n'''\n\nimport time\n\nbasePrice = -1\nratio = 0.05\nacc = _C(exchange.GetAccount)\nlastCancelAll = 0\nminStocks = 0.01\n\ndef CancelAll():\n    while True : \n        orders = _C(exchange.GetOrders)\n        for i in range(len(orders)) :\n            exchange.CancelOrder(orders[i][\"Id\"], orders[i])\n        if len(orders) == 0 :\n            break\n        Sleep(1000)\n\ndef main():\n    global basePrice, acc, lastCancelAll\n    exchange.SetPrecision(2, 3)\n    while True:\n        ticker = _C(exchange.GetTicker)\n        if basePrice == -1 :\n            basePrice = ticker.Last\n        if ticker.Last - basePrice > 0 and (ticker.Last - basePrice) / basePrice > ratio :\n            acc = _C(exchange.GetAccount)\n            if acc.Balance * ratio / ticker.Last > minStocks :\n                exchange.Buy(ticker.Last, acc.Balance * ratio / ticker.Last)\n                basePrice = ticker.Last\n        if ticker.Last - basePrice < 0 and (basePrice - ticker.Last) / basePrice > ratio : \n            acc = _C(exchange.GetAccount)\n            if acc.Stocks * ratio > minStocks :\n                exchange.Sell(ticker.Last, acc.Stocks * ratio)\n                basePrice = ticker.Last\n        ts = time.time()\n        if ts - lastCancelAll > 60 * 5 :\n            CancelAll()\n            lastCancelAll = ts \n        LogStatus(_D(), \"\\n\", \"行情信息:\", ticker, \"\\n\", \"账户信息:\", acc)\n        Sleep(500)",
        "strategy_description": "策略名称: Python版追涨杀跌策略教学\n\n未找到描述"
    },
    {
        "strategy_id": "32_Python版追涨杀跌策略教学币安USDT永续合约",
        "strategy_code": "python\n'''backtest\nstart: 2021-05-01 00:00:00\nend: 2021-05-29 00:00:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"BTC_USDT\"}]\n'''\n\n# 原版代码是现货版：\n# https://www.fmz.com/bbs-topic/4908\n\n# 现在改为合约版。\n\n# ———— 韬奋量化（微信：himandy）\n\n\n# 好的交易平台可以让你的策略扶摇直上九万里，通过链接注册可获得两个月VIP5的手续费率优惠：\n# （现货：挂单0%，吃单0.07%。合约：挂单0%，吃单0.04%）\n# https://www.kucoin.cc/ucenter/signup?rcode=1wxJ2fQ&lang=zh_CN&utmsource=VIP_TF\n\nimport time\n\nbasePrice = -1\nratio = 0.05\nacc = _C(exchange.GetAccount)\npos = _C(exchange.GetPosition)\nlastCancelAll = 0\nminStocks = 0.01\n\ndef CancelAll():\n    while True : \n        orders = _C(exchange.GetOrders)\n        for i in range(len(orders)) :\n            exchange.CancelOrder(orders[i][\"Id\"], orders[i])\n        if len(orders) == 0 :\n            break\n        Sleep(1000)\n\ndef main():\n    global basePrice, acc, lastCancelAll, leverage, StopGain, StopLoss\n    #Log(StopLoss * -1)\n    exchange.SetContractType(\"swap\")\n    exchange.SetMarginLevel(leverage)\n    exchange.SetPrecision(2, 3)\n    pos = _C(exchange.GetPosition)\n    while True:\n        ticker = _C(exchange.GetTicker)\n        if basePrice == -1 :\n            basePrice = ticker.Last\n        if ticker.Last - basePrice > 0 and (ticker.Last - basePrice) / basePrice > ratio :\n            acc = _C(exchange.GetAccount)            \n            if acc.Balance * ratio * leverage / ticker.Last > minStocks and len(pos) == 0:\n                exchange.SetDirection(\"buy\")\n                exchange.Buy(_N(ticker.Last, 2), _N(acc.Balance * ratio / ticker.Last, 3))\n                basePrice = ticker.Last\n                ts = time.time()\n                if ts - lastCancelAll > 60 * 5 :\n                    CancelAll()\n                    lastCancelAll = ts\n                pos = _C(exchange.GetPosition)\n        if ticker.Last - basePrice < 0 and (basePrice - ticker.Last) / basePrice > ratio : \n            acc = _C(exchange.GetAccount)\n            pos = _C(exchange.GetPosition)\n            if acc.Balance * ratio * leverage / ticker.Last > minStocks and len(pos) == 0:\n                exchange.SetDirection(\"sell\")\n                exchange.Sell(_N(ticker.Last, 2), _N(acc.Balance * ratio / ticker.Last, 3))\n                basePrice = ticker.Last\n                ts = time.time()\n                if ts - lastCancelAll > 60 * 5 :\n                    CancelAll()\n                    lastCancelAll = ts\n                pos = _C(exchange.GetPosition)\n        if len(pos) == 1 :\n        \t#Log(pos)\n            if pos[0][\"Profit\"] / pos[0][\"Margin\"] > StopGain :\n                if pos[0][\"Type\"] == 0 :\n                    exchange.SetDirection(\"closebuy\")\n                    exchange.Sell(-1, pos[0][\"Amount\"])\n                    pos = _C(exchange.GetPosition)\n                elif pos[0][\"Type\"] == 1 :\n                    exchange.SetDirection(\"closesell\")\n                    exchange.Buy(-1, pos[0][\"Amount\"])\n                    pos = _C(exchange.GetPosition)\n            elif pos[0][\"Profit\"] / pos[0][\"Margin\"] < StopLoss * -1 :\n                if pos[0][\"Type\"] == 0 :\n                    exchange.SetDirection(\"closebuy\")\n                    exchange.Sell(-1, pos[0][\"Amount\"])\n                    pos = _C(exchange.GetPosition)\n                elif pos[0][\"Type\"] == 1 :\n                    exchange.SetDirection(\"closesell\")\n                    exchange.Buy(-1, pos[0][\"Amount\"])\n                    pos = _C(exchange.GetPosition)\n\n        LogStatus(_D(), \"\\n\", \"行情信息:\", ticker, \"\\n\", \"账户信息:\", acc)\n        if exchange.GetName() == \"Futures_Binance\" and IsVirtual() == false :\n            LogProfit(_N(float(acc[\"Info\"][\"totalWalletBalance\"], 4)))\n        Sleep(500)",
        "strategy_description": "策略名称: Python版追涨杀跌策略教学币安USDT永续合约\n\n# https://www.fmz.com/bbs-topic/4908"
    },
    {
        "strategy_id": "33_Python简单测试策略",
        "strategy_code": "python\nimport time\nimport talib\n\ndef main():\n    LogProfitReset()\n    LogReset()\n    Log(\"init OK\", time.strftime('%Y-%m-%d %X', time.localtime(time.time())))\n    Log(a,b,c,d)\n    _G(\"ok\", 123)\n    Log(GetPid(), _G(), _G(\"ok\"), _G(\"dummy\"))\n    Sleep(1000)\n    _G(None)\n    Log(_G(\"ok\"))\n\n    LogStatus(\"Time\", time.time())\n    EnableLog(True)\n    SetErrorFilter(\"net\")\n    Log(GetLastError())\n    Log(GetCommand())\n    ticker = exchange.GetTicker()\n    Log('ticker buy', ticker.Buy, ticker['Buy']);\n    \n    r = _C(exchange.GetRecords)\n    Log(TA.ATR(r))\n    Log(TA.EMA(r, 10))\n    # test talib\n    Log(str(talib.EMA(r.Close, 10)))\n\n    for e in exchanges:\n        Log(e.GetName(), e.GetRate(), e.GetCurrency())\n        Log(e.GetAccount())\n        Log(_C(e.GetOrders))\n        Log(e.GetOrder(10))\n        Log(e.CancelOrder(10000))\n \n        Log(e.GetUSDCNY())\n        #Log(e.GetPosition())\n        #Log(e.SetContractType(\"next_week\"))\n        Log(e.GetTicker())\n        Log('Asks:', len(e.GetDepth().Asks))\n        #Log(e.SetMarginLevel(10))\n        #Log(e.SetDirection(\"buy\"))\n        #Log(e.SetContractType(\"quarter\"))\n        #Log(e.GetRecords(PERIOD_M30)[0])\n        Log(e.GetRecords()[0])\n    x = Chart({\n        'title' : { 'text' : 'test chart'},\n        'xAxis': { 'type': 'datetime'},\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\n        })\n    x.reset()\n    Log(\"策略将每10秒更新一次ticker\");\n    for i in range(100):\n        ts = int(time.time() * 1000)\n        ticker = _C(exchange.GetTicker)\n        x.add(0, [ts, ticker.Buy])\n        x.add(1, [ts, ticker.Sell])\n        LogStatus(ticker)\n        Sleep(10000)",
        "strategy_description": "策略名称: Python简单测试策略\n\nLog(str(talib.EMA(r.Close, 10)))\n\n    for e in exchanges:\n        Log(e.GetName(), e.GetRate(), e.GetCurrency())\n        Log(e.GetAccount())\n        Log(_C(e.GetOrders))\n        Log(e.GetOrder(10))\n        Log(e.CancelOrder(10000))\n \n        Log(e.GetUSDCNY())\n        #Log(e.GetPosition())\n        #Log(e.SetContractType(\"next_week\"))\n        Log(e.GetTicker())\n        Log('Asks:', len(e.GetDepth().Asks))\n        #Log(e.SetMarginLevel(10))\n        #Log(e.SetDirection(\"buy\"))\n        #Log(e.SetContractType(\"quarter\"))\n        #Log(e.GetRecords(PERIOD_M30)[0])\n        Log(e.GetRecords()[0])\n    x = Chart({\n        'title' : { 'text' : 'test chart'},\n        'xAxis': { 'type': 'datetime'},\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\n        })\n    x.reset()\n    Log(\"策略将每10秒更新一次ticker\");\n    for i in range(100):\n        ts = int(time.time() * 1000)\n        ticker = _C(exchange.GetTicker)\n        x.add(0, [ts, ticker.Buy])\n        x.add(1, [ts, ticker.Sell])\n        LogStatus(ticker)\n        Sleep(10000)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/20761\n\n> Last Modified\n\n2018-06-05 16:43:46"
    },
    {
        "strategy_id": "34_R-Breaker-交易策略",
        "strategy_code": "python\n#!/usr/local/bin/python\n#-*- coding: UTF-8 -*-\n#R-Breaker 交易策略\n#策略提供者 @FJK   QQ:171938416\n#改进  @太极  QQ:7650371\n\ndef my_buy(): #开仓\n    try:\n        global buy_price,buy_qty\n        initAccount = ext.GetAccount()  #交易模板的导出函数， 获得账户状态，保存策略运行前账户初始状态\n        opAmount=1\n        PositionRatio =1\n        #开仓之前判断有币没有没有先进行买入\n        if int(initAccount.Stocks)>1:\n            if buy_price<1:\n                buy_price=_C(exchange.GetTicker).Last\n                buy_qty=initAccount.Stocks\n            #Log('开仓信息1 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\n            return 1\n        if int(initAccount.Stocks)<1:\n            if int(str(initAccount.Stocks).replace('0.',''))>=3:\n                if buy_price<1:\n                    buy_price=_C(exchange.GetTicker).Last\n                    buy_qty=initAccount.Stocks\n                #Log('开仓信息2 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\n                return 1\n\n        #if int(str(initAccount.Stocks).replace('0.',''))==0:\n        opAmount = _N(initAccount.Balance*PositionRatio,3)  #买入数量\n        Log(\"开仓没有币先进行 开仓买入%s元\"%(str(opAmount)))   #生成LOG日志\n\n        Dict = ext.Buy(opAmount)  #买入ext.Buy\n        if(Dict):#确认开仓成功\n            buy_price=Dict['price'] #买入价格   #{'price': 4046.446, 'amount': 1.5}\n            buy_qty=Dict['amount']  #买入数量\n            #LogProfit(_N(gains,4),'开仓信息 钱:',initAccount.Balance,'--币:',initAccount.Stocks,'--开仓详情:',Dict)\n            print_log(1,initAccount)\n            return 1\n        return 0\n\n    except Exception,ex:\n        Log('except Exception my_buy:',ex)\n        return 0\n\n\nimport time\nimport datetime\ndef Caltime(date1,date2):   #计算运行天数\n    try:\n        date1=time.strptime(date1,\"%Y-%m-%d %H:%M:%S\")\n        date2=time.strptime(date2,\"%Y-%m-%d %H:%M:%S\")\n        date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])\n        date2=datetime.datetime(date2[0],date2[1],date2[2],date2[3],date2[4],date2[5])\n        return date2-date1\n    except Exception,ex:\n        Log('except Exception Caltime:',ex)\n        return \"except Exception\"\n\nstart_timexx =time.localtime(time.time()) #time.clock()\nstart_time=time.strftime(\"%Y-%m-%d %H:%M:%S\",start_timexx)\nbuy_price=0 #买入价格\nbuy_qty=0  #买入数量\ngains=0  #盈利\n\nbeng_Account = ext.GetAccount()  #初始化信息\nbeng_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\nbeng_Balance=(beng_Account.Stocks*beng_ticker)+beng_Account.Balance #初始化账户钱\ndef print_log(k_p,data=\"\"):  #输出\n    try:\n        name=\"\"\n        if k_p:\n            name=\"开仓\"\n        else:\n            name=\"平仓\"\n        global beng_Account,beng_ticker,beng_Balance\n        global gains\n        end_Account = ext.GetAccount()  #当前账户信息\n        end_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\n        #################################################\n        date1=time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime(time.time()))\n        msg_data0=(\"本次开始运行时间:%s已运行:%s\\r\\n\"%(start_time,Caltime(start_time,date1)))\n        #################################################\n        msg_data1=(\"本次初始化状态:%s\\r\\n当前运行状态:%s\\r\\n\"%(beng_Account,end_Account))\n        #################################################\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\n        msg_data2=(\"初始化钱:%s现在钱:%s盈亏:%s\\r\\n\"%(str(beng_Balance),str(end_Balance),str(end_Balance-beng_Balance)))\n        #################################################\n        total = end_Account.Balance+end_Account.Stocks*_C(exchange.GetTicker).Last #账户总额\n        roi = ((total/beng_Balance) -1)*100\n        msg_data3=(\"当前状态:%s--钱:%s--币:%s--总值约:%.2f\\r\\n\"%(str(name),str(end_Account.Balance),str(end_Account.Stocks),roi))\n        #################################################\n        income = total - beng_Account['Balance'] - beng_Account['Stocks']*beng_ticker #总盈亏\n        msg_data4=(\"本次盈亏:%s(RMB)\\t总盈亏:%.2f(RMB) %.2f\\r\\n\"%(str(gains),income,roi))\n        #################################################\n        #盈利计算方法\n        #盈利计算方法   浮动利润： 按 （现在币 - 初始币）x 现在的价格 + （现在的钱 - 初始的钱）\n        diff_stocks=end_Account.Stocks-beng_Account.Stocks    #比的差值\n        diff_balance=end_Account.Balance-beng_Account.Balance   #钱的差值\n        new_end_balance=diff_stocks*end_ticker+diff_balance #实现盈亏   #当前的盈利\n        #盈利计算方法   账面利润 ： （现在币 x 现在价格+现在钱） - （初始币 x 初始价格 + 初始钱）\n        new_end_balance2=(end_Account.Stocks*end_ticker+end_Account.Balance)-(beng_Account.Stocks*beng_ticker+beng_Account.Balance)\n        msg_data5=(\"浮动利润:%s(RMB)\\r\\n账面利润:%s(RMB)\\r\\n\"%(str(_N(new_end_balance,3)),str(_N(new_end_balance2,3))))\n        #################################################\n        LogStatus(\"初始化投入2016/9/24  投入0.2个币=等于行情800RMB\\r\\n\",\n                  msg_data0,msg_data1,msg_data2,msg_data3,msg_data4,msg_data5,\n                  \"更新时间:%s\\r\\n\"%(date1),\n                  \"%s\"%(data)\n                  )\n        #################################################\n        #################################################\n        #################################################\n    except Exception,ex:\n        Log('except Exception print_log:',ex)\n\ndef my_sell(): #平仓\n    try:\n        global buy_price,buy_qty,gains,ExitPeriod\n        ExitPeriod = 0\n        nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\n        if nowAccount.Stocks<=0.002:  #保证满足交易量\n            #Log('不满足最小交易量:',nowAccount.Stocks)\n            return 1\n\n        #history_Last=_N(Volume_averages(Ticker_list),2)    #历史均价\n        #cur_last = _N(_C(exchange.GetTicker).Last,2)\n\n        #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod :   #当前价格一定要大于  开仓价格\n        if True:\n            #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod and  history_Last - cur_last >0 and  history_Last - cur_last < 2 :   #当前价格一定要大于  开仓价格\n            #Log('历史差价:',history_Last - cur_last)\n            Dict = ext.Sell(nowAccount.Stocks)\n            #Dict ={\"price\":_C(exchange.GetTicker).Last}\n            if(Dict):\n                #sell_count+=1\n                sell_gains=(Dict['price']-buy_price)*Dict['amount']\n                gains=gains+sell_gains\n                buy_price=0 #买入价格\n                buy_qty=0  #买入数量\n                LogProfit(_N(gains,4),'平仓信息 钱:',nowAccount.Balance,'--币:',nowAccount.Stocks,'--平仓详情:',Dict)#收益曲线\n                print_log(0,nowAccount)\n                return 1\n        else:\n            current_Last = _N(_C(exchange.GetTicker).Last,2)    ##当前价格\n            data=\"不具备平仓条件:买入-当前=差价:%s-%s=%s\"%(buy_price,current_Last,_N(buy_price-current_Last,2))\n            print_log(0,nowAccount,data)\n        return 0\n    except Exception,ex:\n        Log('except Exception my_sell:',ex)\n        return 0\n\n########################################################\ndef onTick():\n    try:\n        records =exchange.GetRecords()  #由你自己设定的周期数返回的数据\n        HH = records[-2]['High'] #最日最高\n        LC = records[-2]['Low']  #昨日最低\n        HC = records[-2]['Close'] #昨日收盘\n        LL = records[-2]['Low']  #昨日最低\n        Pivot = (HH+HC+LC)/3 #枢轴点\n        R1 = 2*Pivot-LC #阻力1\n        R2 = Pivot+(HH-LC) #阻力2\n        R3 = HH +2*(Pivot-LC) #阻力3\n\n        S1 = 2*Pivot-HH  #支撑位1\n        S2 = Pivot - (HH-LC)  #支撑位2\n        S3 = LC-2*(HH-Pivot)  #支撑位3\n        #Log('r1',R1,\"R2\",R2,'R3',R3)\n        #Log('S1',S1,\"S2\",S2,'S3',S3)\n        To = records[-1]['Open'] #今日开盘价\n        Th = records[-1]['High'] #今日最高价\n        Tl = records[-1]['Low'] #今日最低价\n        current_price = _C(exchange.GetTicker).Last #当前价格\n\n        #当前价格>阻力3   开仓\n        if current_price > R3: #突破上轨开多\n            if my_buy(): #Log('多')\n                return\n\n        #当前价格<支撑位3  平仓\n        if current_price < S3: #突破下轨卖空\n            if my_sell(): #Log('空')\n                return\n\n        # 条件1   今日最高价>阻力2\n        # 条件2   今日最高价<阻力3\n        # 条件3   当前价格<阻力1\n        # 同时具备这3个条件平仓\n        if Th >R2 and Th <R3 and current_price <R1: #趋势反转卖出\n            if my_sell(): #Log('空')\n                return\n\n        # 条件1   今日最低价<支撑位2\n        # 条件2   今日最低价>支撑位3\n        # 条件3   当前价格<支撑位1\n        # 同时具备这3个条件开仓\n        if Tl <S2 and Tl >S3 and current_price <S1: #支撑位1\n            if my_buy(): #Log('多')\n                return\n                # Log(records[-1])#今日K\n                # Log(records[-2])#昨日K\n                # Log(exchange.GetTicker())#当前\n\n    except Exception,ex:\n        Log('except Exception onTick:',ex)\n\n\n\ndef main():\n    global outAccount\n    outAccount = ext.GetAccount()  #初始化信息\n    Log(\"run  \",outAccount)  #输出初始账户信息\n    while True:\n        onTick()\n        Sleep(1000)",
        "strategy_description": "策略名称: R-Breaker-交易策略\n\nmsg_data0=(\"本次开始运行时间:%s已运行:%s\\r\\n\"%(start_time,Caltime(start_time,date1)))\n        #################################################\n        msg_data1=(\"本次初始化状态:%s\\r\\n当前运行状态:%s\\r\\n\"%(beng_Account,end_Account))\n        #################################################\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\n        msg_data2=(\"初始化钱:%s现在钱:%s盈亏:%s\\r\\n\"%(str(beng_Balance),str(end_Balance),str(end_Balance-beng_Balance)))\n        #################################################\n        total = end_Account.Balance+end_Account.Stocks*_C(exchange.GetTicker).Last #账户总额\n        roi = ((total/beng_Balance) -1)*100\n        msg_data3=(\"当前状态:%s--钱:%s--币:%s--总值约:%.2f\\r\\n\"%(str(name),str(end_Account.Balance),str(end_Account.Stocks),roi))\n        #################################################\n        income = total - beng_Account['Balance'] - beng_Account['Stocks']*beng_ticker #总盈亏\n        msg_data4=(\"本次盈亏:%s(RMB)\\t总盈亏:%.2f(RMB) %.2f\\r\\n\"%(str(gains),income,roi))\n        #################################################\n        #盈利计算方法\n        #盈利计算方法   浮动利润： 按 （现在币 - 初始币）x 现在的价格 + （现在的钱 - 初始的钱）\n        diff_stocks=end_Account.Stocks-beng_Account.Stocks    #比的差值\n        diff_balance=end_Account.Balance-beng_Account.Balance   #钱的差值\n        new_end_balance=diff_stocks*end_ticker+diff_balance #实现盈亏   #当前的盈利\n        #盈利计算方法   账面利润 ： （现在币 x 现在价格+现在钱） - （初始币 x 初始价格 + 初始钱）\n        new_end_balance2=(end_Account.Stocks*end_ticker+end_Account.Balance)-(beng_Account.Stocks*beng_ticker+beng_Account.Balance)\n        msg_data5=(\"浮动利润:%s(RMB)\\r\\n账面利润:%s(RMB)\\r\\n\"%(str(_N(new_end_balance,3)),str(_N(new_end_balance2,3))))\n        #################################################\n        LogStatus(\"初始化投入2016/9/24  投入0.2个币=等于行情800RMB\\r\\n\",\n                  msg_data0,msg_data1,msg_data2,msg_data3,msg_data4,msg_data5,\n                  \"更新时间:%s\\r\\n\"%(date1),\n                  \"%s\"%(data)\n                  )\n        #################################################\n        #################################################\n        #################################################\n    except Exception,ex:\n        Log('except Exception print_log:',ex)\n\ndef my_sell(): #平仓\n    try:\n        global buy_price,buy_qty,gains,ExitPeriod\n        ExitPeriod = 0\n        nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\n        if nowAccount.Stocks<=0.002:  #保证满足交易量\n            #Log('不满足最小交易量:',nowAccount.Stocks)\n            return 1\n\n        #history_Last=_N(Volume_averages(Ticker_list),2)    #历史均价\n        #cur_last = _N(_C(exchange.GetTicker).Last,2)\n\n        #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod :   #当前价格一定要大于  开仓价格\n        if True:\n            #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod and  history_Last - cur_last >0 and  history_Last - cur_last < 2 :   #当前价格一定要大于  开仓价格\n            #Log('历史差价:',history_Last - cur_last)\n            Dict = ext.Sell(nowAccount.Stocks)\n            #Dict ={\"price\":_C(exchange.GetTicker).Last}\n            if(Dict):\n                #sell_count+=1\n                sell_gains=(Dict['price']-buy_price)*Dict['amount']\n                gains=gains+sell_gains\n                buy_price=0 #买入价格\n                buy_qty=0  #买入数量\n                LogProfit(_N(gains,4),'平仓信息 钱:',nowAccount.Balance,'--币:',nowAccount.Stocks,'--平仓详情:',Dict)#收益曲线\n                print_log(0,nowAccount)\n                return 1\n        else:\n            current_Last = _N(_C(exchange.GetTicker).Last,2)    ##当前价格\n            data=\"不具备平仓条件:买入-当前=差价:%s-%s=%s\"%(buy_price,current_Last,_N(buy_price-current_Last,2))\n            print_log(0,nowAccount,data)\n        return 0\n    except Exception,ex:\n        Log('except Exception my_sell:',ex)\n        return 0"
    },
    {
        "strategy_id": "35_R-Breaker11-交易策略",
        "strategy_code": "python\n# botvs@f976b25629baf8373e73da860a54030d\n#!/usr/local/bin/python\n#-*- coding: UTF-8 -*-\n#删除反转止损\nimport math\nimport talib\ndef adjustFloat(v):\n    v =math.floor(v*1000)\n    return v/1000\n\ndef GetAccount():\n    account = _C(exchange.GetAccount)\n    while account == null:\n        account = _C(exchange.GetAccount)\n        Sleep(1000)\n    return account\n\ndef GetTicker():\n    ticker = exchange.GetTicker()\n    while ticker ==null:\n        ticker = exchange.GetTicker()\n        Sleep(1000)\n    return ticker\n# def updateProfit(accountInit, accountNow, ticker):\n#     netNow = accountNow.Balance + accountNow.FrozenBalance + ((accountNow.Stocks + accountNow.FrozenStocks) * ticker.Buy)\n#     netInit = accountInit.Balance + accountInit.FrozenBalance + ((accountInit.Stocks + accountInit.FrozenStocks) * ticker.Buy)\n#     LogProfit(adjustFloat(netNow - netInit), accountNow)\n\n#获取当期账户总额\ndef GetNowamount():\n    account =GetAccount()\n    ticker = exchange.GetTicker()\n    return account.Balance + account.FrozenBalance + ((account.Stocks + account.FrozenStocks) * ticker.Buy)\n#获取当前账户市值\ndef GetStockcap():\n    account=GetAccount()\n    ticker = GetTicker()\n    return (account.Stocks + account.FrozenStocks) * ticker.Buy\n\n\n\n#type 0 总持仓比例 1 可买入币的百分比\ndef my_buy(ratio,type):\n    try:\n        global InitAccount\n        account = GetAccount()\n        ticker=_C(exchange.GetTicker)\n        #计算买入量\n        if type == 0:\n            unit =(GetNowamount()/ticker.Buy)*ratio - account.Stocks - account.FrozenStocks\n        else:\n            unit =((GetNowamount()/ticker.Buy) - account.Stocks - account.FrozenStocks)*ratio\n        \n        #不足最低交易退出买入操作\n        if unit < exchange.GetMinStock():\n            return 0\n        Dict = ext.Buy(unit)  #买入ext.Buy\n        if(Dict):#确认开仓成功\n            #buy_price=Dict['price'] #买入价格   #{'price': 4046.446, 'amount': 1.5}\n            #buy_qty=Dict['amount']  #买入数量\n            #LogProfit(_N(gains,4),'开仓信息 钱:',initAccount.Balance,'--币:',initAccount.Stocks,'--开仓详情:',Dict)\n            #updateProfit(InitAccount, GetAccount(), GetTicker())\n            Balance_log() #收益计算\n            print_log(1,InitAccount)\n            return 1\n        return 0\n    except Exception,ex:\n        Log('except Exception my_buy:',ex)\n        return 0\n\ndef my_sell(ratio,type):\n    try:\n        global InitAccount\n        account = GetAccount()\n        if type == 0:\n            unit = 1\n        else:\n            unit =(account.Stocks + account.FrozenStocks)*ratio\n\n        if unit<exchange.GetMinStock():\n            return 0\n\n        Dict = ext.Sell(unit)\n            #Dict ={\"price\":_C(exchange.GetTicker).Last}\n        if(Dict):\n            #updateProfit(InitAccount, GetAccount(), GetTicker())\n            Balance_log() #收益计算\n            print_log(0,GetAccount())\n            return 1\n    except Exception,ex:\n        Log('except Exception my_sell:',ex)\n        return 0\n\n\n########################################################\nimport datetime\ndef Caltime(date1,date2):\n    try:\n        date1=time.strptime(date1,\"%Y-%m-%d %H:%M:%S\")\n        date2=time.strptime(date2,\"%Y-%m-%d %H:%M:%S\")\n        date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])\n        date2=datetime.datetime(date2[0],date2[1],date2[2],date2[3],date2[4],date2[5])\n        return date2-date1\n    except Exception,ex:\n        Log('except Exception Caltime:',ex)\n        return \"except Exception\"\n\n\nimport time\nstart_timexx =time.localtime(time.time()) #time.clock()\nstart_time=time.strftime(\"%Y-%m-%d %H:%M:%S\",start_timexx)\nbuy_price=0 #买入价格\nbuy_qty=0  #买入数量\ngains=0  #盈利\n\nbeng_Account = ext.GetAccount()  #初始化信息\nbeng_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\nbeng_Balance=(beng_Account.Stocks*beng_ticker)+beng_Account.Balance #初始化账户钱\n\ndef Balance_log(): #收益计算\n    try:\n        end_Account = ext.GetAccount()  #当前账户信息\n        end_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\n        LogProfit(end_Balance-beng_Balance) \t#记录盈利值\n    except Exception,ex:\n        Log('except Exception Balance_log:',ex)\n\ndef print_log(k_p,data=\"\"):  #输出\n    try:\n        name=\"\"\n        if k_p:\n            name=\"开仓\"\n        else:\n            name=\"平仓\"\n        global beng_Account,beng_ticker,beng_Balance\n        global R1,R2,R3,S1,S2,S3\n        global gains\n        end_Account = ext.GetAccount()  #当前账户信息\n        end_ticker = _C(exchange.GetTicker).Last#Ticker \t市场行情   最后成交价\n        #################################################\n        date1=time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime(time.time()))\n        msg_data0=(\"本次开始运行时间:%s已运行:%s\\r\\n\"%(start_time,Caltime(start_time,date1)))\n        #################################################\n        msg_data1=(\"本次初始化状态:%s\\r\\n当前运行状态:%s\\r\\n\"%(beng_Account,end_Account))\n        #################################################\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\n        msg_data2=(\"初始化钱:%s现在钱:%s盈亏:%s\\r\\n\"%(str(beng_Balance),str(end_Balance),str(end_Balance-beng_Balance)))\n        #################################################\n        total = end_Account.Balance+end_Account.Stocks*_C(exchange.GetTicker).Last #账户总额\n        roi = ((total/beng_Balance) -1)*100\n        msg_data3=(\"当前状态:%s--钱:%s--币:%s--总值约:%.2f\\r\\n\"%(str(name),str(end_Account.Balance),str(end_Account.Stocks),roi))\n        #################################################\n        income = total - beng_Account['Balance'] - beng_Account['Stocks']*beng_ticker #总盈亏\n        msg_data4=(\"本次盈亏:%s(RMB)\\t总盈亏:%.2f(RMB) %.2f\\r\\n\"%(str(gains),income,roi))\n        #################################################\n        #盈利计算方法\n        #盈利计算方法   浮动利润： 按 （现在币 - 初始币）x 现在的价格 + （现在的钱 - 初始的钱）\n        diff_stocks=end_Account.Stocks-beng_Account.Stocks    #比的差值\n        diff_balance=end_Account.Balance-beng_Account.Balance   #钱的差值\n        new_end_balance=diff_stocks*end_ticker+diff_balance #实现盈亏   #当前的盈利\n        #盈利计算方法   账面利润 ： （现在币 x 现在价格+现在钱） - （初始币 x 初始价格 + 初始钱）\n        new_end_balance2=(end_Account.Stocks*end_ticker+end_Account.Balance)-(beng_Account.Stocks*beng_ticker+beng_Account.Balance)\n        msg_data5=(\"浮动利润:%s(RMB)\\r\\n账面利润:%s(RMB)\\r\\n\"%(str(_N(new_end_balance,3)),str(_N(new_end_balance2,3))))\n        msg_data6 ='R1',R1,'R2',R2,'R3',R3,'\\r\\n'\n        msg_data7 ='S1',S1,'S2',S2,'S3',S3,'\\r\\n'\n        msg_data8 =\"当前价格:\",end_ticker,'\\r\\n'\n        #################################################\n        LogStatus(\"初始化投入2016/9/24  投入0.2个币=等于行情800RMB\\r\\n\",\n                  msg_data0,msg_data1,msg_data2,msg_data3,msg_data4,msg_data5,msg_data6,msg_data7,msg_data8,\n                  \"更新时间:%s\\r\\n\"%(date1),\n                  \"%s\"%(data)\n                  )\n        #################################################\n        #################################################\n        #################################################\n    except Exception,ex:\n        Log('except Exception print_log:',ex)\n\n\n\n\ndef _GetCommand():\n    get_command=GetCommand()\n    if get_command:\n        global K1,K2,N\n        arr =get_command.split(\":\")\n        if arr[0] == 'K1':\n            K1 = float(arr[-1])\n        if arr[0] =='K2':\n            K2 = float(arr[-1])\n        if arr[0] =='N':\n            N = int(arr[-1])\n\n\nN=2\n\nLastDeal = 0 #上次交易时间\ndef onTick(exchange):\n    try:\n        global R1,R2,R3,S1,S2,S3,short_state_buy,short_state_sell,LastDeal,task_state,buy_count,sell_count\n        amount = GetAccount() # 获取账户状态\n        records =exchange.GetRecords() #默认5分钟\n        To = records[-1]['Open'] #今日开盘价\n        Th = records[-1]['High'] #今日最高价\n        Tl = records[-1]['Low'] #今日最低\n        time = records[-1].Time\n        if LastDeal == time:\n            return 0\n        else:\n            LastDeal = 0\n\n        \n        records1 =exchange.GetRecords(PERIOD_M30) #监控周期\n        #time =(records1[-2].Time - records1[-1].Time)/(60*1000)\n        #Log(time);\n        records.pop()\n        records1.pop()\n        ma5 = TA.MA(records1,5)\n        ma10 = TA.MA(records1,10)\n     \n\n\n        # HH = records[-2]['High'] #最日最高\n        # LC = records[-2]['Low']  #昨日最低\n        HC = records[-1]['Close'] #昨日收盘\n        # LL = records[-2]['Low']  #昨日最低\n        HH = TA.Highest(records,N,'High') #N日high的最高价\n            #lc = records[-2]['Low']\n        #HC = TA.Lowest(records,N,'Close') #//N日close的最低价\n            #hc = records[-2]['Close']\n        #HH = TA.Highest(records,N,'Close') #N日close的最高价\n            #ll = records[-2]['Low']\n        LC = TA.Lowest(records,N,'Low') #//N日low的最低价\n        #HC = TA.Highest(records,N,'Close')\n        if ma5[-1] <ma10[-1]:\n            HC = records[-1]['Open']\n\n        Pivot = (HH+HC+LC)/3 #枢轴点\n        Pivot = Pivot\n        R1 = 2*Pivot-LC #阻力1W\n        R2 = Pivot+(HH-LC) #阻力2\n        R3 = HH +2*(Pivot-LC) #阻力3\n\n        S1 = 2*Pivot-HH\n        S2 = Pivot - (HH-LC)\n        S3 = LC-2*(HH-Pivot)\n        # Log('r1',R1,\"R2\",R2,'R3',R3)\n        # Log('S1',S1,\"S2\",S2,'S3',S3)\n        \n        current_price = _C(exchange.GetTicker).Last #当前价格\n        capratio = (amount.Stocks + amount.FrozenStocks)/GetNowamount()\n        #突破上轨 和半小时 均线向上 资金大于100 则买入\n        if ma5[-1] >ma10[-1] :\n            if current_price > R3 and amount.Balance > 100 and ma5[-1] >ma10[-1] and capratio <0.8 and buy_count <3 :\n               # Log(ma5[-1],ma10[-1])\n                Log('开多')\n                if my_buy(0.4,1):\n                    LastDeal = time\n                    sell_count = 0\n                    buy_count+=1\n                    return\n            #突破下轨卖空 有币 进入卖出操作\n            if current_price < S3 and amount.Stocks > 0.03 :\n                Log('清仓')\n                if my_sell(1,0):\n                    sell_count+=1\n                    buy_count = 0\n                    LastDeal = time\n                    return\n            if Th >R2 and Th <R3 and current_price <R1 and current_price >S1   and amount.Stocks > 0.003 and buy_count <3:\n                Log('趋势反转卖')\n                if my_sell(0.5,1):\n                    LastDeal = time\n                    buy_count = 0\n                    sell_count+=1\n                    return\n            if Tl <S2 and Tl >S3 and current_price <S1  and current_price < R1 and capratio <0.6 and ma5[-1] >ma10[-1] and buy_count <3 :\n                #Log(ma5[-1],ma10[-1])\n                Log('趋势反转买')\n                if my_buy(0.2,1):\n                    buy_count+=1\n                    sell_count = 0\n                    LastDeal = time\n                    return\n        else :\n            if(current_price > R3 and amount.Stocks > 0.03):\n                if my_sell(0.5,1):\n                    Log('测试买')\n                    LastDeal = time\n                    return\n\n            if (current_price < S3 and ma5[-1] >ma5[-5]):\n                if my_buy(0.05,1):\n                    Log('测试买入')\n                    LastDeal = time\n                    buy_count = 0\n                    return\n\n\n\n\n\n\n        \n\n\n    except Exception,ex:\n        Log('except Exception onTick:',ex)\n        return 0\n\n\ndef main():\n    global outAccount,init_price,InitAccount,short_state_buy,short_state_sell,task_state,buy_count,sell_count\n    init_price = _C(exchange.GetTicker).Last\n    InitAccount = GetAccount()\n    Log(init_price)\n    short_state_buy =short_state_sell = 0\n    task_state =0\n    buy_count = 0\n    sell_count = 0\n    while True:\n            onTick(exchange)\n            nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\n            print_log(0,nowAccount)\n            Sleep(1000)",
        "strategy_description": "策略名称: R-Breaker11-交易策略\n\n#!/usr/local/bin/python"
    },
    {
        "strategy_id": "36_RecordsCollecter-升级提供自定义数据源功能",
        "strategy_code": "python\nimport _thread\nimport pymongo\nimport json\nimport math\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse\n\ndef url2Dict(url):\n    query = urlparse(url).query  \n    params = parse_qs(query)  \n    result = {key: params[key][0] for key in params}  \n    return result\n\nclass Provider(BaseHTTPRequestHandler):\n    def do_GET(self):\n        try:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"application/json\")\n            self.end_headers()\n\n            dictParam = url2Dict(self.path)\n            Log(\"自定义数据源服务接收到请求，self.path:\", self.path, \"query 参数：\", dictParam)\n            \n            # 目前回测系统只能从列表中选择交易所名称，在添加自定义数据源时，设置为币安，即：Binance\n            exName = exchange.GetName()                                     \n            # 注意，period为底层K线周期\n            tabName = \"%s_%s\" % (\"records\", int(int(dictParam[\"period\"]) / 1000))  \n            priceRatio = math.pow(10, int(dictParam[\"round\"]))\n            amountRatio = math.pow(10, int(dictParam[\"vround\"]))\n            fromTS = int(dictParam[\"from\"]) * int(1000)\n            toTS = int(dictParam[\"to\"]) * int(1000)\n            \n            \n            # 连接数据库\n            Log(\"连接数据库服务，获取数据，数据库：\", exName, \"表：\", tabName)\n            myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")\n            ex_DB = myDBClient[exName]\n            exRecords = ex_DB[tabName]\n            \n            \n            # 要求应答的数据\n            data = {\n                \"schema\" : [\"time\", \"open\", \"high\", \"low\", \"close\", \"vol\"],\n                \"data\" : []\n            }\n            \n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\n            dbQuery = {\"$and\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\n            Log(\"查询条件：\", dbQuery, \"查询条数：\", exRecords.find(dbQuery).count(), \"数据库总条数：\", exRecords.find().count())\n            \n            for x in exRecords.find(dbQuery).sort(\"Time\"):\n                # 需要根据请求参数round和vround，处理数据精度\n                bar = [x[\"Time\"], int(x[\"Open\"] * priceRatio), int(x[\"High\"] * priceRatio), int(x[\"Low\"] * priceRatio), int(x[\"Close\"] * priceRatio), int(x[\"Volume\"] * amountRatio)]\n                data[\"data\"].append(bar)\n            \n            Log(\"数据：\", data, \"响应回测系统请求。\")\n            # 写入数据应答\n            self.wfile.write(json.dumps(data).encode())\n        except BaseException as e:\n            Log(\"Provider do_GET error, e:\", e)\n\n\ndef createServer(host):\n    try:\n        server = HTTPServer(host, Provider)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except BaseException as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\ndef main():\n    LogReset(1)\n    exName = exchange.GetName()\n    period = exchange.GetPeriod()\n    Log(\"收集\", exName, \"交易所的K线数据，\", \"K线周期:\", period, \"秒\")\n    \n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\n    Log(\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\")\n    myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")   \n    # 创建数据库\n    ex_DB = myDBClient[exName]\n    \n    # 打印目前数据库表\n    collist = ex_DB.list_collection_names()\n    Log(\"mongodb \", exName, \" collist:\", collist)\n    \n    # 检测是否删除表\n    arrDropNames = json.loads(dropNames)\n    if isinstance(arrDropNames, list):\n        for i in range(len(arrDropNames)):\n            dropName = arrDropNames[i]\n            if isinstance(dropName, str):\n                if not dropName in collist:\n                    continue\n                tab = ex_DB[dropName]\n                Log(\"dropName:\", dropName, \"删除：\", dropName)\n                ret = tab.drop()\n                collist = ex_DB.list_collection_names()\n                if dropName in collist:\n                    Log(dropName, \"删除失败\")\n                else :\n                    Log(dropName, \"删除成功\")\n    \n    # 开启一个线程，提供自定义数据源服务\n    try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))     # 本机测试\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))         # VPS服务器上测试\n        Log(\"开启自定义数据源服务线程\", \"#FF0000\")\n    except BaseException as e:\n        Log(\"启动自定义数据源服务失败！\")\n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")\n    \n    # 创建records表\n    ex_DB_Records = ex_DB[\"%s_%d\" % (\"records\", period)]\n    Log(\"开始收集\", exName, \"K线数据\", \"周期：\", period, \"打开（创建）数据库表：\", \"%s_%d\" % (\"records\", period), \"#FF0000\")\n    preBarTime = 0\n    index = 1\n    while True:\n        r = _C(exchange.GetRecords)\n        if len(r) < 2:\n            Sleep(1000)\n            continue\n        if preBarTime == 0:\n            # 首次写入所有BAR数据\n            for i in range(len(r) - 1):\n                bar = r[i]\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\n                retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n                if retQuery.count() > 0:\n                    continue\n                \n                # 写入bar到数据库表\n                ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})                \n                index += 1\n            preBarTime = r[-1][\"Time\"]\n        elif preBarTime != r[-1][\"Time\"]:\n            bar = r[-2]\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\n            retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n            if retQuery.count() > 0:\n                continue\n            \n            ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})\n            index += 1\n            preBarTime = r[-1][\"Time\"]\n        LogStatus(_D(), \"preBarTime:\", preBarTime, \"_D(preBarTime):\", _D(preBarTime/1000), \"index:\", index)\n        # 增加画图展示\n        ext.PlotRecords(r, \"%s_%d\" % (\"records\", period))\n        Sleep(10000)",
        "strategy_description": "策略名称: RecordsCollecter-升级提供自定义数据源功能\n\nexName = exchange.GetName()                                     \n            # 注意，period为底层K线周期\n            tabName = \"%s_%s\" % (\"records\", int(int(dictParam[\"period\"]) / 1000))  \n            priceRatio = math.pow(10, int(dictParam[\"round\"]))\n            amountRatio = math.pow(10, int(dictParam[\"vround\"]))\n            fromTS = int(dictParam[\"from\"]) * int(1000)\n            toTS = int(dictParam[\"to\"]) * int(1000)\n            \n            \n            # 连接数据库\n            Log(\"连接数据库服务，获取数据，数据库：\", exName, \"表：\", tabName)\n            myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")\n            ex_DB = myDBClient[exName]\n            exRecords = ex_DB[tabName]\n            \n            \n            # 要求应答的数据\n            data = {\n                \"schema\" : [\"time\", \"open\", \"high\", \"low\", \"close\", \"vol\"],\n                \"data\" : []\n            }\n            \n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\n            dbQuery = {\"$and\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\n            Log(\"查询条件：\", dbQuery, \"查询条数：\", exRecords.find(dbQuery).count(), \"数据库总条数：\", exRecords.find().count())\n            \n            for x in exRecords.find(dbQuery).sort(\"Time\"):\n                # 需要根据请求参数round和vround，处理数据精度\n                bar = [x[\"Time\"], int(x[\"Open\"] * priceRatio), int(x[\"High\"] * priceRatio), int(x[\"Low\"] * priceRatio), int(x[\"Close\"] * priceRatio), int(x[\"Volume\"] * amountRatio)]\n                data[\"data\"].append(bar)\n            \n            Log(\"数据：\", data, \"响应回测系统请求。\")\n            # 写入数据应答\n            self.wfile.write(json.dumps(data).encode())\n        except BaseException as e:\n            Log(\"Provider do_GET error, e:\", e)\n\n\ndef createServer(host):\n    try:\n        server = HTTPServer(host, Provider)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except BaseException as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\ndef main():\n    LogReset(1)\n    exName = exchange.GetName()\n    period = exchange.GetPeriod()\n    Log(\"收集\", exName, \"交易所的K线数据，\", \"K线周期:\", period, \"秒\")\n    \n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\n    Log(\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\")\n    myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")   \n    # 创建数据库\n    ex_DB = myDBClient[exName]\n    \n    # 打印目前数据库表\n    collist = ex_DB.list_collection_names()\n    Log(\"mongodb \", exName, \" collist:\", collist)\n    \n    # 检测是否删除表\n    arrDropNames = json.loads(dropNames)\n    if isinstance(arrDropNames, list):\n        for i in range(len(arrDropNames)):\n            dropName = arrDropNames[i]\n            if isinstance(dropName, str):\n                if not dropName in collist:\n                    continue\n                tab = ex_DB[dropName]\n                Log(\"dropName:\", dropName, \"删除：\", dropName)\n                ret = tab.drop()\n                collist = ex_DB.list_collection_names()\n                if dropName in collist:\n                    Log(dropName, \"删除失败\")\n                else :\n                    Log(dropName, \"删除成功\")\n    \n    # 开启一个线程，提供自定义数据源服务\n    try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))     # 本机测试\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))         # VPS服务器上测试\n        Log(\"开启自定义数据源服务线程\", \"#FF0000\")\n    except BaseException as e:\n        Log(\"启动自定义数据源服务失败！\")\n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")\n    \n    # 创建records表\n    ex_DB_Records = ex_DB[\"%s_%d\" % (\"records\", period)]\n    Log(\"开始收集\", exName, \"K线数据\", \"周期：\", period, \"打开（创建）数据库表：\", \"%s_%d\" % (\"records\", period), \"#FF0000\")\n    preBarTime = 0\n    index = 1\n    while True:\n        r = _C(exchange.GetRecords)\n        if len(r) < 2:\n            Sleep(1000)\n            continue\n        if preBarTime == 0:\n            # 首次写入所有BAR数据\n            for i in range(len(r) - 1):\n                bar = r[i]\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\n                retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n                if retQuery.count() > 0:\n                    continue\n                \n                # 写入bar到数据库表\n                ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})                \n                index += 1\n            preBarTime = r[-1][\"Time\"]\n        elif preBarTime != r[-1][\"Time\"]:\n            bar = r[-2]\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\n            retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n            if retQuery.count() > 0:\n                continue\n            \n            ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})\n            index += 1\n            preBarTime = r[-1][\"Time\"]\n        LogStatus(_D(), \"preBarTime:\", preBarTime, \"_D(preBarTime):\", _D(preBarTime/1000), \"index:\", index)\n        # 增加画图展示\n        ext.PlotRecords(r, \"%s_%d\" % (\"records\", period))\n        Sleep(10000)\n        \n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/205143\n\n> Last Modified\n\n2020-05-09 15:58:04"
    },
    {
        "strategy_id": "37_RecordsCollecter-升级提供自定义数据源功能支持CSV数据文件提供数据源",
        "strategy_code": "python\nimport _thread\nimport pymongo\nimport json\nimport math\nimport csv\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse\n\ndef url2Dict(url):\n    query = urlparse(url).query  \n    params = parse_qs(query)  \n    result = {key: params[key][0] for key in params}  \n    return result\n\nclass Provider(BaseHTTPRequestHandler):\n    def do_GET(self):\n        global isOnlySupportCSV, filePathForCSV\n        try:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"application/json\")\n            self.end_headers()\n\n            dictParam = url2Dict(self.path)\n            Log(\"自定义数据源服务接收到请求，self.path:\", self.path, \"query 参数：\", dictParam)\n            \n            # 目前回测系统只能从列表中选择交易所名称，在添加自定义数据源时，设置为币安，即：Binance\n            exName = exchange.GetName()                                     \n            # 注意，period为底层K线周期\n            tabName = \"%s_%s\" % (\"records\", int(int(dictParam[\"period\"]) / 1000))  \n            priceRatio = math.pow(10, int(dictParam[\"round\"]))\n            amountRatio = math.pow(10, int(dictParam[\"vround\"]))\n            fromTS = int(dictParam[\"from\"]) * int(1000)\n            toTS = int(dictParam[\"to\"]) * int(1000)\n\n            # 要求应答的数据\n            data = {\n                \"schema\" : [\"time\", \"open\", \"high\", \"low\", \"close\", \"vol\"],\n                \"data\" : []\n            }\n            \n            if isOnlySupportCSV:\n                # 处理CSV读取,filePathForCSV路径\n                listDataSequence = []\n                with open(filePathForCSV, \"r\") as f:\n                    reader = csv.reader(f)\n                    # 获取表头\n                    header = next(reader)\n                    headerIsNoneCount = 0\n                    if len(header) != len(data[\"schema\"]):\n                        Log(\"CSV文件格式有误，列数不同，请检查！\", \"#FF0000\")\n                        return \n                    for ele in header:\n                        for i in range(len(data[\"schema\"])):\n                            if data[\"schema\"][i] == ele or ele == \"\":\n                                if ele == \"\":\n                                    headerIsNoneCount += 1\n                                if headerIsNoneCount > 1:\n                                    Log(\"CSV文件格式有误，请检查！\", \"#FF0000\")\n                                    return \n                                listDataSequence.append(i)\n                                break\n                    \n                    # 读取内容\n                    while True:\n                        record = next(reader, -1)\n                        if record == -1:\n                            break\n                        index = 0\n                        arr = [0, 0, 0, 0, 0, 0]\n                        for ele in record:\n                            arr[listDataSequence[index]] = int(ele) if listDataSequence[index] == 0 else (int(float(ele) * amountRatio) if listDataSequence[index] == 5 else int(float(ele) * priceRatio))\n                            index += 1\n                        data[\"data\"].append(arr)\n                \n                Log(\"数据：\", data, \"响应回测系统请求。\")\n                self.wfile.write(json.dumps(data).encode())\n                return \n            \n            # 连接数据库\n            Log(\"连接数据库服务，获取数据，数据库：\", exName, \"表：\", tabName)\n            myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")\n            ex_DB = myDBClient[exName]\n            exRecords = ex_DB[tabName]\n            \n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\n            dbQuery = {\"$and\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\n            Log(\"查询条件：\", dbQuery, \"查询条数：\", exRecords.find(dbQuery).count(), \"数据库总条数：\", exRecords.find().count())\n            \n            for x in exRecords.find(dbQuery).sort(\"Time\"):\n                # 需要根据请求参数round和vround，处理数据精度\n                bar = [x[\"Time\"], int(x[\"Open\"] * priceRatio), int(x[\"High\"] * priceRatio), int(x[\"Low\"] * priceRatio), int(x[\"Close\"] * priceRatio), int(x[\"Volume\"] * amountRatio)]\n                data[\"data\"].append(bar)\n            \n            Log(\"数据：\", data, \"响应回测系统请求。\")\n            # 写入数据应答\n            self.wfile.write(json.dumps(data).encode())\n        except BaseException as e:\n            Log(\"Provider do_GET error, e:\", e)\n\n\ndef createServer(host):\n    try:\n        server = HTTPServer(host, Provider)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except BaseException as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\ndef main():\n    LogReset(1)\n    if (isOnlySupportCSV):\n        try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))         # 本机测试\n            _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))         # VPS服务器上测试\n            Log(\"开启自定义数据源服务线程，数据由CSV文件提供。\", \"#FF0000\")\n        except BaseException as e:\n            Log(\"启动自定义数据源服务失败！\")\n            Log(\"错误信息：\", e)\n            raise Exception(\"stop\")\n        while True:\n            LogStatus(_D(), \"只启动自定义数据源服务，不收集数据！\")\n            Sleep(2000)\n    \n    exName = exchange.GetName()\n    period = exchange.GetPeriod()\n    Log(\"收集\", exName, \"交易所的K线数据，\", \"K线周期:\", period, \"秒\")\n    \n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\n    Log(\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\")\n    myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")   \n    # 创建数据库\n    ex_DB = myDBClient[exName]\n    \n    # 打印目前数据库表\n    collist = ex_DB.list_collection_names()\n    Log(\"mongodb \", exName, \" collist:\", collist)\n    \n    # 检测是否删除表\n    arrDropNames = json.loads(dropNames)\n    if isinstance(arrDropNames, list):\n        for i in range(len(arrDropNames)):\n            dropName = arrDropNames[i]\n            if isinstance(dropName, str):\n                if not dropName in collist:\n                    continue\n                tab = ex_DB[dropName]\n                Log(\"dropName:\", dropName, \"删除：\", dropName)\n                ret = tab.drop()\n                collist = ex_DB.list_collection_names()\n                if dropName in collist:\n                    Log(dropName, \"删除失败\")\n                else :\n                    Log(dropName, \"删除成功\")\n    \n    # 开启一个线程，提供自定义数据源服务\n    try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))     # 本机测试\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))         # VPS服务器上测试\n        Log(\"开启自定义数据源服务线程\", \"#FF0000\")\n    except BaseException as e:\n        Log(\"启动自定义数据源服务失败！\")\n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")\n    \n    # 创建records表\n    ex_DB_Records = ex_DB[\"%s_%d\" % (\"records\", period)]\n    Log(\"开始收集\", exName, \"K线数据\", \"周期：\", period, \"打开（创建）数据库表：\", \"%s_%d\" % (\"records\", period), \"#FF0000\")\n    preBarTime = 0\n    index = 1\n    while True:\n        r = _C(exchange.GetRecords)\n        if len(r) < 2:\n            Sleep(1000)\n            continue\n        if preBarTime == 0:\n            # 首次写入所有BAR数据\n            for i in range(len(r) - 1):\n                bar = r[i]\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\n                retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n                if retQuery.count() > 0:\n                    continue\n                \n                # 写入bar到数据库表\n                ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})                \n                index += 1\n            preBarTime = r[-1][\"Time\"]\n        elif preBarTime != r[-1][\"Time\"]:\n            bar = r[-2]\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\n            retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n            if retQuery.count() > 0:\n                continue\n            \n            ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})\n            index += 1\n            preBarTime = r[-1][\"Time\"]\n        LogStatus(_D(), \"preBarTime:\", preBarTime, \"_D(preBarTime):\", _D(preBarTime/1000), \"index:\", index)\n        # 增加画图展示\n        ext.PlotRecords(r, \"%s_%d\" % (\"records\", period))\n        Sleep(10000)",
        "strategy_description": "策略名称: RecordsCollecter-升级提供自定义数据源功能支持CSV数据文件提供数据源\n\nexName = exchange.GetName()                                     \n            # 注意，period为底层K线周期\n            tabName = \"%s_%s\" % (\"records\", int(int(dictParam[\"period\"]) / 1000))  \n            priceRatio = math.pow(10, int(dictParam[\"round\"]))\n            amountRatio = math.pow(10, int(dictParam[\"vround\"]))\n            fromTS = int(dictParam[\"from\"]) * int(1000)\n            toTS = int(dictParam[\"to\"]) * int(1000)\n\n            # 要求应答的数据\n            data = {\n                \"schema\" : [\"time\", \"open\", \"high\", \"low\", \"close\", \"vol\"],\n                \"data\" : []\n            }\n            \n            if isOnlySupportCSV:\n                # 处理CSV读取,filePathForCSV路径\n                listDataSequence = []\n                with open(filePathForCSV, \"r\") as f:\n                    reader = csv.reader(f)\n                    # 获取表头\n                    header = next(reader)\n                    headerIsNoneCount = 0\n                    if len(header) != len(data[\"schema\"]):\n                        Log(\"CSV文件格式有误，列数不同，请检查！\", \"#FF0000\")\n                        return \n                    for ele in header:\n                        for i in range(len(data[\"schema\"])):\n                            if data[\"schema\"][i] == ele or ele == \"\":\n                                if ele == \"\":\n                                    headerIsNoneCount += 1\n                                if headerIsNoneCount > 1:\n                                    Log(\"CSV文件格式有误，请检查！\", \"#FF0000\")\n                                    return \n                                listDataSequence.append(i)\n                                break\n                    \n                    # 读取内容\n                    while True:\n                        record = next(reader, -1)\n                        if record == -1:\n                            break\n                        index = 0\n                        arr = [0, 0, 0, 0, 0, 0]\n                        for ele in record:\n                            arr[listDataSequence[index]] = int(ele) if listDataSequence[index] == 0 else (int(float(ele) * amountRatio) if listDataSequence[index] == 5 else int(float(ele) * priceRatio))\n                            index += 1\n                        data[\"data\"].append(arr)\n                \n                Log(\"数据：\", data, \"响应回测系统请求。\")\n                self.wfile.write(json.dumps(data).encode())\n                return \n            \n            # 连接数据库\n            Log(\"连接数据库服务，获取数据，数据库：\", exName, \"表：\", tabName)\n            myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")\n            ex_DB = myDBClient[exName]\n            exRecords = ex_DB[tabName]\n            \n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\n            dbQuery = {\"$and\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\n            Log(\"查询条件：\", dbQuery, \"查询条数：\", exRecords.find(dbQuery).count(), \"数据库总条数：\", exRecords.find().count())\n            \n            for x in exRecords.find(dbQuery).sort(\"Time\"):\n                # 需要根据请求参数round和vround，处理数据精度\n                bar = [x[\"Time\"], int(x[\"Open\"] * priceRatio), int(x[\"High\"] * priceRatio), int(x[\"Low\"] * priceRatio), int(x[\"Close\"] * priceRatio), int(x[\"Volume\"] * amountRatio)]\n                data[\"data\"].append(bar)\n            \n            Log(\"数据：\", data, \"响应回测系统请求。\")\n            # 写入数据应答\n            self.wfile.write(json.dumps(data).encode())\n        except BaseException as e:\n            Log(\"Provider do_GET error, e:\", e)\n\n\ndef createServer(host):\n    try:\n        server = HTTPServer(host, Provider)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except BaseException as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\ndef main():\n    LogReset(1)\n    if (isOnlySupportCSV):\n        try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))         # 本机测试\n            _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))         # VPS服务器上测试\n            Log(\"开启自定义数据源服务线程，数据由CSV文件提供。\", \"#FF0000\")\n        except BaseException as e:\n            Log(\"启动自定义数据源服务失败！\")\n            Log(\"错误信息：\", e)\n            raise Exception(\"stop\")\n        while True:\n            LogStatus(_D(), \"只启动自定义数据源服务，不收集数据！\")\n            Sleep(2000)\n    \n    exName = exchange.GetName()\n    period = exchange.GetPeriod()\n    Log(\"收集\", exName, \"交易所的K线数据，\", \"K线周期:\", period, \"秒\")\n    \n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\n    Log(\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\")\n    myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")   \n    # 创建数据库\n    ex_DB = myDBClient[exName]\n    \n    # 打印目前数据库表\n    collist = ex_DB.list_collection_names()\n    Log(\"mongodb \", exName, \" collist:\", collist)\n    \n    # 检测是否删除表\n    arrDropNames = json.loads(dropNames)\n    if isinstance(arrDropNames, list):\n        for i in range(len(arrDropNames)):\n            dropName = arrDropNames[i]\n            if isinstance(dropName, str):\n                if not dropName in collist:\n                    continue\n                tab = ex_DB[dropName]\n                Log(\"dropName:\", dropName, \"删除：\", dropName)\n                ret = tab.drop()\n                collist = ex_DB.list_collection_names()\n                if dropName in collist:\n                    Log(dropName, \"删除失败\")\n                else :\n                    Log(dropName, \"删除成功\")\n    \n    # 开启一个线程，提供自定义数据源服务\n    try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))     # 本机测试\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))         # VPS服务器上测试\n        Log(\"开启自定义数据源服务线程\", \"#FF0000\")\n    except BaseException as e:\n        Log(\"启动自定义数据源服务失败！\")\n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")\n    \n    # 创建records表\n    ex_DB_Records = ex_DB[\"%s_%d\" % (\"records\", period)]\n    Log(\"开始收集\", exName, \"K线数据\", \"周期：\", period, \"打开（创建）数据库表：\", \"%s_%d\" % (\"records\", period), \"#FF0000\")\n    preBarTime = 0\n    index = 1\n    while True:\n        r = _C(exchange.GetRecords)\n        if len(r) < 2:\n            Sleep(1000)\n            continue\n        if preBarTime == 0:\n            # 首次写入所有BAR数据\n            for i in range(len(r) - 1):\n                bar = r[i]\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\n                retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n                if retQuery.count() > 0:\n                    continue\n                \n                # 写入bar到数据库表\n                ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})                \n                index += 1\n            preBarTime = r[-1][\"Time\"]\n        elif preBarTime != r[-1][\"Time\"]:\n            bar = r[-2]\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\n            retQuery = ex_DB_Records.find({\"Time\": bar[\"Time\"]})\n            if retQuery.count() > 0:\n                continue\n            \n            ex_DB_Records.insert_one({\"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})\n            index += 1\n            preBarTime = r[-1][\"Time\"]\n        LogStatus(_D(), \"preBarTime:\", preBarTime, \"_D(preBarTime):\", _D(preBarTime/1000), \"index:\", index)\n        # 增加画图展示\n        ext.PlotRecords(r, \"%s_%d\" % (\"records\", period))\n        Sleep(10000)\n        \n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/209461\n\n> Last Modified\n\n2020-05-23 17:38:55"
    },
    {
        "strategy_id": "38_RecordsCollecter-教学",
        "strategy_code": "python\nimport pymongo\nimport json\n\ndef main():\n    Log(\"测试数据收集\")\n    \n    # 连接数据库服务\n    myDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")   # mongodb://127.0.0.1:27017\n    # 创建数据库\n    huobi_DB = myDBClient[\"huobi\"]\n    \n    # 打印目前数据库表\n    collist = huobi_DB.list_collection_names()\n    Log(\"collist:\", collist)\n    \n    # 检测是否删除表\n    arrDropNames = json.loads(dropNames)\n    if isinstance(arrDropNames, list):\n        for i in range(len(arrDropNames)):\n            dropName = arrDropNames[i]\n            if isinstance(dropName, str):\n                if not dropName in collist:\n                    continue\n                tab = huobi_DB[dropName]\n                Log(\"dropName:\", dropName, \"删除：\", dropName)\n                ret = tab.drop()\n                collist = huobi_DB.list_collection_names()\n                if dropName in collist:\n                    Log(dropName, \"删除失败\")\n                else :\n                    Log(dropName, \"删除成功\")\n    \n    # 创建records表\n    huobi_DB_Records = huobi_DB[\"records\"]\n    \n    # 请求数据\n    preBarTime = 0\n    index = 1\n    while True:\n        r = _C(exchange.GetRecords)\n        if len(r) < 2:\n            Sleep(1000)\n            continue\n        if preBarTime == 0:\n            # 首次写入所有BAR数据\n            for i in range(len(r) - 1):\n                # 逐根写入\n                bar = r[i]\n                huobi_DB_Records.insert_one({\"index\": index, \"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})                \n                index += 1\n            preBarTime = r[-1][\"Time\"]\n        elif preBarTime != r[-1][\"Time\"]:\n            bar = r[-2]\n            huobi_DB_Records.insert_one({\"index\": index, \"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})\n            index += 1\n            preBarTime = r[-1][\"Time\"]\n        LogStatus(_D(), \"preBarTime:\", preBarTime, \"_D(preBarTime):\", _D(preBarTime/1000), \"index:\", index)\n        Sleep(10000)",
        "strategy_description": "策略名称: RecordsCollecter-教学\n\nmyDBClient = pymongo.MongoClient(\"mongodb://localhost:27017\")   # mongodb://127.0.0.1:27017\n    # 创建数据库\n    huobi_DB = myDBClient[\"huobi\"]\n    \n    # 打印目前数据库表\n    collist = huobi_DB.list_collection_names()\n    Log(\"collist:\", collist)\n    \n    # 检测是否删除表\n    arrDropNames = json.loads(dropNames)\n    if isinstance(arrDropNames, list):\n        for i in range(len(arrDropNames)):\n            dropName = arrDropNames[i]\n            if isinstance(dropName, str):\n                if not dropName in collist:\n                    continue\n                tab = huobi_DB[dropName]\n                Log(\"dropName:\", dropName, \"删除：\", dropName)\n                ret = tab.drop()\n                collist = huobi_DB.list_collection_names()\n                if dropName in collist:\n                    Log(dropName, \"删除失败\")\n                else :\n                    Log(dropName, \"删除成功\")\n    \n    # 创建records表\n    huobi_DB_Records = huobi_DB[\"records\"]\n    \n    # 请求数据\n    preBarTime = 0\n    index = 1\n    while True:\n        r = _C(exchange.GetRecords)\n        if len(r) < 2:\n            Sleep(1000)\n            continue\n        if preBarTime == 0:\n            # 首次写入所有BAR数据\n            for i in range(len(r) - 1):\n                # 逐根写入\n                bar = r[i]\n                huobi_DB_Records.insert_one({\"index\": index, \"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})                \n                index += 1\n            preBarTime = r[-1][\"Time\"]\n        elif preBarTime != r[-1][\"Time\"]:\n            bar = r[-2]\n            huobi_DB_Records.insert_one({\"index\": index, \"High\": bar[\"High\"], \"Low\": bar[\"Low\"], \"Open\": bar[\"Open\"], \"Close\": bar[\"Close\"], \"Time\": bar[\"Time\"], \"Volume\": bar[\"Volume\"]})\n            index += 1\n            preBarTime = r[-1][\"Time\"]\n        LogStatus(_D(), \"preBarTime:\", preBarTime, \"_D(preBarTime):\", _D(preBarTime/1000), \"index:\", index)\n        Sleep(10000)\n        \n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/199120\n\n> Last Modified\n\n2020-04-16 15:18:28"
    },
    {
        "strategy_id": "39_SpotGridStra",
        "strategy_code": "python\n# 现货网格管理\n'''\n# Example:\n\ndef main():\n    spot_g_stra = ext.SpotGridStra({'exchange': exchanges[1],    #现货交易所\n                         'ZPrecision': 2,\n                         'XPrecision': 3,\n                          'MinStock': 0.001,\n                          'GridSize': 0.03,\n                          'Symbol': 'BNB',\n                          'BalancePoint': 0.5\n                         })\n    while True:\n        spot_g_stra.run()\n        Sleep(60*10000)\n\n'''\n\n\nclass SpotGridStra():\n    \n    def __init__(self, cfg):\n        self.cfg = cfg\n        self.exchange = cfg['exchange']                     #交易所\n        self.ZPrecision = cfg['ZPrecision']                 #币的价格精度, 整数\n        self.XPrecision = cfg['XPrecision']                 #币的交易量最小分位数， 如BNB是2\n        self.Symbol = cfg['Symbol']                         #币的符号\n        self.GridSize = cfg['GridSize']                     #差额多大就调整\n        self.MinStock = cfg['MinStock']                     #币的最小交易量\n        self.BalancePoint = cfg.get('BalancePoint', 0.5)    #特定币种占仓位的平衡点\n        \n    def CancelPendingOrders(self):\n        ret = False\n        while True:\n            orders = _C(self.exchange.GetOrders)\n            if len(orders) == 0 :\n                return ret\n\n            for j in range(len(orders)):\n                self.exchange.CancelOrder(orders[j].Id)\n                ret = True\n                if j < len(orders) - 1:\n                    Sleep(1000)\n        return ret \n\n    def onTick(self):\n        self.exchange.SetCurrency(self.Symbol + '_USDT')\n        acc = _C(self.exchange.GetAccount)\n        #Log(acc)\n        ticker = _C(self.exchange.GetTicker)\n        spread = ticker.Sell - ticker.Buy\n        account_info = acc['Info']\n        bals = account_info['balances']\n        sel_asset = None \n        usdt_val = 0.0\n        for asset in bals:\n            if asset['asset'] == self.Symbol:\n                sel_asset = asset\n            if asset['asset'] == 'USDT':\n                usdt_val = float(asset['free'])\n        assert sel_asset is not None, '找不到对应资产:' + self.Symbol\n        asset_val = ((float(sel_asset['free']) + float(sel_asset['locked'])) * ticker.Sell)\n        total_val = usdt_val + asset_val\n        Log(self.Symbol, total_val, '=', acc.Balance, '+', asset_val)\n        diffAsset = (total_val*self.BalancePoint  - asset_val)\n        ratio = diffAsset / total_val\n        #Log(\"ratio:\", ratio, _D())\n        if abs(ratio) < self.GridSize:\n            return False\n        if ratio > 0 :\n            buyPrice = _N(ticker.Sell + spread, self.ZPrecision)\n            buyAmount = _N(diffAsset / buyPrice, self.XPrecision)\n            if buyAmount < self.MinStock:\n                return False\n            self.exchange.Buy(buyPrice, buyAmount, diffAsset, ratio)\n        else :\n            sellPrice = _N(ticker.Buy - spread, self.ZPrecision)\n            sellAmount = _N(-diffAsset / sellPrice, self.XPrecision)\n            if sellAmount < self.MinStock:\n                return False \n            self.exchange.Sell(sellPrice, sellAmount, diffAsset, ratio)\n        return True\n    \n    def run(self):\n        if self.onTick():\n            Sleep(1000)\n            self.CancelPendingOrders()\n\next.SpotGridStra = SpotGridStra",
        "strategy_description": "策略名称: SpotGridStra\n\n'''"
    },
    {
        "strategy_id": "40_SuperTrend-V1",
        "strategy_code": "python\n'''backtest\nstart: 2020-01-01 00:00:00\nend: 2020-04-01 00:00:00\nperiod: 15m\nexchanges: [{\"eid\":\"Futures_OKCoin\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport pandas as pd\nimport time\n\ndef main():\n    exchange.SetContractType(\"quarter\")\n    preTime = 0\n    Log(exchange.GetAccount())\n    while True:\n        records = exchange.GetRecords(PERIOD_M15)\n        if records and records[-2].Time > preTime:\n            preTime = records[-2].Time\n            doTicker(records[:-1])\n        Sleep(1000 *60)\n    '''\n    while True:  \n        a=time.localtime(Unix())\n        if(14<a.tm_min<16):\n            Log(a)\n        if(a.tm_min==0 or a.tm_min==15 or a.tm_min==30 or a.tm_min==45):\n            doTicker()\n        Sleep(1000 *60)\n    '''\n\n        \ndef doTicker(records):\n    #Log('onTick',exchange.GetTicker())\n    M15 = pd.DataFrame(records)\n\n    #Factor=3\n    #Pd=7\n    \n    M15.columns = ['time','open','high','low','close','volume','OpenInterest']  \n    \n    #HL2\n    M15['hl2']=(M15['high']+M15['low'])/2\n\n    #ATR(PD)\n    length=Pd\n    M15['prev_close']=M15['close'].shift(1)\n    ranges= [M15['high'] - M15['low'],M15['high']-M15['prev_close'],M15['low']-M15['prev_close']]\n    M15['tr'] = pd.DataFrame(ranges).T.abs().max(axis=1)\n    alpha = (1.0 / length) if length > 0 else 0.5\n    M15['atr']=M15['tr'].ewm(alpha=alpha, min_periods=length).mean()\n\n\n    M15['Up']=M15['hl2']-(Factor*M15['atr'])\n    M15['Dn']=M15['hl2']+(Factor*M15['atr'])\n    \n    M15['TrendUp']=0.0\n    M15['TrendDown']=0.0\n    M15['Trend']=1\n    M15['Tsl']=0.0\n    M15['linecolor']='Homily'\n    M15 = M15.fillna(0)\n\n    for x in range(len(M15)):\n        M15['TrendUp'].values[x] = max(M15['Up'].values[x],M15['TrendUp'].values[x-1]) if (M15['close'].values[x-1]>M15['TrendUp'].values[x-1]) else M15['Up'].values[x]\n        M15['TrendDown'].values[x] = min(M15['Dn'].values[x],M15['TrendDown'].values[x-1]) if (M15['close'].values[x-1]<M15['TrendDown'].values[x-1]) else M15['Dn'].values[x]\n        M15['Trend'].values[x] = 1 if (M15['close'].values[x] > M15['TrendDown'].values[x-1]) else ( -1 if (M15['close'].values[x]< M15['TrendUp'].values[x-1])else M15['Trend'].values[x-1] )\n        M15['Tsl'].values[x] = M15['TrendUp'].values[x] if  (M15['Trend'].values[x]==1) else M15['TrendDown'].values[x]\n        M15['linecolor'].values[x]= 'Long' if ( M15['Trend'].values[x]==1) else  'Short'\n \n\n    linecolor=M15['linecolor'].values[-2]\n    close=M15['close'].values[-2]\n    Tsl=M15['Tsl'].values[-2] \n\n    \n    if(M15['Trend'].values[-1] == 1 and M15['Trend'].values[-2] == -1):\n\n        Log('SuperTrend V.1 Alert Long','Create Order Buy')\n        Log('Tsl=',Tsl)\n        position = exchange.GetPosition()\n        if len(position) > 0:\n            Amount=position[0][\"Amount\"]\n            exchange.SetDirection(\"closesell\")\n            exchange.Buy(_C(exchange.GetTicker).Sell*1.01, Amount);\n        \n        exchange.SetDirection(\"buy\")\n        exchange.Buy(_C(exchange.GetTicker).Sell*1.01, vol);\n\n    if(M15['Trend'].values[-1] == -1 and M15['Trend'].values[-2] == 1):\n        Log('SuperTrend V.1 Alert Long','Create Order Sell')\n        Log('Tsl=',Tsl)\n        position = exchange.GetPosition()\n        if len(position) > 0:\n            Amount=position[0][\"Amount\"]\n            exchange.SetDirection(\"closebuy\")\n            exchange.Sell(_C(exchange.GetTicker).Buy*0.99,Amount);\n        exchange.SetDirection(\"sell\")\n        exchange.Sell(_C(exchange.GetTicker).Buy*0.99, vol*2);",
        "strategy_description": "策略名称: SuperTrend-V1\n\n未找到描述"
    },
    {
        "strategy_id": "41_TD狄马克序列",
        "strategy_code": "python\n'''backtest\nstart: 2021-01-01 00:00:00\nend: 2021-03-12 00:00:00\nperiod: 15m\nexchanges: [{\"eid\":\"Futures_OKCoin\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport time\nimport pandas as pd\nimport numpy as np\n\ndef main():\n    exchange.SetContractType(\"quarter\")\n    while True:\n        #start_time = time.time()\n        records = exchange.GetRecords(PERIOD_H1)\n        if len(records) < 100:\n            Sleep(1000)\n            return\n        kline = pd.DataFrame(records)\n        kline.columns = ['time','open','high','low','close','volume','OpenInterest']\n        i = 0\n        j = 0\n        for x in range(len(kline)-40,len(kline)):\n            if kline['close'].values[x] > kline['close'].values[x-4]:\n                i += 1\n            else:\n                i = 0\n            if kline['close'].values[x] < kline['close'].values[x-4]:\n                j -= 1\n            else:\n                j = 0\n        TDindex = i if i>0 else j\n        #if 13 > TDindex >= 8 :\n            #Log('温馨警告，进入超买区域，可考虑卖出止盈：')\n        #elif 21 > TDindex >= 13 :\n            #Log('一般警告，进入超级超买区域，可考虑卖出止盈：')\n        #elif TDindex >= 21 :\n            #Log('严重警告，进入超级超级超买区域，可考虑清仓止盈：')\n        #elif -13 < TDindex <= -8 :\n            #Log('温馨警告，进入超卖区域，可考虑买入博个反弹：')\n        #elif -21 < TDindex <= -13 :\n            #Log('一般警告，进入超级超卖区域，可考虑加仓买入：')\n        #elif TDindex <= -21 :\n            #Log('严重警告，进入超级超级超卖区域，可考虑全仓杀入：')\n        position = exchange.GetPosition()\n        #if len(position) > 0:\n            #Log(position[0][\"Type\"])\n        if TDindex == 9 or TDindex == 13 or TDindex == 22:  #and len(position) == 0 :\n            Log('上根K线的TD序列为：',TDindex)\n            exchange.SetDirection(\"sell\")\n            id2 = exchange.Sell(-1, 1)\n        \n        if TDindex == -9 or TDindex == -13 or TDindex == -22:  #and len(position) == 0 :\n            Log('上根K线的TD序列为：',TDindex)\n            exchange.SetDirection(\"buy\")\n            id2 = exchange.Buy(-1, 1)\n        if len(position) > 0:\n            if position[0][\"Type\"] ==0 and TDindex >= 2 :\n                #Log(position[0][\"Type\"])\n                Log('上根K线的TD序列为：',TDindex)\n                exchange.SetDirection(\"closebuy\")\n                id2 = exchange.Sell(-1, 1)\n            \n            if position[0][\"Type\"] ==1 and TDindex <= -2 :\n                #Log(position[0][\"Type\"])\n                Log('上根K线的TD序列为：',TDindex)\n                exchange.SetDirection(\"closesell\")\n                id2 = exchange.Buy(-1, 1)\n        # end_time = time.time()\n        #spend_time = end_time - start_time\n        Sleep(1000*900)",
        "strategy_description": "策略名称: TD狄马克序列\n\n#spend_time = end_time - start_time\n        Sleep(1000*900)\n                \n                \n                \n    \n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/262467\n\n> Last Modified\n\n2021-03-16 11:18:47"
    },
    {
        "strategy_id": "42_Telegram-发信接口-V200-Python",
        "strategy_code": "# key 为 Bot key\n## 获取 Bot key 可以参考 https://www.ccino.org/create-a-telegram-bot.html\n# chat_id 为收信用户Telegram ID\n## Telegram ID 可以通过 @dwx_aibot 机器人获取， 连接至此机器人后发送 /getid 即可获得 ChatID\nTelegram = ext.Telegram(key=string, chat_id=integer)    # 创建一个新的接口对象\n\n# ==========================================\n\npython\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n# \n# Telegram Interface for FMZ.com\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\ntry:\n    import requests\nexcept:\n    print('Requests not installed. Try: pip install requests')\n    Log('Requests not installed. Try: pip install requests')\n    \n    raise Exception('Requests not installed. Try: pip install requests')\n\nclass Telegram:\n    def __init__(self):\n        self.key = KEY\n        self.chat_id = CHATID\n        self.url = 'https://api.telegram.org/bot%s' % self.key\n        \n    def Send(self, message='', chat_id=None):\n        if chat_id is None:\n            chat_id = self.chat_id\n        PARAM = {}\n        PARAM['chat_id'] = chat_id\n        PARAM['text'] = message\n        PARAM['parse_mode'] = 'markdown'\n        URL = self.url + '/sendMessage'\n        try:\n            res = requests.post(URL, data = PARAM)\n            return True\n        except IOError as e:\n            print(e)\n            return False\n        \n\next.Telegram = Telegram\n\n# 模块功能测试\ndef main():\n    if DEBUG == 1:\n        msger = ext.Telegram(KEY, CHATID)\n        msger.Send(\"Hello World!\")\n    \n    return True",
        "strategy_description": "策略名称: Telegram-发信接口-V200-Python\n\n##### 这个库目前只能Telegram发信 后续会增加更多功能。"
    },
    {
        "strategy_id": "43_TradingViewWebHook直连策略",
        "strategy_code": "python\n'''\n请求格式：http://x.x.x.x:xxxx/data?access_key=xxx&secret_key=yyy&type=buy&amount=0.001\n策略机器人参数：\n- 类型：加密字符串，AccessKey , SecretKey ，可以用FMZ平台的低权限的API KEY，或者自己生成KEY也可以。\n- 类型：字符串，合约ID，ContractType\n- 类型：数值，端口号，Port\n'''\n\nimport re\nimport _thread\nimport json\nfrom http.server import ThreadingHTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse\n\ndef url2Dict(url):\n    query = urlparse(url).query  \n    params = parse_qs(query)  \n    result = {key: params[key][0] for key in params}  \n    return result\n\nclass Executor(BaseHTTPRequestHandler):\n    def do_GET(self):\n        try:\n            dictParam = url2Dict(self.path)\n            Log(\"测试\", dictParam)\n        except Exception as e:\n            Log(\"Provider do_GET error, e:\", e)\n    def do_POST(self):\n        try:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"application/json\")\n            self.end_headers()\n            dictParam = url2Dict(self.path)\n            \n            # 测试POST请求Body信息            \n            data = self.rfile.read(200)   # 指定了读取长度\n            Log(\"data:\", data)            # 打印POST请求的数据，可以根据请求中的数据具体再让机器人执行对应的操作\n            \n            # 校验\n            if len(dictParam) == 4 and dictParam[\"access_key\"] == AccessKey and dictParam[\"secret_key\"] == SecretKey:\n                del dictParam[\"access_key\"]\n                del dictParam[\"secret_key\"]\n                Log(\"接收到请求\", \"参数：\", dictParam, \"#FF0000\")\n                '''\n                map[access_key:xxx amount:0.001 secret_key:yyy type:buy]\n                '''\n                isSpot = True\n                if exchange.GetName().find(\"Futures\") != -1:\n                    if ContractType != \"\":\n                        exchange.SetContractType(ContractType)\n                        isSpot = False \n                    else :\n                        raise \"未设置期货合约\"\n                                \n                q = None\n                if exchange.GetName() == \"Futures_CTP\" and UseMarketOrderForCTP == False:\n                    q = ext.NewTaskQueue()\n                \n                if isSpot and dictParam[\"type\"] == \"buy\":\n                    exchange.Buy(-1, float(dictParam[\"amount\"]))\n                    Log(exchange.GetAccount())\n                elif isSpot and dictParam[\"type\"] == \"sell\":\n                    exchange.Sell(-1, float(dictParam[\"amount\"]))\n                    Log(exchange.GetAccount())\n                elif not isSpot and dictParam[\"type\"] == \"long\":\n                    exchange.SetDirection(\"buy\")\n                    if not q:\n                        exchange.Buy(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"buy\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                elif not isSpot and dictParam[\"type\"] == \"short\":\n                    exchange.SetDirection(\"sell\")\n                    if not q:\n                        exchange.Sell(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"sell\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                elif not isSpot and dictParam[\"type\"] == \"cover_long\":\n                    exchange.SetDirection(\"closebuy\")\n                    if not q:\n                        exchange.Sell(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"closebuy\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                elif not isSpot and dictParam[\"type\"] == \"cover_short\":\n                    exchange.SetDirection(\"closesell\")\n                    if not q:\n                        exchange.Buy(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"closesell\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                \n                if q is not None:\n                    while q.size() > 0:\n                        q.poll()\n                        Sleep(500)\n            \n            # 处理body数据\n            if isDealBodyMsg:\n                if exchange.GetName().find(\"Futures\") != -1:\n                    Log(\"data:\", data.decode('utf-8'))  # 测试\n                    if re.search(r'buy', data.decode('utf-8')):\n                        Log(\"触发buy\")\n                        exchange.SetContractType(ct)\n                        exchange.SetDirection(\"buy\")\n                        exchange.Buy(-1, amount)\n                    elif re.search(r'sell', data.decode('utf-8')):\n                        Log(\"触发sell\")\n                        exchange.SetContractType(ct)\n                        exchange.SetDirection(\"sell\")\n                        exchange.Sell(-1, amount)\n            \n            # 写入数据应答\n            self.wfile.write(json.dumps({\"state\": \"ok\"}).encode())\n        except Exception as e:\n            Log(\"Provider do_POST error, e:\", e)\n\n\ndef createServer(host):\n    try:\n        server = ThreadingHTTPServer(host, Executor)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except Exception as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\ndef main():\n    # 开启一个线程\n    try:\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", Port), ))         # VPS服务器上测试           \n    except Exception as e:        \n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")    \n    if exchange.GetName().find(\"Futures\") != -1:\n        exchange.SetContractType(ContractType)\n    Log(\"账户资产信息：\", _C(exchange.GetAccount))\n    while True:\n        if exchange.GetName() == \"Futures_CTP\":\n            if exchange.IO(\"status\"):\n                LogStatus(_D(), \"CTP连接\")\n            else:\n                LogStatus(_D(), \"CTP未连接\")\n        else:\n            LogStatus(_D())\n        Sleep(2000)",
        "strategy_description": "策略名称: TradingViewWebHook直连策略\n\ndata = self.rfile.read(200)   # 指定了读取长度\n            Log(\"data:\", data)            # 打印POST请求的数据，可以根据请求中的数据具体再让机器人执行对应的操作\n            \n            # 校验\n            if len(dictParam) == 4 and dictParam[\"access_key\"] == AccessKey and dictParam[\"secret_key\"] == SecretKey:\n                del dictParam[\"access_key\"]\n                del dictParam[\"secret_key\"]\n                Log(\"接收到请求\", \"参数：\", dictParam, \"#FF0000\")\n                '''\n                map[access_key:xxx amount:0.001 secret_key:yyy type:buy]\n                '''\n                isSpot = True\n                if exchange.GetName().find(\"Futures\") != -1:\n                    if ContractType != \"\":\n                        exchange.SetContractType(ContractType)\n                        isSpot = False \n                    else :\n                        raise \"未设置期货合约\"\n                                \n                q = None\n                if exchange.GetName() == \"Futures_CTP\" and UseMarketOrderForCTP == False:\n                    q = ext.NewTaskQueue()\n                \n                if isSpot and dictParam[\"type\"] == \"buy\":\n                    exchange.Buy(-1, float(dictParam[\"amount\"]))\n                    Log(exchange.GetAccount())\n                elif isSpot and dictParam[\"type\"] == \"sell\":\n                    exchange.Sell(-1, float(dictParam[\"amount\"]))\n                    Log(exchange.GetAccount())\n                elif not isSpot and dictParam[\"type\"] == \"long\":\n                    exchange.SetDirection(\"buy\")\n                    if not q:\n                        exchange.Buy(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"buy\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                elif not isSpot and dictParam[\"type\"] == \"short\":\n                    exchange.SetDirection(\"sell\")\n                    if not q:\n                        exchange.Sell(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"sell\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                elif not isSpot and dictParam[\"type\"] == \"cover_long\":\n                    exchange.SetDirection(\"closebuy\")\n                    if not q:\n                        exchange.Sell(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"closebuy\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                elif not isSpot and dictParam[\"type\"] == \"cover_short\":\n                    exchange.SetDirection(\"closesell\")\n                    if not q:\n                        exchange.Buy(-1, float(dictParam[\"amount\"]))\n                    else :\n                        q.pushTask(exchange, ContractType, \"closesell\", float(dictParam[\"amount\"]), lambda task, ret: Log(task[\"desc\"], ret, \"#FF0000\"))\n                    Log(\"持仓：\", exchange.GetPosition())\n                \n                if q is not None:\n                    while q.size() > 0:\n                        q.poll()\n                        Sleep(500)\n            \n            # 处理body数据\n            if isDealBodyMsg:\n                if exchange.GetName().find(\"Futures\") != -1:\n                    Log(\"data:\", data.decode('utf-8'))  # 测试\n                    if re.search(r'buy', data.decode('utf-8')):\n                        Log(\"触发buy\")\n                        exchange.SetContractType(ct)\n                        exchange.SetDirection(\"buy\")\n                        exchange.Buy(-1, amount)\n                    elif re.search(r'sell', data.decode('utf-8')):\n                        Log(\"触发sell\")\n                        exchange.SetContractType(ct)\n                        exchange.SetDirection(\"sell\")\n                        exchange.Sell(-1, amount)\n            \n            # 写入数据应答\n            self.wfile.write(json.dumps({\"state\": \"ok\"}).encode())\n        except Exception as e:\n            Log(\"Provider do_POST error, e:\", e)\n\n\ndef createServer(host):\n    try:\n        server = ThreadingHTTPServer(host, Executor)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except Exception as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\ndef main():\n    # 开启一个线程\n    try:\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", Port), ))         # VPS服务器上测试           \n    except Exception as e:        \n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")    \n    if exchange.GetName().find(\"Futures\") != -1:\n        exchange.SetContractType(ContractType)\n    Log(\"账户资产信息：\", _C(exchange.GetAccount))\n    while True:\n        if exchange.GetName() == \"Futures_CTP\":\n            if exchange.IO(\"status\"):\n                LogStatus(_D(), \"CTP连接\")\n            else:\n                LogStatus(_D(), \"CTP未连接\")\n        else:\n            LogStatus(_D())\n        Sleep(2000)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/221850\n\n> Last Modified\n\n2021-03-31 11:33:30"
    },
    {
        "strategy_id": "44_VNC-SVM-Test",
        "strategy_code": "python\nimport numpy as np\nimport pandas as pd\n\ndata = DataAPI.MktIdxdGet(indexID=u\"\",ticker=u\"000300\",tradeDate=u\"\",beginDate=u\"20100101\",endDate=u\"20180501\",exchangeCD=u\"XSHE,XSHG\",field=u\"\",pandas=\"1\")\ndata.set_index('tradeDate', inplace = True)\n# 获取HS300的每日价格数据\n\nfor i in range(1, 21, 1):\n    data['close-' + str(i) + 'd'] = data['closeIndex'].shift(i)\n# 对于收盘价，在data中增加了20列数据，分别为1天前的收盘价至20天前的收盘价\n    \nhs_close = data[[x for x in data.columns if 'close' in x]].iloc[20:]\n# 选取今天及1-20天前的收盘价，iloc[20:]剔除了无效数据\n\nhs_close = hs_close.iloc[:, ::-1]\n# 将新DataFrame的列按倒序排列\n################################################################################################\nfrom sklearn import svm\n# 从sklearn库中导入svm算法\n\ndays = 1500\n# 设定全局变量，分割训练集和测试集的数据，1500在上文数据中约占75%\n\nclf_close = svm.SVR(kernel='linear')\n# 使用svm下的SVR算法，'linear'表示线性核\nf_close_train = hs_close[:days]\n# 训练集features\nl_close_train = hs_close['closeIndex'].shift(-1)[:days]\n# 训练集labels，将收盘价shift(-1)表示预测的是下一天的收盘价\nf_close_test = hs_close[days:]\n# 测试集features\nl_close_test = hs_close['closeIndex'].shift(-1)[days:]\n# 训练集labels，将收盘价shift(-1)表示预测的是下一天的收盘价\nclf_close.fit(f_close_train, l_close_train)\n# 训练模型\n\n######################################################################################\n\np_close_train = clf_close.predict(f_close_train)\n# 将训练集features导入模型进行预测，生成预测的收盘价\ndf_close_train = pd.DataFrame(l_close_train)\n# 新建一个DataFrame，内容为训练集labels,即下一天的收盘价\ndf_close_train.columns = ['next close']\n# 列名重命名为'next close'\ndf_close_train['predicted next close'] = p_close_train\n# 加入一列预测的收盘价数据\ndf_close_train['next open'] = data['openIndex'][20:20 + days].shift(-1)\n# 加入一列下一天开盘价的数据，从data而非hs_close中获取，需要切片\n\ntrigger = 1.0\ndf_close_train['position'] = np.where(df_close_train['predicted next close'] > df_close_train['next open'] * trigger, 1, 0)\n# 通过np.where函数判断，当预测的下一天收盘价 > 下一天开盘价相乘或相加一个trigger时，仓位设置为1，否则为0\ndf_close_train['PL'] = np.where(df_close_train['position'] == 1, (df_close_train['next close'] - df_close_train['next open']) / df_close_train['next open'], 0)\n# 当仓位为1时，在下一天开盘时买入，收盘时卖出，记录下一天应获得的收益率，否则收益率为0\n\ndf_close_train['strategy'] = (df_close_train['PL'].shift(1) + 1).cumprod()\n# 策略每日收益的累积收益率，其中shift(1)表示当日记录的是下一天才能获得的收益率，当日无法获得\ndf_close_train['return'] = (df_close_train['next close'].pct_change() + 1).cumprod()\n# benchmark的累积收益率\n\ndf_close_train[['strategy', 'return']].dropna().plot()\n# 画出策略与benchmark的累计收益率图\n\n##########################################################################\ndef main():\n    Log(exchange.GetAccount())",
        "strategy_description": "策略名称: VNC-SVM-Test\n\nfor i in range(1, 21, 1):\n    data['close-' + str(i) + 'd'] = data['closeIndex'].shift(i)"
    },
    {
        "strategy_id": "45_WR-突破马丁",
        "strategy_code": "python\n'''backtest\nstart: 2021-03-19 05:00:00\nend: 2021-03-21 00:00:00\nperiod: 15m\nbasePeriod: 15m\nexchanges: [{\"eid\":\"Futures_HuobiDM\",\"currency\":\"BTC_USD\"},{\"eid\":\"Futures_HuobiDM\",\"currency\":\"ETH_USD\",\"stocks\":300},{\"eid\":\"Futures_HuobiDM\",\"currency\":\"EOS_USD\",\"stocks\":5000}]\nargs: [[\"openConMode\",null]]\n'''\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport json\nimport time\nimport talib\nimport math\nimport urllib.request\n\nChartCfg = {\n    '__isStock': True,\n    'title': {\n        'text': 'WR'\n    },\n    'yAxis': [{\n        'title': {'text': 'WR'},\n        'style': {'color': '#4572A7'},\n        'opposite': False #右边轴\n    }],\n    'series': [{\n        'type': 'line',\n        'id': 'wr',\n        'name': 'wr',\n        'data': []\n    }]\n}\n\ndef MyLog(str1,ktime,price=''):\n    if (_G('str')!=str1 or _G('ktime')!=ktime) and  not (_G('str2')==str1 and ktime==_G('ktime2')) :\n        _G('str2',_G('str'))\n        _G('ktime2',_G('ktime'))\n\n        _G('str',str1)\n        _G('ktime',ktime)\n        Log(str1+str(price)) \n\n\ndef moveStocks(_moveStocks):\n    global todayProfit\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance  只有币本位有交割且共用资金 2-U本位向现货   4-币本位向现货  返回tranId\n        if exchanges[0].GetCurrency().find('USDT')>=0:\n            movecurrency = 'USDT'\n            mtype = 2\n        else:#币本位\n            movecurrency = 'BTC'\n            mtype = 4\n        timestamp = Unix()*1000       \n        params = \"type=\"+str(mtype)+\"&asset=\"+movecurrency+\"&amount=\"+str(_moveStocks)+\"&timestamp=\"+str(timestamp)\n        exchanges[0].SetBase('https://api.binance.com')\n        moveid = exchange.IO(\"api\", \"POST\", \"/sapi/v1/futures/transfer\", params)   \n        exchanges[0].SetBase('https://fapi.binance.com')\n        if moveid is not None:\n            Log('资金转出成功',moveid)\n            _G('moveStocks',_G('moveStocks')+_moveStocks)\n            todayProfit[\"initStocks\"] = todayProfit[\"initStocks\"] - _moveStocks\n            _G('todayProfit',todayProfit)\n            \n        else:\n            Log('资金转出失败')\n    else:\n        Log('暂不支持该交易所转移')\n    \ndef cancelOD(i):\n    orders = _C(exchanges[i].GetOrders)\n    for order in orders:\n        exchanges[i].CancelOrder(order.Id)\n        Sleep(100)\n\ndef coverAll(i):\n    position = _C(exchanges[i].GetPosition)\n    cancelOD(i)\n    Sleep(200)\n    for j in range(len(position)):\n        pamount = position[j][\"Amount\"] #-position[0][\"FrozenAmount\"]\n        if position[j][\"Type\"]==0:     #持多单\n            Deal(-1 , pamount, \"closebuy\", exchanges[i].GetCurrency()+'手动市价清仓',i)\n        elif position[j][\"Type\"]==1:     #持空单\n            Deal(-1 , pamount, \"closesell\", exchanges[i].GetCurrency()+'手动市价清仓',i)\n        \ndef  getOpenPrice(position):\n    if hasattr(position[0],'Info') and hasattr(position[0].Info,'cost_open'):#huobi\n        return position[0].Info.cost_open\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'avg_cost'):#ok\n        return position[0].Info.avg_cost\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'entryPrice'):#binance\n        return position[0].Info.entryPrice\n    else:\n        return position[0][\"Price\"] \n\n    \ndef UpdateAccout():\n    accout = _C(exchanges[0].GetAccount)\n    acc1 = accout.FrozenBalance    #其它币的冻结余额  是否共用?\n    acc2 = accout.Balance\n    \n    _G(\"ableAccount\", acc2)#当前可用U\n    _G(\"allAccount\",acc1+acc2+GetMargin()) #没计算浮盈\n    if acc2<1:\n        Log(\"账户保证金余额不足\")\n        Sleep(8000)\n\ndef GetMargin():\n    allMargin = 0\n    for i in range(len(exchanges)):\n        allMargin += _G(\"margin\")[i]\n    return _N(allMargin,2)\n\n\ndef GetHighest(records,i,period):\n    high = 0\n    for i in range(i-period+1,i+1):\n        if records[i].High > high:\n            high = records[i].High\n    return high\n\ndef GetLowest(records,i,period):\n    low = 1000000\n    for i in range(i-period+1,i+1):\n        if records[i].Low < low:\n            low = records[i].Low\n    return low\n    \n        \ndef SetType(type):\n    if type==0:\n        _G(\"contractType\",\"swap\")\n    elif type==1:\n        _G(\"contractType\",\"this_week\")\n    elif type==2:\n        _G(\"contractType\",\"next_week\")\n    elif type==3:\n        _G(\"contractType\",\"quarter\")\n    elif type==4:\n        _G(\"contractType\",\"next_quarter\")\n        \ndef Deal(price, num, btype, beizhu='',i=0 ):\n    Sleep(50)\n    #if beizhu!='':\n    #    Log(beizhu)\n    exchanges[i].SetDirection(btype)\n    if btype==\"closebuy\" or btype==\"sell\" :\n        exchanges[i].Sell(price , num, beizhu)\n        #Log('开空',price)\n    else:\n        exchanges[i].Buy(price , num, beizhu)\n        #Log('开多',price)\n\n\ndef myProfit():\n    LogProfit( _G(\"allAccount\")-_G(\"initStocks\") )\n\n\ndef initData():\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|No need to change|reused\")\n    global allCoinData\n    Log(\"正在初始化...\")\n\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance\n        getBinanceAllCoinData()\n        Sleep(3000)\n        Log(\"获取交易所信息结束\")\n    else:\n        Log('暂不支持该交易所')\n        return\n    \n    if _G(\"moveStocks\") is None:\n        _G(\"moveStocks\",0)\n    if _G(\"moveInStocks\") is None:\n        _G(\"moveInStocks\",0)\n        \n    for i in range(len(exchanges)):#初始化 交易所\n        symbol = exchanges[i].GetCurrency().split('_')[0]\n        exchanges[i].SetContractType(\"swap\")\n        exchanges[i].SetPrecision(allCoinData[symbol]['tick_size'], allCoinData[symbol]['size_increment'])\n        exchanges[i].SetMarginLevel(marginLevel)\n        timestamp = Unix()*1000      \n        exchanges[i].IO(\"api\", \"POST\", \"/fapi/v1/positionSide/dual\", \"dualSidePosition=true&timestamp=\"+str(timestamp))\n        \n    \n        \ndef main():\n    global allCoinData, orderID\n    if _G(\"contractType\") is None:\n        _G(\"contractType\",\"swap\")\n    global ChartCfg\n    preTime = 0\n    chart = Chart(ChartCfg)\n    chart.reset()\n    \n    margin = [0 for i in range(len(exchanges)) ] \n    _G(\"margin\",margin)\n    preTime = 0\n    bucTimes = [0 for i in range(len(exchanges)) ] \n    initData()\n    #LogProfitReset(1)\n    #暂未考虑仓位不足\n    while(true):\n        #Log('测试循环')\n        cmd = GetCommand()\n        if cmd:\n            if cmd == \"清仓停机\":\n                for i in range(len(exchanges)):\n                    Sleep(100)\n                    coverAll(i)\n                Sleep(1000)\n                return\n            if cmd.find('cover-')>=0:\n                arr = cmd.split(\"-\")\n                coverAll(int(arr[1]))\n                Sleep(2000)\n            elif cmd == 'cancelOD':\n                cancelOD()\n                Sleep(1000)\n        \n        tab1 = {\n            \"type\": \"table\", \n            \"title\": \"账户信息\", \n            \"cols\": [\"初始资金\", \"当前资金\" , \"可用资金\", \"已移出资金\", \"总盈利率\"], \n            \"rows\": []\n        }\n        tab2 = {\n            \"type\": \"table\", \n            \"title\": \"持仓状态\", \n            \"cols\": [\"币种\", \"最新价\",\"持仓数\", \"持仓均价\",  \"浮动盈亏\",\"操作\"], \n            \"rows\": []\n        }\n        \n        \n        UpdateAccout() \n        if _G(\"initStocks\") is None or _G(\"initStocks\")<10 :\n            _G(\"initStocks\", _G(\"allAccount\"))\n        if autoMoveStocks>100 and _G('ableAccount')>autoMoveStocks :\n                Log('自动移出资金：100U#32CD32')\n                moveStocks(100)\n                continue\n\n        for i in range(len(exchanges)):\n            Sleep(100)\n            records = _C(exchanges[i].GetRecords,60 * period)\n            #wr_high = TA.Highest(records, WRperiod, 'High')\n            #wr_low = TA.Lowest(records, WRperiod, 'Low')\n            #wr = (records[-1].Close-wr_high)/(wr_high-wr_low)*100\n            position = _C(exchanges[i].GetPosition)\n            margin = _G(\"margin\")\n            if len(position)>0:\n                oprice = float(getOpenPrice(position))\n                margin[i] = position[0][\"Margin\"]\n                floatProfit =  float(position[0][\"Profit\"])\n                pamount = float(position[0]['Amount'])\n                #止损\n                if -1*floatProfit > oprice*pamount/marginLevel*zhis/100:\n                    if position[0]['Type']==0:\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止损'+format(records[-1].Close,'.4f'),i)\n                    else:\n                        Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止损'+format(records[-1].Close,'.4f'),i)\n                    Sleep(500)\n                    myProfit()\n                    bucTimes[i] += 1\n                    if bucTimes[i]>maxBuc:\n                        bucTimes[i] = maxBuc\n                #止盈\n                if floatProfit > oprice*pamount/marginLevel*zhiy/100:\n                    if position[0]['Type']==0:\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止盈'+format(records[-1].Close,'.4f'),i)\n                    else:\n                        Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止盈'+format(records[-1].Close,'.4f'),i)\n                    Sleep(500)\n                    myProfit()\n                    bucTimes[i] = 0\n            else:\n                oprice = 0\n                margin[i] = 0\n                floatProfit = ''\n\n            _G(\"margin\", margin)\n            \n            \n            for k in range(50, len(records)):\n\n                wr_high1 = GetHighest(records,k, WRperiod)\n                wr_low1 = GetLowest(records,k, WRperiod)\n                wr1 = (records[k].Close-wr_high1)/(wr_high1-wr_low1)*100\n                if k==len(records)-1:\n                    if wr1>-5:#开空\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==0):#平多\n                            if len(position)>0:\n                                Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单清仓'+format(records[-1].Close,'.4f'),i)\n                                Sleep(500)\n                                myProfit()\n                                if floatProfit<0:\n                                    bucTimes[i] += 1\n                                    if bucTimes[i]>maxBuc:\n                                        bucTimes[i] = maxBuc\n                                else:\n                                    bucTimes[i] = 0\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\n                            if famount==0:\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\n                                continue\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\n                            Deal(-1, pamount, 'sell',exchanges[i].GetCurrency()+' 空单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)\n                    elif wr1<-95:#开多\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==1):#平空\n                            if len(position)>0:\n                                Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单清仓'+format(records[-1].Close,'.4f'),i)\n                                Sleep(500)\n                                myProfit()\n                                if floatProfit<0:\n                                    bucTimes[i] += 1\n                                    if bucTimes[i]>maxBuc:\n                                        bucTimes[i] = maxBuc\n                                else:\n                                    bucTimes[i] = 0\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\n                            if famount==0:\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\n                                continue\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\n                            Deal(-1, pamount, 'buy',exchanges[i].GetCurrency()+' 多单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)        \n                    #Log(wr1)\n                \n                #画图\n                if i==0 and records[k]['Time'] == preTime:\n                    chart.add(0, [records[k]['Time'], wr1], -1)\n                elif i==0 and records[k]['Time'] > preTime:\n                    #Log('insert',records[k]['Time'],wr_high1,wr_low1,records[k].Close,wr1)\n                    chart.add(0, [records[k]['Time'], wr1])\n                    preTime = records[k]['Time']\n            \n\n            #myProfit()\n\n            if len(position)>0 and position[0]['Type']==0:\n                pamount = '多：'+str(position[0]['Amount'])+str('#32CD32')\n            elif len(position)>0 and position[0]['Type']==1:\n                pamount = '空：'+str(position[0]['Amount'])+str('#BC1717')\n            else:\n                pamount = ''\n            if len(position)>0:\n                floatProfit = format( position[0][\"Profit\"],'.2f')\n            symbol = exchanges[i].GetCurrency().split('_')[0]\n            tab2[\"rows\"].append([ exchanges[i].GetCurrency() , records[-1].Close \\\n                             , pamount, format(oprice,'.'+str(allCoinData[symbol]['tick_size'])+'f'), floatProfit \\\n                             , { \"type\": \"button\",  \"cmd\": 'cover-'+str(i), \"name\": \"清仓\" } ])\n\n        #总盈利\n        allzhiy = float(_G('allAccount'))-float(_G('moveInStocks'))+float(_G('moveStocks'))-float(_G('initStocks'))\n        if _G('initStocks')==0:\n            allzhiyl=0\n        else:\n            allzhiyl = (float(_G('moveStocks'))+float(_G('allAccount'))-float(_G('moveInStocks'))-float(_G('initStocks')))/float(_G('initStocks'))*100\n         \n        tab1[\"rows\"].append([format(_G('initStocks'),'.1f')+'U', format(_G('allAccount'),'.1f')+'U', format(_G('ableAccount'),'.1f')+'U', format(_G('moveStocks'),'.1f')+'U' \\\n                             , format(allzhiyl,'.1f')+'%('+format(allzhiy,'.1f')+'U)'])    \n        LogStatus(  '`' +json.dumps(tab1) + \"`\\n\" +\"`\" + json.dumps(tab2) + \"`\\n\"  )\n           \n        Sleep(1000)\n           \n                \n\n# 获取Binance永续合约所有币对消息\ndef getBinanceAllCoinData():\n    global allCoinData\n    tmp = dict()\n    data = getUrlData(\"http://fapi.binance.com/fapi/v1/exchangeInfo\")\n    for item in data['symbols']:\n        # 需要USDT为衡量币对\n        if \"USDT\" in item[\"symbol\"]:\n            size = item['filters'][1]['stepSize']    # DOGE 1.00000000   BTC 0.00000100\n            if float(size) == 1:\n                sizein = 0\n            elif len(size.split(\".\"))>1:\n                sizein = str(size).split(\".\")[1].find('1')+1\n            else:\n                sizein = 0\n            tmp[item[\"baseAsset\"]] = {\n                'tick_size': int(item['pricePrecision']),  # 价格精度\n                'old_increment': item['filters'][1]['stepSize'],#最小购买值\n                'size_increment': sizein # 折算数量\n            }\n    allCoinData = tmp\n    \n    \n# 通过url获取数据\ndef getUrlData(url):\n    response = urllib.request.urlopen(url)\n    html = response.read().decode('utf-8')#decode('utf-8') 解决:the JSON object must be str, not 'bytes'\n    try:\n        tmp = json.loads(html)\n        return json.loads(html)\n    except Exception as e:\n        Log('e:',e)      \n\n        \n# 对合约进行止盈止损   cangType=0默认逐仓  =1全仓\ndef zhiyingzhisun(i, amount, directionStr, positionSide, zhiying, zhisun, cangType = 0):\n    return bianSwap(i, amount, directionStr, positionSide, zhiying, zhisun)\n \n# 发送请求\ndef AsynIo(i, paramList):\n        if (len(paramList) == 3):\n            arrRoutine = exchanges[i].Go(\"IO\", paramList[0], paramList[1], paramList[2])\n        elif (len(paramList) == 4):\n            arrRoutine = exchanges[i].Go(\"IO\", paramList[0], paramList[1], paramList[2], paramList[3])\n        elif (len(paramList) == 5):\n            arrRoutine = exchanges[i].Go(\"IO\", paramList[0], paramList[1], paramList[2], paramList[3], paramList[4])\n        data, ok = arrRoutine.wait()\n        Log(data)\n        return data\n\n# 币安合约\ndef bianSwap(i, amount, directionStr, positionSide, zhiying, zhisun):\n    global orderID\n    instrument_id = exchanges[i].GetCurrency().replace('_',\"\")\n    # U本位或币本位，设置请求url\n    if instrument_id.find('USDT') >= 0 :\n        url = \"/fapi/v1/order\"\n    elif instrument_id.find('USD') >= 0 :\n        url = '/dapi/v1/order'\n    else:\n        return False\n    # 止损  side = SELL  BUY\n    '''\n    timestamp = Unix()*1000      \n    params = \"symbol=\"+instrument_id+\"&side=\"+str(directionStr)+\"&positionSide=\"+positionSide+\"&type=STOP_MARKET&stopPrice=\"+str(zhisun)+\"&closePosition=true&timestamp=\"+str(timestamp)\n    Log(params)\n    zhisunData = exchanges[i].IO(\"api\", \"POST\", \"/fapi/v1/order\", params)\n    Log(zhisunData)\n    '''\n    zhisunData = AsynIo(i, ['api', 'POST', url , '', json.dumps({\n        \"symbol\": instrument_id,\n        \"side\": directionStr,\n        \"positionSide\":positionSide,\n        \"type\": \"STOP_MARKET\",\n        #\"quantity\": amount,\n        \"closePosition\":\"true\",\n        #\"price\": zhisun,\n        \"stopPrice\": zhisun,\n        \"timestamp\": str(int(round(time.time() * 1000)))\n    })])\n\n    if int(float(zhisunData['stopPrice'])) != int(float(zhisun)):\n        Log('止损价格不一样',float(zhisunData['stopPrice']),int(float(zhisunData['stopPrice'])), float(zhisun), int(float(zhisun)) )\n        return False\n    orderID[i][0] = zhisunData['orderId']\n    Log('设置'+exchanges[i].GetCurrency()+'止损，订单号：'+str(orderID[i][0]))\n    # 止盈\n    zhiyingData = AsynIo(i, ['api', 'POST', url , '', json.dumps({\n        \"symbol\": instrument_id,\n        \"side\": directionStr,\n        \"positionSide\":positionSide,\n        \"type\": \"TAKE_PROFIT_MARKET\",\n        #\"quantity\": amount,\n        \"closePosition\":\"true\",\n        #\"price\": zhiying,\n        \"stopPrice\": zhiying,\n        \"timestamp\": str(int(round(time.time() * 1000)))\n    })])\n    if int(float(zhiyingData['stopPrice'])) != int(zhiying):\n        Log('止盈价格不一样',float(zhiyingData['stopPrice']),int(float(zhiyingData['stopPrice'])), float(zhiying), int(float(zhiying)) )\n        return False\n    orderID[i][1] = zhiyingData['orderId']\n    Log('设置'+exchanges[i].GetCurrency()+'止盈，订单号：'+str(orderID[i][1]))\n    _G(\"orderID\",orderID)\n    return True",
        "strategy_description": "策略名称: WR-突破马丁\n\nimport json\nimport time\nimport talib\nimport math\nimport urllib.request\n\nChartCfg = {\n    '__isStock': True,\n    'title': {\n        'text': 'WR'\n    },\n    'yAxis': [{\n        'title': {'text': 'WR'},\n        'style': {'color': '#4572A7'},\n        'opposite': False #右边轴\n    }],\n    'series': [{\n        'type': 'line',\n        'id': 'wr',\n        'name': 'wr',\n        'data': []\n    }]\n}\n\ndef MyLog(str1,ktime,price=''):\n    if (_G('str')!=str1 or _G('ktime')!=ktime) and  not (_G('str2')==str1 and ktime==_G('ktime2')) :\n        _G('str2',_G('str'))\n        _G('ktime2',_G('ktime'))\n\n        _G('str',str1)\n        _G('ktime',ktime)\n        Log(str1+str(price)) \n\n\ndef moveStocks(_moveStocks):\n    global todayProfit\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance  只有币本位有交割且共用资金 2-U本位向现货   4-币本位向现货  返回tranId\n        if exchanges[0].GetCurrency().find('USDT')>=0:\n            movecurrency = 'USDT'\n            mtype = 2\n        else:#币本位\n            movecurrency = 'BTC'\n            mtype = 4\n        timestamp = Unix()*1000       \n        params = \"type=\"+str(mtype)+\"&asset=\"+movecurrency+\"&amount=\"+str(_moveStocks)+\"&timestamp=\"+str(timestamp)\n        exchanges[0].SetBase('https://api.binance.com')\n        moveid = exchange.IO(\"api\", \"POST\", \"/sapi/v1/futures/transfer\", params)   \n        exchanges[0].SetBase('https://fapi.binance.com')\n        if moveid is not None:\n            Log('资金转出成功',moveid)\n            _G('moveStocks',_G('moveStocks')+_moveStocks)\n            todayProfit[\"initStocks\"] = todayProfit[\"initStocks\"] - _moveStocks\n            _G('todayProfit',todayProfit)\n            \n        else:\n            Log('资金转出失败')\n    else:\n        Log('暂不支持该交易所转移')\n    \ndef cancelOD(i):\n    orders = _C(exchanges[i].GetOrders)\n    for order in orders:\n        exchanges[i].CancelOrder(order.Id)\n        Sleep(100)\n\ndef coverAll(i):\n    position = _C(exchanges[i].GetPosition)\n    cancelOD(i)\n    Sleep(200)\n    for j in range(len(position)):\n        pamount = position[j][\"Amount\"] #-position[0][\"FrozenAmount\"]\n        if position[j][\"Type\"]==0:     #持多单\n            Deal(-1 , pamount, \"closebuy\", exchanges[i].GetCurrency()+'手动市价清仓',i)\n        elif position[j][\"Type\"]==1:     #持空单\n            Deal(-1 , pamount, \"closesell\", exchanges[i].GetCurrency()+'手动市价清仓',i)\n        \ndef  getOpenPrice(position):\n    if hasattr(position[0],'Info') and hasattr(position[0].Info,'cost_open'):#huobi\n        return position[0].Info.cost_open\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'avg_cost'):#ok\n        return position[0].Info.avg_cost\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'entryPrice'):#binance\n        return position[0].Info.entryPrice\n    else:\n        return position[0][\"Price\"] \n\n    \ndef UpdateAccout():\n    accout = _C(exchanges[0].GetAccount)\n    acc1 = accout.FrozenBalance    #其它币的冻结余额  是否共用?\n    acc2 = accout.Balance\n    \n    _G(\"ableAccount\", acc2)#当前可用U\n    _G(\"allAccount\",acc1+acc2+GetMargin()) #没计算浮盈\n    if acc2<1:\n        Log(\"账户保证金余额不足\")\n        Sleep(8000)\n\ndef GetMargin():\n    allMargin = 0\n    for i in range(len(exchanges)):\n        allMargin += _G(\"margin\")[i]\n    return _N(allMargin,2)\n\n\ndef GetHighest(records,i,period):\n    high = 0\n    for i in range(i-period+1,i+1):\n        if records[i].High > high:\n            high = records[i].High\n    return high\n\ndef GetLowest(records,i,period):\n    low = 1000000\n    for i in range(i-period+1,i+1):\n        if records[i].Low < low:\n            low = records[i].Low\n    return low\n    \n        \ndef SetType(type):\n    if type==0:\n        _G(\"contractType\",\"swap\")\n    elif type==1:\n        _G(\"contractType\",\"this_week\")\n    elif type==2:\n        _G(\"contractType\",\"next_week\")\n    elif type==3:\n        _G(\"contractType\",\"quarter\")\n    elif type==4:\n        _G(\"contractType\",\"next_quarter\")\n        \ndef Deal(price, num, btype, beizhu='',i=0 ):\n    Sleep(50)\n    #if beizhu!='':\n    #    Log(beizhu)\n    exchanges[i].SetDirection(btype)\n    if btype==\"closebuy\" or btype==\"sell\" :\n        exchanges[i].Sell(price , num, beizhu)\n        #Log('开空',price)\n    else:\n        exchanges[i].Buy(price , num, beizhu)\n        #Log('开多',price)\n\n\ndef myProfit():\n    LogProfit( _G(\"allAccount\")-_G(\"initStocks\") )\n\n\ndef initData():\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|No need to change|reused\")\n    global allCoinData\n    Log(\"正在初始化...\")\n\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance\n        getBinanceAllCoinData()\n        Sleep(3000)\n        Log(\"获取交易所信息结束\")\n    else:\n        Log('暂不支持该交易所')\n        return\n    \n    if _G(\"moveStocks\") is None:\n        _G(\"moveStocks\",0)\n    if _G(\"moveInStocks\") is None:\n        _G(\"moveInStocks\",0)\n        \n    for i in range(len(exchanges)):#初始化 交易所\n        symbol = exchanges[i].GetCurrency().split('_')[0]\n        exchanges[i].SetContractType(\"swap\")\n        exchanges[i].SetPrecision(allCoinData[symbol]['tick_size'], allCoinData[symbol]['size_increment'])\n        exchanges[i].SetMarginLevel(marginLevel)\n        timestamp = Unix()*1000      \n        exchanges[i].IO(\"api\", \"POST\", \"/fapi/v1/positionSide/dual\", \"dualSidePosition=true&timestamp=\"+str(timestamp))\n        \n    \n        \ndef main():\n    global allCoinData, orderID\n    if _G(\"contractType\") is None:\n        _G(\"contractType\",\"swap\")\n    global ChartCfg\n    preTime = 0\n    chart = Chart(ChartCfg)\n    chart.reset()\n    \n    margin = [0 for i in range(len(exchanges)) ] \n    _G(\"margin\",margin)\n    preTime = 0\n    bucTimes = [0 for i in range(len(exchanges)) ] \n    initData()\n    #LogProfitReset(1)\n    #暂未考虑仓位不足\n    while(true):\n        #Log('测试循环')\n        cmd = GetCommand()\n        if cmd:\n            if cmd == \"清仓停机\":\n                for i in range(len(exchanges)):\n                    Sleep(100)\n                    coverAll(i)\n                Sleep(1000)\n                return\n            if cmd.find('cover-')>=0:\n                arr = cmd.split(\"-\")\n                coverAll(int(arr[1]))\n                Sleep(2000)\n            elif cmd == 'cancelOD':\n                cancelOD()\n                Sleep(1000)\n        \n        tab1 = {\n            \"type\": \"table\", \n            \"title\": \"账户信息\", \n            \"cols\": [\"初始资金\", \"当前资金\" , \"可用资金\", \"已移出资金\", \"总盈利率\"], \n            \"rows\": []\n        }\n        tab2 = {\n            \"type\": \"table\", \n            \"title\": \"持仓状态\", \n            \"cols\": [\"币种\", \"最新价\",\"持仓数\", \"持仓均价\",  \"浮动盈亏\",\"操作\"], \n            \"rows\": []\n        }\n        \n        \n        UpdateAccout() \n        if _G(\"initStocks\") is None or _G(\"initStocks\")<10 :\n            _G(\"initStocks\", _G(\"allAccount\"))\n        if autoMoveStocks>100 and _G('ableAccount')>autoMoveStocks :\n                Log('自动移出资金：100U#32CD32')\n                moveStocks(100)\n                continue\n\n        for i in range(len(exchanges)):\n            Sleep(100)\n            records = _C(exchanges[i].GetRecords,60 * period)\n            #wr_high = TA.Highest(records, WRperiod, 'High')\n            #wr_low = TA.Lowest(records, WRperiod, 'Low')\n            #wr = (records[-1].Close-wr_high)/(wr_high-wr_low)*100\n            position = _C(exchanges[i].GetPosition)\n            margin = _G(\"margin\")\n            if len(position)>0:\n                oprice = float(getOpenPrice(position))\n                margin[i] = position[0][\"Margin\"]\n                floatProfit =  float(position[0][\"Profit\"])\n                pamount = float(position[0]['Amount'])\n                #止损\n                if -1*floatProfit > oprice*pamount/marginLevel*zhis/100:\n                    if position[0]['Type']==0:\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止损'+format(records[-1].Close,'.4f'),i)\n                    else:\n                        Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止损'+format(records[-1].Close,'.4f'),i)\n                    Sleep(500)\n                    myProfit()\n                    bucTimes[i] += 1\n                    if bucTimes[i]>maxBuc:\n                        bucTimes[i] = maxBuc\n                #止盈\n                if floatProfit > oprice*pamount/marginLevel*zhiy/100:\n                    if position[0]['Type']==0:\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止盈'+format(records[-1].Close,'.4f'),i)\n                    else:\n                        Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止盈'+format(records[-1].Close,'.4f'),i)\n                    Sleep(500)\n                    myProfit()\n                    bucTimes[i] = 0\n            else:\n                oprice = 0\n                margin[i] = 0\n                floatProfit = ''\n\n            _G(\"margin\", margin)\n            \n            \n            for k in range(50, len(records)):\n\n                wr_high1 = GetHighest(records,k, WRperiod)\n                wr_low1 = GetLowest(records,k, WRperiod)\n                wr1 = (records[k].Close-wr_high1)/(wr_high1-wr_low1)*100\n                if k==len(records)-1:\n                    if wr1>-5:#开空\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==0):#平多\n                            if len(position)>0:\n                                Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单清仓'+format(records[-1].Close,'.4f'),i)\n                                Sleep(500)\n                                myProfit()\n                                if floatProfit<0:\n                                    bucTimes[i] += 1\n                                    if bucTimes[i]>maxBuc:\n                                        bucTimes[i] = maxBuc\n                                else:\n                                    bucTimes[i] = 0\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\n                            if famount==0:\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\n                                continue\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\n                            Deal(-1, pamount, 'sell',exchanges[i].GetCurrency()+' 空单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)\n                    elif wr1<-95:#开多\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==1):#平空\n                            if len(position)>0:\n                                Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单清仓'+format(records[-1].Close,'.4f'),i)\n                                Sleep(500)\n                                myProfit()\n                                if floatProfit<0:\n                                    bucTimes[i] += 1\n                                    if bucTimes[i]>maxBuc:\n                                        bucTimes[i] = maxBuc\n                                else:\n                                    bucTimes[i] = 0\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\n                            if famount==0:\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\n                                continue\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\n                            Deal(-1, pamount, 'buy',exchanges[i].GetCurrency()+' 多单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)        \n                    #Log(wr1)\n                \n                #画图\n                if i==0 and records[k]['Time'] == preTime:\n                    chart.add(0, [records[k]['Time'], wr1], -1)\n                elif i==0 and records[k]['Time'] > preTime:\n                    #Log('insert',records[k]['Time'],wr_high1,wr_low1,records[k].Close,wr1)\n                    chart.add(0, [records[k]['Time'], wr1])\n                    preTime = records[k]['Time']\n            \n\n            #myProfit()\n\n            if len(position)>0 and position[0]['Type']==0:\n                pamount = '多：'+str(position[0]['Amount'])+str('#32CD32')\n            elif len(position)>0 and position[0]['Type']==1:\n                pamount = '空：'+str(position[0]['Amount'])+str('#BC1717')\n            else:\n                pamount = ''\n            if len(position)>0:\n                floatProfit = format( position[0][\"Profit\"],'.2f')\n            symbol = exchanges[i].GetCurrency().split('_')[0]\n            tab2[\"rows\"].append([ exchanges[i].GetCurrency() , records[-1].Close \\\n                             , pamount, format(oprice,'.'+str(allCoinData[symbol]['tick_size'])+'f'), floatProfit \\\n                             , { \"type\": \"button\",  \"cmd\": 'cover-'+str(i), \"name\": \"清仓\" } ])\n\n        #总盈利\n        allzhiy = float(_G('allAccount'))-float(_G('moveInStocks'))+float(_G('moveStocks'))-float(_G('initStocks'))\n        if _G('initStocks')==0:\n            allzhiyl=0\n        else:\n            allzhiyl = (float(_G('moveStocks'))+float(_G('allAccount'))-float(_G('moveInStocks'))-float(_G('initStocks')))/float(_G('initStocks'))*100\n         \n        tab1[\"rows\"].append([format(_G('initStocks'),'.1f')+'U', format(_G('allAccount'),'.1f')+'U', format(_G('ableAccount'),'.1f')+'U', format(_G('moveStocks'),'.1f')+'U' \\\n                             , format(allzhiyl,'.1f')+'%('+format(allzhiy,'.1f')+'U)'])    \n        LogStatus(  '`' +json.dumps(tab1) + \"`\\n\" +\"`\" + json.dumps(tab2) + \"`\\n\"  )\n           \n        Sleep(1000)"
    },
    {
        "strategy_id": "46_ZT-交易所接口可用于对接平台暂不支持的冷门交易所-ZT",
        "strategy_code": "python\n#!Python3\n\n\"\"\"\n《策略代写》 与 （此程序帮助），致信QQ：35787501\n\nZT 交易所接口，可用于对接 平台暂不支持的冷门交易所 ZT\n\"\"\"\n\nfrom requests import get, post\nfrom hashlib import md5\nfrom urllib.parse import urlencode\n\n\nclass ZT:\n    def __init__(self, api_key, secret_key):\n        self.api_key = api_key\n        self.secret_key = secret_key\n        self.host = \"https://www.ztb.im\"\n        self.headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\n                          'AppleWebKit/537.36 (KHTML, like Gecko) '\n                          'Chrome/92.0.4515.159 Safari/537.36',\n            \"content-type\": \"application/x-www-form-urlencoded\",\n            'X-SITE-ID': '1',\n        }\n\n    def http_post(self, path, params):\n        return post(f\"{self.host}{path}\", data=urlencode(params), headers=self.headers, timeout=5)\n\n    def get_sign(self, params):\n        return md5((urlencode(params) + f\"&secret_key={self.secret_key}\").encode()).hexdigest().upper()\n\n    def get_ticker(self, symbol):\n        return float(\n            get(\n                f\"{self.host}/api/v1/trades?symbol={symbol}&size=1\", headers=self.headers, timeout=5\n            ).json()[0][\"price\"]\n        )\n\n    def send_order(self, symbol, side, price, amount):\n        path = \"/api/v1/private/trade/limit\"\n        params = {\n            \"amount\": amount,\n            \"api_key\": self.api_key,\n            \"market\": symbol,\n            \"price\": price,\n        }\n        all_side = {\"close_sell\": 1, \"open_buy\": 2}\n        params[\"side\"] = all_side[side]\n        params[\"sign\"] = self.get_sign(params)\n        return str(self.http_post(path, params).json().get(\"result\", {'id': \"0\"})[\"id\"])\n\n    def select_order(self, symbol, oid):\n        path = \"/api/v1/private/order/pending/detail\"\n        params = {\n            \"api_key\": self.api_key,\n            \"market\": symbol,\n            \"order_id\": oid,\n        }\n        params[\"sign\"] = self.get_sign(params)\n        return not self.http_post(path, params).json()['result']\n\n    def cancel_order(self, symbol, oid):\n        path = \"/api/v1/private/trade/cancel\"\n        params = {\n            \"api_key\": self.api_key,\n            \"market\": symbol,\n            \"order_id\": oid,\n        }\n        params[\"sign\"] = self.get_sign(params)\n        return self.http_post(path, params).json()",
        "strategy_description": "策略名称: ZT-交易所接口可用于对接平台暂不支持的冷门交易所-ZT\n\n未找到描述"
    },
    {
        "strategy_id": "47_binance部分交易封装示例",
        "strategy_code": "python\n# -*- coding = utf-8 -*-\n# @Time:2023/2/20 11:04\n# @Author: 作手君\n# @File: binance.py\n# @Software: PyCharm\n\nimport json\nimport time\nimport hmac\nfrom hashlib import sha256\nimport requests\nfrom logger import logger\n\n\ndef cleanNoneValue(d) -> dict:\n    out = {}\n    for k in d.keys():\n        if d[k] is not None:\n            out[k] = d[k]\n    return out\n\n\ndef get_timestamp() -> int:\n    return int(time.time()) * 1000\n    # cet_tz = pytz.timezone('Etc/GMT+0')\n    # t = datetime.now(cet_tz)\n    # return int(time.mktime(t.timetuple())) * 1000\n    # return (int(time.time()) - (8*60*60)) * 1000\n    # utc_t = datetime.datetime.utcnow().timestamp()\n    # return int(utc_t * 1000)\n\n\nclass Binance(object):\n    def __init__(self, api_key, secret_key):\n        self.api_key = api_key\n        self.secret_key = secret_key\n        self.host = 'https://fapi.binance.com'\n        self.timestamp = ''\n        self.method = ''\n        self.request_path = ''\n\n    # 交易\n    def trade_order(self, symbol, pos_side, trade_side, sz, client_id, ord_type=\"market\", px=None):\n        self.request_path = '/fapi/v1/order'\n        self.method = 'POST'\n        params = {\n            'symbol': symbol.upper() + 'USDT',\n            'side': trade_side.upper(),  # 买卖方向 SELL, BUY\n            'positionSide': pos_side,  # long short\n            'type': ord_type.upper(),\n            'quantity': sz,  # 数量\n            'newClientOrderId': 'x-YZChr3zS' + str(client_id),  # 客户订单号\n            # 'timeInForce': 'GTC',\n        }\n        if ord_type == 'limit':\n            params['timeInForce'] = 'GTC'\n            params['price'] = str(px)\n        url = self.generate_url(params)\n        # 0 成功 1暂停几秒 2忽略此次交易 3 用户停止策略\n        try:\n            response = self.send(url)\n            if 'code' in response.keys():\n                if int(response['code']) == -2018 or int(response['code']) == -2019:\n                    # 余额不足 直接清仓\n                    return {\"code\": 3, \"msg\": response.get('msg', ''), \"data\": {}}\n                return {\"code\": 1, \"msg\": response.get('msg', ''), \"data\": {}}\n                pass\n            else:\n                return {\n                    'code': 0,\n                    'msg': '',\n                    'data': {\n                        'clOrdId': response['clientOrderId'],\n                        'ordId': response['orderId'],\n                    }\n                }\n        except Exception as e:\n            logger.error('binance error')\n            logger.error(e)\n            return {\"code\": 2, \"msg\": str(e), \"data\": {}}\n\n    # 获取挂单列表\n    def get_open_order(self):\n        self.request_path = '/fapi/v1/openOrders'\n        self.method = 'GET'\n        url = self.generate_url({})\n        response = self.send(url)\n        return response\n\n    def get_kline(self, symbol, limit, interval):\n        self.request_path = '/fapi/v1/klines'\n        self.method = 'GET'\n        params = {\n            'symbol': symbol.upper() + 'USDT',\n            'interval': interval,\n            'limit': limit,\n        }\n        url = self.generate_url(params)\n        response = self.send(url)\n        return response\n\n    # 获取单币种挂单列表\n    def get_symbol_open_order(self, symbol):\n        self.request_path = '/fapi/v1/openOrders'\n        self.method = 'GET'\n        url = self.generate_url({\n            'symbol': symbol.upper() + 'USDT'\n        })\n        response = self.send(url)\n        return response\n\n    # 获取挂单列表\n    def get_positions(self, symbol):\n\n        self.request_path = '/fapi/v2/account'\n        self.method = 'GET'\n        url = self.generate_url({})\n        response = self.send(url)\n        positions = response['positions']\n        return positions\n\n    # 撤单\n    def cancel_order(self, symbol):\n        self.request_path = '/fapi/v1/allOpenOrders'\n        self.method = 'DELETE'\n        params = {\n            'symbol': symbol.upper() + 'USDT',\n        }\n        url = self.generate_url(params)\n        response = self.send(url)\n        if 'code' in response.keys() and int(response.get('code', 0)) != 200:\n            raise Exception(response.get('msg'))\n        return response\n\n    def generate_url(self, params, use_timestamp=True):\n        if use_timestamp:\n            params['timestamp'] = get_timestamp()\n        return '{}{}?{}'.format(self.host, self.request_path, self.generate_sign(params))\n\n    def generate_sign(self, params):\n        query_string = ''\n        for k in params.keys():\n            query_string = query_string + '{}={}&'.format(k, params.get(k))\n        query_string = query_string[:-1]\n        if self.secret_key:\n            signature = hmac.new(self.secret_key.encode(\"utf-8\"),\n                                 query_string.encode(\"utf-8\"), digestmod=sha256).hexdigest()\n            query_string = query_string + '&signature=' + signature\n        return query_string\n\n    def send(self, url, params=None):\n        session = requests.Session()\n        session.headers.update(\n            {\n                \"Content-Type\": \"application/json;charset=utf-8\",\n                \"X-MBX-APIKEY\": self.api_key,\n            }\n        )\n        if self.method == 'GET':\n            response = session.get(url=url, params=params)\n        elif self.method == 'DELETE':\n            response = session.delete(url=url, params=params)\n        else:\n            response = session.post(url=url, params=params)\n        # logger.info('币安请求信息')\n        # logger.info(params)\n        # logger.info(response.text)\n        return json.loads(response.text)",
        "strategy_description": "策略名称: binance部分交易封装示例\n\n# @Time:2023/2/20 11:04"
    },
    {
        "strategy_id": "48_bollmaboll",
        "strategy_code": "python\nimport numpy as np\nimport talib\nimport time\nif period == 1:\n\tper = PERIOD_M1\nif period == 2:\n\tper = PERIOD_M3\nif period == 3:\n\tper = PERIOD_M5\nif period == 4:\n\tper = PERIOD_M15\nif period == 5:\n\tper = PERIOD_M30\nif period == 6:\n\tper = PERIOD_H1\n\t\nstatus=0 #多：1  空：2\n\nposition = 0\n\ndef ontick():\n\tglobal position\n\trecords = exchange.GetRecords(per)\n\t#------------指标计算---------\n\t#rsi = TA.RSI(records,14)\n\t#if rsi[-1] > 65 or rsi[-1] < 35:\n\t#    return\n\tbb = talib.BBANDS(records.Close,timeperiod=bo, nbdevup=2, nbdevdn=2, matype=0) #计算BB\n\trsi = talib.RSI(records.Close,timeperiod=12)\n\tcmi = talib.CMO(records.Close,timeperiod=12)\n\tprint(cmi[-1])\n\tmove = talib.SMA(records.Close,ma2)#收盘价ma\n\tmabt = talib.SMA(bb[0],ma)#上轨ma\n\tmabd = talib.SMA(bb[2],ma)#下跪ma\n\taccount = exchange.GetAccount()\n\n\t\n\n\tif bb[0][-1] > mabt[-1] and bb[0][-2] < mabt[-2] and bb[2][-1] < bb[2][-2] and bb[1][-1] > bb[1][-2] and records.Close[-1] > move[-1] and rsi[-1]>60:\n\t\tposition += 1\n\t\texchange.Buy(-1,account.Balance*0.1)\n\t\t#log('向上突破开多 '+ str(close[-1]))\n\t\n\tif bb[2][-1] < mabd[-1] and bb[2][-2] > mabd[-2] and bb[0][-1] > bb[0][-2] and bb[1][-1] < bb[1][-2] and records.Close[-1] < move[-1] and rsi[-1]<40:\n\t\tposition -= 1\n\t\texchange.Sell(-1,account.Stocks*0.1)\n\t\t#log('向下突破开空 '+ str(close[-1]))\n\t\n\tif bb[0][-1]-bb[2][-1] < bb[0][-2]-bb[2][-2]:\n\t\tif bb[0][-1] < mabt[-1] and bb[0][-2] > mabt[-2] and position> 0:\n\t\t\tposition -= 1\n\t\t\texchange.Sell(-1,account.Stocks*0.1)\n\t\t\t#log('多单平仓 '+ str(close[-1]))\n\n\t\tif bb[2][-1] > mabd[-1] and bb[2][-2] < mabd[-2] and position < 0:\n\t\t\tposition += 1\n\t\t\texchange.Buy(-1,account.Balance*0.1)\n\t\t\t#log('空单平仓 '+ str(close[-1]))\n\ndef main():\n\twhile True:\n\t\tontick()\n\t\tSleep(30000)",
        "strategy_description": "策略名称: bollmaboll\n\nbb = talib.BBANDS(records.Close,timeperiod=bo, nbdevup=2, nbdevdn=2, matype=0) #计算BB\n\trsi = talib.RSI(records.Close,timeperiod=12)\n\tcmi = talib.CMO(records.Close,timeperiod=12)\n\tprint(cmi[-1])\n\tmove = talib.SMA(records.Close,ma2)#收盘价ma\n\tmabt = talib.SMA(bb[0],ma)#上轨ma\n\tmabd = talib.SMA(bb[2],ma)#下跪ma\n\taccount = exchange.GetAccount()\n\n\t\n\n\tif bb[0][-1] > mabt[-1] and bb[0][-2] < mabt[-2] and bb[2][-1] < bb[2][-2] and bb[1][-1] > bb[1][-2] and records.Close[-1] > move[-1] and rsi[-1]>60:\n\t\tposition += 1\n\t\texchange.Buy(-1,account.Balance*0.1)\n\t\t#log('向上突破开多 '+ str(close[-1]))\n\t\n\tif bb[2][-1] < mabd[-1] and bb[2][-2] > mabd[-2] and bb[0][-1] > bb[0][-2] and bb[1][-1] < bb[1][-2] and records.Close[-1] < move[-1] and rsi[-1]<40:\n\t\tposition -= 1\n\t\texchange.Sell(-1,account.Stocks*0.1)\n\t\t#log('向下突破开空 '+ str(close[-1]))\n\t\n\tif bb[0][-1]-bb[2][-1] < bb[0][-2]-bb[2][-2]:\n\t\tif bb[0][-1] < mabt[-1] and bb[0][-2] > mabt[-2] and position> 0:\n\t\t\tposition -= 1\n\t\t\texchange.Sell(-1,account.Stocks*0.1)\n\t\t\t#log('多单平仓 '+ str(close[-1]))\n\n\t\tif bb[2][-1] > mabd[-1] and bb[2][-2] < mabd[-2] and position < 0:\n\t\t\tposition += 1\n\t\t\texchange.Buy(-1,account.Balance*0.1)\n\t\t\t#log('空单平仓 '+ str(close[-1]))\n\ndef main():\n\twhile True:\n\t\tontick()\n\t\tSleep(30000)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/146391\n\n> Last Modified\n\n2020-04-23 16:46:09"
    },
    {
        "strategy_id": "49_grid",
        "strategy_code": "python\nlast_tick = []\nline = []\ngrid_buy_list = []\n\ndef net(now_price):\n    global line\n    print(now_price)\n    line = [now_price*(1+0.003*i) for i in range(-1000,1000)]\n    Log(line)\n    \ndef ontick():\n    global last_tick\n    global  line\n    global grid_buy_list\n    account = exchange.GetAccount()\n    ticker = exchange.GetTicker()\n    last_tick.append(ticker['Last'])\n    if len(last_tick) == 1:return\n    elif len(last_tick) == 100:del last_tick[0]\n    for i in range(len(line)):\n        if last_tick[-1] > line[i] and last_tick[-2] < line[i] and len(grid_buy_list)!= 0 and i > min(grid_buy_list)  and account['Stocks'] >= 0.001:\n            exchange.Sell(last_tick[-1],0.01)\n            del grid_buy_list[grid_buy_list.index(min(grid_buy_list))]\n            Log(exchange.GetAccount())\n        elif last_tick[-1] < line[i] and last_tick[-2] > line[i] and i not in grid_buy_list:\n            exchange.Buy(last_tick[-1],0.01)\n            grid_buy_list.append(i)\n            Log(exchange.GetAccount())\n\ndef main():\n    net(exchange.GetTicker()['Last'])\n    Log(exchange.GetAccount())\n    while(True):\n        ontick()\n        Sleep(1000)",
        "strategy_description": "策略名称: grid\n\n未找到描述"
    },
    {
        "strategy_id": "50_python-状态栏表格-显示按钮范例",
        "strategy_code": "python\nimport json\n\ndef main():\n    tab = {\n        \"type\" : \"table\", \n        \"title\" : \"demo\", \n        \"cols\" : [\"a\", \"b\", \"c\"], \n        \"rows\" : [[\"1\", \"2\", {\"type\" : \"button\", \"cmd\" : \"coverAll\", \"name\" : \"平仓\"}]]    # 在状态栏表格 第一行，第三列上配置一个按钮 名字是平仓\n    }\n    \n    LogStatus(\"`\" + json.dumps(tab) + \"`\")",
        "strategy_description": "策略名称: python-状态栏表格-显示按钮范例\n\n}\n    \n    LogStatus(\"`\" + json.dumps(tab) + \"`\")\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/147155\n\n> Last Modified\n\n2019-05-10 11:35:13"
    },
    {
        "strategy_id": "51_python",
        "strategy_code": "python\n'''backtest\nstart: 2021-06-26 00:00:00\nend: 2022-01-23 00:00:00\nperiod: 1d\nbasePeriod: 1h\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"BTC_USDT\"}]\n'''\ndef main():\n    exchange.SetMarginLevel(7)\n    exchange.SetContractType(\"swap\")\n    exchange.SetDirection(\"buy\")\n    ticker = exchange.GetTicker()\n    Log(ticker)\n    exchange.Buy(ticker[\"Last\"] - 100, 0.001)\n    exchange.Buy(ticker[\"Last\"] - 500, 0.001)\n    exchange.Buy(ticker[\"Last\"] -1000, 0.002)\n    exchange.Buy(ticker[\"Last\"] - 1500, 0.003)\n    exchange.Buy(ticker[\"Last\"] - 2000, 0.005)\n    exchange.Buy(ticker[\"Last\"] - 2500, 0.008)\n    exchange.Buy(ticker[\"Last\"] - 3000, 0.013)\n    exchange.Buy(ticker[\"Last\"] - 3500, 0.021)\n    exchange.Buy(ticker[\"Last\"] - 4000, 0.034)\n    exchange.Buy(ticker[\"Last\"] - 4500, 0.055)\n    exchange.Buy(ticker[\"Last\"] - 5000, 0.089)\n    exchange.Buy(ticker[\"Last\"] - 5500, 0.144)\n    exchange.Buy(ticker[\"Last\"] - 6000, 0.233)\n    exchange.Buy(ticker[\"Last\"] - 6500, 0.377)\n    exchange.Buy(ticker[\"Last\"] - 7000, 0.610)\n    exchange.Buy(ticker[\"Last\"] - 7500, 0.987)\n    exchange.Buy(ticker[\"Last\"] - 8000, 1.597)\n    exchange.Buy(ticker[\"Last\"] - 8500, 2.584)\n    \n    exchange.SetContractType(\"swap\")\n    exchange.SetDirection(\"sell\")\n    ticker = exchange.GetTicker()\n    Log(ticker)\n    exchange.Sell(ticker[\"Last\"] + 100, 0.001)\n    exchange.Sell(ticker[\"Last\"] + 500, 0.001)\n    exchange.Sell(ticker[\"Last\"] + 1000, 0.002)\n    exchange.Sell(ticker[\"Last\"] + 1500, 0.003)\n    exchange.Sell(ticker[\"Last\"] + 2000, 0.005)\n    exchange.Sell(ticker[\"Last\"] + 2500, 0.008)\n    exchange.Sell(ticker[\"Last\"] + 3000, 0.013)\n    exchange.Sell(ticker[\"Last\"] + 3500, 0.021)\n    exchange.Sell(ticker[\"Last\"] + 4000, 0.034)\n    exchange.Sell(ticker[\"Last\"] + 4500, 0.055)\n    exchange.Sell(ticker[\"Last\"] + 5000, 0.089)\n    exchange.Sell(ticker[\"Last\"] + 5500, 0.144)\n    exchange.Sell(ticker[\"Last\"] + 6000, 0.233)\n    exchange.Sell(ticker[\"Last\"] + 6500, 0.377)\n    exchange.Sell(ticker[\"Last\"] + 7000, 0.610)\n    exchange.Sell(ticker[\"Last\"] + 7500, 0.987)\n    exchange.Sell(ticker[\"Last\"] + 8000, 1.597)\n    exchange.Sell(ticker[\"Last\"] + 8500, 2.584)\n    \n    Log(\"orders\", exchange.GetOrders())\n    Sleep(1000)",
        "strategy_description": "策略名称: python\n\n未找到描述"
    },
    {
        "strategy_id": "52_python利用asyncio-http获取行情数据示范",
        "strategy_code": "python\n'''backtest\nstart: 2021-11-04 00:00:00\nend: 2022-02-01 00:00:00\nperiod: 1h\nbasePeriod: 15m\n'''\n\nimport time\nimport asyncio\nfrom aiohttp import ClientSession\nimport time\nimport datetime\nglobal tasks\ntasks = []\n\nasync def fetch_exchangeinfo():\n    exchangeinfo=\"https://fapi.binance.com//fapi/v1/exchangeInfo\"\n    async with ClientSession() as session:\n        async with session.get(exchangeinfo) as response:\n            result=await response.read()\n            Log(result.text, time.time())\n            return result\n            \n\nasync def fetch_depth(symbol,limit):\n    symbol_depth=\"https://fapi.binance.com//fapi/v1/depth?symbol=\"+str(symbol)+\"&limit=\"+str(limit)\n    async with ClientSession() as session:\n        async with session.get(symbol_depth) as response:\n            result=await response.read()\n            Log(result.text, time.time())\n            return result\n            \n\nasync def fetch_klines(symbol,interval,limit):\n    symbol_kline=\"https://fapi.binance.com//fapi/v1/klines?symbol=\"+str(symbol)+\"&interval=\"+str(interval)+\"&limit=\"+str(limit)\n    async with ClientSession() as session:\n        async with session.get(symbol_kline) as response:\n            result = await response.read()\n            Log(symbol,result, time.time())\n            return result\n           \nasync def fetch_all_ticker():\n    all_symbol_ticker = \"https://fapi.binance.com/fapi/v1/ticker/price\"\n    async with ClientSession() as session:\n        async with session.get(all_symbol_ticker) as response:\n            result = await response.read()\n            Log(result.text, time.time())\n            return result\n            \n\ndef main():\n    while True:\n        Log(datetime.datetime.now(),'开始')\n        symbol_list=['BTCUSDT','ETHUSDT','BNBUSDT','ETCUSDT','EOSUSDT','SANDUSDT','XRPUSDT','ADAUSDT','GALAUSDT','IOTXUSDT','BNBUSDT','MATICUSDT']\n        for i in range(12):\n            task = asyncio.ensure_future(fetch_klines(symbol_list[i],'15m',500))\n            tasks.append(task)\n        loop = asyncio.get_event_loop()\n        result = loop.run_until_complete(asyncio.gather(*tasks))\n        Log(datetime.datetime.now(),'完成')\n        Sleep(1000)",
        "strategy_description": "策略名称: python利用asyncio-http获取行情数据示范\n\n未找到描述"
    },
    {
        "strategy_id": "53_python版-Dual-Thrust-OKCoin-期货",
        "strategy_code": "python\nimport time\nclass Error_noSupport(BaseException):\n    def __init__(self):\n        Log(\"只支持OKCoin期货！#FF0000\")\n\nclass Error_AtBeginHasPosition(BaseException):\n    def __init__(self):\n        Log(\"启动时有期货持仓! #FF0000\")\n\nChartCfg = {\n    '__isStock': True,\n    'title': {\n        'text': 'Dual Thrust 上下轨图'\n    },\n    'yAxis': {\n        'plotLines': [{\n            'value': 0,\n            'color': 'red',\n            'width': 2,\n            'label': {\n                'text': '上轨',\n                'align': 'center'\n            },\n        }, {\n            'value': 0,\n            'color': 'green',\n            'width': 2,\n            'label': {\n                'text': '下轨',\n                'align': 'center'\n            },\n        }]\n    },\n    'series': [{\n        'type': 'candlestick',\n        'name': '当前周期',\n        'id': 'primary',\n        'data': []\n    }, {\n        'type': 'flags',\n        'onSeries': 'primary',\n        'data': []\n    }]\n}\n\nSTATE_IDLE = 0\nSTATE_LONG = 1\nSTATE_SHORT = 2\nState = STATE_IDLE\n\nLastBarTime = 0\nUpTrack = 0\nBottomTrack = 0\nchart = None\nInitAccount = None\nLastAccount = None\nCounter = {\n    'w': 0,\n    'l': 0\n}\n\ndef GetPosition(posType):  # if the positions has no this posType ,will return [] ,Another case is return a dict of object\n    positions = exchange.GetPosition()\n    return [{'Price': position['Price'], 'Amount': position['Amount']} for position in positions if position['Type'] == posType]\n\ndef CancelPendingOrders():\n    while True:\n        orders = exchange.GetOrders()\n        [exchange.CancelOrder(order['Id']) for order in orders if not Sleep(500)]\n        if len(orders) == 0:\n            break \n\ndef Trade(currentState,nextState):\n    global InitAccount,LastAccount,OpenPrice,ClosePrice\n    ticker = _C(exchange.GetTicker)\n    slidePrice = 1\n    pfn = exchange.Buy if nextState == STATE_LONG else exchange.Sell \n    if currentState != STATE_IDLE:\n        Log(_C(exchange.GetPosition)) # ceshi \n        exchange.SetDirection(\"closebuy\" if currentState == STATE_LONG else \"closesell\")\n        while True:\n            ID = pfn( (ticker['Last'] - slidePrice) if currentState == STATE_LONG else (ticker['Last'] + slidePrice), AmountOP) # xiugai 限价单\n            # ID = pfn(-1, AmountOP) # xiugai  市价单\n            # ID = pfn(AmountOP) # xiugai  市价单\n            Sleep(Interval)\n            Log(exchange.GetOrder(ID)) # xiugai\n            ClosePrice = (exchange.GetOrder(ID))['AvgPrice'] # \n            CancelPendingOrders()\n            if len(GetPosition(PD_LONG if currentState == STATE_LONG else PD_SHORT)) == 0:\n                break \n        account = exchange.GetAccount()\n        if account['Stocks'] > LastAccount['Stocks']:\n            Counter['w'] += 1\n        else:\n            Counter['l'] += 1\n        # Log(\"ceshi account:\",account,InitAccount) #ceshi\n        Log(account) # xiugai\n        LogProfit((account['Stocks'] - InitAccount['Stocks']),\"收益率:\", ((account['Stocks'] - InitAccount['Stocks']) * 100 / InitAccount['Stocks']),'%')\n        Cal(OpenPrice,ClosePrice)\n        LsatAccount = account \n    \n    exchange.SetDirection(\"buy\" if nextState == STATE_LONG else \"sell\") \n    Log(_C(exchange.GetAccount))\n    while True:\n        ID = pfn( (ticker['Last'] + slidePrice) if nextState == STATE_LONG else (ticker['Last'] - slidePrice), AmountOP) # 限价单\n        # ID = pfn(-1, AmountOP) # 市价单\n        # ID = pfn(AmountOP) # 市价单\n        Sleep(Interval)\n        Log(exchange.GetOrder(ID)) # xiugai\n        CancelPendingOrders()\n        pos = GetPosition(PD_LONG if nextState == STATE_LONG else PD_SHORT)\n        if len(pos) != 0:\n            Log(\"持仓均价\",pos[0]['Price'],\"数量:\",pos[0]['Amount'])\n            OpenPrice = (exchange.GetOrder(ID))['AvgPrice'] # pos[0]['Price']\n            Log(\"now account:\",exchange.GetAccount())\n            break \n\ndef onTick(exchange):\n    global LastBarTime,chart,State,UpTrack,DownTrack,LastAccount\n    records = exchange.GetRecords()\n    if not records or len(records) <= NPeriod:\n        return \n    Bar = records[-1]\n    if LastBarTime != Bar['Time']:\n        HH = TA.Highest(records, NPeriod, 'High')\n        HC = TA.Highest(records, NPeriod, 'Close')\n        LL = TA.Lowest(records, NPeriod, 'Low')\n        LC = TA.Lowest(records, NPeriod, 'Close')\n        \n        Range = max(HH - LC, HC - LL)\n        UpTrack = _N(Bar['Open'] + (Ks * Range))\n        DownTrack = _N(Bar['Open'] - (Kx * Range))\n        if LastBarTime > 0:\n            PreBar = records[-2]\n            chart.add(0, [PreBar['Time'], PreBar['Open'], PreBar['High'], PreBar['Low'], PreBar['Close']], -1)\n        else:\n            for i in range(len(records) - min(len(records), NPeriod * 3), len(records)):\n                b = records[i]\n                chart.add(0,[b['Time'], b['Open'], b['High'], b['Low'], b['Close']])\n                \n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']])\n        ChartCfg['yAxis']['plotLines'][0]['value'] = UpTrack \n        ChartCfg['yAxis']['plotLines'][1]['value'] = DownTrack \n        ChartCfg['subtitle'] = {\n            'text': '上轨' + str(UpTrack) + '下轨' + str(DownTrack)\n        }\n        chart.update(ChartCfg)\n        chart.reset(PeriodShow)\n        \n        LastBarTime = Bar['Time']\n    else:\n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']], -1)\n        \n    LogStatus(\"Price:\", Bar[\"Close\"], \"up:\", UpTrack, \"down:\", DownTrack, \"wins:\", Counter['w'], \"losses:\", Counter['l'], \"Date:\", time.time())\n    msg = \"\"\n    if State == STATE_IDLE or State == STATE_SHORT:\n        if Bar['Close'] >= UpTrack:\n            msg = \"做多，触发价：\" + str(Bar['Close']) + \"上轨\" + str(UpTrack)\n            Log(msg)\n            Trade(State, STATE_LONG)\n            State = STATE_LONG \n            chart.add(1,{'x': Bar['Time'], 'color': 'red', 'shape': 'flag', 'title': '多', 'text': msg})\n    \n    if State == STATE_IDLE or State == STATE_LONG:\n        if Bar['Close'] <= DownTrack:\n            msg = \"做空，触发价：\" + str(Bar['Close']) + \"下轨\" + str(DownTrack)\n            Log(msg)\n            Trade(State, STATE_SHORT)\n            State = STATE_SHORT\n            chart.add(1,{'x': Bar['Time'], 'color': 'green', 'shape': 'circlepin', 'title': '空', 'text': msg})\n\nOpenPrice = 0\nClosePrice = 0\ndef Cal(OpenPrice, ClosePrice):\n    global AmountOP,State\n    if State == STATE_SHORT:\n        Log(AmountOP,OpenPrice,ClosePrice,\"策略盈亏:\", (AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice, \"个币，  手续费：\", - (100 * AmountOP * 0.0003), \"美元,折合：\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \"个币\")\n        Log(((AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\n    if State == STATE_LONG:\n        Log(AmountOP,OpenPrice,ClosePrice,\"策略盈亏:\", (AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePrice, \"个币，  手续费：\", - (100 * AmountOP * 0.0003), \"美元,折合：\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \"个币\")\n        Log(((AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\n\ndef main():\n    global LoopInterval,chart,LastAccount,InitAccount\n    if exchange.GetName() != 'Futures_OKCoin':\n        raise Error_noSupport\n    exchange.SetRate(1)\n    exchange.SetContractType([\"this_week\",\"next_week\",\"quarter\"][ContractTypeIdx]) \n    exchange.SetMarginLevel([10,20][MarginLevelIdx])\n    \n    # Log(\"Fee:\",exchange.GetFee())\n    if len(exchange.GetPosition()) > 0:\n        raise Error_AtBeginHasPosition\n    CancelPendingOrders()\n    InitAccount = LastAccount = exchange.GetAccount()\n    LoopInterval = min(1,LoopInterval)\n    Log(\"交易平台:\",exchange.GetName(), InitAccount)\n    LogStatus(\"Ready...\")\n    \n    LogProfitReset()\n    chart = Chart(ChartCfg)\n    chart.reset()\n    \n    LoopInterval = max(LoopInterval, 1)\n    while True:\n        onTick(exchange)\n        Sleep(LoopInterval * 1000)",
        "strategy_description": "策略名称: python版-Dual-Thrust-OKCoin-期货\n\npositions = exchange.GetPosition()\n    return [{'Price': position['Price'], 'Amount': position['Amount']} for position in positions if position['Type'] == posType]\n\ndef CancelPendingOrders():\n    while True:\n        orders = exchange.GetOrders()\n        [exchange.CancelOrder(order['Id']) for order in orders if not Sleep(500)]\n        if len(orders) == 0:\n            break \n\ndef Trade(currentState,nextState):\n    global InitAccount,LastAccount,OpenPrice,ClosePrice\n    ticker = _C(exchange.GetTicker)\n    slidePrice = 1\n    pfn = exchange.Buy if nextState == STATE_LONG else exchange.Sell \n    if currentState != STATE_IDLE:\n        Log(_C(exchange.GetPosition)) # ceshi \n        exchange.SetDirection(\"closebuy\" if currentState == STATE_LONG else \"closesell\")\n        while True:\n            ID = pfn( (ticker['Last'] - slidePrice) if currentState == STATE_LONG else (ticker['Last'] + slidePrice), AmountOP) # xiugai 限价单\n            # ID = pfn(-1, AmountOP) # xiugai  市价单\n            # ID = pfn(AmountOP) # xiugai  市价单\n            Sleep(Interval)\n            Log(exchange.GetOrder(ID)) # xiugai\n            ClosePrice = (exchange.GetOrder(ID))['AvgPrice'] # \n            CancelPendingOrders()\n            if len(GetPosition(PD_LONG if currentState == STATE_LONG else PD_SHORT)) == 0:\n                break \n        account = exchange.GetAccount()\n        if account['Stocks'] > LastAccount['Stocks']:\n            Counter['w'] += 1\n        else:\n            Counter['l'] += 1\n        # Log(\"ceshi account:\",account,InitAccount) #ceshi\n        Log(account) # xiugai\n        LogProfit((account['Stocks'] - InitAccount['Stocks']),\"收益率:\", ((account['Stocks'] - InitAccount['Stocks']) * 100 / InitAccount['Stocks']),'%')\n        Cal(OpenPrice,ClosePrice)\n        LsatAccount = account \n    \n    exchange.SetDirection(\"buy\" if nextState == STATE_LONG else \"sell\") \n    Log(_C(exchange.GetAccount))\n    while True:\n        ID = pfn( (ticker['Last'] + slidePrice) if nextState == STATE_LONG else (ticker['Last'] - slidePrice), AmountOP) # 限价单\n        # ID = pfn(-1, AmountOP) # 市价单\n        # ID = pfn(AmountOP) # 市价单\n        Sleep(Interval)\n        Log(exchange.GetOrder(ID)) # xiugai\n        CancelPendingOrders()\n        pos = GetPosition(PD_LONG if nextState == STATE_LONG else PD_SHORT)\n        if len(pos) != 0:\n            Log(\"持仓均价\",pos[0]['Price'],\"数量:\",pos[0]['Amount'])\n            OpenPrice = (exchange.GetOrder(ID))['AvgPrice'] # pos[0]['Price']\n            Log(\"now account:\",exchange.GetAccount())\n            break \n\ndef onTick(exchange):\n    global LastBarTime,chart,State,UpTrack,DownTrack,LastAccount\n    records = exchange.GetRecords()\n    if not records or len(records) <= NPeriod:\n        return \n    Bar = records[-1]\n    if LastBarTime != Bar['Time']:\n        HH = TA.Highest(records, NPeriod, 'High')\n        HC = TA.Highest(records, NPeriod, 'Close')\n        LL = TA.Lowest(records, NPeriod, 'Low')\n        LC = TA.Lowest(records, NPeriod, 'Close')\n        \n        Range = max(HH - LC, HC - LL)\n        UpTrack = _N(Bar['Open'] + (Ks * Range))\n        DownTrack = _N(Bar['Open'] - (Kx * Range))\n        if LastBarTime > 0:\n            PreBar = records[-2]\n            chart.add(0, [PreBar['Time'], PreBar['Open'], PreBar['High'], PreBar['Low'], PreBar['Close']], -1)\n        else:\n            for i in range(len(records) - min(len(records), NPeriod * 3), len(records)):\n                b = records[i]\n                chart.add(0,[b['Time'], b['Open'], b['High'], b['Low'], b['Close']])\n                \n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']])\n        ChartCfg['yAxis']['plotLines'][0]['value'] = UpTrack \n        ChartCfg['yAxis']['plotLines'][1]['value'] = DownTrack \n        ChartCfg['subtitle'] = {\n            'text': '上轨' + str(UpTrack) + '下轨' + str(DownTrack)\n        }\n        chart.update(ChartCfg)\n        chart.reset(PeriodShow)\n        \n        LastBarTime = Bar['Time']\n    else:\n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']], -1)\n        \n    LogStatus(\"Price:\", Bar[\"Close\"], \"up:\", UpTrack, \"down:\", DownTrack, \"wins:\", Counter['w'], \"losses:\", Counter['l'], \"Date:\", time.time())\n    msg = \"\"\n    if State == STATE_IDLE or State == STATE_SHORT:\n        if Bar['Close'] >= UpTrack:\n            msg = \"做多，触发价：\" + str(Bar['Close']) + \"上轨\" + str(UpTrack)\n            Log(msg)\n            Trade(State, STATE_LONG)\n            State = STATE_LONG \n            chart.add(1,{'x': Bar['Time'], 'color': 'red', 'shape': 'flag', 'title': '多', 'text': msg})\n    \n    if State == STATE_IDLE or State == STATE_LONG:\n        if Bar['Close'] <= DownTrack:\n            msg = \"做空，触发价：\" + str(Bar['Close']) + \"下轨\" + str(DownTrack)\n            Log(msg)\n            Trade(State, STATE_SHORT)\n            State = STATE_SHORT\n            chart.add(1,{'x': Bar['Time'], 'color': 'green', 'shape': 'circlepin', 'title': '空', 'text': msg})\n\nOpenPrice = 0\nClosePrice = 0\ndef Cal(OpenPrice, ClosePrice):\n    global AmountOP,State\n    if State == STATE_SHORT:\n        Log(AmountOP,OpenPrice,ClosePrice,\"策略盈亏:\", (AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice, \"个币，  手续费：\", - (100 * AmountOP * 0.0003), \"美元,折合：\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \"个币\")\n        Log(((AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\n    if State == STATE_LONG:\n        Log(AmountOP,OpenPrice,ClosePrice,\"策略盈亏:\", (AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePrice, \"个币，  手续费：\", - (100 * AmountOP * 0.0003), \"美元,折合：\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \"个币\")\n        Log(((AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\n\ndef main():\n    global LoopInterval,chart,LastAccount,InitAccount\n    if exchange.GetName() != 'Futures_OKCoin':\n        raise Error_noSupport\n    exchange.SetRate(1)\n    exchange.SetContractType([\"this_week\",\"next_week\",\"quarter\"][ContractTypeIdx]) \n    exchange.SetMarginLevel([10,20][MarginLevelIdx])\n    \n    # Log(\"Fee:\",exchange.GetFee())\n    if len(exchange.GetPosition()) > 0:\n        raise Error_AtBeginHasPosition\n    CancelPendingOrders()\n    InitAccount = LastAccount = exchange.GetAccount()\n    LoopInterval = min(1,LoopInterval)\n    Log(\"交易平台:\",exchange.GetName(), InitAccount)\n    LogStatus(\"Ready...\")\n    \n    LogProfitReset()\n    chart = Chart(ChartCfg)\n    chart.reset()\n    \n    LoopInterval = max(LoopInterval, 1)\n    while True:\n        onTick(exchange)\n        Sleep(LoopInterval * 1000)\n    \n    \n\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/21856\n\n> Last Modified\n\n2018-03-23 16:53:49"
    },
    {
        "strategy_id": "54_python版-画线类库-兼容2-3-Python-Version-Drawing-Class-Library-Compatible-2-3",
        "strategy_code": "python\n# Python 2/3 兼容版本\nimport time\nchart = None\nseries = []\nlabelIdx = {}\npreBarTime = 0\npreFlagTime = 0\npreDotTime = {}\n\ncfg = {\n    \"tooltip\" : {\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\"\n    },\n    \"legend\" : {\n        \"enabled\" : True\n    },\n    \"plotOptions\" : {\n        \"candlestick\" : {\n            \"color\" : \"#d75442\",\n            \"upColor\" : \"#6ba583\"\n        }\n    },\n    \"rangeSelector\" : {\n        \"buttons\" : [{\n            \"type\" : \"hour\",\n            \"count\" : 1,\n            \"text\" : \"1h\",\n        }, {\n            \"type\" : 'hour',\n            \"count\" : 3,\n            \"text\" : \"3h\"\n        }, {\n            \"type\" : \"hour\",\n            \"count\" : 8,\n            \"text\" : \"8h\"\n        }, {\n            \"type\" : \"all\",\n            \"text\" : \"All\"\n        }],\n        \"selected\" : 2,\n        \"inputEnabled\" : True\n    },\n    \"series\" : series,\n}\n\ndef GetCfg():\n    global cfg\n    return cfg\n\n# 画水平线\ndef PlotHLine(value = None, label = None, color = None, style = None):\n    global cfg, chart\n    if (\"yAxis\" in cfg) == False :\n        cfg.setdefault(\"yAxis\", {\"plotLines\" : []})\n    elif (\"plotLines\" in cfg[\"yAxis\"]) == False :\n        cfg[\"yAxis\"].setdefault(\"plotLines\", [])\n    \n    obj = {\n        \"value\" : value,\n        \"color\" : color or \"red\",\n        \"width\" : 2,\n        \"dashStyle\" : style or \"Solid\",\n        \"label\" : {\n            \"text\" : label or \"\",\n            \"align\" : \"center\"\n        }\n    }\n    found = False\n    for i in range(len(cfg[\"yAxis\"][\"plotLines\"])) : \n        if cfg[\"yAxis\"][\"plotLines\"][i][\"label\"][\"text\"] == label : \n            cfg[\"yAxis\"][\"plotLines\"][i] = obj\n            found = True\n    if not found :\n        cfg[\"yAxis\"][\"plotLines\"].append(obj)\n    if not chart :\n        chart = Chart(cfg)\n        chart.update(cfg)    # 更新图表\n    else :\n        chart.update(cfg)\n\n# 画K线\ndef PlotRecords(records, title = None):\n    global labelIdx, series, preBarTime, chart\n    if not chart :\n        chart = Chart(cfg)\n        chart.reset()\n    if (\"candlestick\" in labelIdx) == False : \n        cfg[\"__isStock\"] = True\n        seriesIdx = len(series)\n        series.append({\n            \"type\" : \"candlestick\",\n            \"name\" : \"\" if title == None else title,\n            \"id\" : \"primary\",\n            \"data\" : []\n            })\n        chart.update(cfg)\n        labelIdx.setdefault(\"candlestick\", seriesIdx)\n    else :\n        seriesIdx = labelIdx[\"candlestick\"]\n    if isinstance(records, dict) and (\"Time\" in records) == True :\n        Bar = records\n        if Bar[\"Time\"] == preBarTime :\n            chart.add(seriesIdx, [Bar[\"Time\"], Bar[\"Open\"], Bar[\"High\"], Bar[\"Low\"], Bar[\"Close\"]], -1)\n        elif Bar[\"Time\"] > preBarTime : \n            preBarTime = Bar.Time\n            chart.add(seriesIdx, [Bar[\"Time\"], Bar[\"Open\"], Bar[\"High\"], Bar[\"Low\"], Bar[\"Close\"]])    \n    else :\n        for i in range(len(records)) :\n            if records[i][\"Time\"] == preBarTime :\n                chart.add(seriesIdx, [records[i][\"Time\"], records[i][\"Open\"], records[i][\"High\"], records[i][\"Low\"], records[i][\"Close\"]], -1)\n            elif records[i][\"Time\"] > preBarTime :\n                preBarTime = records[i][\"Time\"]\n                chart.add(seriesIdx, [records[i][\"Time\"], records[i][\"Open\"], records[i][\"High\"], records[i][\"Low\"], records[i][\"Close\"]])\n    return chart\n\n# 画指标线\ndef PlotLine(label, dot, Ntime = None):\n    global labelIdx, chart, series, preDotTime\n    if not chart :\n        cfg.setdefault(\"xAxis\", {\n            \"type\" : \"datetime\"\n            })\n        chart = Chart(cfg)\n        chart.reset()\n    if (label in labelIdx) == False :\n        seriesIdx = len(series)\n        preDotTime.setdefault(str(seriesIdx), 0)\n        labelIdx[label] = seriesIdx\n        series.append({\n            \"type\" : \"line\",\n            \"yAxis\" : 0,\n            \"showInLegend\" : True,\n            \"name\" : label,\n            \"data\" : [],\n            \"tooltip\" : {\"valueDecimals\" : 5}\n            })\n        chart.update(cfg)\n    else :\n        seriesIdx = labelIdx[label]\n    if Ntime == None :\n        Ntime = _N(time.time() * 1000, 0)\n    if preDotTime[str(seriesIdx)] != Ntime :\n        preDotTime[str(seriesIdx)] = Ntime\n        chart.add(seriesIdx, [Ntime, dot])\n    else :\n        chart.add(seriesIdx, [Ntime, dot], -1)\n    return chart\n\n# 画标记\ndef PlotFlag(time, text, title, shape = \"\", color = \"\"):\n    global chart, cfg, labelIdx, preFlagTime\n    if not chart :\n        chart = Chart(cfg)\n        chart.reset()\n    label = \"flag\"\n    if (label in labelIdx) == False : \n        seriesIdx = len(series)\n        labelIdx[label] = seriesIdx\n        series.append({\n            \"type\" : \"flags\",\n            \"onSeries\" : \"primary\",\n            \"data\" : []\n            })\n        chart.update(cfg)\n    else :\n        seriesIdx = labelIdx[label]\n    obj = {\n        \"x\" : time,\n        \"color\" : color,\n        \"shape\" : shape,\n        \"title\" : title,\n        \"text\" : text\n    }\n    if preFlagTime != time : \n        preFlagTime = time\n        chart.add(seriesIdx, obj)\n    else :\n        chart.add(seriesIdx, obj, -1)\n    return chart\n\n# 设置图表标题\ndef PlotTitle(title, chartTitle = None):\n    global cfg\n    if (\"subtitle\" in cfg) == True : \n        cfg[\"subtitle\"] = {\"text\" : title}\n    else :\n        cfg.setdefault(\"subtitle\", {\"text\" : title})\n    if chartTitle != None :\n        if (title in cfg) == True :\n            cfg[\"title\"] = {\"text\" : chartTitle}\n        else :\n            cfg.setdefault(\"title\", {\"text\" : chartTitle})\n    if chart :\n        chart.update(cfg)\n\n# 导出函数\next.GetCfg = GetCfg\next.PlotHLine = PlotHLine\next.PlotRecords = PlotRecords\next.PlotLine = PlotLine\next.PlotFlag = PlotFlag\next.PlotTitle = PlotTitle\n\n# 测试代码\ndef main():\n    isFirst = True\n    while True:\n        records = exchange.GetRecords()\n        if records and len(records) > 0 :\n            ext.PlotRecords(records, \"BTC\")\n            if isFirst :\n                ext.PlotFlag(records[-1][\"Time\"], \"Start\", \"S\")\n                isFirst = False\n                ext.PlotHLine(records[-1][\"Close\"], \"Close\")\n        ticker = exchange.GetTicker()\n        if ticker :\n            ext.PlotLine(\"Last\", ticker.Last)\n            ext.PlotLine(\"buy\", ticker.Buy + 10)\n            ext.PlotTitle(\"Last\" + str(ticker.Last))\n        Sleep(60000)",
        "strategy_description": "策略名称: python版-画线类库-兼容2-3-Python-Version-Drawing-Class-Library-Compatible-2-3\n\n> Source (python)\n\n``` python"
    },
    {
        "strategy_id": "55_python版现货数字货币交易类库Python-Version-Spot-Cryptocurrency-Trading-Class-Library",
        "strategy_code": "python\nimport types # 导入类型模块\nimport time  # 导入时间模块\nimport platform # 版本信息 \n\nversionMainValue = None\nisFirstCheck = True\ndef typeOfstr(str):\n    if str == \"list\":\n        if versionMainValue == 2:\n            return types.ListType\n        elif versionMainValue == 3:\n            return list\n    elif str == \"int\":\n        if versionMainValue == 2:\n            return types.IntType\n        elif versionMainValue == 3:\n            return int\n    elif str == \"float\":\n        if versionMainValue == 2:\n            return types.FloatType\n        elif versionMainValue == 3:\n            return float\n    else:\n        Log(\"error , typeOfstr used false\")\n            \ndef CheckVersion():\n    global versionMainValue,isFirstCheck\n    platformInfo = platform.python_version()\n    if platformInfo[0] == '2':\n        Log(\"您使用的托管者 python编译环境的python版本是\",platformInfo)\n        versionMainValue = 2\n    elif platformInfo[0] == '3':\n        Log(\"您使用的托管者 python编译环境的python版本是\",platformInfo)\n        versionMainValue = 3\n    else:\n        Log(\"其它版本\")\n    isFirstCheck = False\n\ndef CancelPendingOrders(e, orderType = \"\") : # 取消所有未完成挂单\n    while True: # 循环\n        orders = e.GetOrders()\n        LogStatus(\"orders:\",orders,time.time()) # 测试\n        if(type(orders) != typeOfstr(\"list\")):\n            Sleep(RetryDelay)\n            continue\n        processed = 0\n        for j in range(len(orders)):\n            if (type(orderType) == typeOfstr(\"int\") and orders[j].Type != orderType):\n                continue\n            e.CancelOrder(orders[j].Id,orders[j])\n            processed += 1\n            if (j < (len(orders) - 1)):\n                Sleep(RetryDelay)\n        if(processed == 0):\n            break\n\ndef GetAccount(e, waitFrozen = False):\n    account = null\n    alreadyAlert = False\n    while True:\n        account = _C(e.GetAccount)\n        if(not waitFrozen or (account.FrozenStocks < _GetMinStocks and account.FrozenBalance < 0.01)):\n            break\n        if(not alreadyAlert):\n            alreadyAlert = True\n            Log(\"发现账户有冻结的钱或币\",account)\n        Sleep(RetryDelay)\n    return account\n\ndef StripOrders(e,orderId = null):\n    order = null\n    while True:\n        dropped = 0\n        orders = _C(e.GetOrders)\n        for i in range(len(orders)):\n            if(orders[i].Id == orderId):\n                order = orders[i]\n            else:\n                extra = \"\"\n                if(orders[i].DealAmount > 0):\n                    extra = \"成交：\" + str(orders[i].DealAmount)\n                else:\n                    extra = \"未成交\"\n                e.CancelOrder(orders[i].Id,\"买单\" if orders[i].Type == ORDER_TYPE_BUY else \"卖单\",extra)\n                dropped += 1\n        if(dropped == 0):\n            break\n        Sleep(RetryDelay)\n    return order\n\ndef Trade(e,tradeType,tradeAmount,mode,slidePrice,maxAmount,maxSpace,retryDelay):\n    initAccount = GetAccount(e,True)\n    nowAccount = initAccount\n    orderId = null\n    prePrice = 0.0\n    dealAmount = 0.0\n    diffMoney = 0.0\n    isFirst = True\n    tradeFunc = e.Buy if tradeType == ORDER_TYPE_BUY else e.Sell\n    isBuy = (tradeType == ORDER_TYPE_BUY)\n    while True:\n        ticker = _C(e.GetTicker)\n        tradePrice = 0.0\n        if(isBuy):\n            tradePrice = _N((ticker.Sell if mode == 0 else ticker.Buy) + slidePrice,4)\n        else:\n            tradePrice = _N((ticker.Buy if mode == 0 else ticker.Sell) - slidePrice,4)\n        if(not orderId):\n            if(isFirst):\n                isFirst = False\n            else:\n                nowAccount = GetAccount(e,True)\n            doAmount = 0.0;\n            if(isBuy):\n                diffMoney = _N(initAccount.Balance - nowAccount.Balance,4)\n                dealAmount = _N(nowAccount.Stocks - initAccount.Stocks,4)\n                doAmount = min(maxAmount,tradeAmount - dealAmount,_N((nowAccount.Balance - 10) / tradePrice,4))\n            else:\n                diffMoney = _N(nowAccount.Balance - initAccount.Balance,4)\n                dealAmount = _N(initAccount.Stocks - nowAccount.Stocks,4)\n                doAmount = min(maxAmount,tradeAmount - dealAmount,nowAccount.Stocks)\n            if(doAmount < _GetMinStocks):\n                break\n            prePrice = tradePrice\n            orderId = tradeFunc(tradePrice,doAmount,ticker)\n            if(not orderId):\n                CancelPendingOrders(e,tradeType)\n        else:\n            if(mode == 0 or (abs(tradePrice - prePrice) > maxSpace)):\n                orderId = null\n            order = StripOrders(e,orderId)\n            if(not order):\n                orderId = null\n        Sleep(retryDelay)\n    if(dealAmount <= 0):\n        Log(\"交易失败--TradeType:\",\"buy\" if tradeType == ORDER_TYPE_BUY else \"sell\",\"  ,diffMoney:\",diffMoney,\"  ,dealAmount\",dealAmount,\"  ,doAmount\",doAmount)\n        return null\n    \n    ret = {'price': _N(diffMoney/dealAmount,4),'amount':dealAmount}\n    return ret\n    # 调用时 这样写  ret['price'] 、 ret['amount']\n\ndef _Buy(e = exchange,amount = 0):\n    if isFirstCheck:\n        CheckVersion()\n    if (type(e) == typeOfstr(\"int\") or type(e) == typeOfstr(\"float\")):\n        amount = e\n        e = exchange\n    return Trade(e,ORDER_TYPE_BUY,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\n\ndef _Sell(e = exchange,amount = 0):\n    if isFirstCheck:\n        CheckVersion()\n    if (type(e) == typeOfstr(\"int\") or type(e) == typeOfstr(\"float\")):\n        amount = e\n        e = exchange\n    return Trade(e,ORDER_TYPE_SELL,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\n\ndef _CancelPendingOrders(e = exchange,orderType = \"\"):\n    if isFirstCheck:\n        CheckVersion()\n    return CancelPendingOrders(e,orderType)\n\ndef _GetAccount(e = exchange):\n    if isFirstCheck:\n        CheckVersion()\n    return _C(e.GetAccount)\n\n_MACalcMethod = [TA.EMA,TA.MA][MAType]\nInterval = 200\ndef Cross(a,b):\n    if isFirstCheck:\n        CheckVersion()\n    crossNum = 0\n    arr1 = []\n    arr2 = []\n    if type(a) == typeOfstr(\"list\") and type(b) == typeOfstr(\"list\"):\n        arr1 = a\n        arr2 = b\n    else:\n        records = null\n        while True:\n            records = exchange.GetRecords()\n            if records and len(records) > a and len(records) > b:\n                break\n            Sleep(Interval)\n        arr1 = _MACalcMethod(records,a)\n        arr2 = _MACalcMethod(records,b)\n    if len(arr1) != len(arr2):\n        raise Exception(\"array length not equal\")\n    for i in range(len(arr1) - 1,-1,-1):\n        if (type(arr1[i]) != typeOfstr(\"int\") and type(arr1[i]) != typeOfstr(\"float\")) or (type(arr2[i]) != typeOfstr(\"int\") and type(arr2[i]) != typeOfstr(\"float\")):\n            break\n        if arr1[i] < arr2[i] :\n            if crossNum > 0 :\n                break\n            crossNum -= 1\n        elif arr1[i] > arr2[i] :\n            if crossNum < 0 :\n                break\n            crossNum += 1\n        else:\n            break\n    return crossNum\n\n\n# 导出函数\next.Buy = _Buy\next.Sell = _Sell\next.CancelPendingOrders = _CancelPendingOrders\next.GetAccount = _GetAccount\next.Cross = Cross\n\n# 测试\ndef main():\n    ret = ext.Buy(0.2)\n    exchange.Sell(4500,1)\n    Sleep(10 * 1000)\n    ext.CancelPendingOrders()\n    Log(\"ret:\",ret)\n    avgprice = ret['price']\n    dealamount = ret['amount']\n    Log(\"avgprice:\",avgprice,\"  dealamount:\",dealamount)",
        "strategy_description": "策略名称: python版现货数字货币交易类库Python-Version-Spot-Cryptocurrency-Trading-Class-Library\n\nimport time  # 导入时间模块\nimport platform # 版本信息 \n\nversionMainValue = None\nisFirstCheck = True\ndef typeOfstr(str):\n    if str == \"list\":\n        if versionMainValue == 2:\n            return types.ListType\n        elif versionMainValue == 3:\n            return list\n    elif str == \"int\":\n        if versionMainValue == 2:\n            return types.IntType\n        elif versionMainValue == 3:\n            return int\n    elif str == \"float\":\n        if versionMainValue == 2:\n            return types.FloatType\n        elif versionMainValue == 3:\n            return float\n    else:\n        Log(\"error , typeOfstr used false\")\n            \ndef CheckVersion():\n    global versionMainValue,isFirstCheck\n    platformInfo = platform.python_version()\n    if platformInfo[0] == '2':\n        Log(\"您使用的托管者 python编译环境的python版本是\",platformInfo)\n        versionMainValue = 2\n    elif platformInfo[0] == '3':\n        Log(\"您使用的托管者 python编译环境的python版本是\",platformInfo)\n        versionMainValue = 3\n    else:\n        Log(\"其它版本\")\n    isFirstCheck = False\n\ndef CancelPendingOrders(e, orderType = \"\") : # 取消所有未完成挂单\n    while True: # 循环\n        orders = e.GetOrders()\n        LogStatus(\"orders:\",orders,time.time()) # 测试\n        if(type(orders) != typeOfstr(\"list\")):\n            Sleep(RetryDelay)\n            continue\n        processed = 0\n        for j in range(len(orders)):\n            if (type(orderType) == typeOfstr(\"int\") and orders[j].Type != orderType):\n                continue\n            e.CancelOrder(orders[j].Id,orders[j])\n            processed += 1\n            if (j < (len(orders) - 1)):\n                Sleep(RetryDelay)\n        if(processed == 0):\n            break\n\ndef GetAccount(e, waitFrozen = False):\n    account = null\n    alreadyAlert = False\n    while True:\n        account = _C(e.GetAccount)\n        if(not waitFrozen or (account.FrozenStocks < _GetMinStocks and account.FrozenBalance < 0.01)):\n            break\n        if(not alreadyAlert):\n            alreadyAlert = True\n            Log(\"发现账户有冻结的钱或币\",account)\n        Sleep(RetryDelay)\n    return account\n\ndef StripOrders(e,orderId = null):\n    order = null\n    while True:\n        dropped = 0\n        orders = _C(e.GetOrders)\n        for i in range(len(orders)):\n            if(orders[i].Id == orderId):\n                order = orders[i]\n            else:\n                extra = \"\"\n                if(orders[i].DealAmount > 0):\n                    extra = \"成交：\" + str(orders[i].DealAmount)\n                else:\n                    extra = \"未成交\"\n                e.CancelOrder(orders[i].Id,\"买单\" if orders[i].Type == ORDER_TYPE_BUY else \"卖单\",extra)\n                dropped += 1\n        if(dropped == 0):\n            break\n        Sleep(RetryDelay)\n    return order\n\ndef Trade(e,tradeType,tradeAmount,mode,slidePrice,maxAmount,maxSpace,retryDelay):\n    initAccount = GetAccount(e,True)\n    nowAccount = initAccount\n    orderId = null\n    prePrice = 0.0\n    dealAmount = 0.0\n    diffMoney = 0.0\n    isFirst = True\n    tradeFunc = e.Buy if tradeType == ORDER_TYPE_BUY else e.Sell\n    isBuy = (tradeType == ORDER_TYPE_BUY)\n    while True:\n        ticker = _C(e.GetTicker)\n        tradePrice = 0.0\n        if(isBuy):\n            tradePrice = _N((ticker.Sell if mode == 0 else ticker.Buy) + slidePrice,4)\n        else:\n            tradePrice = _N((ticker.Buy if mode == 0 else ticker.Sell) - slidePrice,4)\n        if(not orderId):\n            if(isFirst):\n                isFirst = False\n            else:\n                nowAccount = GetAccount(e,True)\n            doAmount = 0.0;\n            if(isBuy):\n                diffMoney = _N(initAccount.Balance - nowAccount.Balance,4)\n                dealAmount = _N(nowAccount.Stocks - initAccount.Stocks,4)\n                doAmount = min(maxAmount,tradeAmount - dealAmount,_N((nowAccount.Balance - 10) / tradePrice,4))\n            else:\n                diffMoney = _N(nowAccount.Balance - initAccount.Balance,4)\n                dealAmount = _N(initAccount.Stocks - nowAccount.Stocks,4)\n                doAmount = min(maxAmount,tradeAmount - dealAmount,nowAccount.Stocks)\n            if(doAmount < _GetMinStocks):\n                break\n            prePrice = tradePrice\n            orderId = tradeFunc(tradePrice,doAmount,ticker)\n            if(not orderId):\n                CancelPendingOrders(e,tradeType)\n        else:\n            if(mode == 0 or (abs(tradePrice - prePrice) > maxSpace)):\n                orderId = null\n            order = StripOrders(e,orderId)\n            if(not order):\n                orderId = null\n        Sleep(retryDelay)\n    if(dealAmount <= 0):\n        Log(\"交易失败--TradeType:\",\"buy\" if tradeType == ORDER_TYPE_BUY else \"sell\",\"  ,diffMoney:\",diffMoney,\"  ,dealAmount\",dealAmount,\"  ,doAmount\",doAmount)\n        return null\n    \n    ret = {'price': _N(diffMoney/dealAmount,4),'amount':dealAmount}\n    return ret\n    # 调用时 这样写  ret['price'] 、 ret['amount']\n\ndef _Buy(e = exchange,amount = 0):\n    if isFirstCheck:\n        CheckVersion()\n    if (type(e) == typeOfstr(\"int\") or type(e) == typeOfstr(\"float\")):\n        amount = e\n        e = exchange\n    return Trade(e,ORDER_TYPE_BUY,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\n\ndef _Sell(e = exchange,amount = 0):\n    if isFirstCheck:\n        CheckVersion()\n    if (type(e) == typeOfstr(\"int\") or type(e) == typeOfstr(\"float\")):\n        amount = e\n        e = exchange\n    return Trade(e,ORDER_TYPE_SELL,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\n\ndef _CancelPendingOrders(e = exchange,orderType = \"\"):\n    if isFirstCheck:\n        CheckVersion()\n    return CancelPendingOrders(e,orderType)\n\ndef _GetAccount(e = exchange):\n    if isFirstCheck:\n        CheckVersion()\n    return _C(e.GetAccount)\n\n_MACalcMethod = [TA.EMA,TA.MA][MAType]\nInterval = 200\ndef Cross(a,b):\n    if isFirstCheck:\n        CheckVersion()\n    crossNum = 0\n    arr1 = []\n    arr2 = []\n    if type(a) == typeOfstr(\"list\") and type(b) == typeOfstr(\"list\"):\n        arr1 = a\n        arr2 = b\n    else:\n        records = null\n        while True:\n            records = exchange.GetRecords()\n            if records and len(records) > a and len(records) > b:\n                break\n            Sleep(Interval)\n        arr1 = _MACalcMethod(records,a)\n        arr2 = _MACalcMethod(records,b)\n    if len(arr1) != len(arr2):\n        raise Exception(\"array length not equal\")\n    for i in range(len(arr1) - 1,-1,-1):\n        if (type(arr1[i]) != typeOfstr(\"int\") and type(arr1[i]) != typeOfstr(\"float\")) or (type(arr2[i]) != typeOfstr(\"int\") and type(arr2[i]) != typeOfstr(\"float\")):\n            break\n        if arr1[i] < arr2[i] :\n            if crossNum > 0 :\n                break\n            crossNum -= 1\n        elif arr1[i] > arr2[i] :\n            if crossNum < 0 :\n                break\n            crossNum += 1\n        else:\n            break\n    return crossNum"
    },
    {
        "strategy_id": "56_robotCtrl教学策略",
        "strategy_code": "python\n# -*- coding: utf-8 -*-\nimport time\nimport json\n\ntry:\n    import md5\n    import urllib2\n    from urllib import urlencode\nexcept:\n    import hashlib as md5\n    import urllib.request as urllib2\n    from urllib.parse import urlencode\n\ndef api(method, *args):\n    d = {\n        'version': '1.0',\n        'access_key': accessKey,\n        'method': method,\n        'args': json.dumps(list(args)),\n        'nonce': int(time.time() * 1000),\n        }\n\n    d['sign'] = md5.md5(('%s|%s|%s|%d|%s' % (d['version'], d['method'], d['args'], d['nonce'], secretKey)).encode('utf-8')).hexdigest()\n    return json.loads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\n\nRobotParams = json.loads(strRobotParams)\n\ndef main():\n    global RobotParams \n    arrParams = []\n    nowDay = 0\n    strPush = \"\"\n    if isPushMsg:\n        strPush = \"@\"\n\n    for i in range(len(RobotParams)):\n        param = {}\n        arr = RobotParams[i].split(\",\")\n        if len(arr) != 2:\n            raise Exception(\"字符串配置错误：分隔符号,\")\n        param[\"id\"] = arr[0]\n        param[\"isProcessOpenThisDay\"] = False\n        param[\"isProcessCloseThisDay\"] = False\n\n        arr = arr[1].split(\"-\")\n        if len(arr) != 2:\n            raise Exception(\"字符串配置错误：分隔符号-\")\n\n        begin = arr[0]\n        arrBegin = begin.split(\":\")\n        if len(arrBegin) != 3:\n            raise Exception(\"字符串配置错误：起始时间分隔符号:\")\n        \n        param[\"begin\"] = {}\n        param[\"begin\"][\"hour\"] = float(arrBegin[0])\n        param[\"begin\"][\"min\"] = float(arrBegin[1])\n        param[\"begin\"][\"sec\"] = float(arrBegin[2])\n\n        end = arr[1]\n        arrEnd = end.split(\":\")\n        if len(arrEnd) != 3:\n            raise Exception(\"字符串配置错误：结束时间分隔符号:\")            \n        \n        param[\"end\"] = {}\n        param[\"end\"][\"hour\"] = float(arrEnd[0])\n        param[\"end\"][\"min\"] = float(arrEnd[1])\n        param[\"end\"][\"sec\"] = float(arrEnd[2])\n        arrParams.append(param)\n\n    # 测试\n    Log(\"输出参数\", arrParams, \"#FF0000\")  \n\n    while True:\n        nowTime = time.localtime(time.time())\n        nowHour = nowTime.tm_hour \n        nowMin = nowTime.tm_min\n        nowSec = nowTime.tm_sec\n        \n        tbl = {\n            \"type\" : \"table\", \n            \"title\" : \"msg\", \n            \"cols\" : [\"id\", \"begin\", \"end\", \"今天是否执行过启动\", \"今天是否执行过停止\"],\n            \"rows\" : []\n        }\n\n        for i in range(len(arrParams)):\n            tbl[\"rows\"].append([arrParams[i][\"id\"], json.dumps(arrParams[i][\"begin\"]), json.dumps(arrParams[i][\"end\"]), arrParams[i][\"isProcessOpenThisDay\"], arrParams[i][\"isProcessCloseThisDay\"]])\n            if nowDay != nowTime.tm_mday:\n                arrParams[i][\"isProcessOpenThisDay\"] = False\n                arrParams[i][\"isProcessCloseThisDay\"] = False\n\n            if arrParams[i][\"isProcessOpenThisDay\"] == False:\n                if nowTime.tm_hour == arrParams[i][\"begin\"][\"hour\"] and nowTime.tm_min >= arrParams[i][\"begin\"][\"min\"] and nowTime.tm_sec >= arrParams[i][\"begin\"][\"sec\"]:\n                    ret = api('RestartRobot', int(arrParams[i][\"id\"]))                    \n                    arrParams[i][\"isProcessOpenThisDay\"] = True\n                    Log(\"机器人ID:\", arrParams[i][\"id\"], \"执行启动，请登录平台检查是否启动成功\", \"扩展API返回值：\", ret, strPush)\n\n            if arrParams[i][\"isProcessCloseThisDay\"] == False:\n                if nowTime.tm_hour == arrParams[i][\"end\"][\"hour\"] and nowTime.tm_min >= arrParams[i][\"end\"][\"min\"] and nowTime.tm_sec >= arrParams[i][\"end\"][\"sec\"]:\n                    ret = api('StopRobot', int(arrParams[i][\"id\"]))\n                    arrParams[i][\"isProcessCloseThisDay\"] = True\n                    Log(\"机器人ID:\", arrParams[i][\"id\"], \"执行停止，请登录平台检查是否停止成功\", \"扩展API返回值：\", ret, strPush)\n        \n        if nowDay != nowTime.tm_mday:\n            nowDay = nowTime.tm_mday\n\n        LogStatus(_D(), nowTime, \"\\n`\" + json.dumps(tbl) + \"`\")\n        Sleep(500)",
        "strategy_description": "策略名称: robotCtrl教学策略\n\nimport time\nimport json\n\ntry:\n    import md5\n    import urllib2\n    from urllib import urlencode\nexcept:\n    import hashlib as md5\n    import urllib.request as urllib2\n    from urllib.parse import urlencode\n\ndef api(method, *args):\n    d = {\n        'version': '1.0',\n        'access_key': accessKey,\n        'method': method,\n        'args': json.dumps(list(args)),\n        'nonce': int(time.time() * 1000),\n        }\n\n    d['sign'] = md5.md5(('%s|%s|%s|%d|%s' % (d['version'], d['method'], d['args'], d['nonce'], secretKey)).encode('utf-8')).hexdigest()\n    return json.loads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\n\nRobotParams = json.loads(strRobotParams)\n\ndef main():\n    global RobotParams \n    arrParams = []\n    nowDay = 0\n    strPush = \"\"\n    if isPushMsg:\n        strPush = \"@\"\n\n    for i in range(len(RobotParams)):\n        param = {}\n        arr = RobotParams[i].split(\",\")\n        if len(arr) != 2:\n            raise Exception(\"字符串配置错误：分隔符号,\")\n        param[\"id\"] = arr[0]\n        param[\"isProcessOpenThisDay\"] = False\n        param[\"isProcessCloseThisDay\"] = False\n\n        arr = arr[1].split(\"-\")\n        if len(arr) != 2:\n            raise Exception(\"字符串配置错误：分隔符号-\")\n\n        begin = arr[0]\n        arrBegin = begin.split(\":\")\n        if len(arrBegin) != 3:\n            raise Exception(\"字符串配置错误：起始时间分隔符号:\")\n        \n        param[\"begin\"] = {}\n        param[\"begin\"][\"hour\"] = float(arrBegin[0])\n        param[\"begin\"][\"min\"] = float(arrBegin[1])\n        param[\"begin\"][\"sec\"] = float(arrBegin[2])\n\n        end = arr[1]\n        arrEnd = end.split(\":\")\n        if len(arrEnd) != 3:\n            raise Exception(\"字符串配置错误：结束时间分隔符号:\")            \n        \n        param[\"end\"] = {}\n        param[\"end\"][\"hour\"] = float(arrEnd[0])\n        param[\"end\"][\"min\"] = float(arrEnd[1])\n        param[\"end\"][\"sec\"] = float(arrEnd[2])\n        arrParams.append(param)\n\n    # 测试\n    Log(\"输出参数\", arrParams, \"#FF0000\")  \n\n    while True:\n        nowTime = time.localtime(time.time())\n        nowHour = nowTime.tm_hour \n        nowMin = nowTime.tm_min\n        nowSec = nowTime.tm_sec\n        \n        tbl = {\n            \"type\" : \"table\", \n            \"title\" : \"msg\", \n            \"cols\" : [\"id\", \"begin\", \"end\", \"今天是否执行过启动\", \"今天是否执行过停止\"],\n            \"rows\" : []\n        }\n\n        for i in range(len(arrParams)):\n            tbl[\"rows\"].append([arrParams[i][\"id\"], json.dumps(arrParams[i][\"begin\"]), json.dumps(arrParams[i][\"end\"]), arrParams[i][\"isProcessOpenThisDay\"], arrParams[i][\"isProcessCloseThisDay\"]])\n            if nowDay != nowTime.tm_mday:\n                arrParams[i][\"isProcessOpenThisDay\"] = False\n                arrParams[i][\"isProcessCloseThisDay\"] = False\n\n            if arrParams[i][\"isProcessOpenThisDay\"] == False:\n                if nowTime.tm_hour == arrParams[i][\"begin\"][\"hour\"] and nowTime.tm_min >= arrParams[i][\"begin\"][\"min\"] and nowTime.tm_sec >= arrParams[i][\"begin\"][\"sec\"]:\n                    ret = api('RestartRobot', int(arrParams[i][\"id\"]))                    \n                    arrParams[i][\"isProcessOpenThisDay\"] = True\n                    Log(\"机器人ID:\", arrParams[i][\"id\"], \"执行启动，请登录平台检查是否启动成功\", \"扩展API返回值：\", ret, strPush)\n\n            if arrParams[i][\"isProcessCloseThisDay\"] == False:\n                if nowTime.tm_hour == arrParams[i][\"end\"][\"hour\"] and nowTime.tm_min >= arrParams[i][\"end\"][\"min\"] and nowTime.tm_sec >= arrParams[i][\"end\"][\"sec\"]:\n                    ret = api('StopRobot', int(arrParams[i][\"id\"]))\n                    arrParams[i][\"isProcessCloseThisDay\"] = True\n                    Log(\"机器人ID:\", arrParams[i][\"id\"], \"执行停止，请登录平台检查是否停止成功\", \"扩展API返回值：\", ret, strPush)\n        \n        if nowDay != nowTime.tm_mday:\n            nowDay = nowTime.tm_mday\n\n        LogStatus(_D(), nowTime, \"\\n`\" + json.dumps(tbl) + \"`\")\n        Sleep(500)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/184600\n\n> Last Modified\n\n2020-05-08 10:47:52"
    },
    {
        "strategy_id": "57_三角套利-基础版",
        "strategy_code": "python\n#!python2\n# -*- coding:utf-8 -*-\nfrom time import sleep\n\nQ3 = 0.5\ntax = 0.0015   #交易费率，0.15%\n\n\nclass fmz_market():\n\n    # 基础行情数据处理,根据传入的交易对，获取数据，返回行情dict\n    def basic_data_handle(self, pair):\n        pair_depth = {'sale_volume': 0, 'sale_price': 0, 'buy_volume': 0, 'buy_price': 0}\n        depth = exchanges[pair].GetDepth()\n        asks_infor = depth.Asks[0]\n        bids_infor = depth.Bids[0]\n        pair_depth['sale_volume'] = asks_infor.Amount\n        pair_depth['sale_price'] = asks_infor.Price\n        pair_depth['buy_volume'] = bids_infor.Amount\n        pair_depth['buy_price'] = bids_infor.Price\n        #Log(pair_depth)\n        return pair_depth\n\n\n\n    #进行参数计算\n    def profit_calculation(self):\n        profit_obtain = 0\n        #先获取行情数据\n        P1_depth = self.basic_data_handle(0)\n        P2_depth = self.basic_data_handle(1)\n        P3_depth = self.basic_data_handle(2)\n        #买一价格整理\n        p1_sale_price =float(P1_depth['sale_price'])\n        p1_buy_price = float(P1_depth['buy_price'])\n        p2_sale_price = float(P2_depth['sale_price'])\n        p2_buy_price = float(P2_depth['buy_price'])\n        p3_sale_price = float(P3_depth['sale_price'])\n        p3_buy_price = float(P3_depth['buy_price'])\n\n        #深度数据整理\n        p1_sale_volume = float(P1_depth['sale_volume'])\n        p1_buy_volume = float(P1_depth['buy_volume'])\n        p2_sale_volume = float(P2_depth['sale_volume'])\n        p2_buy_volume = float(P2_depth['buy_volume'])\n        p3_sale_volume = float(P3_depth['sale_volume'])\n        p3_buy_volume = float(P3_depth['buy_volume'])\n        # 进行数据分析，正向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_ETH,卖出EOS，买入BTC，买入EOS（卖，买，买）\n        if p1_buy_price / p2_sale_price > p3_sale_price:\n            #总的手续费计算\n            tax_account = (p1_buy_price + p3_sale_price*p2_sale_price + p3_sale_price*p2_sale_price) * Q3 * tax\n            #总的获利计算\n            profit_sum = (p1_buy_price / p2_sale_price - p3_sale_price) * Q3 * p2_buy_price\n            Log('P1;',p1_buy_price,',P2:',p2_sale_price,',P3:',p3_sale_price,',tax_account:',tax_account,',profit_sum:',profit_sum)\n            #如果总的获利 < 手续费，则直接退出\n            if profit_sum < tax_account:\n                return 0\n            p1_accout_receive = p1_buy_price * Q3 * (1 - tax) #卖出EOS得到usdt，同时减去税\n            p3_accout_used = p3_sale_price * Q3 * (1 + tax)  #计算买入Q3 EOS的时候,需要的BTC\n            p2_accout_used =  p2_sale_price *  p3_accout_used * (1 + tax) #计算买入的BTC 需要耗费的USDT数量\n            #获利总量计算\n            profit_obtain = p1_accout_receive - p2_accout_used  #卖EOS得到的usdt - 买入同样数量的EOS需要的USDT\n            return profit_obtain\n\n        # 进行数据分析，逆向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_BTC,卖出EOS->BTC，卖出BTC，买入EOS（卖，卖，买）\n        if p1_buy_price / p2_sale_price < p3_sale_price:\n            # 总的手续费计算\n            tax_account = (p3_buy_price * p2_buy_price + p3_buy_price * p2_buy_price + p1_sale_price) * Q3 * tax\n            # 总的获利计算\n            profit_sum = (p3_sale_price - p1_buy_price / p2_sale_price) * Q3 * p2_buy_price\n            Log('P1;', p1_buy_price, ',P2:', p2_sale_price, ',P3:', p3_sale_price, ',tax_account:', tax_account, ',profit_sum:', profit_sum)\n            # 如果总的获利 < 手续费，则直接退出\n            if profit_sum < tax_account:\n                return 0\n            p3_accout_receive = p3_buy_price * Q3 * (1 - tax)  # 卖出EOS得到BTC，同时减去税\n            p1_accout_used = p1_sale_price * Q3 * (1 + tax)  # 计算买入Q3 EOS的时候,需要的USDT\n            p2_accout_receive = p2_buy_price * p3_accout_receive * (1 - tax)  # 计算卖出的BTC 得到的USDT数量\n            # 获利总量计算\n            profit_obtain = p2_accout_receive - p1_accout_used   #卖出的BTC得到的usdt - 买入EOS锁需要消耗的usdt\n            return profit_obtain\n\n        return 0\n\n    #循环计算\n    def profit_calculation_cycle(self):\n        usdt_remain = 0\n        for i in range(10000):\n            profit_obtain = self.profit_calculation()\n            usdt_remain = usdt_remain + profit_obtain\n            if profit_obtain > 0:\n                Log(u'EOS:',Q3,u'.....USDT:',usdt_remain)\n\n\n\ndef main():\n    Log(exchange.GetAccount())\n    Log(\"测试\")\n    fmz_market_instances = fmz_market()\n    fmz_market_instances.profit_calculation_cycle()\n    # fmz_market_instances.basic_data_handle(0)",
        "strategy_description": "策略名称: 三角套利-基础版\n\nfrom time import sleep\n\nQ3 = 0.5\ntax = 0.0015   #交易费率，0.15%\n\n\nclass fmz_market():\n\n    # 基础行情数据处理,根据传入的交易对，获取数据，返回行情dict\n    def basic_data_handle(self, pair):\n        pair_depth = {'sale_volume': 0, 'sale_price': 0, 'buy_volume': 0, 'buy_price': 0}\n        depth = exchanges[pair].GetDepth()\n        asks_infor = depth.Asks[0]\n        bids_infor = depth.Bids[0]\n        pair_depth['sale_volume'] = asks_infor.Amount\n        pair_depth['sale_price'] = asks_infor.Price\n        pair_depth['buy_volume'] = bids_infor.Amount\n        pair_depth['buy_price'] = bids_infor.Price\n        #Log(pair_depth)\n        return pair_depth\n\n\n\n    #进行参数计算\n    def profit_calculation(self):\n        profit_obtain = 0\n        #先获取行情数据\n        P1_depth = self.basic_data_handle(0)\n        P2_depth = self.basic_data_handle(1)\n        P3_depth = self.basic_data_handle(2)\n        #买一价格整理\n        p1_sale_price =float(P1_depth['sale_price'])\n        p1_buy_price = float(P1_depth['buy_price'])\n        p2_sale_price = float(P2_depth['sale_price'])\n        p2_buy_price = float(P2_depth['buy_price'])\n        p3_sale_price = float(P3_depth['sale_price'])\n        p3_buy_price = float(P3_depth['buy_price'])\n\n        #深度数据整理\n        p1_sale_volume = float(P1_depth['sale_volume'])\n        p1_buy_volume = float(P1_depth['buy_volume'])\n        p2_sale_volume = float(P2_depth['sale_volume'])\n        p2_buy_volume = float(P2_depth['buy_volume'])\n        p3_sale_volume = float(P3_depth['sale_volume'])\n        p3_buy_volume = float(P3_depth['buy_volume'])\n        # 进行数据分析，正向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_ETH,卖出EOS，买入BTC，买入EOS（卖，买，买）\n        if p1_buy_price / p2_sale_price > p3_sale_price:\n            #总的手续费计算\n            tax_account = (p1_buy_price + p3_sale_price*p2_sale_price + p3_sale_price*p2_sale_price) * Q3 * tax\n            #总的获利计算\n            profit_sum = (p1_buy_price / p2_sale_price - p3_sale_price) * Q3 * p2_buy_price\n            Log('P1;',p1_buy_price,',P2:',p2_sale_price,',P3:',p3_sale_price,',tax_account:',tax_account,',profit_sum:',profit_sum)\n            #如果总的获利 < 手续费，则直接退出\n            if profit_sum < tax_account:\n                return 0\n            p1_accout_receive = p1_buy_price * Q3 * (1 - tax) #卖出EOS得到usdt，同时减去税\n            p3_accout_used = p3_sale_price * Q3 * (1 + tax)  #计算买入Q3 EOS的时候,需要的BTC\n            p2_accout_used =  p2_sale_price *  p3_accout_used * (1 + tax) #计算买入的BTC 需要耗费的USDT数量\n            #获利总量计算\n            profit_obtain = p1_accout_receive - p2_accout_used  #卖EOS得到的usdt - 买入同样数量的EOS需要的USDT\n            return profit_obtain\n\n        # 进行数据分析，逆向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_BTC,卖出EOS->BTC，卖出BTC，买入EOS（卖，卖，买）\n        if p1_buy_price / p2_sale_price < p3_sale_price:\n            # 总的手续费计算\n            tax_account = (p3_buy_price * p2_buy_price + p3_buy_price * p2_buy_price + p1_sale_price) * Q3 * tax\n            # 总的获利计算\n            profit_sum = (p3_sale_price - p1_buy_price / p2_sale_price) * Q3 * p2_buy_price\n            Log('P1;', p1_buy_price, ',P2:', p2_sale_price, ',P3:', p3_sale_price, ',tax_account:', tax_account, ',profit_sum:', profit_sum)\n            # 如果总的获利 < 手续费，则直接退出\n            if profit_sum < tax_account:\n                return 0\n            p3_accout_receive = p3_buy_price * Q3 * (1 - tax)  # 卖出EOS得到BTC，同时减去税\n            p1_accout_used = p1_sale_price * Q3 * (1 + tax)  # 计算买入Q3 EOS的时候,需要的USDT\n            p2_accout_receive = p2_buy_price * p3_accout_receive * (1 - tax)  # 计算卖出的BTC 得到的USDT数量\n            # 获利总量计算\n            profit_obtain = p2_accout_receive - p1_accout_used   #卖出的BTC得到的usdt - 买入EOS锁需要消耗的usdt\n            return profit_obtain\n\n        return 0\n\n    #循环计算\n    def profit_calculation_cycle(self):\n        usdt_remain = 0\n        for i in range(10000):\n            profit_obtain = self.profit_calculation()\n            usdt_remain = usdt_remain + profit_obtain\n            if profit_obtain > 0:\n                Log(u'EOS:',Q3,u'.....USDT:',usdt_remain)\n\n\n\ndef main():\n    Log(exchange.GetAccount())\n    Log(\"测试\")\n    fmz_market_instances = fmz_market()\n    fmz_market_instances.profit_calculation_cycle()\n    # fmz_market_instances.basic_data_handle(0)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/151145\n\n> Last Modified\n\n2019-06-11 14:24:17"
    },
    {
        "strategy_id": "58_三大交易所止盈止损集成类库",
        "strategy_code": "python\nimport json\n\n# 对合约进行止盈止损   cangType=0默认逐仓  =1全仓\ndef zhiyingzhisun(ex, amount, directionStr, zhiying, zhisun, cangType = 0):\n    if ex.GetName().find('OK') >= 0 :\n        # okex\n        return okexSwap(ex, amount, directionStr, zhiying, zhisun)\n    elif ex.GetName().find('Huobi') >= 0 :\n        # huobi\n        return huobiSwap(ex, amount, directionStr, zhiying, zhisun, cangType)\n    elif ex.GetName().find('Binance') >= 0 :\n        # bian\n        return bianSwap(ex, amount, directionStr, zhiying, zhisun)\n    else:\n        return False\n\n# 发送请求\ndef AsynIo(ex, paramList):\n        if (len(paramList) == 3):\n            arrRoutine = ex.Go(\"IO\", paramList[0], paramList[1], paramList[2])\n        elif (len(paramList) == 4):\n            arrRoutine = ex.Go(\"IO\", paramList[0], paramList[1], paramList[2], paramList[3])\n        elif (len(paramList) == 5):\n            arrRoutine = ex.Go(\"IO\", paramList[0], paramList[1], paramList[2], paramList[3], paramList[4])\n        data, ok = arrRoutine.wait()\n        return data\n# 火币合约\ndef huobiSwap(ex, amount, directionStr, zhiying, zhisun, cangType):\n    instrument_id = ex.GetCurrency().replace('_',\"-\")\n    # 根据全仓或逐仓 与 U本位或币本位，设置请求url\n    if instrument_id.find('USDT') >= 0 :\n        if cangType == 0:\n            url = \"/linear-swap-api/v1/swap_tpsl_order\"\n        elif cangType == 1:\n            url = '/linear-swap-api/v1/swap_cross_tpsl_order'\n        else:\n            return False\n    elif instrument_id.find('USD') >= 0 :\n        url = \"/swap-api/v1/swap_tpsl_order\"\n    else:\n        return False\n    # 发送请求\n    data = AsynIo(ex, ['api', 'POST', url, '', json.dumps({\n        \"contract_code\": instrument_id,\n        \"direction\": directionStr,\n        \"volume\" : amount,\n        \"tp_order_price\": zhiying,\n        \"tp_trigger_price\": zhiying,\n        \"sl_trigger_price\": zhisun,\n        \"sl_order_price\": zhisun,\n    })])\n    if data[\"status\"] == 'ok':\n        return True\n    else:\n        return False\n\n# 币安合约\ndef bianSwap(ex, amount, directionStr, zhiying, zhisun):\n    instrument_id = ex.GetCurrency().replace('_',\"\")\n    # U本位或币本位，设置请求url\n    if instrument_id.find('USDT') >= 0 :\n        url = \"/fapi/v1/order\"\n    elif instrument_id.find('USD') >= 0 :\n        url = '/dapi/v1/order'\n    else:\n        return False\n    # 止损\n    zhisunData = AsynIo(ex, ['api', 'POST', url , '', json.dumps({\n        \"symbol\": instrument_id,\n        \"side\": directionStr,\n        \"type\": \"STOP\",\n        \"quantity\": amount,\n        \"price\": zhisun,\n        \"stopPrice\": zhisun,\n        \"timestamp\": str(int(round(time.time() * 1000)))\n    })])\n    if int(zhisunData['stopPrice']) != int(zhisun):\n        return False\n    # 止盈\n    zhiyingData = AsynIo(ex, ['api', 'POST', url , '', json.dumps({\n        \"symbol\": instrument_id,\n        \"side\": direction,\n        \"type\": \"TAKE_PROFIT\",\n        \"quantity\": amount,\n        \"price\": zhiying,\n        \"stopPrice\": zhiying,\n        \"timestamp\": str(int(round(time.time() * 1000)))\n    })])\n    if int(zhiyingData['stopPrice']) != int(zhiying):\n        return False\n    return True\n\n\n# 欧易合约\ndef okexSwap(ex, amount, directionStr, zhiying, zhisun):\n    instrument_id = ex.GetCurrency().replace('_',\"-\") + '-SWAP'\n    # 获取仓位方向\n    if directionStr == 'buy':\n        direction = '4'\n    elif directionStr == 'sell':\n        direction = '3'\n    else:\n        return False\n    data =  AsynIo(ex, ['api', 'POST', '/v1/order/orders/place', '', json.dumps({\n        \"instrument_id\": instrument_id,\n        \"type\": direction,\n        \"order_type\": '5',\n        \"size\": amount,\n        \"tp_trigger_price\": zhiying,\n        \"tp_price\": zhiying,\n        \"sl_trigger_price\": zhisun,\n        \"sl_price\": zhisun\n    })])\n    if data[\"error_code\"] == \"0\":\n        return True\n    else:\n        return False\n    \next.zhiyingzhisun = zhiyingzhisun",
        "strategy_description": "策略名称: 三大交易所止盈止损集成类库\n\ndef zhiyingzhisun(ex, amount, directionStr, zhiying, zhisun, cangType = 0):\n    if ex.GetName().find('OK') >= 0 :\n        # okex\n        return okexSwap(ex, amount, directionStr, zhiying, zhisun)\n    elif ex.GetName().find('Huobi') >= 0 :\n        # huobi\n        return huobiSwap(ex, amount, directionStr, zhiying, zhisun, cangType)\n    elif ex.GetName().find('Binance') >= 0 :\n        # bian\n        return bianSwap(ex, amount, directionStr, zhiying, zhisun)\n    else:\n        return False"
    },
    {
        "strategy_id": "59_交易所对倒刷量对敲互刷",
        "strategy_code": "python\ndef main():\n    # 设置交易所地址\n    exchanges[0].SetBase(\"\")\n    exchanges[1].SetBase(\"\")\n    Log(\"等待指令\")\n    while True:\n        LogStatus(_D())\n        cmd = GetCommand()\n        if cmd:\n            arr = cmd.split(\":\")\n            # 交易次数\n            for i in range(trade_num):\n                Account0 = exchanges[0].GetAccount()\n                Account1 = exchanges[1].GetAccount()\n                # Log(\"Account0-usdt\", Account0[\"Balance\"], \"Account0-DEC\", Account0[\"Stocks\"])\n                # Log(\"Account 1-usdt\", Account1[\"Balance\"], \"Account1-DEC\", Account1[\"Stocks\"])\n                # 获取A0和A1的币\n                A0_stocks = Account0[\"Stocks\"]\n                A1_stocks = Account1[\"Stocks\"]\n                error = 0\n                if A0_stocks > A1_stocks:\n                    Log(\"Account0有币\")\n                    # 重置索引\n                    ex_chang = [exchanges[0], exchanges[1]]\n                    if abstest(A0_stocks, A1_stocks) == 1:\n                        break\n                    else:\n                        # Log(\"可继续交易\")\n                        pass\n                else:\n                    Log(\"Account1有dec\")\n                    # 重置索引\n                    ex_chang = [exchanges[1], exchanges[0]]\n                    if abstest(A0_stocks, A1_stocks) == 1:\n                        break\n                    else:\n                        # Log(\"可继续交易\")\n                        pass\n                # 0索引永远卖出    \n                ex_chang[0].Sell(pprice, nnum)\n                # 1索引永远卖出  \n                ex_chang[1].Buy(pprice, nnum)\n                Log(\"交易完成\",i)\n                Sleep(5)\n            if abstest(A0_stocks, A1_stocks) == 1:\n                break\n            else:\n                # Log(\"可继续交易\")\n                pass\n    Log(\"运行结束\")\n\ndef abstest(a, b):\n    # 简单判断\n    abs_value = abs(a - b)\n    # Log(\"币种差值:\" + str(abs_value))\n    if abs_value == 0:\n        Log(\"币种不够，请检查\")\n        error = 1\n    else:\n        # Log(\"可继续交易\")\n        error = 0\n    return error",
        "strategy_description": "策略名称: 交易所对倒刷量对敲互刷\n\nexchanges[0].SetBase(\"\")\n    exchanges[1].SetBase(\"\")\n    Log(\"等待指令\")\n    while True:\n        LogStatus(_D())\n        cmd = GetCommand()\n        if cmd:\n            arr = cmd.split(\":\")\n            # 交易次数\n            for i in range(trade_num):\n                Account0 = exchanges[0].GetAccount()\n                Account1 = exchanges[1].GetAccount()\n                # Log(\"Account0-usdt\", Account0[\"Balance\"], \"Account0-DEC\", Account0[\"Stocks\"])\n                # Log(\"Account 1-usdt\", Account1[\"Balance\"], \"Account1-DEC\", Account1[\"Stocks\"])\n                # 获取A0和A1的币\n                A0_stocks = Account0[\"Stocks\"]\n                A1_stocks = Account1[\"Stocks\"]\n                error = 0\n                if A0_stocks > A1_stocks:\n                    Log(\"Account0有币\")\n                    # 重置索引\n                    ex_chang = [exchanges[0], exchanges[1]]\n                    if abstest(A0_stocks, A1_stocks) == 1:\n                        break\n                    else:\n                        # Log(\"可继续交易\")\n                        pass\n                else:\n                    Log(\"Account1有dec\")\n                    # 重置索引\n                    ex_chang = [exchanges[1], exchanges[0]]\n                    if abstest(A0_stocks, A1_stocks) == 1:\n                        break\n                    else:\n                        # Log(\"可继续交易\")\n                        pass\n                # 0索引永远卖出    \n                ex_chang[0].Sell(pprice, nnum)\n                # 1索引永远卖出  \n                ex_chang[1].Buy(pprice, nnum)\n                Log(\"交易完成\",i)\n                Sleep(5)\n            if abstest(A0_stocks, A1_stocks) == 1:\n                break\n            else:\n                # Log(\"可继续交易\")\n                pass\n    Log(\"运行结束\")\n\ndef abstest(a, b):\n    # 简单判断\n    abs_value = abs(a - b)\n    # Log(\"币种差值:\" + str(abs_value))\n    if abs_value == 0:\n        Log(\"币种不够，请检查\")\n        error = 1\n    else:\n        # Log(\"可继续交易\")\n        error = 0\n    return error\n\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/226845\n\n> Last Modified\n\n2021-07-14 15:44:40"
    },
    {
        "strategy_id": "60_仓位管理配置思路",
        "strategy_code": "python\n'''backtest\nstart: 2017-06-26 00:00:00\nend: 2022-04-6 00:00:00\nperiod: 1d\nbasePeriod: 1h\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"BTC_USDT\"}]\n'''\ndef main():\n    exchange.SetMarginLevel(20)\n    exchange.SetContractType(\"swap\")\n    exchange.SetDirection(\"buy\")\n    exchange.SetDirection(\"sell\")\n    ticker = exchange.GetTicker()\n    Log(ticker)\n    \n    exchange.SetDirection(\"buy\")\n    exchange.Buy(ticker[\"Last\"] /1, 0.001)\n    exchange.Buy(ticker[\"Last\"] /1.1, 0.001)\n    exchange.Buy(ticker[\"Last\"] /1.2, 0.002)\n    exchange.Buy(ticker[\"Last\"] /1.3, 0.002)\n    exchange.Buy(ticker[\"Last\"] /1.4, 0.003)\n    exchange.Buy(ticker[\"Last\"] /1.5, 0.003)\n    exchange.Buy(ticker[\"Last\"] /1.6, 0.003)\n    exchange.Buy(ticker[\"Last\"] /1.7, 0.005)\n    exchange.Buy(ticker[\"Last\"] /1.8, 0.005)\n    exchange.Buy(ticker[\"Last\"] /1.9, 0.005)\n    exchange.Buy(ticker[\"Last\"] /2, 0.005)\n    exchange.Buy(ticker[\"Last\"] /2.1, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.2, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.3, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.4, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.5, 0.008)\n    exchange.Buy(ticker[\"Last\"] /2.6, 0.013)\n    exchange.Buy(ticker[\"Last\"] /2.7, 0.013)\n    exchange.Buy(ticker[\"Last\"] /2.8, 0.013)\n    exchange.Buy(ticker[\"Last\"] /2.9, 0.013)\n    exchange.Buy(ticker[\"Last\"] /3, 0.013)\n    exchange.Buy(ticker[\"Last\"] /3.1, 0.013)\n    exchange.Buy(ticker[\"Last\"] /3.2, 0.013)\n    exchange.Buy(ticker[\"Last\"] /3.3, 0.021)\n    exchange.Buy(ticker[\"Last\"] /3.4, 0.021)\n    exchange.Buy(ticker[\"Last\"] /3.5, 0.021) \n    exchange.Buy(ticker[\"Last\"] /3.6, 0.021)\n    exchange.Buy(ticker[\"Last\"] /3.7, 0.021)\n    exchange.Buy(ticker[\"Last\"] /3.8, 0.021) \n    exchange.Buy(ticker[\"Last\"] /3.9, 0.021) \n    exchange.Buy(ticker[\"Last\"] /4.0, 0.034) \n    exchange.Buy(ticker[\"Last\"] /4.1, 0.034) \n    exchange.Buy(ticker[\"Last\"] /4.2, 0.034)\n    exchange.Buy(ticker[\"Last\"] /4.3, 0.034) \n    exchange.Buy(ticker[\"Last\"] /4.4, 0.034)\n    exchange.Buy(ticker[\"Last\"] /4.5, 0.034) \n    exchange.Buy(ticker[\"Last\"] /4.6, 0.034)\n    exchange.Buy(ticker[\"Last\"] /4.7, 0.034)  \n    exchange.SetDirection(\"sell\")\n    exchange.Sell(ticker[\"Last\"] * 1, 0.001)\n    exchange.Sell(ticker[\"Last\"] * 1.1, 0.002)\n    exchange.Sell(ticker[\"Last\"] * 1.2, 0.002)\n    exchange.Sell(ticker[\"Last\"] * 1.3, 0.003)\n    exchange.Sell(ticker[\"Last\"] * 1.4, 0.003)\n    exchange.Sell(ticker[\"Last\"] * 1.5, 0.003)\n    exchange.Sell(ticker[\"Last\"] * 1.6, 0.005)\n    exchange.Sell(ticker[\"Last\"] * 1.7, 0.005)\n    exchange.Sell(ticker[\"Last\"] * 1.8, 0.005)\n    exchange.Sell(ticker[\"Last\"] * 1.9, 0.005)\n    exchange.Sell(ticker[\"Last\"] * 2, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.1, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.2, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.3, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.4, 0.008)\n    exchange.Sell(ticker[\"Last\"] * 2.5, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 2.6, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 2.7, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 2.8, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 2.9, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 3, 0.013)\n    exchange.Sell(ticker[\"Last\"] * 3.1, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.2, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.3, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.4, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.5, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.6, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.7, 0.021)\n    exchange.Sell(ticker[\"Last\"] * 3.8, 0.034)\n    exchange.Sell(ticker[\"Last\"] * 3.9, 0.034) \n    exchange.Sell(ticker[\"Last\"] * 4.0, 0.034)\n    exchange.Sell(ticker[\"Last\"] * 4.1, 0.034)\n    exchange.Sell(ticker[\"Last\"] * 4.2, 0.034) \n    exchange.Sell(ticker[\"Last\"] * 4.3, 0.034)  \n    exchange.Sell(ticker[\"Last\"] * 4.4, 0.034)\n    exchange.Sell(ticker[\"Last\"] * 4.5, 0.034)  \n    Log(\"orders\", exchange.GetOrders())\n    Sleep(1000)",
        "strategy_description": "策略名称: 仓位管理配置思路\n\n未找到描述"
    },
    {
        "strategy_id": "61_企业微信群机器人消息推送",
        "strategy_code": "python\n#!Python3\n\n\"\"\"\n《策略代写》 与 （此程序帮助），致信QQ：35787501\n\n企业微信消息推送，用于群自定义机器人\n同理：修改 data，也可以接入其他软件的 webhook\n\"\"\"\n\nimport requests\n\n\ndef send(text):\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"msgtype\": \"text\",\n        \"text\": {\n            \"content\": text,\n        }\n    }\n    response = requests.post(webhook, headers=headers, json=data)\n    records = response.json()\n    return records\n\n\ndef LogQYWX(*args):\n    text = \" \".join(args)\n    Log(text, send(text))\n\n\next.LogQYWX = LogQYWX",
        "strategy_description": "策略名称: 企业微信群机器人消息推送\n\n未找到描述"
    },
    {
        "strategy_id": "62_冰山委托买入-Jason",
        "strategy_code": "python\nimport random\n\n\ndef main():\n    # 获取账户所有未成交订单\n    Log(\"取消所有未成交订单\")\n    orders = _C(exchange.GetOrders)\n    if len(orders) > 0:\n        for i in range(len(orders)):\n            exchange.CancelOrder(orders[i][\"Id\"])\n            Sleep(priceInterval*1000)\n\n    # 对比账户余额\n    Log(\"获取用户初始化账户\")\n    initAccount = _C(exchange.GetAccount)\n    if initAccount[\"Balance\"] < buyAmount:\n        Log(\"账户余额不足\")\n        return\n    \n    #比较单笔购买数量均值*市场买一价是否大于账户余额\n    ticker = _C(exchange.GetTicker)\n    if (ticker['Last'] * buyNum) > initAccount['Balance']:\n        Log(\"单次购买均值价格大于账户余额，请调整参数\")\n        return\n\n    lastBuyPrice = 0\n\n    while (True):\n        Sleep(priceInterval*1000)\n        #获取账户信息\n        account = _C(exchange.GetAccount)\n        #获取当下行情\n        ticker = _C(exchange.GetTicker)\n        # 上次购买价格不为空，查看订单是否完成，没有完成则取消\n        if lastBuyPrice > 0:\n            orders1 = exchange.GetOrders()\n            if len(orders1) > 0:\n                for j in range(len(orders1)):\n                    #计算实际市场委托深度\n                    if ticker[\"Last\"] > lastBuyPrice and ((ticker[\"Last\"] - lastBuyPrice)/lastBuyPrice) > (2* (depthStatus/100)):\n                        Log(\"委托价格偏离过多，最新成交价:\",ticker[\"Last\"],\"委托价\",lastBuyPrice)\n                        exchange.CancelOrder(orders1[j][\"Id\"])\n                        lastBuyPrice = 0\n                continue\n            else:\n                Log(\"买单完成, 累计花费:\", _N(initAccount[\"Balance\"] - account[\"Balance\"]), \"平均买入价:\", _N((initAccount[\"Balance\"] - account[\"Balance\"]) / (account[\"Stocks\"] - initAccount[\"Stocks\"])))\n                lastBuyPrice = 0\n                continue     \n        else:\n            Log(\"剩余余额:\",account[\"Balance\"])\n            #委托价格 = 最新买一价*（1-委托深度/100）\n            entrustPrice = _N(ticker[\"Buy\"]*(1-depthStatus/100))\n            Log(\"委托价格：\",entrustPrice)\n            #判断委托价格是否大于最高价格限定\n            if entrustPrice > highPrice:\n                continue\n            #随机购买数量 = 单次购买数量均值 * ((100-单次均值浮点数)/100)+(单次均值浮点数*2 /100* 单次购买数量均值 *随机数0~1)  \n            randomBuyNum = (buyNum*((100-buyOncePoint)/100))+(buyOncePoint*2/100 *buyNum*random.random())\n            #可用数量金额 \n            useMoney = min(account[\"Balance\"],randomBuyNum,buyAmount - (initAccount[\"Balance\"] - account[\"Balance\"]))\n            #购买数量\n            orderBuyNum = _N(useMoney/entrustPrice)\n            Log(\"交易数量：\",orderBuyNum)\n            #判断是否小于最小交易量\n            if orderBuyNum < minBuyNum:\n                break\n            #因为要扣手续费，所以大概为账户99.7%\n            if (entrustPrice*orderBuyNum)>(account[\"Balance\"]*0.997):\n                Log(\"金额为\",(entrustPrice*orderBuyNum))\n                Log(\"账户余额为\",(account[\"Balance\"]))\n                continue\n            #更新上次购买价格\n            lastBuyPrice = entrustPrice\n            #下单\n            exchange.Buy(entrustPrice,orderBuyNum)\n            \n    account = _C(exchange.GetAccount)  \n    Log(\"冰山委托买单完成,共计花费：\",_N(initAccount[\"Balance\"]-account[\"Balance\"]),\"平均单价为:\",_N((initAccount[\"Balance\"]-account[\"Balance\"])/(account[\"Stocks\"]-initAccount[\"Stocks\"])))",
        "strategy_description": "策略名称: 冰山委托买入-Jason\n\nLog(\"取消所有未成交订单\")\n    orders = _C(exchange.GetOrders)\n    if len(orders) > 0:\n        for i in range(len(orders)):\n            exchange.CancelOrder(orders[i][\"Id\"])\n            Sleep(priceInterval*1000)\n\n    # 对比账户余额\n    Log(\"获取用户初始化账户\")\n    initAccount = _C(exchange.GetAccount)\n    if initAccount[\"Balance\"] < buyAmount:\n        Log(\"账户余额不足\")\n        return\n    \n    #比较单笔购买数量均值*市场买一价是否大于账户余额\n    ticker = _C(exchange.GetTicker)\n    if (ticker['Last'] * buyNum) > initAccount['Balance']:\n        Log(\"单次购买均值价格大于账户余额，请调整参数\")\n        return\n\n    lastBuyPrice = 0\n\n    while (True):\n        Sleep(priceInterval*1000)\n        #获取账户信息\n        account = _C(exchange.GetAccount)\n        #获取当下行情\n        ticker = _C(exchange.GetTicker)\n        # 上次购买价格不为空，查看订单是否完成，没有完成则取消\n        if lastBuyPrice > 0:\n            orders1 = exchange.GetOrders()\n            if len(orders1) > 0:\n                for j in range(len(orders1)):\n                    #计算实际市场委托深度\n                    if ticker[\"Last\"] > lastBuyPrice and ((ticker[\"Last\"] - lastBuyPrice)/lastBuyPrice) > (2* (depthStatus/100)):\n                        Log(\"委托价格偏离过多，最新成交价:\",ticker[\"Last\"],\"委托价\",lastBuyPrice)\n                        exchange.CancelOrder(orders1[j][\"Id\"])\n                        lastBuyPrice = 0\n                continue\n            else:\n                Log(\"买单完成, 累计花费:\", _N(initAccount[\"Balance\"] - account[\"Balance\"]), \"平均买入价:\", _N((initAccount[\"Balance\"] - account[\"Balance\"]) / (account[\"Stocks\"] - initAccount[\"Stocks\"])))\n                lastBuyPrice = 0\n                continue     \n        else:\n            Log(\"剩余余额:\",account[\"Balance\"])\n            #委托价格 = 最新买一价*（1-委托深度/100）\n            entrustPrice = _N(ticker[\"Buy\"]*(1-depthStatus/100))\n            Log(\"委托价格：\",entrustPrice)\n            #判断委托价格是否大于最高价格限定\n            if entrustPrice > highPrice:\n                continue\n            #随机购买数量 = 单次购买数量均值 * ((100-单次均值浮点数)/100)+(单次均值浮点数*2 /100* 单次购买数量均值 *随机数0~1)  \n            randomBuyNum = (buyNum*((100-buyOncePoint)/100))+(buyOncePoint*2/100 *buyNum*random.random())\n            #可用数量金额 \n            useMoney = min(account[\"Balance\"],randomBuyNum,buyAmount - (initAccount[\"Balance\"] - account[\"Balance\"]))\n            #购买数量\n            orderBuyNum = _N(useMoney/entrustPrice)\n            Log(\"交易数量：\",orderBuyNum)\n            #判断是否小于最小交易量\n            if orderBuyNum < minBuyNum:\n                break\n            #因为要扣手续费，所以大概为账户99.7%\n            if (entrustPrice*orderBuyNum)>(account[\"Balance\"]*0.997):\n                Log(\"金额为\",(entrustPrice*orderBuyNum))\n                Log(\"账户余额为\",(account[\"Balance\"]))\n                continue\n            #更新上次购买价格\n            lastBuyPrice = entrustPrice\n            #下单\n            exchange.Buy(entrustPrice,orderBuyNum)\n            \n    account = _C(exchange.GetAccount)  \n    Log(\"冰山委托买单完成,共计花费：\",_N(initAccount[\"Balance\"]-account[\"Balance\"]),\"平均单价为:\",_N((initAccount[\"Balance\"]-account[\"Balance\"])/(account[\"Stocks\"]-initAccount[\"Stocks\"])))        \n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/271475\n\n> Last Modified\n\n2021-04-16 10:26:23"
    },
    {
        "strategy_id": "63_冲币安新上币开盘",
        "strategy_code": "python\ndef main():\n    Log(exchange.GetAccount())\n    Log(exchange.GetCurrency())\n    while True:\n        ticker = exchange.GetTicker()\n        if ticker:\n            Log(\"开盘了，冲啊！！！@\")\n            exchange.SetPrecision(1,0)\n            amount = XX/ticker['Last']\n            exchange.Buy(-1, amount)\n            exchange.Buy(-1, amount/2)\n            exchange.Buy(-1, amount/4)\n            exchange.Buy(-1, amount/8)\n            exchange.Buy(-1, amount/16)\n            Sleep(15*1000)\n            while True:\n                try:\n                    _ticker = exchange.GetTicker()\n                    if _ticker['Last'] > ticker['Last']:\n                        exchange.Sell(-1, amount/3)\n                        Log(\"已经卖出三分之一@\")\n                        return\n                    else:\n                        Sleep(30)\n                        continue\n                except:\n                    Sleep(30)\n                    continue\n        else:\n            Sleep(20)",
        "strategy_description": "策略名称: 冲币安新上币开盘\n\n未找到描述"
    },
    {
        "strategy_id": "64_分享-赌徒策略-马丁策略",
        "strategy_code": "python\nimport time\n\n# 初始化策略参数\nsymbol = 'huobip/btc_usdt'\nperiod = '1m'\namount = 0.01\nmartingale_factor = 2\nmax_martingale_times = 5\nstop_loss = 0.05\nstop_profit = 0.1\nlast_buy_price = 0\nmartingale_times = 0\n\n# 连接API\nexchange = Exchange()\nexchange.SetContractType(symbol)\nexchange.SetPeriod(period)\n\n# 主循环\nwhile True:\n    # 获取K线数据\n    klines = exchange.GetRecords()\n    if not klines:\n        continue\n\n    # 获取当前价格\n    current_price = float(klines[-1]['Close'])\n\n    # 判断是否需要加仓\n    if last_buy_price != 0 and current_price < last_buy_price * (1 - stop_loss):\n        # 止损，卖出所有持仓\n        sell_price = current_price\n        sell_amount = exchange.GetPosition()['Amount']\n        exchange.Sell(sell_price, sell_amount)\n        last_buy_price = 0\n        martingale_times = 0\n        print('止损，卖出所有持仓，价格', sell_price)\n    elif last_buy_price != 0 and current_price > last_buy_price * (1 + stop_profit):\n        # 止盈，卖出所有持仓\n        sell_price = current_price\n        sell_amount = exchange.GetPosition()['Amount']\n        exchange.Sell(sell_price, sell_amount)\n        last_buy_price = 0\n        martingale_times = 0\n        print('止盈，卖出所有持仓，价格', sell_price)\n    elif last_buy_price == 0:\n        # 买入一份初始仓位\n        buy_price = current_price\n        buy_amount = amount / buy_price\n        exchange.Buy(buy_price, buy_amount)\n        last_buy_price = buy_price\n        martingale_times = 0\n        print('买入初始仓位，价格', buy_price)\n    elif martingale_times < max_martingale_times:\n        # 加仓\n        buy_price = current_price * martingale_factor\n        buy_amount = amount / buy_price\n        exchange.Buy(buy_price, buy_amount)\n        last_buy_price = (last_buy_price * martingale_times + buy_price) / (martingale_times + 1)\n        martingale_times += 1\n        print('加仓，价格', buy_price)\n\n    # 等待下一次循环\n    time.sleep(60)",
        "strategy_description": "策略名称: 分享-赌徒策略-马丁策略\n\nsymbol = 'huobip/btc_usdt'\nperiod = '1m'\namount = 0.01\nmartingale_factor = 2\nmax_martingale_times = 5\nstop_loss = 0.05\nstop_profit = 0.1\nlast_buy_price = 0\nmartingale_times = 0"
    },
    {
        "strategy_id": "65_分享RSI超买超卖策略",
        "strategy_code": "python\nimport talib\nimport numpy as np\nimport time\n\n# 初始化策略参数\nsymbol = 'huobip/btc_usdt'\nperiod = '1m'\nrsi_period = 14\nrsi_buy = 30\nrsi_sell = 70\namount = 0.01\nlast_buy_price = 0\n\n# 连接API\nexchange = Exchange()\nexchange.SetContractType(symbol)\nexchange.SetPeriod(period)\n\n# 主循环\nwhile True:\n    # 获取K线数据\n    klines = exchange.GetRecords()\n    if not klines:\n        continue\n\n    # 计算RSI指标\n    close_prices = np.array([float(k['Close']) for k in klines])\n    rsi = talib.RSI(close_prices, rsi_period)\n\n    # 获取当前价格\n    current_price = float(klines[-1]['Close'])\n\n    # 判断是否超买或超卖\n    if rsi[-1] < rsi_buy and last_buy_price == 0:\n        # 超卖，买入\n        buy_price = current_price\n        buy_amount = amount / buy_price\n        exchange.Buy(buy_price, buy_amount)\n        last_buy_price = buy_price\n        print('买入', buy_amount, 'BTC，价格', buy_price)\n    elif rsi[-1] > rsi_sell and last_buy_price != 0:\n        # 超买，卖出\n        sell_price = current_price\n        sell_amount = amount / sell_price\n        exchange.Sell(sell_price, sell_amount)\n        last_buy_price = 0\n        print('卖出', sell_amount, 'BTC，价格', sell_price)\n\n    # 等待下一次循环\n    time.sleep(60)",
        "strategy_description": "策略名称: 分享RSI超买超卖策略\n\nsymbol = 'huobip/btc_usdt'\nperiod = '1m'\nrsi_period = 14\nrsi_buy = 30\nrsi_sell = 70\namount = 0.01\nlast_buy_price = 0"
    },
    {
        "strategy_id": "66_分享抢新现货策略",
        "strategy_code": "python\nimport time\n\n# 初始化策略参数\nsymbol = 'huobip/ht_usdt'\namount = 10\nmax_price = 1.5\nmin_price = 0.5\ninterval = 0.1\n\n# 连接API\nexchange = Exchange()\nexchange.SetContractType(symbol)\n\n# 主循环\nwhile True:\n    # 获取当前市场深度\n    depth = exchange.GetDepth()\n\n    # 获取当前买一和卖一价格\n    buy_price = float(depth['Bids'][0]['Price'])\n    sell_price = float(depth['Asks'][0]['Price'])\n\n    # 判断是否满足条件\n    if buy_price <= max_price and sell_price >= min_price:\n        # 满足条件，进行买入操作\n        buy_amount = amount / buy_price\n        exchange.Buy(buy_price, buy_amount)\n        print('买入', buy_amount, 'HT，价格', buy_price)\n\n        # 等待一段时间后进行卖出操作\n        time.sleep(interval)\n        sell_price = float(depth['Asks'][0]['Price'])\n        sell_amount = amount / sell_price\n        exchange.Sell(sell_price, sell_amount)\n        print('卖出', sell_amount, 'HT，价格', sell_price)\n\n    # 等待下一次循环\n    time.sleep(1)\n\n\n#该策略使用了FMZ平台提供的Exchange API来进行交易。在主循环中，首先获取当前市场深度，然后获取当前买一和卖一价格。如果买一价格小于等于设定的最大价格且卖一价格大于等于设定的最小价格，则进行买入操作。等待一段时间后再获取当前卖一价格进行卖出操作。最后等待下一次循环。需要注意的是，抢新现货策略存在一定的风险，需要谨慎操作。",
        "strategy_description": "策略名称: 分享抢新现货策略\n\nsymbol = 'huobip/ht_usdt'\namount = 10\nmax_price = 1.5\nmin_price = 0.5\ninterval = 0.1"
    },
    {
        "strategy_id": "67_动态平衡策略-python-版",
        "strategy_code": "python\n\n# !usr/bin/ python3\n# *_* coding:utf-8 *_*\n#学会python后写的第一个动态平衡策略\n# QQ：5325049 不足之处欢迎指正\n\nimport time\n\n#定义获取行情及账户信息函数\ndef nowinfo(): \n    global NowTicker,NowAsset,NowCoinValue,AssetDiff\n    NowTicker = exchange.GetTicker() #获取行情信息\n    NowAsset = exchange.GetAccount() # 获取账户信息\n    NowCoinValue =NowTicker.Last * NowAsset.Stocks #计算币资产净值\n    AssetDiff = NowCoinValue-NowAsset.Balance #计算币资产与现金差额\n\n# 定义交易执行函数\ndef trade():\n    if AssetDiff > NowAsset.Balance*0.05: # 判断币值是否超过资金5%\n        Log(\"交易将被执行，以\",NowTicker.Buy,\"卖出\",AssetDiff/2/NowTicker.Buy,\"个币\")\n        exchange.SetPrecision(5,5) #设置计价精度\n        exchange.Sell(NowTicker.Buy,AssetDiff/2/NowTicker.Buy) #执行币卖出交易\n    elif AssetDiff < NowAsset.Balance*(-0.05): #判断币值是否低于资金5%\n        Log(\"交易将被执行，以\",NowTicker.Sell,\"买入\",AssetDiff/-2/NowTicker.Sell,\"个币\")\n        exchange.SetPrecision(5,5) #设置计价精度\n        exchange.Buy(NowTicker.Sell,AssetDiff/-2/NowTicker.Sell) #执行币买入交易\n    else:\n        Log(\"未触发交易条件\")\n\n# 入口函数，只要定义了系统就会自动执行该函数，不需要调用啊\ndef main():\n    i = 0\n    while i < 1000: #设置执行总次数\n        nowinfo() # 调用获取行情资产函数\n        Log(NowTicker) # 打印行情信息\n        Log(NowAsset) # 打印账户信息\n        Log(\"当前币余额：\",NowAsset.Stocks)\n        Log(\"当前资金余额：\",NowAsset.Balance)\n        Log(\"当前币市值：\", NowCoinValue)\n        Log(\"币市值与资金差额：\",AssetDiff)\n        trade() #调用 交易执行函数\n        i+=1 # 条件迭代\n        Log(\"第\", i, \"轮循环结束\")\n        time.sleep(60) # 等待60秒",
        "strategy_description": "策略名称: 动态平衡策略-python-版\n\n# *_* coding:utf-8 *_*"
    },
    {
        "strategy_id": "68_双平台对冲-练习用-求交流求指点",
        "strategy_code": "python\nimport time\nimport numpy as np\n\ndef reject_outliers(arr, m=2):\n    final_list = [x for x in arr if (x > np.mean(arr) - 2 * np.std(arr))]\n    final_list = [x for x in final_list if (x < np.mean(arr) + 2 * np.std(arr))]\n    return final_list\n\ndef main():\n    '''SetErrorFilter(\"canceled\")'''\n     \n    LogReset()\n    LogProfitReset()\n    \n    global sellTrue \n    global buyTrue \n    sellTrue = 0 \n    buyTrue = 0\n    initStocks = 0.0\n    initBalance = 0.0\n    lastTradeTime = 0\n    lastTradeErrExchange = ''\n    accountsCache = []\n    depthCache=[]\n    names = []\n    buyPrice=0\n    sellPrice=0\n    dealtransactioned = False\n\n    for e in exchanges:\n        names.append(e.GetName())\n        account = _C(e.GetAccount)\n        initStocks += account.Stocks\n        initBalance += account.Balance\n        Log(\"Switch\", e.GetLabel(), \"To\", e.IO(\"websocket\"))\n        \n    Log(\"Total Currency:\", _N(initBalance), \"Total Asset\", _N(initStocks), 'Python:', __import__('sys').version)\n    while (True):\n        LogStatus(_D())\n        if not accountsCache:\n            accountsCache = [_C(e.GetAccount) for e in exchanges]\n        Sleep(LoopInterval)\n        depthA = exchanges[0].GetDepth()\n        depthCache.append(depthA)\n        if not depthA:\n            continue\n        depthB = exchanges[1].GetDepth()\n        depthCache.append(depthB)\n        if not depthB:\n            continue\n        \n                \n        '''trade part'''\n        \n        diffA = _N(depthA.Bids[0].Price - depthB.Asks[0].Price, 3)\n        diffB = _N(depthB.Bids[0].Price - depthA.Asks[0].Price, 3)\n        LogStatus(\"A平台币\",exchanges[0].GetAccount().Stocks,\"A平台钱\",exchanges[0].GetAccount().Balance,\"B平台币\",exchanges[1].GetAccount().Stocks,\"B平台钱\",exchanges[1].GetAccount().Balance)\n        \n        if diffA > 0:\n            buytarget = depthB.Asks[0]\n            opAmount=min(depthA.Bids[0].Amount,buytarget.Amount)\n            buyAmount=min(opAmount,exchanges[1].GetAccount().Balance/buytarget.Price)\n            sellAmount=min(buyAmount,exchanges[0].GetAccount().Stocks)\n            \n            if diffA > (buyAmount*depthB.Asks[0].Price*0.2/100+sellAmount*depthA.Bids[0].Price*0.2/100)*p:\n                Log('buy from B sell at A')\n                Log(\"A平台币\",exchanges[0].GetAccount().Stocks,\"A平台钱\",exchanges[0].GetAccount().Balance,\"B平台币\",exchanges[1].GetAccount().Stocks,\"B平台钱\",exchanges[1].GetAccount().Balance)\n                tradeAmount=min(buyAmount,sellAmount)     \n                buyorder =exchanges[1].Buy(buytarget.Price,tradeAmount)\n                sellorder = exchanges[0].Sell(depthA.Bids[0].Price,tradeAmount)\n                canceller = 0\n                    \n                    \n                while True:\n             \n                    \n                    \n                    if (exchanges[1].GetOrder(buyorder).Status == 2) and (exchanges[0].GetOrder(sellorder).Status == 2):\n                        Log('deal transactioned')\n                        buyPrice = exchanges[1].GetOrder(buyorder).Price\n                        sellPrice = exchanges[0].GetOrder(sellorder).Price\n                        LogProfit(exchanges[0].GetOrder(sellorder).Amount*exchanges[0].GetOrder(sellorder).Price-exchanges[1].GetOrder(buyorder).Amount*exchanges[1].GetOrder(buyorder).Price)\n                        dealtransactioned = True\n                        break\n                    elif ((exchanges[1].GetOrder(buyorder).Status == 1) or (exchanges[0].GetOrder(sellorder).Status == 1)):\n                        buyPrice = exchanges[1].GetOrder(buyorder).Price\n                        sellPrice = exchanges[0].GetOrder(sellorder).Price\n                        canceller += 1\n                        dealtransactioned = True\n                        Sleep(200)\n                    elif ((exchanges[1].GetOrder(buyorder).Status == 0) and (exchanges[0].GetOrder(sellorder).Status == 0)):\n                        Sleep(200)\n                        canceller += 1\n                    if canceller == 5:        \n                        exchanges[1].CancelOrder(buyorder)\n                        exchanges[0].CancelOrder(sellorder)\n                        Log('deal cancelled')       \n                        break    \n                \n                    \n\n        elif diffB > 0:\n            \n            opAmount=min(depthB.Bids[0].Amount,depthA.Asks[0].Amount)\n            buyAmount=min(opAmount,exchanges[0].GetAccount().Balance/depthA.Asks[0].Price)\n            sellAmount=min(buyAmount,exchanges[1].GetAccount().Stocks)\n            canceller = 0\n            if diffB > (buyAmount*depthA.Asks[0].Price*0.2/100+sellAmount*depthB.Bids[0].Price*0.2/100)*p:\n                Log('buy from A sell at B')\n                \n                tradeAmount=min(buyAmount,sellAmount)\n                buyorder=exchanges[0].Buy(depthA.Asks[0].Price,tradeAmount)\n                sellorder=exchanges[1].Sell(depthB.Bids[0].Price,tradeAmount)\n                canceller =0\n                \n                while True:\n                       \n                    if (exchanges[0].GetOrder(buyorder).Status == 2) and (exchanges[1].GetOrder(sellorder).Status == 2):\n                        Log('deal transactioned')\n                        buyPrice=exchanges[0].GetOrder(buyorder).Price\n                        sellPrice=exchanges[1].GetOrder(sellorder).Price\n                        LogProfit(exchanges[1].GetOrder(sellorder).Amount*exchanges[1].GetOrder(sellorder).Price-exchanges[0].GetOrder(buyorder).Amount*exchanges[0].GetOrder(buyorder).Price)\n                        dealtransactioned = True\n                        break\n                    elif ((exchanges[0].GetOrder(buyorder).Status == 1) or (exchanges[1].GetOrder(sellorder).Status == 1)):\n                        \n                        buyPrice=exchanges[0].GetOrder(buyorder).Price\n                        sellPrice=exchanges[1].GetOrder(sellorder).Price\n                        canceller += 1\n                        dealtransactioned = True\n                        Sleep(200)\n                    elif ((exchanges[0].GetOrder(buyorder).Status == 0) and (exchanges[1].GetOrder(sellorder).Status == 0)):\n                        Sleep(200)\n                        canceller += 1\n                    if canceller == 5:        \n                        exchanges[0].CancelOrder(buyorder)\n                        exchanges[1].CancelOrder(sellorder)\n                        Log('deal cancelled')       \n                        break \n              \n        '''balance part'''\n        for i in [0,1]:\n            if dealtransactioned:\n                if(exchanges[i].GetAccount().Stocks > (initStocks/2)* q and exchanges[i].GetAccount().Balance < (initBalance/2)*q):           \n                    sellwait = 1\n                    Log('ready to sell')\n                    loopbreaker = 0\n                    while (sellwait):\n                        \n                        if (_N(depthCache[i].Bids[0].Price,3)> buyPrice*r):\n                            sellwait = 0\n\n                            break\n                        else:\n                            Sleep(1000)\n                            Log('sellwait')\n                            loopbreaker += 1\n                        if loopbreaker == 600:\n                            '''break'''\n                        \n                    \n\n                    sellTrue = 1\n\n                    while(sellTrue):\n                        dealprice = depthCache[i].Bids[0].Price\n                        Log('insufficient money, sell some')\n                        idealamount = initBalance/8\n                        availamount = exchanges[i].GetAccount().Stocks/2\n                        dealamount = min(idealamount,availamount)\n                        balancesell = exchanges[i].Sell(depthCache[i].Bids[0].Price, dealamount)\n                        Sleep(200)\n                        while( exchanges[i].GetOrder(balancesell).Status not in [1,2] ):\n                            exchanges[i].CancelOrder(balancesell)\n                            if( dealprice > buyPrice):\n                                dealprice -= 1\n                            balancesell = exchanges[i].Sell(dealprice,dealamount)\n                            Sleep(200)\n                        '''buyPrice=[]'''\n                        Log(\"Sell Balance finished\")\n                        sellTrue=0\n\n\n                if(exchanges[i].GetAccount().Balance > (initBalance/2)*q and exchanges[i].GetAccount().Stocks < (initStocks/2)*q):\n                    buywait = 1\n                    loopbreaker = 0\n                    while (buywait):\n                        \n                        if(_N(depthCache[i].Asks[0].Price,3)< sellPrice*r):\n\n                            buywait=0\n\n                            break\n                        else:\n                            Sleep(1000)\n                            Log(_N(depthCache[i].Asks[0].Price,3),sellPrice*r)\n                            loopbreaker +=1\n                        if loopbreaker == 600:\n                            '''break\n                        break'''\n                            \n\n\n\n                    buyTrue = 1\n                    while(buyTrue):\n                        Log('buyTrue started')\n                        dealprice = depthCache[i].Asks[0].Price\n                        Log('insufficient stocks, buy some')\n                        idealamount = initStocks/8\n                        availamount = exchanges[i].GetAccount().Balance/dealprice/2\n                        dealamount = min(idealamount,availamount)\n                        balancebuy = exchanges[i].Buy(dealprice,dealamount)\n                        Sleep(200)\n                        while(exchanges[i].GetOrder(balancebuy).Status not in [1,2]):\n\n                            exchanges[i].CancelOrder(balancebuy)\n                            if (dealprice < sellPrice):\n                                dealprice += 1\n                            balancebuy = exchanges[i].Buy(dealprice,dealamount)\n                            Sleep(200)\n                        '''sellPrice=[]'''\n                        Log(\"Buy Balance finished\")\n                        buyTrue = 0\n                        break\n                else:         \n                    continue\n                break\n            else:\n                break",
        "strategy_description": "策略名称: 双平台对冲-练习用-求交流求指点\n\n未找到描述"
    },
    {
        "strategy_id": "69_双平台对冲平衡策略",
        "strategy_code": "python\n'''backtest\nstart: 2024-11-19 00:00:00\nend: 2024-12-18 08:00:00\nperiod: 1d\nbasePeriod: 1d\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"TRB_USDT\"},{\"eid\":\"OKX\",\"currency\":\"TRB_USDT\"}]\n'''\n\nimport time\nimport json\n\n# 全局变量定义\ndepthA = depthB = None\ntimeBegin = timeEnd = None\naskPriceA = bidPriceA = askAmountA = bidAmountA = 0\naskPriceB = bidPriceB = askAmountB = bidAmountB = 0\nminAmount = 20  # 最小下单量\nfeeA = 0.0020  # Huobi 手续费   \nfeeB = 0.0010  # Binance 手续费\nfees = None\nminProfit = 0.0002  # 最小利润\nnotDealAmountA = notDealAmountB = None\naccountA = accountB = None\ninitAccountA = initAccountB = None\nmaxDeltaAmount = 100  # 最大可容忍币偏差\ndealAmountA = 0\ndealAmountB = 0\nsafeAmount = 800  # 安全最大成交量\nprofit = None\nmaxTime = 150  # 最大延迟过滤\naccountBNB = None\nreload = False\n\n# 初始化函数\ndef init():\n    global fees, initAccountA, initAccountB, accountA, accountB\n\n    try:\n        fees = feeA + feeB\n\n        initAccountA = _G(\"initAccountA\")\n        initAccountB = _G(\"initAccountB\")\n        \n        if initAccountA is None or initAccountB is None:\n            initAccountA = _C(exchanges[0].GetAccount)\n            initAccountB = _C(exchanges[1].GetAccount)\n            _G(\"initAccountA\", initAccountA)\n            _G(\"initAccountB\", initAccountB)\n            Log(\"账号初值初始化成功\")\n        else:\n            Log(\"继承初值数据成功\")\n        \n        accountA = initAccountA\n        accountB = initAccountB\n\n    except Exception as e:\n        Log(\"初始化失败 请重启:\", e)\n\n# 规范化深度数据\ndef legalize_depth(depthA, depthB):\n    global askPriceA, bidPriceA, askAmountA, bidAmountA\n    global askPriceB, bidPriceB, askAmountB, bidAmountB\n\n    askPriceA = bidPriceA = askAmountA = bidAmountA = 0\n    askPriceB = bidPriceB = askAmountB = bidAmountB = 0\n\n    for ask in depthA[0][\"Asks\"]:\n        askPriceA = ask[\"Price\"]\n        askAmountA += ask[\"Amount\"]\n        if askAmountA >= minAmount:\n            break\n\n    for bid in depthA[0][\"Bids\"]:\n        bidPriceA = bid[\"Price\"]\n        bidAmountA += bid[\"Amount\"]\n        if bidAmountA >= minAmount:\n            break\n\n    for ask in depthB[0][\"Asks\"]:\n        askPriceB = ask[\"Price\"]\n        askAmountB += ask[\"Amount\"]\n        if askAmountB >= minAmount:\n            break\n\n    for bid in depthB[0][\"Bids\"]:\n        bidPriceB = bid[\"Price\"]\n        bidAmountB += bid[\"Amount\"]\n        if bidAmountB >= minAmount:\n            break\n\n# 取消所有挂单\ndef cancel_all_orders():\n    global dealAmountA, dealAmountB\n\n    orders = _C(exchanges[0].GetOrders)\n    for order in orders:\n        exchanges[0].CancelOrder(order[\"Id\"])\n        Log(\"成交:\", order[\"DealAmount\"], \"未成交:\", order[\"Amount\"] - order[\"DealAmount\"])\n        dealAmountA -= order[\"Amount\"] - order[\"DealAmount\"]\n\n    orders = _C(exchanges[1].GetOrders)\n    for order in orders:\n        exchanges[1].CancelOrder(order[\"Id\"])\n        Log(\"成交:\", order[\"DealAmount\"], \"未成交:\", order[\"Amount\"] - order[\"DealAmount\"])\n        dealAmountB -= order[\"Amount\"] - order[\"DealAmount\"]\n\n# 检查余额\ndef check_balance():\n    global accountA, accountB, dealAmountA, dealAmountB\n\n    cancel_all_orders()\n    deltaStocks = (initAccountA[\"Stocks\"] + initAccountA[\"FrozenStocks\"] + initAccountB[\"Stocks\"] + initAccountB[\"FrozenStocks\"]\n        - accountA[\"Stocks\"] - accountA[\"FrozenStocks\"] - accountB[\"Stocks\"] - accountB[\"FrozenStocks\"])\n\n    deltaStocks = round(deltaStocks, 0)\n\n    if deltaStocks < -maxDeltaAmount:  # 仓位过重\n        if askPriceA > askPriceB and accountA[\"Stocks\"] > -deltaStocks:\n            exchanges[0].Sell(askPriceA, -deltaStocks)\n            dealAmountA += -deltaStocks\n        else:\n            exchanges[1].Sell(askPriceB, -deltaStocks)\n            dealAmountB += -deltaStocks\n        return True\n\n    if deltaStocks > maxDeltaAmount:  # 仓位过轻\n        if bidPriceA < bidPriceB and accountA[\"Balance\"] * 0.999 / bidPriceA > deltaStocks:\n            exchanges[0].Buy(bidPriceA, deltaStocks)\n            dealAmountA += deltaStocks\n        else:\n            exchanges[1].Buy(bidPriceB, deltaStocks)\n            dealAmountB += deltaStocks\n        return True\n\n    return False\n\n# 更新利润\ndef update_profit():\n    global profit\n\n    profit = (\n        accountA[\"Balance\"] + accountB[\"Balance\"] + accountA[\"FrozenBalance\"] + accountB[\"FrozenBalance\"]\n        + (accountA[\"Stocks\"] + accountA[\"FrozenStocks\"] + accountB[\"Stocks\"] + accountB[\"FrozenStocks\"]\n        - initAccountA[\"Stocks\"] - initAccountA[\"FrozenStocks\"] - initAccountB[\"Stocks\"] - initAccountB[\"FrozenStocks\"]) * askPriceA\n        - (initAccountA[\"Balance\"] + initAccountA[\"FrozenBalance\"] + initAccountB[\"Balance\"] + initAccountB[\"FrozenBalance\"]))\n\n    return profit\n\n# 检查套利机会\ndef check_opportunity():\n    global dealAmountA, dealAmountB, accountA, accountB, diff_A, diff_B \n\n    diff_A = bidPriceB - askPriceA  # A交易所买 -> B交易所卖\n    diff_B = bidPriceA - askPriceB  # B交易所买 -> A交易所卖\n\n    if diff_A > 0 and diff_A > (minProfit + fees) * askPriceA:\n        maxBuyAmount = min(accountA[\"Balance\"] / askPriceA * 0.98, askAmountA)\n        maxSellAmount = min(accountB[\"Stocks\"], bidAmountB)\n        amount = min(maxBuyAmount, maxSellAmount, safeAmount)\n        amount = round(amount, 0)\n\n        if amount >= minAmount:\n            Log(\"huobi -> binance\", amount)\n            exchanges[0].Buy(askPriceA, amount)\n            exchanges[1].Sell(bidPriceB, amount)\n            time.sleep(3)\n            dealAmountA += amount\n            dealAmountB += amount\n            accountA = _C(exchanges[0].GetAccount)\n            accountB = _C(exchanges[1].GetAccount)\n            Log(\"利润更新:\", update_profit())\n\n    if diff_B > 0 and diff_B > (minProfit + fees) * askPriceB:\n        maxBuyAmount = min(accountB[\"Balance\"] / askPriceB * 0.98, askAmountB)\n        maxSellAmount = min(accountA[\"Stocks\"], bidAmountA)\n        amount = min(maxBuyAmount, maxSellAmount, safeAmount)\n        amount = round(amount, 0)\n\n        if amount >= minAmount:\n            Log(\"binance -> huobi\", amount)\n            exchanges[1].Buy(askPriceB, amount)\n            exchanges[0].Sell(bidPriceA, amount)\n            time.sleep(3)\n            dealAmountA += amount\n            dealAmountB += amount\n            accountA = _C(exchanges[0].GetAccount)\n            accountB = _C(exchanges[1].GetAccount)\n            Log(\"利润更新:\", update_profit())\n\ndef main():\n    global initAccountA, initAccountB\n    if reload == True:\n        initAccountA = _C(exchanges[0].GetAccount)\n        initAccountB = _C(exchanges[1].GetAccount)\n        _G(\"initAccountA\", initAccountA)\n        _G(\"initAccountB\", initAccountB)\n\n    init()\n\n    checkBalanceCount = 60\n    \n    while True:\n        accountA = exchanges[0].GetAccount()\n        accountB = exchanges[1].GetAccount()\n        timeBegin = int(time.time() * 1000)\n        depthA = exchanges[0].Go(\"GetDepth\")\n        depthB = exchanges[1].Go(\"GetDepth\")\n        depthA = depthA.wait()\n        depthB = depthB.wait()\n        \n        timeEnd = int(time.time() * 1000)\n        # 真实交易，去除205-208注释\n        #if timeEnd - timeBegin > maxTime:\n        #    continue  # 延迟超过 maxTime 毫秒就放弃当组数据\n        #if depthA is None or depthB is None or accountA is None or accountB is None:\n        #    continue\n\n        legalize_depth(depthA, depthB)\n\n        if checkBalanceCount >= 60:\n            checkBalanceCount = 0\n            if check_balance():\n                continue\n        else:\n            checkBalanceCount += 1\n        \n        check_opportunity()\n        \n        # 数据可视化操作\n        table = {\n            'type': 'table',\n            'title': '持仓操作',\n            'cols': ['交易所', '初始余额', '初始币数', '当前余额', '当前币数', '成交量'],\n            'rows': [\n                ['huobi', initAccountA.Balance + initAccountA.FrozenBalance, initAccountA.Stocks + initAccountA.FrozenStocks,\n                    accountA.Balance + accountA.FrozenBalance, accountA.Stocks + accountA.FrozenStocks, dealAmountA],\n                ['binance', initAccountB.Balance + initAccountB.FrozenBalance, initAccountB.Stocks + initAccountB.FrozenStocks,\n                    accountB.Balance + accountB.FrozenBalance, accountB.Stocks + accountB.FrozenStocks, dealAmountB],\n                ['合计', initAccountA.Balance + initAccountB.Balance, initAccountA.Stocks + initAccountB.Stocks,\n                    accountA.Balance + accountA.FrozenBalance + accountB.Balance + accountB.FrozenBalance,\n                    accountA.Stocks + accountA.FrozenStocks + accountB.Stocks + accountB.FrozenStocks, dealAmountA + dealAmountB],\n                ['huobi盘口', askPriceA, askAmountA, bidPriceA, bidAmountA, ''],\n                ['binance盘口', askPriceB, askAmountB, bidPriceB, bidAmountB, ''],\n                ['收益:', str(_N(update_profit(), 8)) + '#FF0000',  '', '', ''],\n                ['收益率', str(_N(100 * profit / (initAccountA.Balance + initAccountA.FrozenBalance + initAccountB.Balance + initAccountB.FrozenBalance), 6)) + '%' + '#FF0000', '', '', '', ''],\n                ['总延迟', timeEnd - timeBegin, '', '', '', ''],\n                ['最后更新时间', _D(), '', '', '', ''],\n            ]\n        }\n        LogStatus('`' + json.dumps(table) + '`')\n\n        time.sleep(10)",
        "strategy_description": "策略名称: 双平台对冲平衡策略\n\ndepthA = depthB = None\ntimeBegin = timeEnd = None\naskPriceA = bidPriceA = askAmountA = bidAmountA = 0\naskPriceB = bidPriceB = askAmountB = bidAmountB = 0\nminAmount = 20  # 最小下单量\nfeeA = 0.0020  # Huobi 手续费   \nfeeB = 0.0010  # Binance 手续费\nfees = None\nminProfit = 0.0002  # 最小利润\nnotDealAmountA = notDealAmountB = None\naccountA = accountB = None\ninitAccountA = initAccountB = None\nmaxDeltaAmount = 100  # 最大可容忍币偏差\ndealAmountA = 0\ndealAmountB = 0\nsafeAmount = 800  # 安全最大成交量\nprofit = None\nmaxTime = 150  # 最大延迟过滤\naccountBNB = None\nreload = False"
    },
    {
        "strategy_id": "70_可变图表示例",
        "strategy_code": "python\nPS = ext.PersistentStorage()\nALPHA = 0.0008\nclass GraphManager:\n\n    diffs_chart = {\n        '__isStock': False,\n        'extension': {\n            'layout': 'single',\n            'height': 300,\n            'col': 6\n        },\n        'chart': {\n            'zoomType': 'x'\n        },\n        'title': {\n            'text': '各币种价格与指数的偏离值'\n        },\n        'subtitle': {\n            'text': 'Alpha: %s' % ALPHA\n        },\n        'xAxis': {\n            'type': 'datetime'\n        },\n        'series': []\n    }\n    index_chart = {\n        '__isStock': False,\n        'extension': {\n            'layout': 'single',\n            'height': 300,\n            'col': 6\n        },\n        'chart': {\n            'zoomType': 'x'\n        },\n        'title': {\n            'text': '基准指数值'\n        },\n        'xAxis': {\n            'type': 'datetime'\n        },\n        'series': [{\n            'type': 'line',\n            'name': 'INDEX',\n            'data': []\n        }]\n    }\n    pos_chart = {\n        '__isStock': False,\n        'extension': {\n            'layout': 'single',\n            'height': 300,\n            'col': 6\n        },\n        'chart': {\n            'zoomType': 'x'\n        },\n        'title': {\n            'text': '各币种当前持仓价值'\n        },\n        'subtitle': {\n            'text': '以USDT计算'\n        },\n        'xAxis': {\n            'type': 'datetime'\n        },\n        'series': []\n    }\n    upnl_chart = {\n        '__isStock': False,\n        'extension': {\n            'layout': 'single',\n            'height': 300,\n            'col': 6\n        },\n        'chart': {\n            'zoomType': 'x'\n        },\n        'title': {\n            'text': '各币种当前未实现盈亏'\n        },\n        'subtitle': {\n            'text': '以USDT计算'\n        },\n        'xAxis': {\n            'type': 'datetime'\n        },\n        'series': []\n    }\n\n    def __init__(self, reset: bool):\n        self.indices = {}\n        self.diffs_data = {}\n        self.pos_data = {}\n        self.upnl_data = {}\n        self.index = 1\n        self.not_manual_reset = True\n        if PS['symbols'] is None or reset:\n            echo('图表管理器第一次初始化')\n            if reset:\n                PS['symbols'] = None\n                self.not_manual_reset = False\n\n    def initialize(self, symbols):\n        self.symbols = symbols\n        self.create_chart()\n        if self.symbols != PS['symbols']:\n            if self.not_manual_reset:\n                echo('币种出现更改，图表重新初始化')\n            self.reset_graph()\n        PS['symbols'] = self.symbols\n\n    def reset_graph(self):\n        self.chart.reset(0)\n\n    def create_chart(self):\n        i = 0\n        for symbol in self.symbols:\n            # DIFF Chart\n            self.diffs_chart['series'].append({\n                'type': 'line',\n                'name': symbol,\n                'data': []\n            })\n            self.indices[symbol+'_diff'] = i\n            i+=1\n        # INDEX Chart\n        self.indices['INDEX_CHART'] = i\n        i+=1\n        for symbol in self.symbols:\n            # POS Chart\n            self.pos_chart['series'].append({\n                'type': 'line',\n                'name': symbol,\n                'data': []\n            })\n            self.indices[symbol+'_pos'] = i\n            i+=1\n        for symbol in self.symbols:\n            # UPNL Chart\n            self.upnl_chart['series'].append({\n                'type': 'line',\n                'name': symbol,\n                'data': []\n            })\n            self.indices[symbol+'_upnl'] = i\n            i+=1\n        self.chart = Chart([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])\n\n    def add_diff_data(self, symbol, diff):\n        self.diffs_data[symbol] = diff\n\n    def add_pos_data(self, symbol, pos):\n        self.pos_data[symbol] = pos\n\n    def add_upnl_data(self, symbol, upnl):\n        self.upnl_data[symbol] = upnl\n\n    def add_index_data(self, index):\n        self.index = index\n\n    def update_chart(self, timestamp):\n        for symbol in self.diffs_data.keys():\n            index = self.indices[symbol+'_diff']\n            data = self.diffs_data[symbol]\n            self.chart.add(index, [timestamp, data])\n\n        for symbol in self.pos_data.keys():\n            index = self.indices[symbol+'_pos']\n            data = self.pos_data[symbol]\n            self.chart.add(index, [timestamp, data])\n\n        for symbol in self.upnl_data.keys():\n            index = self.indices[symbol+'_upnl']\n            data = self.upnl_data[symbol]\n            self.chart.add(index, [timestamp, data])\n\n        index = self.indices['INDEX_CHART']\n        self.chart.add(index, [timestamp, self.index])\n        self.chart.update([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])",
        "strategy_description": "策略名称: 可变图表示例\n\nself.diffs_chart['series'].append({\n                'type': 'line',\n                'name': symbol,\n                'data': []\n            })\n            self.indices[symbol+'_diff'] = i\n            i+=1\n        # INDEX Chart\n        self.indices['INDEX_CHART'] = i\n        i+=1\n        for symbol in self.symbols:\n            # POS Chart\n            self.pos_chart['series'].append({\n                'type': 'line',\n                'name': symbol,\n                'data': []\n            })\n            self.indices[symbol+'_pos'] = i\n            i+=1\n        for symbol in self.symbols:\n            # UPNL Chart\n            self.upnl_chart['series'].append({\n                'type': 'line',\n                'name': symbol,\n                'data': []\n            })\n            self.indices[symbol+'_upnl'] = i\n            i+=1\n        self.chart = Chart([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])\n\n    def add_diff_data(self, symbol, diff):\n        self.diffs_data[symbol] = diff\n\n    def add_pos_data(self, symbol, pos):\n        self.pos_data[symbol] = pos\n\n    def add_upnl_data(self, symbol, upnl):\n        self.upnl_data[symbol] = upnl\n\n    def add_index_data(self, index):\n        self.index = index\n\n    def update_chart(self, timestamp):\n        for symbol in self.diffs_data.keys():\n            index = self.indices[symbol+'_diff']\n            data = self.diffs_data[symbol]\n            self.chart.add(index, [timestamp, data])\n\n        for symbol in self.pos_data.keys():\n            index = self.indices[symbol+'_pos']\n            data = self.pos_data[symbol]\n            self.chart.add(index, [timestamp, data])\n\n        for symbol in self.upnl_data.keys():\n            index = self.indices[symbol+'_upnl']\n            data = self.upnl_data[symbol]\n            self.chart.add(index, [timestamp, data])\n\n        index = self.indices['INDEX_CHART']\n        self.chart.add(index, [timestamp, self.index])\n        self.chart.update([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/214723\n\n> Last Modified\n\n2020-06-17 11:27:43"
    },
    {
        "strategy_id": "71_各平台策略代写区块链5年专业经验低价高质量-薇芯bov1107",
        "strategy_code": "python\ndef main():\n    Log(exchange.GetAccount())",
        "strategy_description": "策略名称: 各平台策略代写区块链5年专业经验低价高质量-薇芯bov1107\n\n未找到描述"
    },
    {
        "strategy_id": "72_各平台策略代写区块链5年专业经验低价高质量薇芯bov1107",
        "strategy_code": "python\ndef main():\n    Log(exchange.GetAccount())",
        "strategy_description": "策略名称: 各平台策略代写区块链5年专业经验低价高质量薇芯bov1107\n\n未找到描述"
    },
    {
        "strategy_id": "73_合成任意周期K线-使用请看源码最下面",
        "strategy_code": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n# \n# Candlestick merger.\n#\n# Copyright 2018 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n# Do What the Fuck You Want To Public License\n#\n\nfrom math import *\nfrom datetime import datetime\n\ndef timeFilter(records, since, to=1000000000000000):\n    bars = []\n    for i in records:\n        if i['Time'] >= since and i['Time'] <= to:\n            bars.append(i)\n\n    return bars\n\ndef calcRecords(records, period=30, start=None):\n    try:\n        records[0]\n    except IndexError:\n        return []\n    \n    period_ms = period * 60000  # 以毫秒记的K线周期\n    end_in = records[len(records)-1]['Time']  # K线的结束时间\n    start_at = records[0]['Time']  # K线的开始时间\n    \n    # 获得可以用于计算目标K线的开始时间\n    r_offest = start_at % period_ms\n    start_at = start_at - r_offest + period_ms\n    if start is not None:\n        start_at = start\n    \n    target_count = ceil((end_in-start_at)/period_ms) # 目标K线的数量\n    \n    n_records = []\n    \n    for i in range(0, target_count):\n        bars = timeFilter(records, start_at+i*period_ms, start_at+(i+1)*period_ms-1000)\n        try:\n            bars[0]\n        except IndexError:\n            continue\n        # 初始化新的Bar\n        Time = bars[0]['Time']\n        Open = bars[0]['Open']\n        High = bars[0]['High']\n        Low = bars[0]['Low']\n        Close = bars[0]['Close']\n        Volume = 0\n        for item in bars:\n            High = max(High, item['High'])\n            Low = min(Low, item['Low'])\n            Close = item['Close']\n            Volume+=item['Volume']\n            \n        # 将Bar添加添加到新的K线中\n        n_records.append(dict({\n            'Time' : Time,\n            'Open' : Open,\n            'High' : High,\n            'Low' : Low,\n            'Close' : Close,\n            'Volume' : Volume\n        }))\n        \n    return n_records\n\ndef getRecords(exchange, period=30):\n    records = exchange.GetRecords(PERIOD_M1)\n        \n    return calcRecords(records, period)\n\ndef calcRecordsWithOldRecords(records, old_records, period=30):\n    try:\n        start = old_records[len(old_records)-1]['Time']\n        del old_records[len(old_records)-1]\n    except IndexError:\n        old_records = []\n        start = None\n        \n    return old_records + calcRecords(records=records, period=period, start=start)\n        \next.calcRecords = calcRecords\next.getRecords = getRecords\next.calcRecordsWithOldRecords = calcRecordsWithOldRecords\n\n# Function Test\ndef main():\n    LogReset()\n    M1 = exchange.GetRecords(PERIOD_M1)\n    M15 = exchange.GetRecords(PERIOD_M15)\n    M15_GEN = ext.calcRecords(M1, 15) # 使用ext.calcRecords函数 按照1分钟K线 计算出15分钟K线\n    Log(M15[len(M15)-50:])\n    Log(M15_GEN[len(M15_GEN)-50:])",
        "strategy_description": "策略名称: 合成任意周期K线-使用请看源码最下面\n\n# encoding: utf-8"
    },
    {
        "strategy_id": "74_回测保存K线到本地CSV",
        "strategy_code": "python\n'''\n/*backtest\nstart: 2017-10-01        \nend: 2017-11-16          \nperiod: 1440\nperiodBase: 15\nmode: 0                 \n*/\n'''\n\n#需要用的pandas库，并且用自己的托管回测才能保存到本地\n#import numpy as np\nimport pandas as pd\n\n#保存路径\npath = 'C:\\\\Users\\\\Public\\\\Documents\\\\'\n\ndef main():\n    df=pd.DataFrame()\n    while True:\n        records = _C(exchange.GetRecords)\n        df_new = pd.DataFrame(records)  #把records转为dataframe\n        df_new['Time'] = pd.to_datetime(df_new['Time'],unit='ms')+pd.Timedelta('8 h')\n        df_new.index = df_new['Time']\n        if df.empty or df_new['Time'].min() >= df['Time'].max():\n            df=df.combine_first(df_new)\n            Log(df['Time'].max())\n        #确定最后一次时间，用于保存数据\n        if df_new['Time'].max() == pd.Timestamp('2017-11-15 23:45:00'):\n            Log('保存数据')\n            df=df.combine_first(df_new)\n            df.to_csv(path+'records15.csv',index=False)\n            break\n        #休眠时间是选择周期\n        Sleep(15*60*1000)",
        "strategy_description": "策略名称: 回测保存K线到本地CSV\n\n未找到描述"
    },
    {
        "strategy_id": "75_回测系统随机行情生成器",
        "strategy_code": "python\nimport _thread\nimport json\nimport math\nimport csv\nimport random\nimport os\nimport datetime as dt\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse\n\narrTrendType = [\"down\", \"slow_up\", \"sharp_down\", \"sharp_up\", \"narrow_range\", \"wide_range\", \"neutral_random\"]\n\ndef url2Dict(url):\n    query = urlparse(url).query  \n    params = parse_qs(query)  \n    result = {key: params[key][0] for key in params}  \n    return result\n\nclass Provider(BaseHTTPRequestHandler):\n    def do_GET(self):\n        global filePathForCSV, pround, vround, ct\n        try:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"application/json\")\n            self.end_headers()\n\n            dictParam = url2Dict(self.path)\n            Log(\"自定义数据源服务接收到请求，self.path:\", self.path, \"query 参数：\", dictParam)            \n            \n            eid = dictParam[\"eid\"]\n            symbol = dictParam[\"symbol\"]\n            arrCurrency = symbol.split(\".\")[0].split(\"_\")\n            baseCurrency = arrCurrency[0]\n            quoteCurrency = arrCurrency[1]\n            fromTS = int(dictParam[\"from\"]) * int(1000)\n            toTS = int(dictParam[\"to\"]) * int(1000)\n            priceRatio = math.pow(10, int(pround))\n            amountRatio = math.pow(10, int(vround))\n\n            data = {\n                \"detail\": {\n                    \"eid\": eid,\n                    \"symbol\": symbol,\n                    \"alias\": symbol,\n                    \"baseCurrency\": baseCurrency,\n                    \"quoteCurrency\": quoteCurrency,\n                    \"marginCurrency\": quoteCurrency,\n                    \"basePrecision\": vround,\n                    \"quotePrecision\": pround,\n                    \"minQty\": 0.00001,\n                    \"maxQty\": 9000,\n                    \"minNotional\": 5,\n                    \"maxNotional\": 9000000,\n                    \"priceTick\": 10 ** -pround,\n                    \"volumeTick\": 10 ** -vround,\n                    \"marginLevel\": 10,\n                    \"contractType\": ct\n                },\n                \"schema\" : [\"time\", \"open\", \"high\", \"low\", \"close\", \"vol\"],\n                \"data\" : []\n            }\n            \n            listDataSequence = []\n            with open(filePathForCSV, \"r\") as f:\n                reader = csv.reader(f)\n                header = next(reader)\n                headerIsNoneCount = 0\n                if len(header) != len(data[\"schema\"]):\n                    Log(\"CSV文件格式有误，列数不同，请检查！\", \"#FF0000\")\n                    return \n                for ele in header:\n                    for i in range(len(data[\"schema\"])):\n                        if data[\"schema\"][i] == ele or ele == \"\":\n                            if ele == \"\":\n                                headerIsNoneCount += 1\n                            if headerIsNoneCount > 1:\n                                Log(\"CSV文件格式有误，请检查！\", \"#FF0000\")\n                                return \n                            listDataSequence.append(i)\n                            break\n                \n                while True:\n                    record = next(reader, -1)\n                    if record == -1:\n                        break\n                    index = 0\n                    arr = [0, 0, 0, 0, 0, 0]\n                    for ele in record:\n                        arr[listDataSequence[index]] = int(ele) if listDataSequence[index] == 0 else (int(float(ele) * amountRatio) if listDataSequence[index] == 5 else int(float(ele) * priceRatio))\n                        index += 1\n                    data[\"data\"].append(arr)            \n            Log(\"数据data.detail：\", data[\"detail\"], \"响应回测系统请求。\")\n            self.wfile.write(json.dumps(data).encode())\n        except BaseException as e:\n            Log(\"Provider do_GET error, e:\", e)\n        return \n\ndef createServer(host):\n    try:\n        server = HTTPServer(host, Provider)\n        Log(\"Starting server, listen at: %s:%s\" % host)\n        server.serve_forever()\n    except BaseException as e:\n        Log(\"createServer error, e:\", e)\n        raise Exception(\"stop\")\n\nclass KlineGenerator:\n    def __init__(self, start_time, end_time, interval):\n        self.start_time = dt.datetime.strptime(start_time, \"%Y-%m-%d %H:%M:%S\")\n        self.end_time = dt.datetime.strptime(end_time, \"%Y-%m-%d %H:%M:%S\")\n        self.interval = self._parse_interval(interval)\n        self.timestamps = self._generate_time_series()\n\n    def _parse_interval(self, interval):\n        unit = interval[-1]\n        value = int(interval[:-1])\n\n        if unit == \"m\":\n            return value * 60\n        elif unit == \"h\":\n            return value * 3600\n        elif unit == \"d\":\n            return value * 86400\n        else:\n            raise ValueError(\"不支持的K线周期，请使用 'm', 'h', 或 'd'.\")\n\n    def _generate_time_series(self):\n        timestamps = []\n        current_time = self.start_time\n        while current_time <= self.end_time:\n            timestamps.append(int(current_time.timestamp() * 1000))\n            current_time += dt.timedelta(seconds=self.interval)\n        return timestamps\n\n    def generate(self, initPrice, trend_type=\"neutral\", volatility=1):\n        data = []\n        current_price = initPrice\n        angle = 0\n        for timestamp in self.timestamps:\n            angle_radians = math.radians((angle + random.uniform(0, 360)) % 360)\n            cos_value = math.cos(angle_radians)   #  -1 ~ 1\n\n            if trend_type == \"down\":\n                change = random.uniform(-0.5, 0.4) * volatility * abs(cos_value) \n            elif trend_type == \"slow_up\":\n                change = random.uniform(-0.4, 0.5) * volatility * abs(cos_value) \n            elif trend_type == \"sharp_down\":\n                change = random.uniform(-10, 7) * volatility * abs(cos_value) \n            elif trend_type == \"sharp_up\":\n                change = random.uniform(-7, 10) * volatility * abs(cos_value) \n            elif trend_type == \"narrow_range\":\n                change = random.uniform(-0.2, 0.2) * volatility * abs(cos_value) \n            elif trend_type == \"wide_range\":\n                change = random.uniform(-20, 20) * volatility * abs(cos_value) \n            else:\n                change = random.uniform(-1, 1) * volatility * abs(cos_value) \n            \n            open_price = current_price\n            close_price = open_price + change\n            high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price + random.uniform(0, abs(change))\n            low_price = close_price - random.uniform(0, abs(change)) if open_price > close_price else open_price - random.uniform(0, abs(change))\n\n            if low_price <= 0:\n                change = random.uniform(1, 5) * volatility * abs(cos_value) \n                close_price = open_price + change\n                high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price + random.uniform(0, abs(change))\n                low_price = open_price * random.uniform(0.8, 1)\n\n\n            if (high_price >= open_price and open_price >= close_price and close_price >= low_price) or (high_price >= close_price and close_price >= open_price and open_price >= low_price):\n                pass\n            else:\n                Log(\"异常数据：\", high_price, open_price, low_price, close_price, \"#FF0000\")\n\n            base_volume = random.uniform(1000, 5000)\n            volume = base_volume * (1 + abs(change) * 0.2)\n\n            kline = {\n                \"Time\": timestamp,\n                \"Open\": round(open_price, 2),\n                \"High\": round(high_price, 2),\n                \"Low\": round(low_price, 2),\n                \"Close\": round(close_price, 2),\n                \"Volume\": round(volume, 2),\n            }\n            data.append(kline)\n            current_price = close_price\n            angle += 1\n        return data\n\n    def save_to_csv(self, filename, data):\n        with open(filename, mode=\"w\", newline=\"\") as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow([\"\", \"open\", \"high\", \"low\", \"close\", \"vol\"])\n            for idx, kline in enumerate(data):\n                writer.writerow(\n                    [kline[\"Time\"], kline[\"Open\"], kline[\"High\"], kline[\"Low\"], kline[\"Close\"], kline[\"Volume\"]]\n                )\n        \n        Log(\"当前路径：\", os.getcwd())\n        with open(\"data.csv\", \"r\") as file:\n            lines = file.readlines()\n            if len(lines) > 1:\n                Log(\"文件写入成功，以下是文件内容的一部分：\")\n                Log(\"\".join(lines[:5]))\n            else:\n                Log(\"文件写入失败，文件为空！\")\n\ndef main():\n    Chart({})\n    LogReset(1)\n    \n    try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))\n        Log(\"开启自定义数据源服务线程，数据由CSV文件提供。\", \", 地址/端口：0.0.0.0:9090\", \"#FF0000\")\n    except BaseException as e:\n        Log(\"启动自定义数据源服务失败！\")\n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")\n    \n    while True:\n        cmd = GetCommand()\n        if cmd:\n            if cmd == \"createRecords\":\n                Log(\"生成器参数：\", \"起始时间：\", startTime, \"结束时间：\", endTime, \"K线周期：\", KLinePeriod, \"初始价格：\", firstPrice, \"波动类型：\", arrTrendType[trendType], \"波动性系数：\", ratio)\n                generator = KlineGenerator(\n                    start_time=startTime,\n                    end_time=endTime,\n                    interval=KLinePeriod,\n                )\n                kline_data = generator.generate(firstPrice, trend_type=arrTrendType[trendType], volatility=ratio)\n                generator.save_to_csv(\"data.csv\", kline_data)\n                ext.PlotRecords(kline_data, \"%s_%s\" % (\"records\", KLinePeriod))\n        LogStatus(_D())\n        Sleep(2000)",
        "strategy_description": "策略名称: 回测系统随机行情生成器\n\nif trend_type == \"down\":\n                change = random.uniform(-0.5, 0.4) * volatility * abs(cos_value) \n            elif trend_type == \"slow_up\":\n                change = random.uniform(-0.4, 0.5) * volatility * abs(cos_value) \n            elif trend_type == \"sharp_down\":\n                change = random.uniform(-10, 7) * volatility * abs(cos_value) \n            elif trend_type == \"sharp_up\":\n                change = random.uniform(-7, 10) * volatility * abs(cos_value) \n            elif trend_type == \"narrow_range\":\n                change = random.uniform(-0.2, 0.2) * volatility * abs(cos_value) \n            elif trend_type == \"wide_range\":\n                change = random.uniform(-20, 20) * volatility * abs(cos_value) \n            else:\n                change = random.uniform(-1, 1) * volatility * abs(cos_value) \n            \n            open_price = current_price\n            close_price = open_price + change\n            high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price + random.uniform(0, abs(change))\n            low_price = close_price - random.uniform(0, abs(change)) if open_price > close_price else open_price - random.uniform(0, abs(change))\n\n            if low_price <= 0:\n                change = random.uniform(1, 5) * volatility * abs(cos_value) \n                close_price = open_price + change\n                high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price + random.uniform(0, abs(change))\n                low_price = open_price * random.uniform(0.8, 1)\n\n\n            if (high_price >= open_price and open_price >= close_price and close_price >= low_price) or (high_price >= close_price and close_price >= open_price and open_price >= low_price):\n                pass\n            else:\n                Log(\"异常数据：\", high_price, open_price, low_price, close_price, \"#FF0000\")\n\n            base_volume = random.uniform(1000, 5000)\n            volume = base_volume * (1 + abs(change) * 0.2)\n\n            kline = {\n                \"Time\": timestamp,\n                \"Open\": round(open_price, 2),\n                \"High\": round(high_price, 2),\n                \"Low\": round(low_price, 2),\n                \"Close\": round(close_price, 2),\n                \"Volume\": round(volume, 2),\n            }\n            data.append(kline)\n            current_price = close_price\n            angle += 1\n        return data\n\n    def save_to_csv(self, filename, data):\n        with open(filename, mode=\"w\", newline=\"\") as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow([\"\", \"open\", \"high\", \"low\", \"close\", \"vol\"])\n            for idx, kline in enumerate(data):\n                writer.writerow(\n                    [kline[\"Time\"], kline[\"Open\"], kline[\"High\"], kline[\"Low\"], kline[\"Close\"], kline[\"Volume\"]]\n                )\n        \n        Log(\"当前路径：\", os.getcwd())\n        with open(\"data.csv\", \"r\") as file:\n            lines = file.readlines()\n            if len(lines) > 1:\n                Log(\"文件写入成功，以下是文件内容的一部分：\")\n                Log(\"\".join(lines[:5]))\n            else:\n                Log(\"文件写入失败，文件为空！\")\n\ndef main():\n    Chart({})\n    LogReset(1)\n    \n    try:\n        # _thread.start_new_thread(createServer, ((\"localhost\", 9090), ))\n        _thread.start_new_thread(createServer, ((\"0.0.0.0\", 9090), ))\n        Log(\"开启自定义数据源服务线程，数据由CSV文件提供。\", \", 地址/端口：0.0.0.0:9090\", \"#FF0000\")\n    except BaseException as e:\n        Log(\"启动自定义数据源服务失败！\")\n        Log(\"错误信息：\", e)\n        raise Exception(\"stop\")\n    \n    while True:\n        cmd = GetCommand()\n        if cmd:\n            if cmd == \"createRecords\":\n                Log(\"生成器参数：\", \"起始时间：\", startTime, \"结束时间：\", endTime, \"K线周期：\", KLinePeriod, \"初始价格：\", firstPrice, \"波动类型：\", arrTrendType[trendType], \"波动性系数：\", ratio)\n                generator = KlineGenerator(\n                    start_time=startTime,\n                    end_time=endTime,\n                    interval=KLinePeriod,\n                )\n                kline_data = generator.generate(firstPrice, trend_type=arrTrendType[trendType], volatility=ratio)\n                generator.save_to_csv(\"data.csv\", kline_data)\n                ext.PlotRecords(kline_data, \"%s_%s\" % (\"records\", KLinePeriod))\n        LogStatus(_D())\n        Sleep(2000)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/473286\n\n> Last Modified\n\n2024-12-07 18:32:50"
    },
    {
        "strategy_id": "76_均仓策略",
        "strategy_code": "python\n'''backtest\nstart: 2020-04-03 00:00:00\nend: 2021-04-02 23:59:00\nperiod: 1h\nbasePeriod: 15m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\",\"stocks\":0}]\n'''\n\nimport time\nclass juncang_strategy():  \n    def __init__(self,exchange):\n        self.p = 0.5\n        self.account = None\n        self.cny = 0\n        self.btc = 0\n        self.exchange =exchange\n        #以上都是self对象的属性\n\n    def cancelAllOrders(self):\n        orders = _C(self.exchange.GetOrders)\n        for order in orders:\n            exchange.CancelOrder(order['Id'], order)\n        return True\n\n\n    def balanceAccount(self):\n        self.cancelAllOrders()\n\n        kr =  _C(self.exchange.GetRecords,PERIOD_M1)\n        account = _C(self.exchange.GetAccount)\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n\n        #赋值\n        self.btc = account.Stocks+account.FrozenStocks\n        self.cny = account.Balance+account.FrozenBalance\n        \n        accountmoney=self.btc * kr[-1].Close + self.cny\n        self.p = self.btc * kr[-1].Close / accountmoney\n        # Log(self.p)\n        tradenum=accountmoney/kr[-1].Close/100\n        if tradenum<0.001:\n            tradenum=0.001\n        #判断self.p的值是否小于0.48\n        Log(self.p)\n        if (0.45<self.p < 0.49):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #判断self.p的值是否大于0.52\n        elif (0.55 > self.p > 0.51):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            #调用Sell函数并传入相应的参数\n            self.exchange.Sell(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p >= 0.55):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡,快速平仓\", self.p)\n\n            self.exchange.Sell(kr[-1].Close, tradenum*10)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p <= 0.45):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡，快速建仓\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, tradenum*10)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n\n\n\n#函数main\ndef main():\n    #reaper 是构造函数的实例\n    reaper = juncang_strategy(exchange)\n    while (True):\n        #通过实例调用poll方法\n        reaper.balanceAccount()\n        Sleep(1000*10)",
        "strategy_description": "策略名称: 均仓策略\n\ntradenum=accountmoney/kr[-1].Close/100\n        if tradenum<0.001:\n            tradenum=0.001\n        #判断self.p的值是否小于0.48\n        Log(self.p)\n        if (0.45<self.p < 0.49):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #判断self.p的值是否大于0.52\n        elif (0.55 > self.p > 0.51):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            #调用Sell函数并传入相应的参数\n            self.exchange.Sell(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p >= 0.55):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡,快速平仓\", self.p)\n\n            self.exchange.Sell(kr[-1].Close, tradenum*10)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p <= 0.45):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡，快速建仓\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, tradenum*10)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)"
    },
    {
        "strategy_id": "77_均线-趋势_数字货币策略V02",
        "strategy_code": "python\n#!/usr/local/bin/python\n#-*- coding: UTF-8 -*-\n#均线/趋势  策略\n#通过判断  在死叉下底后回弹多少买入\n#在金叉上扬至顶后下降多少卖出\n\n\n# FastPeriod=3 #开仓快线周期\n# SlowPeriod=7 #开仓慢线周期\n# EnterPeriod=1       #开仓观察期\n# ExitFastPeriod=3 #平仓线周期\n# ExitSlowPeriod=7 #平仓慢线周期\n# ExitPeriod=2        #平仓观察期\n# PositionRatio=0.5 #仓位比例\n# Interval=10 #轮询周期\n# MAType=0 #均线类型 TA.EMA|TA.MA\n\n\nimport types\narray = [TA.EMA,TA.MA]\n_MACalcMethod = array[MAType]\ndef Cross(a,b):   #计算均线方法\n    crossNum = 0\n    arr1 = []\n    arr2 = []\n    if(type(a) == types.ListType and type(b) == types.ListType):\n        arr1 = a\n        arr2 = b\n    else:\n        records = null\n        while True:\n            records = exchange.GetRecords()\n            if(records and len(records) > a and len(records) > b):\n                break\n            Sleep(Interval)\n        arr1 = _MACalcMethod(records,a)\n        arr2 = _MACalcMethod(records,b)\n    if(len(arr1) != len(arr2)):\n        raise Exception(\"array length not equal\")\n    for i in range(len(arr1) - 1,-1,-1):\n        if((type(arr1[i]) != types.IntType and type(arr1[i]) != types.FloatType) or (type(arr2[i]) != types.IntType and type(arr2[i]) != types.FloatType) ):\n            break\n        if(arr1[i] < arr2[i]):\n            if(crossNum > 0):\n                break\n            crossNum -= 1\n        elif(arr1[i] > arr2[i]):\n            if(crossNum < 0):\n                break\n            crossNum += 1\n        else:\n            break\n    return crossNum\n\nimport datetime\ndef Caltime(date1,date2):\n    try:\n        date1=time.strptime(date1,\"%Y-%m-%d %H:%M:%S\")\n        date2=time.strptime(date2,\"%Y-%m-%d %H:%M:%S\")\n        date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])\n        date2=datetime.datetime(date2[0],date2[1],date2[2],date2[3],date2[4],date2[5])\n        return date2-date1\n    except Exception,ex:\n        Log('except Exception Caltime:',ex)\n        return \"except Exception\"\n\nimport time\nstart_timexx =time.localtime(time.time()) #time.clock()\nstart_time=time.strftime(\"%Y-%m-%d %H:%M:%S\",start_timexx)\nbuy_price=0 #买入价格\nbuy_qty=0  #买入数量\ngains=0  #盈利\n\ndef my_buy(): #开仓\n    try:\n        global buy_price,buy_qty\n        initAccount = ext.GetAccount()  #交易模板的导出函数， 获得账户状态，保存策略运行前账户初始状态\n        opAmount=1\n        #开仓之前判断有币没有没有先进行买入\n        if int(initAccount.Stocks)>1:\n            if buy_price<1:\n                buy_price=_C(exchange.GetTicker).Last\n                buy_qty=initAccount.Stocks\n            Log('开仓信息1 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\n            return 1\n        if int(initAccount.Stocks)<1:\n            if int(str(initAccount.Stocks).replace('0.',''))>=1:\n                if buy_price<1:\n                    buy_price=_C(exchange.GetTicker).Last\n                    buy_qty=initAccount.Stocks\n                Log('开仓信息2 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\n                return 1\n\n        #if int(initAccount.Stocks)<1:\n        if int(str(initAccount.Stocks).replace('0.',''))==0:\n            #opAmount=1\n            opAmount = _N(initAccount.Balance*PositionRatio,3)  #买入数量\n            Log(\"开仓没有币先进行 开仓买入%s元\"%(str(opAmount)))   #生成LOG日志\n        #     else:\n        #         opAmount = _N(initAccount.Stocks * PositionRatio,3)  #获取交易数量\n        # else:\n        #     opAmount = _N(initAccount.Stocks * PositionRatio,3)  #获取交易数量\n        Dict = ext.Buy(opAmount)  #买入ext.Buy\n        if(Dict):#确认开仓成功\n            buy_price=Dict['price'] #买入价格   #{'price': 4046.446, 'amount': 1.5}\n            buy_qty=Dict['amount']  #买入数量\n            print_log(1,initAccount,Dict)\n            return 1\n        return 0\n\n    except Exception,ex:\n        Log('except Exception my_buy:',ex)\n        return 0\n\noutAccount = ext.GetAccount()  #初始化信息\ndef print_log(k_p,Account,Dict):\n    try:\n        global outAccount\n        name=\"\"\n        if k_p:\n            LogProfit(_N(gains,4),'开仓信息 钱:',Account.Balance,'--币:',Account.Stocks,'--开仓详情:',Dict)\n            name=\"开仓\"\n        else:\n            LogProfit(_N(gains,4),'平仓信息 钱:',Account.Balance,'--币:',Account.Stocks,'--平仓详情:',Dict)\n            name=\"平仓\"\n        endAccount = ext.GetAccount()  #初始化信息\n        date1=time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime(time.time()))\n        LogStatus(\"初始化投入2016/9/16  投入资金2000元\\r\\n\",\n                  \"本次初始化状态:\",outAccount,\n                  \"\\r\\n当前运  行状态:\",endAccount,\n                  \"\\r\\n本次开始运行时间:%s  已运行:%s\\r\\n\"%(start_time,Caltime(start_time,date1)),\n                  \"本次盈利:%s\\r\\n\"%(str(gains)),\n                  \"当前状态:%s--钱:%s--币:%s\\r\\n\"%(str(name),str(Account.Balance),str(Account.Stocks)),\n                  \"更新时间:%s\"%(date1)\n                  ) # 测试\n    except Exception,ex:\n        Log('except Exception print_log:',ex)\n\n\ndef my_sell(): #平仓\n    try:\n        global buy_price,buy_qty,gains,start_time\n        nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\n        if _C(exchange.GetTicker).Last>buy_price+4:   #当前价格一定要大于  开仓价格\n            Dict = ext.Sell(nowAccount.Stocks)\n            if(Dict):\n                sell_gains=(Dict['price']-buy_price)*Dict['amount']\n                gains=gains+sell_gains\n                buy_price=0 #买入价格\n                buy_qty=0  #买入数量\n                print_log(0,nowAccount,Dict)\n                return 1\n        return 0\n    except Exception,ex:\n        Log('except Exception my_sell:',ex)\n        return 0\n\ndef main():\n    global outAccount\n    STATE_IDLE = -1  #空闲状态\n    state = STATE_IDLE  #初始化  状态 为 空闲\n\n    Log(\"run  \",outAccount)  #输出初始账户信息\n    SetErrorFilter(\"GetAccount|GetRecords|GetTicker\")  #屏蔽错误内容\n\n    b=0  #开仓\n    b1=0  #检测次数\n    a=0  #平仓\n    a1=0  #检测次数\n    while True:\n        if(state == STATE_IDLE):   #判断状态是否 为空闲 触发开仓\n            #开仓\n            n = Cross(FastPeriod,SlowPeriod) #模板函数获取EMA指标快线、慢线交叉结果\n            if n<0:  #确定当前为死叉\n                b1+=1\n                if b>=int(n): #说明现在还是在下跌涨趋势\n                    b=int(n)\n                else: #开始下跌  开仓\n                    if(int(n)>=int(b)+int(EnterPeriod)):  #确认上行走势 至自己定义的点\n                        if my_buy():  #开仓\n                            b=0\n                            b1=0\n                            state = PD_SHORT\n                            # if(b1>=10):#小波动操作开仓\n                            #     b1=0\n                            #     if my_buy():\n                            #         b=0\n                            #         state = PD_SHORT\n        else:#平仓\n            n = Cross(ExitFastPeriod,ExitSlowPeriod) #模板函数获取EMA指标快线、慢线交叉结果\n            if n>0:  #确定当前为金叉\n                a1+=1\n                if a<=int(n): #说明现在还是在上涨趋势\n                    a=int(n)\n                else: #开始下跌  平仓\n                    if(int(n)<=int(a)-int(ExitPeriod)):  #确认下行走势 至自己定义的点\n                        if my_sell(): #平仓\n                            a=0\n                            a1=0\n                            state = STATE_IDLE   #更改状态  为空闲 触发开仓\n                            # if(a1>=10): #小波动操作平仓\n                            #     a1=0\n                            #     if my_sell():\n                            #         a=0\n                            #         state = STATE_IDLE   #更改状态  为空闲 触发开仓\n        Sleep(Interval * 1000)",
        "strategy_description": "策略名称: 均线-趋势_数字货币策略V02\n\n# SlowPeriod=7 #开仓慢线周期"
    },
    {
        "strategy_id": "78_均线策略python版",
        "strategy_code": "python\nimport types\ndef main():\n    STATE_IDLE = -1\n    state = STATE_IDLE\n    initAccount = ext.GetAccount()\n    while True:\n        if state == STATE_IDLE :\n            n = ext.Cross(FastPeriod,SlowPeriod) # 指标交叉函数\n            if abs(n) >= EnterPeriod :\n                opAmount = _N(initAccount.Stocks * PositionRatio,3)\n                Dict = ext.Buy(opAmount) if n > 0 else ext.Sell(opAmount)\n                if Dict :\n                    opAmount = Dict['amount']\n                    state = PD_LONG if n > 0 else PD_SHORT\n                    Log(\"开仓详情\",Dict,\"交叉周期\",n)\n        else:\n            n = ext.Cross(ExitFastPeriod,ExitSlowPeriod) # 指标交叉函数\n            if abs(n) >= ExitPeriod and ((state == PD_LONG and n < 0) or (state == PD_SHORT and n > 0)) :\n                nowAccount = ext.GetAccount()\n                Dict2 = ext.Sell(nowAccount.Stocks - initAccount.Stocks) if state == PD_LONG else ext.Buy(initAccount.Stocks - nowAccount.Stocks)\n                state = STATE_IDLE\n                nowAccount = ext.GetAccount()\n                LogProfit(nowAccount.Balance - initAccount.Balance,'钱：',nowAccount.Balance,'币：',nowAccount.Stocks,'平仓详情：',Dict2,'交叉周期：',n)\n        Sleep(Interval * 1000)",
        "strategy_description": "策略名称: 均线策略python版\n\nif abs(n) >= EnterPeriod :\n                opAmount = _N(initAccount.Stocks * PositionRatio,3)\n                Dict = ext.Buy(opAmount) if n > 0 else ext.Sell(opAmount)\n                if Dict :\n                    opAmount = Dict['amount']\n                    state = PD_LONG if n > 0 else PD_SHORT\n                    Log(\"开仓详情\",Dict,\"交叉周期\",n)\n        else:\n            n = ext.Cross(ExitFastPeriod,ExitSlowPeriod) # 指标交叉函数\n            if abs(n) >= ExitPeriod and ((state == PD_LONG and n < 0) or (state == PD_SHORT and n > 0)) :\n                nowAccount = ext.GetAccount()\n                Dict2 = ext.Sell(nowAccount.Stocks - initAccount.Stocks) if state == PD_LONG else ext.Buy(initAccount.Stocks - nowAccount.Stocks)\n                state = STATE_IDLE\n                nowAccount = ext.GetAccount()\n                LogProfit(nowAccount.Balance - initAccount.Balance,'钱：',nowAccount.Balance,'币：',nowAccount.Stocks,'平仓详情：',Dict2,'交叉周期：',n)\n        Sleep(Interval * 1000)\n\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/21157\n\n> Last Modified\n\n2016-09-30 23:25:18"
    },
    {
        "strategy_id": "79_基于随机森林的趋势策略",
        "strategy_code": "python\n'''backtest\nstart: 2019-02-09 00:00:00\nend: 2019-03-11 00:00:00\nperiod: 1h\nbasePeriod: 15m\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\"}]\n'''\n\nimport itertools\nfrom collections import deque\n\nimport numpy as np\nfrom sklearn.ensemble import RandomForestClassifier\n\ndef main():\n    initAccount = _C(exchange.GetAccount)\n    position = 0\n    classifier = RandomForestClassifier()\n    win_len = 8\n    input = deque(maxlen=300)\n    output = deque(maxlen=300)\n    recent_prices = deque(maxlen=win_len + 2)\n    interval = 3600000 # 一小时采样一次\n    \n    while True:\n        ticker = _C(exchange.GetTicker)\n        recent_prices.append(ticker.Last)\n        \n        if len(recent_prices) > 0:\n            Sleep(interval)\n            \n        if len(recent_prices) < recent_prices.maxlen:\n            continue\n        # 计算波动率\n        price_list = list(itertools.islice(recent_prices, 0, recent_prices.maxlen - 1))\n        volt_list = np.divide(np.diff(recent_prices), price_list)\n        # 根据波动范围，将其分类标记为: 上涨(>+0.5%)、下跌(<-0.5%)、平稳(-0.5%~+0.5%)\n        trend_list = []\n        for volt in volt_list:\n            if 0.005 > volt > -0.005:\n                trend_list.append(0)\n            elif volt >= 0.005:\n                trend_list.append(1)\n            else:\n                trend_list.append(-1)\n\n        # 添加波动数据到训练集\n        input.append(trend_list[:-1])\n        output.append(trend_list[-1])\n\n        # 当训练集个数包含 200 组数据时，认为可以拟合随机森林\n        if len(input) < 200:\n            continue\n        classifier.fit(input, output)            # 拟合\n        prediction = classifier.predict([trend_list[1:]])  # 预测\n        if position == 0:\n            if prediction == 1:\n                exchange.Buy(-1, _C(exchange.GetAccount).Balance)\n                position = 1\n        else:\n            if prediction == -1:\n                exchange.Sell(-1, _C(exchange.GetAccount).Stocks - initAccount.Stocks)\n                position = 0",
        "strategy_description": "策略名称: 基于随机森林的趋势策略\n\nwhile True:\n        ticker = _C(exchange.GetTicker)\n        recent_prices.append(ticker.Last)\n        \n        if len(recent_prices) > 0:\n            Sleep(interval)\n            \n        if len(recent_prices) < recent_prices.maxlen:\n            continue\n        # 计算波动率\n        price_list = list(itertools.islice(recent_prices, 0, recent_prices.maxlen - 1))\n        volt_list = np.divide(np.diff(recent_prices), price_list)\n        # 根据波动范围，将其分类标记为: 上涨(>+0.5%)、下跌(<-0.5%)、平稳(-0.5%~+0.5%)\n        trend_list = []\n        for volt in volt_list:\n            if 0.005 > volt > -0.005:\n                trend_list.append(0)\n            elif volt >= 0.005:\n                trend_list.append(1)\n            else:\n                trend_list.append(-1)\n\n        # 添加波动数据到训练集\n        input.append(trend_list[:-1])\n        output.append(trend_list[-1])\n\n        # 当训练集个数包含 200 组数据时，认为可以拟合随机森林\n        if len(input) < 200:\n            continue\n        classifier.fit(input, output)            # 拟合\n        prediction = classifier.predict([trend_list[1:]])  # 预测\n        if position == 0:\n            if prediction == 1:\n                exchange.Buy(-1, _C(exchange.GetAccount).Balance)\n                position = 1\n        else:\n            if prediction == -1:\n                exchange.Sell(-1, _C(exchange.GetAccount).Stocks - initAccount.Stocks)\n                position = 0\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/140199\n\n> Last Modified\n\n2022-05-20 01:16:44"
    },
    {
        "strategy_id": "80_基础网格交易策略",
        "strategy_code": "python\n'''backtest\nstart: 2021-08-01 00:00:00\nend: 2021-09-01 00:00:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\",\"balance\":1000000,\"stocks\":0,\"fee\":[0.06,0.075]}]\nargs: [[\"lower_price\",30000],[\"upper_price\",50000],[\"grid_num\",200],[\"trading_per_grid\",0.1]]\n'''\n\ngrid = dict()\ninterval = 0\n\n\nclass GridItem:\n    def __init__(self, order_id, status, price):\n        self.order_id = order_id\n        self.status = status  # -1：此点为空白点; -2：此点未下过单\n        self.side = 0  # 1：买入；2：卖出；0：未知\n        self.price = price\n\n\ndef create_grid(ticker_price):\n    global grid\n    global interval\n\n    exchange.SetCurrency(trading_pair)\n    exchange.SetPrecision(price_precision, amount_precision)\n\n    interval = _N((upper_price - lower_price) / grid_num, price_precision)\n    \n    grid[lower_price] = GridItem(-1, -2, lower_price)\n    grid[upper_price] = GridItem(-1, -2, upper_price)\n    for i in range(1, grid_num):\n        price = lower_price + interval * i\n        grid[price] = GridItem(-1, -2, price)\n        \n    buy_stocks = (grid_num - int((ticker_price - lower_price) / interval) - 1) * trading_per_grid\n    buy_2_sell(buy_stocks)\n    \n    \ndef buy_2_sell(buy_stocks):\n    while True:\n        account = exchange.GetAccount()\n        stocks = _N(account['Stocks'], amount_precision)\n        if stocks < buy_stocks:\n            depth = exchange.GetDepth()\n            price = depth['Asks'][0]['Price']\n            vol = _N(price * trading_per_grid, price_precision)\n            min_vol = 1.0 / (10 ** price_precision)\n            exchange.Buy(-1, vol if vol > min_vol else min_vol)\n        else:\n            break\n        Sleep(1000)\n\n\ndef set_blank(price):\n    grid[price].order_id = -1\n    grid[price].status = -1\n    grid[price].side = 0\n\n\ndef update_order():\n    last_blank_price = -1\n    close_price_list = set()\n\n    for grid_item in grid.values():\n        if grid_item.status == -1:\n            last_blank_price = grid_item.price\n        elif grid_item.status == -2:\n            close_price_list.add(grid_item.price)\n        else:\n            order = exchange.GetOrder(grid_item.order_id)\n            grid_item.status = order[\"Status\"]\n            if grid_item.status == 1:\n                close_price_list.add(grid_item.price)\n    return close_price_list, last_blank_price\n\n\ndef remove_blank(close_price_list, last_blank_price):\n    if last_blank_price != -1:\n        close_price_list.discard(last_blank_price)\n\n\ndef set_left_blank(close_price_list, left_side_grid, last_blank_price):\n    set_blank(left_side_grid)\n    close_price_list.discard(left_side_grid)\n    if last_blank_price != -1:\n        close_price_list.add(last_blank_price)\n    \n    \ndef set_right_blank(close_price_list, right_side_grid, last_blank_price):\n    set_blank(right_side_grid)\n    close_price_list.discard(right_side_grid)\n    if last_blank_price != -1:\n        close_price_list.add(last_blank_price)\n\n\ndef trace():\n    close_price_list, last_blank_price = update_order()\n    \n    has_buy_order = False\n    for price in close_price_list:\n        if grid[price].side == 1:\n            has_buy_order = True\n            break\n    \n    if has_buy_order:\n        ticker_price = min(close_price_list) - interval / 2.0\n    else:\n        ticker = exchange.GetTicker()\n        ticker_price = ticker['Last']\n    \n    if not grid:\n        create_grid(ticker_price)\n\n    left_side_grid = int((ticker_price - lower_price) / interval) * interval + lower_price\n    right_side_grid = left_side_grid + interval\n\n    # 设置空白点\n    # 当前价格左侧未成交，当前价格右侧未成交，不存在\n    # 当前价格左侧空白点，当前价格右侧空白点，不存在\n    # 左侧和右侧任何一个为空白点，不需要更新空白点\n    if left_side_grid >= upper_price or right_side_grid <= lower_price:\n        # 在区间外，不需要空白点\n        remove_blank(close_price_list, last_blank_price)\n    elif grid[left_side_grid].status == 0 and grid[right_side_grid].status == 1:\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 0:\n        set_left_blank(close_price_list, left_side_grid, last_blank_price)\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 1:\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\n    elif grid[left_side_grid].status == -2 and grid[right_side_grid].status == -2:\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\n\n    # 重新下单\n    for price in close_price_list:            \n        if price <= ticker_price:\n            order_id = exchange.Buy(price, trading_per_grid)\n            side = 1\n        else:\n            buy_2_sell(trading_per_grid)\n            order_id = exchange.Sell(price, trading_per_grid)\n            side = 2\n\n        if order_id:\n            grid[price].order_id = order_id\n            grid[price].status = 0\n            grid[price].side = side\n\n\ndef main():\n    while True:\n        trace()\n        Sleep(1000)",
        "strategy_description": "策略名称: 基础网格交易策略\n\nself.side = 0  # 1：买入；2：卖出；0：未知\n        self.price = price\n\n\ndef create_grid(ticker_price):\n    global grid\n    global interval\n\n    exchange.SetCurrency(trading_pair)\n    exchange.SetPrecision(price_precision, amount_precision)\n\n    interval = _N((upper_price - lower_price) / grid_num, price_precision)\n    \n    grid[lower_price] = GridItem(-1, -2, lower_price)\n    grid[upper_price] = GridItem(-1, -2, upper_price)\n    for i in range(1, grid_num):\n        price = lower_price + interval * i\n        grid[price] = GridItem(-1, -2, price)\n        \n    buy_stocks = (grid_num - int((ticker_price - lower_price) / interval) - 1) * trading_per_grid\n    buy_2_sell(buy_stocks)\n    \n    \ndef buy_2_sell(buy_stocks):\n    while True:\n        account = exchange.GetAccount()\n        stocks = _N(account['Stocks'], amount_precision)\n        if stocks < buy_stocks:\n            depth = exchange.GetDepth()\n            price = depth['Asks'][0]['Price']\n            vol = _N(price * trading_per_grid, price_precision)\n            min_vol = 1.0 / (10 ** price_precision)\n            exchange.Buy(-1, vol if vol > min_vol else min_vol)\n        else:\n            break\n        Sleep(1000)\n\n\ndef set_blank(price):\n    grid[price].order_id = -1\n    grid[price].status = -1\n    grid[price].side = 0\n\n\ndef update_order():\n    last_blank_price = -1\n    close_price_list = set()\n\n    for grid_item in grid.values():\n        if grid_item.status == -1:\n            last_blank_price = grid_item.price\n        elif grid_item.status == -2:\n            close_price_list.add(grid_item.price)\n        else:\n            order = exchange.GetOrder(grid_item.order_id)\n            grid_item.status = order[\"Status\"]\n            if grid_item.status == 1:\n                close_price_list.add(grid_item.price)\n    return close_price_list, last_blank_price\n\n\ndef remove_blank(close_price_list, last_blank_price):\n    if last_blank_price != -1:\n        close_price_list.discard(last_blank_price)\n\n\ndef set_left_blank(close_price_list, left_side_grid, last_blank_price):\n    set_blank(left_side_grid)\n    close_price_list.discard(left_side_grid)\n    if last_blank_price != -1:\n        close_price_list.add(last_blank_price)\n    \n    \ndef set_right_blank(close_price_list, right_side_grid, last_blank_price):\n    set_blank(right_side_grid)\n    close_price_list.discard(right_side_grid)\n    if last_blank_price != -1:\n        close_price_list.add(last_blank_price)\n\n\ndef trace():\n    close_price_list, last_blank_price = update_order()\n    \n    has_buy_order = False\n    for price in close_price_list:\n        if grid[price].side == 1:\n            has_buy_order = True\n            break\n    \n    if has_buy_order:\n        ticker_price = min(close_price_list) - interval / 2.0\n    else:\n        ticker = exchange.GetTicker()\n        ticker_price = ticker['Last']\n    \n    if not grid:\n        create_grid(ticker_price)\n\n    left_side_grid = int((ticker_price - lower_price) / interval) * interval + lower_price\n    right_side_grid = left_side_grid + interval\n\n    # 设置空白点\n    # 当前价格左侧未成交，当前价格右侧未成交，不存在\n    # 当前价格左侧空白点，当前价格右侧空白点，不存在\n    # 左侧和右侧任何一个为空白点，不需要更新空白点\n    if left_side_grid >= upper_price or right_side_grid <= lower_price:\n        # 在区间外，不需要空白点\n        remove_blank(close_price_list, last_blank_price)\n    elif grid[left_side_grid].status == 0 and grid[right_side_grid].status == 1:\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 0:\n        set_left_blank(close_price_list, left_side_grid, last_blank_price)\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 1:\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\n    elif grid[left_side_grid].status == -2 and grid[right_side_grid].status == -2:\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\n\n    # 重新下单\n    for price in close_price_list:            \n        if price <= ticker_price:\n            order_id = exchange.Buy(price, trading_per_grid)\n            side = 1\n        else:\n            buy_2_sell(trading_per_grid)\n            order_id = exchange.Sell(price, trading_per_grid)\n            side = 2\n\n        if order_id:\n            grid[price].order_id = order_id\n            grid[price].status = 0\n            grid[price].side = side\n\n\ndef main():\n    while True:\n        trace()\n        Sleep(1000)\n\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/316809\n\n> Last Modified\n\n2021-09-27 11:59:39"
    },
    {
        "strategy_id": "81_复杂看盘图表测试版",
        "strategy_code": "python\n\n'''backtest\nstart: 2020-03-11 00:00:00\nend: 2020-04-09 23:59:00\nperiod: 1d\nexchanges: [{\"eid\":\"Bitfinex\",\"currency\":\"BTC_USD\"}]\n'''\nimport pandas as pd\nimport numpy as np\nimport re\npreBarTime_1=0\n'''\nshortChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\",  #single不参于分组，单独显示, 默认为分组 'group'\n        \"height\" : 300, \n    },\n    \"title\" : {\"text\": 'rb888' + '__15M交易信号图'},\n    \"xAxis\" : {\"type\" : \"datetime\"}, # 时间序列轴\n    \"yAxis\" : [{\"labels\": {\n        \"align\": 'right',\n        \"x\": -3\n    },\n                \"title\": {\n                    \"text\": '盘口'\n                },\n                \"height\": \"45%\",  # 相对宽度大小\n                \"resize\": {\n                    \"enabled\": True  # 是否启用重置宽度  \n                },\n                \"opposite\": True,  # 是否将轴显示在对面 默认左\n                \"offset\": 0,  # 坐标轴偏移 正右 负左\n                \"lineWidth\": 2  # 线宽\n               }, {\"labels\": {\n        \"align\": 'right',\n        \"x\": -3\n    },\n                   \"title\": {\n                       \"text\": 'RSI'\n                   },\n                   \"top\": '45%',\n                   \"height\": '25%',\n                   \"opposite\": True,\n                   \"offset\": 0,\n                   \"lineWidth\": 2\n                  }, {\"labels\": {\n        \"align\": 'right',\n        \"x\": -3\n    },\n                      \"title\": {\n                          \"text\": 'MACD_5'\n                      },\n                      \"top\": '70%',\n                      \"height\": '30%',\n                      \"opposite\": True,\n                      \"offset\": 0,\n                      \"lineWidth\": 2\n                     }    \n              ],\n    \"tooltip\":{\n        \"split\": False,  # 原生js？？\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\"\n    },\n    \"series\" : [{'type': 'candlestick',\n                 'name': 'k线',\n                 #'color': 'green',\n                 #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\n                 #'upColor': 'red',\n                 #'upLineColor': 'red',\n                 \"data\" : [],\n                }, {\n            \"type\" : \"line\",\n            \"name\" : \"rsi\",\n            \"data\" : [],\n            \"yAxis\": 1  # 相对位置\n        }\n        , {\n            \"type\" : \"line\",\n            \"name\" : \"diff\",\n            \"data\" : [],\n            \"yAxis\": 2  # 相对位置\n        }, {\n            \"type\" : \"line\",\n            \"name\" : \"dea\",\n            \"data\" : [],\n            \"yAxis\": 2  # 相对位置\n        }, {\n            \"type\" : \"column\",\n            \"name\" : \"macd\",\n            \"data\" : [],\n            \"yAxis\": 2  # 相对位置\n        }\n    ]\n}\n'''\n\"\"\"\nshortChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"single\",  #single不参于分组，单独显示, 默认为分组 'group'\n        \"height\" : 300, \n    },\n    \"title\" : {\"text\": 'rb888' + '__15M交易信号图'},\n    \"xAxis\" : {\"type\" : \"datetime\"}, # 时间序列轴\n    \"yAxis\" : {\"labels\": {\n                    \"align\": 'right',\n                    \"x\": -3\n                },\n                \"title\": {\n                    \"text\": '盘口'\n                },\n                #\"height\": \"45%\",  # 相对宽度大小\n                #\"resize\": {\n                #    \"enabled\": True  # 是否启用重置宽度  \n                \"opposite\": True,  # 是否将轴显示在对面 默认左\n                \"offset\": 0,  # 坐标轴偏移 正右 负左\n                \"lineWidth\": 2  # 线宽\n    },\n    \"tooltip\" : {\n        \"split\": false,  # 原生js？？\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\"\n    },\n    \"series\" : {'type': 'candlestick',\n                'name': 'k线',\n                #'color': 'green',\n                #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\n                #'upColor': 'red',\n                #'upLineColor': 'red',\n                \"data\" : [],\n            }\n}\n\"\"\"\nshortChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n    \"layout\" : \"single\",  #single不参于分组，单独显示, 默认为分组 'group'\n    #\"height\" : 500, \n    },\n    'legend': {\n        'enabled': true  # 图例 true开启\n    },\n    'title' : {\n        'text' : '柱形K线'\n    },\n    \"xAxis\" : {\n        \"type\" : \"datetime\",\n        #'dashStyle': 'dash'  # 准心线样式 虚线\n    }, # 时间序列轴\n    'yAxis' : [{\n        'labels':{\n            'align':'right',\n            'x':-3\n        },\n        'height':\"40%\",\n        'lineWidth':2,\n        #'crosshair': true,  # 准心线\n        'resize':{\n            'enabled':true\n        }\n    },{\n        'labels':{\n            'align':'right',\n            'x':-3\n        },\n        'title':{\n            'text' : 'Volume'\n        },\n        'top':'40%',\n        'height':'15%',\n        'offset':0,\n        #'crosshair': true,\n        'lineWidth':2\n    },{\"labels\": {\n            \"align\": 'right',\n            \"x\":-3\n        },\n        \"title\": {\n            \"text\": 'RSI'\n        },\n        \"top\": '55%',\n        \"height\": '20%',\n        \"opposite\": True,\n        \"offset\": 0,\n        #'crosshair': true,\n        \"lineWidth\": 2,\n        'plotLines': [{\n                'value': 75,  # 值大小\n                'color': 'green',  # 颜色\n                'dashStyle': 'shortdash', # 线条样式\n                'width': 0.5,\n                #'label': {\n                #    'text': '多头止盈线'\n                #}\n        },{\n                'value': 25,\n                'color': 'red',\n                'dashStyle': 'shortdash',\n                'width': 0.5,\n                #'label': {\n                #    'text': '空头止盈线'\n                #}\n        }\n        ]\n    }, {\"labels\": {\n            \"align\": 'right',\n            \"x\":-3\n    },\n        \"title\": {\n            \"text\": 'MACD'\n        },\n        \"top\": '75%',\n        \"height\": '25%',\n        \"opposite\": True,\n        \"offset\": 0,\n        \"lineWidth\": 2\n    }\n    ],\n    'tooltip':{\n        #'shared': true,  # 是否开启提示标签共享,多图下效果基本等同split\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\",\n        'shared': true,\n\t\t'crosshairs': true,\n        'valueDecimals':2, # 保留小数\n        #'split':true, # 提示框分开\n        #'distance': 30,\n\t\t#'padding': 5\n        #'positioner': {\n        #    'x':150,\n        #    'y':150\n        #},\n        #'shadow': false,\n        #'borderWidth': 0,\n        #'backgroundColor': 'rgba(255,255,255,0.8)'\n    },\n    'series':[{\n        'type':'candlestick',\n        'animationLimit':'Infinity',\n        'color': 'green',\n        'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\n        'upColor': 'red',\n        'upLineColor': 'red',\n        'name':'appl',\n        'data':[]\n    },{\n        'type':'column',\n        'name':'Volume',\n        'data':[],\n        'yAxis':1\n    },{\n        \"type\" : \"line\",\n        \"name\" : \"rsi\",\n        \"data\" : [],\n        \"yAxis\": 2  # 相对位置\n    },{\n        \"type\" : \"line\",\n        \"name\" : \"diff\",\n        \"data\" : [],\n        \"yAxis\": 3  # 相对位置\n    },{\n        \"type\" : \"line\",\n        \"name\" : \"dea\",\n        \"data\" : [],\n        \"yAxis\": 3  # 相对位置\n    },{\n        \"type\" : \"column\",\n        \"name\" : \"macd\",\n        \"data\" : [],\n        'maxPointWidth':2,  # 量柱最大宽度\n        \"yAxis\": 3  # 相对位置\n    }\n\n    ]\n}\n    \n\nlongChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n    'rangeSelector':{\n        'selected' : 0 \n    },\n    'chart': {  # 主配置项\n        #'height': 630,  # 高度，平台不支持配置\n        'type': 'line',\n        'zoomType': 'x',  # 缩放\n        #'selectionMarkerFill':'rgba(51,92,223,0.25)',  # 缩放框背景色\n        #'panning': true,  # 开启平移\n        #'panKey': 'shift'  # 平移\n        'borderColor': '#EBBA95', # 外框配置项\n        'borderWidth': 2,  ##\n        'borderRadius': 10, ##\n    },\n    \"rangeSelector\" : {\n        \"buttons\" : [{\n            \"type\" : \"hour\",\n            \"count\" : 1,\n            \"text\" : \"1h\",\n        }, {\n            \"type\" : 'hour',\n            \"count\" : 3,\n            \"text\" : \"3h\"\n        }, {\n            \"type\" : \"day\",\n            \"count\" : 1,\n            \"text\" : \"1d\"\n        }, {\n            \"type\" : \"week\",\n            \"count\" : 1,\n            \"text\" : \"1w\"\n        }, {\n            \"type\" : \"year\",\n            \"count\" : 1,\n            \"text\" : \"1Y\"\n        }, {\n            \"type\" : \"all\",\n            \"text\" : \"All\"\n        }],\n        \"selected\" : 1,\n        \"inputEnabled\" : True\n    },\n    'legend': {\n        'enabled': true  # 图例 true开启\n    },\n    'title' : {\n        'text' : '15'\n    },\n    'subtitle': {\n        'text': '湘水看盘图表',  #'当前价格:'+str(records_5[-1]['Close'] if records_5[-1]['Close'] is not None else **)+' || '+'当前时间:'+str(Time_5 if Time_5 is not None else **)\n    },\n    \"xAxis\" : {\n        \"type\" : \"datetime\",\n        #'dashStyle': 'dash'  # 准心线样式 虚线\n    }, # 时间序列轴\n    \"xAxis\" : {\"type\" : \"datetime\"},\n    \"yAxis\" : [{\n            \"title\": {\n                \"text\": 'Kline'\n            },\n            \"height\": \"60%\",  # 相对宽度大小\n            \"offset\": 0,  # 坐标轴偏移 正右 负左\n            \"lineWidth\": 2  # 线宽\n        },{\n            \"title\": {\n                \"text\": 'MACD'\n            },\n            \"top\": '62%',\n            \"height\": '38%',\n            \"offset\": 0,\n            \"lineWidth\": 2\n        }    \n    ],\n    \"series\" : [\n        {\n            \"type\" : \"candlestick\", \n            \"name\" : \"k_15\",\n            \"id\" : \"k\",\n            \"data\" : [],\n            \"yAxis\": 0  # 相对位置\n        },{\n            \"type\" : \"column\",\n            \"name\" : \"macd_15\",\n            \"data\" : [],  \n            \"yAxis\": 1  # 相对位置\n        }\n    ]\n}\n\nchart0 = {                                        \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n\n    'title' : { 'text' : '日K线图'},                       \n    'xAxis': { 'type': 'datetime'},            \n    'series' : [                                          \n        {                                      \n            'type': 'candlestick',                         \n            'name': 'r',   \n            'id': 'r',                                     \n            'data': []                                           \n        }, {                                      \n            'type': 'column',           \n            'name': 'vol',          \n            'data': [],               \n        }\n    ]\n}\n\nchart1 = {  \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n                                      \n    'title' : { 'text' : 'ris'},                       \n    'xAxis': { 'type': 'datetime'},                       \n    'yAxis' : {                                           \n            'title': {'text': 'rsi'},                           \n            'opposite': false                                 \n    },\n    'series' :                                      \n        { \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'rsi',\n            'data': []\n    },\n}\n\n\nchart2 = {  \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n                                      \n    'title' : { 'text' : 'macd'},                       \n    'xAxis': { 'type': 'datetime'},                       \n    'yAxis' : {                                           \n            'title': {'text': 'macd'},                           \n            'opposite': false                                 \n    },\n    'series' :  [           \n        { \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'dif',\n            'data': []\n    },{ \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'eda',\n            'data': []\n    },{ \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'macd',\n            'data': []\n    },\n    ]\n}\n\n\nhart1 = {                                        \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n\n    'title' : { 'text' : 'MACD_5'},                       \n    'xAxis': { 'type': 'datetime'},             \n    'series' : [                                          \n        {                                      \n            'type': 'candlestick',                             \n            'name': 'k',   \n            'id': 'r1',                                     \n            'data': []                                           \n        }, {                                      \n            'type': 'column',           \n            'name': 'macd_15',          \n            'data': [],               \n        }\n    ]\n}\n\n\n\n\nmacd_15 = []\nrunTime = {}\nrunTime['preBarTime_1'] = [0,0]\nrunTime['arrKIndex'] = []\n_5_lengh = 50\n_15_lengh = 50\ndef ticks_(records, k):\n    if len(records) == 0:\n        return []\n    if isinstance(records[0], int) or isinstance(records[0], float):\n        return records\n\n    ticks = [None] * len(records)\n    for i in range(len(records)):\n        ticks[i] = records[i][k]\n        return ticks\n\n\ndef plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart):\n    for x,symbol in enumerate(arr):\n        #Log(symbol,_D(),)\n        runTime['arrKIndex'] = [index_2[x],index_2[x]+7]   # [0,7] [8,15]\n        #Log(symbol)\n        exchange.SetContractType(symbol)\n        #Log(symbol,_D())\n        records_5 = _C(exchange.GetRecords,PERIOD_M5)  # 返回列表型字典\n        records_15 = _C(exchange.GetRecords,PERIOD_M15)\n        r = records_5\n        m = records_15\n        Time_5 = records_5[-1]['Time']\n        Time_5_list = pd.Series(ticks_(records_5,'Time'))  # 小周期开盘时间数组\n        #Open_5 = records_5['Open']\n        #High_5 = records_5['High']\n        #Low_5 = records_5['Low']\n        Close_5 = pd.Series(ticks_(records_5,'Close'))  # 小周期收盘价数组\n\n        Time_15 = records_15[-1]['Time']\n        Time_15_list = pd.Series(ticks_(records_15,'Time'))  # 小周期开盘时间数组\n        #Open_5 = records_5['Open']\n        #High_5 = records_5['High']\n        #Low_5 = records_5['Low']\n        Close_15 = pd.Series(ticks_(records_15,'Close'))  # 小周期收盘价数组\n\n        #Log(2)\n        '''\n        nowdea_15 = dea_15[-1]\n        nowdiff_15 = diff_15[-1]\n        nowmacd_15 = macd_15[-1]\n        '''\n\n        '''\n        predea_15 = dea_15[-2]\n        prediff_15 = diff_15[-2]\n        premacd_15 = macd_15[-2]\n        '''\n        #index_1 += 5\n        if not r or not m:\n            return\n        #Log(3,len(r))\n\n        if len(r) < _5_lengh:  # 过滤K线过短情况\n            return\n\n        #Log(4)\n        Macd_5 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\n        diff_5 = Macd_5[0]\n        dea_5 = Macd_5[1]\n        macd_5 = pd.Series(Macd_5[2]).fillna(0)\n        macd_5 = macd_5.values*2  # TA的macd算法未乘以2\n\n        Macd_15 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\n        diff_15 = Macd_15[0]\n        dea_15 = Macd_15[1]\n        macd_15 = pd.Series(Macd_15[2]).fillna(0)\n        macd_15 = macd_15.values*2  # TA的macd算法未乘以2\n\n        RSI = TA.RSI(records_5, period = rsi_period)\n        nowdea_5 = dea_5[-1]\n        nowdiff_5 = diff_5[-1]\n        nowmacd_5 = macd_5[-1]\n        if len(macd_15) > 2:\n            nowmacd_15 = macd_15[-1]\n        nowrsi = RSI[-1]\n        \n        predea_5 = dea_5[-2]\n        prediff_5 = diff_5[-2]\n        premacd_5 = macd_5[-2]\n        if len(macd_15) > 2:\n            premacd_15 = macd_15[-2]\n        prersi = RSI[-2]\n        #Log('K线长度',len(r),'dea_5',len(dea_5),'rsi',len(RSI),preBarTime_1)\n            \n            \n\n        if len(macd_15)>0:        \n            #Log(time.strftime(\"%Y-%m-%d %H:%M:%S\",  time.localtime(int(records_5[-1]['Time'])/1000)),_D(),macd_15[-1])\n            pass\n        \n        #r = records_5\n        #m = records_15\n        arr_ = [r,m]        \n\n        #Log(index_2)\n        index_2 = index_2.copy()\n        #index_2 = index_2.tolist()\n        for i in range(len(arr_)):  # i 是k线周期循环\n\n            #Log(runTime['arrKIndex'])\n            for j in range(len(arr_[i])):  # 时间周期循环\n                #Log(arr_[i][j][\"Time\"],runTime['preBarTime_1'][i])\n                if arr_[i][j][\"Time\"] == runTime['preBarTime_1'][i]:  # preBarTime初始为0\n                    if i == 0:  #5分钟 #index_2 0 8\n                        chart.add(int(index_2[x]), [arr_[i][j][\"Time\"], arr_[i][j][\"Open\"], arr_[i][j][\"High\"], arr_[i][j][\"Low\"], arr_[i][j][\"Close\"]], -1)  # 选出不同周期K线的index\n                        #Log(1,int(index_2[i]))\n                    if i == 0 and len(arr_[i]) > _5_lengh:\n                        #Log(2)\n                        if j == len(arr_[i]) - 2:\n                            #Log(3)\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\"Time\"], arr_[i][j][\"Volume\"]],-1)  \n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\"Time\"], prersi], -1)    # 快线\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\"Time\"], prediff_5], -1)    # 慢线\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\"Time\"], predea_5], -1)\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\"Time\"], premacd_5], -1)\n                        elif j == len(arr_[i]) - 1:\n                            #Log(4,int(index_2[i]))\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\"Time\"], arr_[i][j][\"Volume\"]],-1)  \n                            #Log(4.1)\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\"Time\"], nowrsi], -1)    # 快线\n                            #Log(4.2)\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\"Time\"], nowdiff_5], -1)    # 慢线\n                            #Log(4.3)\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\"Time\"], nowdea_5], -1)\n                            #Log(4.4)\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\"Time\"], nowmacd_5], -1)\n                            #Log(4.5)\n                    '''\n                    if i == 1 and len(arr_[i]) > _15_lengh:\n                        if j == len(arr_[i]) - 2:\n                            chart.add(index_2 + 8, [arr_[i][j][\"Time\"], premacd_15], -1)    # 快线\n                        elif j == len(arr_[i]) - 2:\n                            chart.add(index_2 + 8, [arr_[i][j][\"Time\"], nowmacd_15], -1)    # 快线\n                    '''\n                elif arr_[i][j][\"Time\"] > runTime['preBarTime_1'][i]:  # 初始运行此处  每个5，15分钟运行两次\n                    \n                    if i ==1:\n                        pass\n                        \n                        #Log(time.strftime(\"%Y-%m-%d %H:%M:%S\",  time.localtime(int(arr_[i][j][\"Time\"])/1000)),time.strftime(\"%Y-%m-%d %H:%M:%S\",  time.localtime(int(runTime['preBarTime_1'][i])/1000)),'//',i)\n                    runTime['preBarTime_1'][i] = arr_[i][j][\"Time\"]  # K线时间赋值给preBarTime\n                    Log(runTime['preBarTime_1'][0],runTime['preBarTime_1'][1])\n                    # 0 7 8 15\n                    chart.add(int(runTime['arrKIndex'][x]), [arr_[i][j][\"Time\"], arr_[i][j][\"Open\"], arr_[i][j][\"High\"], arr_[i][j][\"Low\"], arr_[i][j][\"Close\"]])\n                    if i ==0 and len(arr_[i]) > _5_lengh:\n                        #Log('i=0',int(runTime['arrKIndex'][x]))\n                        if j == len(arr_[i]) - 1:\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\"Time\"], arr_[i][j][\"Volume\"]])\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\"Time\"], nowrsi])\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\"Time\"], nowdiff_5])\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\"Time\"], nowdea_5])\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\"Time\"], nowmacd_5])\n                    \n                    if i == 1 and len(arr_[i]) > _15_lengh:\n                        Log('i=1',int(index_2[x]) + 7)\n                        if j == len(arr_[i]) - 1:\n                            chart.add(int(index_2[x]) + 7, [arr_[i][j][\"Time\"], nowmacd_5])\n\ndef main():\n    \"\"\"\n    \"\"\"\n    global preBarTime_1,macd_15,runTime,_5_lengh,_15_lengh,shortChart,longChart,chart0,chart1,chart2,hart1\n    if exchange.GetName().find(\"CTP\") == -1:\n        raise Exception(\"只支持商品期货CTP\")\n    SetErrorFilter(\"login|ready|流控|连接失败|初始|Timeout\")\n    mode = exchange.IO(\"mode\", 0)\n    if mode is None:\n        raise Exception(\"切换模式失败，请更新到最新托管者！\")\n    while not exchange.IO(\"status\"):\n        Sleep(3000)\n        LogStatus(\"正在等待与交易服务器连接，\" + _D())\n    positions = _C(exchange.GetPosition)  # 获取当前持仓信息字典\n    if len(positions) > 0:\n        Log(\"检测到当前持有仓位，系统将开始尝试恢复进度...\")\n        Log(\"持仓信息：\", positions)\n\n\n    tts = []  # \n    arrChart_1 = []  # 图表数组\n    arrChart_2 = []\n    index_ = 0  # \n    index_2 = []\n    arrKIndex = []\n    a = []\n    b = []\n    c = []\n    d = []\n\n    #while True:\n    #Log(1)\n    symbolFilter = {}  # 过滤用数组\n    arr = Instruments.split(\",\")  # 合约列表\n    for i in range(len(arr)):  # 遍历合约列表\n        symbol = re.sub(r'/\\s+$/g', \"\", re.sub(r'/^\\s+/g', \"\", arr[i]))  # 规整合约字符串\n        if symbol in symbolFilter.keys():  # 如果 在过滤数组中 存在 名为 symbol的属性，则显示信息 并跳过。\n            raise Exception(symbol + \"已经存在，请检查参数！\")\n        symbolFilter[symbol] = True  # 给过滤数组 添加 名为 symbol 的 keys，下次 同样的 合约代码 会被过滤 保证每个合约只对Manager类方法传入一次参数\n        hasPosition = False  # 初始化 hasPosition 变量 false 代表没有持仓 \n        for j in range(len(positions)):  # 遍历 获取到的持仓信息\n            if positions[j][\"ContractType\"] == symbol:  # 如果持仓中有合约名等于symbol\n                Log('cc')\n                hasPosition = True  # 标记 True 持仓\n                break  # 跳出\n        #fastPeriod = int(arrFastPeriod[i])  # 规整为数值型\n        #slowPeriod = int(arrSlowPeriod[i])\n        Log(123)\n        obj_1 = shortChart #  实例化Manager类\n        obj_2 = longChart\n        index_2.append(index_)  # 0 8\n        index_ += 8 # 长周期的图表index\n        \n        #tts.append(obj)  # tts列表传入 最终根据合约列表 ，生成了若干个品种的 控制对象储存在tts数组 \n        #Log(obj)\n        arrChart_1.append(obj_1)   # 在for循环中 依次把图表信息字典传入图表数组\n        #arrChart_2.append(obj_2)\n        a.append(chart0)\n        b.append(chart1)\n        c.append(chart2)\n        d.append(hart1)\n        Log(len(arrChart_1))\n        Log(111 if arrChart_1[0]==shortChart else 000)\n        #arrChart_2.append(obj.longChart)\n    # 创建图表对象\n    #chart = Chart([arrChart_1, arrChart_2])  # __isStock\" : True表示是highstock图，False表示是highcharts图 使用多图表对象，转为二维数组\n    #chart = Chart([arrChart_1,arrChart_2])\n    chart = Chart([a,b,c,d])\n    #Log(len(arrChart_1),len(arrChart_2))\n    index_2 = np.array(index_2)\n    chart.reset()  # 清空上次轮询的图表数据\n\n    while True:\n        #c = Chart(shortChart)\n        preTicker = None\n        #while True:\n        #Log(1)\n        if exchange.IO('status'):\n            LogStatus(_D(),'已经连接')\n            #t = exchange.GetTicker()\n            plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart)\n        Sleep(1000)                      \n        ''' \n        if i ==0:\n            if signals['buy_sell_sig'+str(trueSymbol)] ==1:\n                Log(1)\n                #ext.PlotFlag(r[-2]['Time'],'开多','L','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'L','text':'开多'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n            if signals['buy_sell_sig'+str(trueSymbol)] ==2:\n                Log(2)\n                #ext.PlotFlag(r[-2]['Time'],'开空','S','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'S','text':'开空'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n            if signals['buy_sell_sig'+str(trueSymbol)] ==3:\n                Log(3)\n                #ext.PlotFlag(r[-2]['Time'],'平多','UL','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'UL','text':'平多'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n            if signals['buy_sell_sig'+str(trueSymbol)] ==4:\n                Log(4)\n                #ext.PlotFlag(r[-2]['Time'],'平空','US','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'US','text':'平空'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n\n        '''\n\n                    #index_1 += 9  # 短周期的图表index",
        "strategy_description": "策略名称: 复杂看盘图表测试版\n\n\"yAxis\" : [{\"labels\": {\n        \"align\": 'right',\n        \"x\": -3\n    },\n                \"title\": {\n                    \"text\": '盘口'\n                },\n                \"height\": \"45%\",  # 相对宽度大小\n                \"resize\": {\n                    \"enabled\": True  # 是否启用重置宽度  \n                },\n                \"opposite\": True,  # 是否将轴显示在对面 默认左\n                \"offset\": 0,  # 坐标轴偏移 正右 负左\n                \"lineWidth\": 2  # 线宽\n               }, {\"labels\": {\n        \"align\": 'right',\n        \"x\": -3\n    },\n                   \"title\": {\n                       \"text\": 'RSI'\n                   },\n                   \"top\": '45%',\n                   \"height\": '25%',\n                   \"opposite\": True,\n                   \"offset\": 0,\n                   \"lineWidth\": 2\n                  }, {\"labels\": {\n        \"align\": 'right',\n        \"x\": -3\n    },\n                      \"title\": {\n                          \"text\": 'MACD_5'\n                      },\n                      \"top\": '70%',\n                      \"height\": '30%',\n                      \"opposite\": True,\n                      \"offset\": 0,\n                      \"lineWidth\": 2\n                     }    \n              ],\n    \"tooltip\":{\n        \"split\": False,  # 原生js？？\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\"\n    },\n    \"series\" : [{'type': 'candlestick',\n                 'name': 'k线',\n                 #'color': 'green',\n                 #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\n                 #'upColor': 'red',\n                 #'upLineColor': 'red',\n                 \"data\" : [],\n                }, {\n            \"type\" : \"line\",\n            \"name\" : \"rsi\",\n            \"data\" : [],\n            \"yAxis\": 1  # 相对位置\n        }\n        , {\n            \"type\" : \"line\",\n            \"name\" : \"diff\",\n            \"data\" : [],\n            \"yAxis\": 2  # 相对位置\n        }, {\n            \"type\" : \"line\",\n            \"name\" : \"dea\",\n            \"data\" : [],\n            \"yAxis\": 2  # 相对位置\n        }, {\n            \"type\" : \"column\",\n            \"name\" : \"macd\",\n            \"data\" : [],\n            \"yAxis\": 2  # 相对位置\n        }\n    ]\n}\n'''\n\"\"\"\nshortChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"single\",  #single不参于分组，单独显示, 默认为分组 'group'\n        \"height\" : 300, \n    },\n    \"title\" : {\"text\": 'rb888' + '__15M交易信号图'},\n    \"xAxis\" : {\"type\" : \"datetime\"}, # 时间序列轴\n    \"yAxis\" : {\"labels\": {\n                    \"align\": 'right',\n                    \"x\": -3\n                },\n                \"title\": {\n                    \"text\": '盘口'\n                },\n                #\"height\": \"45%\",  # 相对宽度大小\n                #\"resize\": {\n                #    \"enabled\": True  # 是否启用重置宽度  \n                \"opposite\": True,  # 是否将轴显示在对面 默认左\n                \"offset\": 0,  # 坐标轴偏移 正右 负左\n                \"lineWidth\": 2  # 线宽\n    },\n    \"tooltip\" : {\n        \"split\": false,  # 原生js？？\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\"\n    },\n    \"series\" : {'type': 'candlestick',\n                'name': 'k线',\n                #'color': 'green',\n                #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\n                #'upColor': 'red',\n                #'upLineColor': 'red',\n                \"data\" : [],\n            }\n}\n\"\"\"\nshortChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n    \"layout\" : \"single\",  #single不参于分组，单独显示, 默认为分组 'group'\n    #\"height\" : 500, \n    },\n    'legend': {\n        'enabled': true  # 图例 true开启\n    },\n    'title' : {\n        'text' : '柱形K线'\n    },\n    \"xAxis\" : {\n        \"type\" : \"datetime\",\n        #'dashStyle': 'dash'  # 准心线样式 虚线\n    }, # 时间序列轴\n    'yAxis' : [{\n        'labels':{\n            'align':'right',\n            'x':-3\n        },\n        'height':\"40%\",\n        'lineWidth':2,\n        #'crosshair': true,  # 准心线\n        'resize':{\n            'enabled':true\n        }\n    },{\n        'labels':{\n            'align':'right',\n            'x':-3\n        },\n        'title':{\n            'text' : 'Volume'\n        },\n        'top':'40%',\n        'height':'15%',\n        'offset':0,\n        #'crosshair': true,\n        'lineWidth':2\n    },{\"labels\": {\n            \"align\": 'right',\n            \"x\":-3\n        },\n        \"title\": {\n            \"text\": 'RSI'\n        },\n        \"top\": '55%',\n        \"height\": '20%',\n        \"opposite\": True,\n        \"offset\": 0,\n        #'crosshair': true,\n        \"lineWidth\": 2,\n        'plotLines': [{\n                'value': 75,  # 值大小\n                'color': 'green',  # 颜色\n                'dashStyle': 'shortdash', # 线条样式\n                'width': 0.5,\n                #'label': {\n                #    'text': '多头止盈线'\n                #}\n        },{\n                'value': 25,\n                'color': 'red',\n                'dashStyle': 'shortdash',\n                'width': 0.5,\n                #'label': {\n                #    'text': '空头止盈线'\n                #}\n        }\n        ]\n    }, {\"labels\": {\n            \"align\": 'right',\n            \"x\":-3\n    },\n        \"title\": {\n            \"text\": 'MACD'\n        },\n        \"top\": '75%',\n        \"height\": '25%',\n        \"opposite\": True,\n        \"offset\": 0,\n        \"lineWidth\": 2\n    }\n    ],\n    'tooltip':{\n        #'shared': true,  # 是否开启提示标签共享,多图下效果基本等同split\n        \"xDateFormat\" : \"%Y-%m-%d %H:%M:%S, %A\",\n        'shared': true,\n\t\t'crosshairs': true,\n        'valueDecimals':2, # 保留小数\n        #'split':true, # 提示框分开\n        #'distance': 30,\n\t\t#'padding': 5\n        #'positioner': {\n        #    'x':150,\n        #    'y':150\n        #},\n        #'shadow': false,\n        #'borderWidth': 0,\n        #'backgroundColor': 'rgba(255,255,255,0.8)'\n    },\n    'series':[{\n        'type':'candlestick',\n        'animationLimit':'Infinity',\n        'color': 'green',\n        'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\n        'upColor': 'red',\n        'upLineColor': 'red',\n        'name':'appl',\n        'data':[]\n    },{\n        'type':'column',\n        'name':'Volume',\n        'data':[],\n        'yAxis':1\n    },{\n        \"type\" : \"line\",\n        \"name\" : \"rsi\",\n        \"data\" : [],\n        \"yAxis\": 2  # 相对位置\n    },{\n        \"type\" : \"line\",\n        \"name\" : \"diff\",\n        \"data\" : [],\n        \"yAxis\": 3  # 相对位置\n    },{\n        \"type\" : \"line\",\n        \"name\" : \"dea\",\n        \"data\" : [],\n        \"yAxis\": 3  # 相对位置\n    },{\n        \"type\" : \"column\",\n        \"name\" : \"macd\",\n        \"data\" : [],\n        'maxPointWidth':2,  # 量柱最大宽度\n        \"yAxis\": 3  # 相对位置\n    }\n\n    ]\n}\n    \n\nlongChart = {\n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n    'rangeSelector':{\n        'selected' : 0 \n    },\n    'chart': {  # 主配置项\n        #'height': 630,  # 高度，平台不支持配置\n        'type': 'line',\n        'zoomType': 'x',  # 缩放\n        #'selectionMarkerFill':'rgba(51,92,223,0.25)',  # 缩放框背景色\n        #'panning': true,  # 开启平移\n        #'panKey': 'shift'  # 平移\n        'borderColor': '#EBBA95', # 外框配置项\n        'borderWidth': 2,  ##\n        'borderRadius': 10, ##\n    },\n    \"rangeSelector\" : {\n        \"buttons\" : [{\n            \"type\" : \"hour\",\n            \"count\" : 1,\n            \"text\" : \"1h\",\n        }, {\n            \"type\" : 'hour',\n            \"count\" : 3,\n            \"text\" : \"3h\"\n        }, {\n            \"type\" : \"day\",\n            \"count\" : 1,\n            \"text\" : \"1d\"\n        }, {\n            \"type\" : \"week\",\n            \"count\" : 1,\n            \"text\" : \"1w\"\n        }, {\n            \"type\" : \"year\",\n            \"count\" : 1,\n            \"text\" : \"1Y\"\n        }, {\n            \"type\" : \"all\",\n            \"text\" : \"All\"\n        }],\n        \"selected\" : 1,\n        \"inputEnabled\" : True\n    },\n    'legend': {\n        'enabled': true  # 图例 true开启\n    },\n    'title' : {\n        'text' : '15'\n    },\n    'subtitle': {\n        'text': '湘水看盘图表',  #'当前价格:'+str(records_5[-1]['Close'] if records_5[-1]['Close'] is not None else **)+' || '+'当前时间:'+str(Time_5 if Time_5 is not None else **)\n    },\n    \"xAxis\" : {\n        \"type\" : \"datetime\",\n        #'dashStyle': 'dash'  # 准心线样式 虚线\n    }, # 时间序列轴\n    \"xAxis\" : {\"type\" : \"datetime\"},\n    \"yAxis\" : [{\n            \"title\": {\n                \"text\": 'Kline'\n            },\n            \"height\": \"60%\",  # 相对宽度大小\n            \"offset\": 0,  # 坐标轴偏移 正右 负左\n            \"lineWidth\": 2  # 线宽\n        },{\n            \"title\": {\n                \"text\": 'MACD'\n            },\n            \"top\": '62%',\n            \"height\": '38%',\n            \"offset\": 0,\n            \"lineWidth\": 2\n        }    \n    ],\n    \"series\" : [\n        {\n            \"type\" : \"candlestick\", \n            \"name\" : \"k_15\",\n            \"id\" : \"k\",\n            \"data\" : [],\n            \"yAxis\": 0  # 相对位置\n        },{\n            \"type\" : \"column\",\n            \"name\" : \"macd_15\",\n            \"data\" : [],  \n            \"yAxis\": 1  # 相对位置\n        }\n    ]\n}\n\nchart0 = {                                        \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n\n    'title' : { 'text' : '日K线图'},                       \n    'xAxis': { 'type': 'datetime'},            \n    'series' : [                                          \n        {                                      \n            'type': 'candlestick',                         \n            'name': 'r',   \n            'id': 'r',                                     \n            'data': []                                           \n        }, {                                      \n            'type': 'column',           \n            'name': 'vol',          \n            'data': [],               \n        }\n    ]\n}\n\nchart1 = {  \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n                                      \n    'title' : { 'text' : 'ris'},                       \n    'xAxis': { 'type': 'datetime'},                       \n    'yAxis' : {                                           \n            'title': {'text': 'rsi'},                           \n            'opposite': false                                 \n    },\n    'series' :                                      \n        { \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'rsi',\n            'data': []\n    },\n}\n\n\nchart2 = {  \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n                                      \n    'title' : { 'text' : 'macd'},                       \n    'xAxis': { 'type': 'datetime'},                       \n    'yAxis' : {                                           \n            'title': {'text': 'macd'},                           \n            'opposite': false                                 \n    },\n    'series' :  [           \n        { \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'dif',\n            'data': []\n    },{ \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'eda',\n            'data': []\n    },{ \n            'type': 'line',\n            #'yAxis': 1, \n            'name': 'macd',\n            'data': []\n    },\n    ]\n}\n\n\nhart1 = {                                        \n    \"__isStock\" : True,\n    \"extension\" : {\n        \"layout\" : \"group\", \n        #\"height\" : 300, \n    },\n\n    'title' : { 'text' : 'MACD_5'},                       \n    'xAxis': { 'type': 'datetime'},             \n    'series' : [                                          \n        {                                      \n            'type': 'candlestick',                             \n            'name': 'k',   \n            'id': 'r1',                                     \n            'data': []                                           \n        }, {                                      \n            'type': 'column',           \n            'name': 'macd_15',          \n            'data': [],               \n        }\n    ]\n}\n\n\n\n\nmacd_15 = []\nrunTime = {}\nrunTime['preBarTime_1'] = [0,0]\nrunTime['arrKIndex'] = []\n_5_lengh = 50\n_15_lengh = 50\ndef ticks_(records, k):\n    if len(records) == 0:\n        return []\n    if isinstance(records[0], int) or isinstance(records[0], float):\n        return records\n\n    ticks = [None] * len(records)\n    for i in range(len(records)):\n        ticks[i] = records[i][k]\n        return ticks\n\n\ndef plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart):\n    for x,symbol in enumerate(arr):\n        #Log(symbol,_D(),)\n        runTime['arrKIndex'] = [index_2[x],index_2[x]+7]   # [0,7] [8,15]\n        #Log(symbol)\n        exchange.SetContractType(symbol)\n        #Log(symbol,_D())\n        records_5 = _C(exchange.GetRecords,PERIOD_M5)  # 返回列表型字典\n        records_15 = _C(exchange.GetRecords,PERIOD_M15)\n        r = records_5\n        m = records_15\n        Time_5 = records_5[-1]['Time']\n        Time_5_list = pd.Series(ticks_(records_5,'Time'))  # 小周期开盘时间数组\n        #Open_5 = records_5['Open']\n        #High_5 = records_5['High']\n        #Low_5 = records_5['Low']\n        Close_5 = pd.Series(ticks_(records_5,'Close'))  # 小周期收盘价数组\n\n        Time_15 = records_15[-1]['Time']\n        Time_15_list = pd.Series(ticks_(records_15,'Time'))  # 小周期开盘时间数组\n        #Open_5 = records_5['Open']\n        #High_5 = records_5['High']\n        #Low_5 = records_5['Low']\n        Close_15 = pd.Series(ticks_(records_15,'Close'))  # 小周期收盘价数组\n\n        #Log(2)\n        '''\n        nowdea_15 = dea_15[-1]\n        nowdiff_15 = diff_15[-1]\n        nowmacd_15 = macd_15[-1]\n        '''\n\n        '''\n        predea_15 = dea_15[-2]\n        prediff_15 = diff_15[-2]\n        premacd_15 = macd_15[-2]\n        '''\n        #index_1 += 5\n        if not r or not m:\n            return\n        #Log(3,len(r))\n\n        if len(r) < _5_lengh:  # 过滤K线过短情况\n            return\n\n        #Log(4)\n        Macd_5 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\n        diff_5 = Macd_5[0]\n        dea_5 = Macd_5[1]\n        macd_5 = pd.Series(Macd_5[2]).fillna(0)\n        macd_5 = macd_5.values*2  # TA的macd算法未乘以2\n\n        Macd_15 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\n        diff_15 = Macd_15[0]\n        dea_15 = Macd_15[1]\n        macd_15 = pd.Series(Macd_15[2]).fillna(0)\n        macd_15 = macd_15.values*2  # TA的macd算法未乘以2\n\n        RSI = TA.RSI(records_5, period = rsi_period)\n        nowdea_5 = dea_5[-1]\n        nowdiff_5 = diff_5[-1]\n        nowmacd_5 = macd_5[-1]\n        if len(macd_15) > 2:\n            nowmacd_15 = macd_15[-1]\n        nowrsi = RSI[-1]\n        \n        predea_5 = dea_5[-2]\n        prediff_5 = diff_5[-2]\n        premacd_5 = macd_5[-2]\n        if len(macd_15) > 2:\n            premacd_15 = macd_15[-2]\n        prersi = RSI[-2]\n        #Log('K线长度',len(r),'dea_5',len(dea_5),'rsi',len(RSI),preBarTime_1)\n            \n            \n\n        if len(macd_15)>0:        \n            #Log(time.strftime(\"%Y-%m-%d %H:%M:%S\",  time.localtime(int(records_5[-1]['Time'])/1000)),_D(),macd_15[-1])\n            pass\n        \n        #r = records_5\n        #m = records_15\n        arr_ = [r,m]        \n\n        #Log(index_2)\n        index_2 = index_2.copy()\n        #index_2 = index_2.tolist()\n        for i in range(len(arr_)):  # i 是k线周期循环\n\n            #Log(runTime['arrKIndex'])\n            for j in range(len(arr_[i])):  # 时间周期循环\n                #Log(arr_[i][j][\"Time\"],runTime['preBarTime_1'][i])\n                if arr_[i][j][\"Time\"] == runTime['preBarTime_1'][i]:  # preBarTime初始为0\n                    if i == 0:  #5分钟 #index_2 0 8\n                        chart.add(int(index_2[x]), [arr_[i][j][\"Time\"], arr_[i][j][\"Open\"], arr_[i][j][\"High\"], arr_[i][j][\"Low\"], arr_[i][j][\"Close\"]], -1)  # 选出不同周期K线的index\n                        #Log(1,int(index_2[i]))\n                    if i == 0 and len(arr_[i]) > _5_lengh:\n                        #Log(2)\n                        if j == len(arr_[i]) - 2:\n                            #Log(3)\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\"Time\"], arr_[i][j][\"Volume\"]],-1)  \n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\"Time\"], prersi], -1)    # 快线\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\"Time\"], prediff_5], -1)    # 慢线\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\"Time\"], predea_5], -1)\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\"Time\"], premacd_5], -1)\n                        elif j == len(arr_[i]) - 1:\n                            #Log(4,int(index_2[i]))\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\"Time\"], arr_[i][j][\"Volume\"]],-1)  \n                            #Log(4.1)\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\"Time\"], nowrsi], -1)    # 快线\n                            #Log(4.2)\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\"Time\"], nowdiff_5], -1)    # 慢线\n                            #Log(4.3)\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\"Time\"], nowdea_5], -1)\n                            #Log(4.4)\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\"Time\"], nowmacd_5], -1)\n                            #Log(4.5)\n                    '''\n                    if i == 1 and len(arr_[i]) > _15_lengh:\n                        if j == len(arr_[i]) - 2:\n                            chart.add(index_2 + 8, [arr_[i][j][\"Time\"], premacd_15], -1)    # 快线\n                        elif j == len(arr_[i]) - 2:\n                            chart.add(index_2 + 8, [arr_[i][j][\"Time\"], nowmacd_15], -1)    # 快线\n                    '''\n                elif arr_[i][j][\"Time\"] > runTime['preBarTime_1'][i]:  # 初始运行此处  每个5，15分钟运行两次\n                    \n                    if i ==1:\n                        pass\n                        \n                        #Log(time.strftime(\"%Y-%m-%d %H:%M:%S\",  time.localtime(int(arr_[i][j][\"Time\"])/1000)),time.strftime(\"%Y-%m-%d %H:%M:%S\",  time.localtime(int(runTime['preBarTime_1'][i])/1000)),'//',i)\n                    runTime['preBarTime_1'][i] = arr_[i][j][\"Time\"]  # K线时间赋值给preBarTime\n                    Log(runTime['preBarTime_1'][0],runTime['preBarTime_1'][1])\n                    # 0 7 8 15\n                    chart.add(int(runTime['arrKIndex'][x]), [arr_[i][j][\"Time\"], arr_[i][j][\"Open\"], arr_[i][j][\"High\"], arr_[i][j][\"Low\"], arr_[i][j][\"Close\"]])\n                    if i ==0 and len(arr_[i]) > _5_lengh:\n                        #Log('i=0',int(runTime['arrKIndex'][x]))\n                        if j == len(arr_[i]) - 1:\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\"Time\"], arr_[i][j][\"Volume\"]])\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\"Time\"], nowrsi])\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\"Time\"], nowdiff_5])\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\"Time\"], nowdea_5])\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\"Time\"], nowmacd_5])\n                    \n                    if i == 1 and len(arr_[i]) > _15_lengh:\n                        Log('i=1',int(index_2[x]) + 7)\n                        if j == len(arr_[i]) - 1:\n                            chart.add(int(index_2[x]) + 7, [arr_[i][j][\"Time\"], nowmacd_5])\n\ndef main():\n    \"\"\"\n    \"\"\"\n    global preBarTime_1,macd_15,runTime,_5_lengh,_15_lengh,shortChart,longChart,chart0,chart1,chart2,hart1\n    if exchange.GetName().find(\"CTP\") == -1:\n        raise Exception(\"只支持商品期货CTP\")\n    SetErrorFilter(\"login|ready|流控|连接失败|初始|Timeout\")\n    mode = exchange.IO(\"mode\", 0)\n    if mode is None:\n        raise Exception(\"切换模式失败，请更新到最新托管者！\")\n    while not exchange.IO(\"status\"):\n        Sleep(3000)\n        LogStatus(\"正在等待与交易服务器连接，\" + _D())\n    positions = _C(exchange.GetPosition)  # 获取当前持仓信息字典\n    if len(positions) > 0:\n        Log(\"检测到当前持有仓位，系统将开始尝试恢复进度...\")\n        Log(\"持仓信息：\", positions)\n\n\n    tts = []  # \n    arrChart_1 = []  # 图表数组\n    arrChart_2 = []\n    index_ = 0  # \n    index_2 = []\n    arrKIndex = []\n    a = []\n    b = []\n    c = []\n    d = []\n\n    #while True:\n    #Log(1)\n    symbolFilter = {}  # 过滤用数组\n    arr = Instruments.split(\",\")  # 合约列表\n    for i in range(len(arr)):  # 遍历合约列表\n        symbol = re.sub(r'/\\s+$/g', \"\", re.sub(r'/^\\s+/g', \"\", arr[i]))  # 规整合约字符串\n        if symbol in symbolFilter.keys():  # 如果 在过滤数组中 存在 名为 symbol的属性，则显示信息 并跳过。\n            raise Exception(symbol + \"已经存在，请检查参数！\")\n        symbolFilter[symbol] = True  # 给过滤数组 添加 名为 symbol 的 keys，下次 同样的 合约代码 会被过滤 保证每个合约只对Manager类方法传入一次参数\n        hasPosition = False  # 初始化 hasPosition 变量 false 代表没有持仓 \n        for j in range(len(positions)):  # 遍历 获取到的持仓信息\n            if positions[j][\"ContractType\"] == symbol:  # 如果持仓中有合约名等于symbol\n                Log('cc')\n                hasPosition = True  # 标记 True 持仓\n                break  # 跳出\n        #fastPeriod = int(arrFastPeriod[i])  # 规整为数值型\n        #slowPeriod = int(arrSlowPeriod[i])\n        Log(123)\n        obj_1 = shortChart #  实例化Manager类\n        obj_2 = longChart\n        index_2.append(index_)  # 0 8\n        index_ += 8 # 长周期的图表index\n        \n        #tts.append(obj)  # tts列表传入 最终根据合约列表 ，生成了若干个品种的 控制对象储存在tts数组 \n        #Log(obj)\n        arrChart_1.append(obj_1)   # 在for循环中 依次把图表信息字典传入图表数组\n        #arrChart_2.append(obj_2)\n        a.append(chart0)\n        b.append(chart1)\n        c.append(chart2)\n        d.append(hart1)\n        Log(len(arrChart_1))\n        Log(111 if arrChart_1[0]==shortChart else 000)\n        #arrChart_2.append(obj.longChart)\n    # 创建图表对象\n    #chart = Chart([arrChart_1, arrChart_2])  # __isStock\" : True表示是highstock图，False表示是highcharts图 使用多图表对象，转为二维数组\n    #chart = Chart([arrChart_1,arrChart_2])\n    chart = Chart([a,b,c,d])\n    #Log(len(arrChart_1),len(arrChart_2))\n    index_2 = np.array(index_2)\n    chart.reset()  # 清空上次轮询的图表数据\n\n    while True:\n        #c = Chart(shortChart)\n        preTicker = None\n        #while True:\n        #Log(1)\n        if exchange.IO('status'):\n            LogStatus(_D(),'已经连接')\n            #t = exchange.GetTicker()\n            plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart)\n        Sleep(1000)                      \n        ''' \n        if i ==0:\n            if signals['buy_sell_sig'+str(trueSymbol)] ==1:\n                Log(1)\n                #ext.PlotFlag(r[-2]['Time'],'开多','L','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'L','text':'开多'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n            if signals['buy_sell_sig'+str(trueSymbol)] ==2:\n                Log(2)\n                #ext.PlotFlag(r[-2]['Time'],'开空','S','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'S','text':'开空'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n            if signals['buy_sell_sig'+str(trueSymbol)] ==3:\n                Log(3)\n                #ext.PlotFlag(r[-2]['Time'],'平多','UL','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'UL','text':'平多'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n            if signals['buy_sell_sig'+str(trueSymbol)] ==4:\n                Log(4)\n                #ext.PlotFlag(r[-2]['Time'],'平空','US','circlepin','K')\n                chart.add(index_2 + 6, [arr_[i][j][\"Time\"], {'X':arr_[i][j][\"Time\"],'title':'US','text':'平空'}])\n                signals['buy_sell_sig'+str(trueSymbol)] =0\n\n        '''\n\n                    #index_1 += 9  # 短周期的图表index\n\n        \n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/216948\n\n> Last Modified\n\n2020-07-07 13:53:18"
    },
    {
        "strategy_id": "82_定投策略",
        "strategy_code": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport json\nimport time\n\nfrom kumex.client import Trade\n\n\nclass Aip(object):\n\n    def __init__(self):\n        # read configuration from json file\n        with open('config.json', 'r') as file:\n            config = json.load(file)\n\n        self.api_key = config['api_key']\n        self.api_secret = config['api_secret']\n        self.api_passphrase = config['api_passphrase']\n        self.sandbox = config['is_sandbox']\n        self.symbol = config['symbol']\n        self.timer = int(config['timer'])\n        self.size = int(config['size'])\n        self.side = config['side']\n        self.leverage = config['leverage']\n        self.rate = float(config['rate'])\n        self.trade = Trade(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\n        if self.side == 'sell':\n            self.close = 'buy'\n        else:\n            self.close = 'sell'\n\n    def get_position_pcnt(self):\n        position = self.trade.get_position_details(self.symbol)\n        return float(position['unrealisedPnlPcnt'])\n\n\nif __name__ == '__main__':\n    aip = Aip()\n    market_order = aip.trade.create_market_order(aip.symbol, aip.side, aip.leverage, type='market', size=aip.size)\n    print('create a market %s order, order id = %s' % (aip.side, market_order['orderId']))\n    while 1:\n        time.sleep(aip.timer * 60)\n        pcnt = aip.get_position_pcnt()\n        if pcnt < 0 and abs(pcnt) > aip.rate:\n            market_order = aip.trade.create_market_order(aip.symbol, aip.side, aip.leverage,\n                                                         type='market', size=aip.size)\n            print('create a market %s order, order id = %s' % (aip.side, market_order['orderId']))\n        elif pcnt > 0 and pcnt > aip.rate:\n            market_order = aip.trade.create_market_order(aip.symbol, aip.close, aip.leverage,\n                                                         type='market', size=(aip.size*2))\n            print('create a market %s order, order id = %s' % (aip.close, market_order['orderId']))",
        "strategy_description": "策略名称: 定投策略\n\n股语有云：新手死于追高，老手死于抄底。讲究的是一个择时问题，一不小心就被套牢了，所以很多策略都会去做一些趋势预测，根据趋势进行调整持仓情况。\n\n而对于定投策略，即定期定额的投资策略，根本核心是——低买高卖，越跌越买，而不是追涨杀跌。所以对于定投策略，可以认为随时都可以买。\n\n制定一份有效的定投策略，能够大幅提高定投的收益，我们在定投前都应该把自己的计划落于纸上，按照计划执行，减少人为的干预，坚持下去，止盈不止损，才能真正体会到定投的价值所在。\n\n在这里我们为控制风险对操作范围加以限制，拟定了如下策略规则：\n\n每分钟定投1手空单，20倍杠杆。\n未平的仓位，如果亏损超过3%，继续定投。如果盈利超过3%，每分钟平仓2手\n其中，在测试脚本中，定投周期、定投数量、杠杆倍数、盈亏率、仓位方向为可配置项。"
    },
    {
        "strategy_id": "83_子辰量化无限网格交易策略",
        "strategy_code": "python\n##\n# 无限网格交易策略（公开版）\n# Author: 子辰量化\n# Last Modified: 2024-1-4\n##\n\nimport time\n\nassetRatio = 0.5 # 资产投资比例\n\noriginalTotalMoney = totalInvestment # 基准投资额，总投资额+盈亏后的全部权益\noriginalAssetMoney = totalInvestment * assetRatio # 基准资产价值\noriginalCashMoney = totalInvestment * (1 - assetRatio) # 基准现金\n\nremainCashMoney = originalTotalMoney # 当前剩余现金\ninvestAssetMoney = 0 # 当前资产价值\ninverstAssetAmount = 0 # 当前资产数量\n\nboolInited = False # 是否完成了首次建仓\n\ni = 0 # tick计算\n\ndef num_cut(num, c):\n    str_num = str(num)\n    return float(str_num[:str_num.index('.') + 1 + c])\n\ndef onTick():\n    global assetRatio\n    global originalTotalMoney\n    global originalAssetMoney\n    global originalCashMoney\n    global remainCashMoney\n    global investAssetMoney\n    global inverstAssetAmount\n    global boolInited\n    global i\n\n    ticker = exchange.GetTicker()\n    # Log(ticker)\n    openTime = time.localtime(ticker.Time / 1000) # ticker time\n    openTimeStr = time.strftime(\"%Y-%m-%dT%H:%M:%S\", openTime) \n    price = ticker.Last\n\n    # 初始建仓\n    if not boolInited:\n        money = originalAssetMoney\n        id = exchange.Buy(-1, money) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"buy money:\", money)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        money = order[\"Amount\"] # 成交的money\n        dealAmount = order[\"DealAmount\"] # 已扣除手续费的资产数量\n        price = order[\"AvgPrice\"] # 成交均价\n        remainCashMoney = originalCashMoney\n        investAssetMoney = originalAssetMoney\n        inverstAssetAmount = dealAmount        \n        boolInited = True\n        Log(f\"use ${investAssetMoney} buy {inverstAssetAmount} asset at price ${price} at time {openTimeStr}\")\n\n        Log(f\"{i} summary:\")\n        originalTotalMoney = originalAssetMoney + originalCashMoney\n        investAssetMoney = inverstAssetAmount * price\n        currentTotalMoney = investAssetMoney + remainCashMoney\n        Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n        Log(f\"originalCashMoney: ${originalCashMoney}\")\n        Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n        Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n        Log(f\"investAssetMoney: ${investAssetMoney}\")\n        Log(f\"remainCashMoney: ${remainCashMoney}\")\n        Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n        # account = exchange.GetAccount()\n        # Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # 买入\n    money = inverstAssetAmount * price # pirce\n    if money < originalAssetMoney * (1 - buyRatio):\n        money = originalAssetMoney * buyRatio # 买入金额\n        account = exchange.GetAccount()\n        if remainCashMoney > money and account[\"Balance\"] > money: # 判断是否还有足够的现金，双重检查 \n            # amount = money / price\n            id = exchange.Buy(-1, money) # 市价单\n            # Log(\"order id:\", id)\n            order = exchange.GetOrder(id)\n            Log(\"buy money:\", money)\n            Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n            money = order[\"Amount\"] # 成交的money\n            dealAmount = order[\"DealAmount\"] # 已扣除手续费的资产数量\n            price = order[\"AvgPrice\"] # 成交均价  \n            remainCashMoney -= money\n            inverstAssetAmount = inverstAssetAmount + dealAmount\n            Log(f\"bull/bear buy {dealAmount} asset at ${price} at time {openTimeStr}\")\n\n            Log(f\"{i} summary:\")\n            originalTotalMoney = originalAssetMoney + originalCashMoney\n            investAssetMoney = inverstAssetAmount * price\n            currentTotalMoney = investAssetMoney + remainCashMoney\n            Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n            Log(f\"originalCashMoney: ${originalCashMoney}\")\n            Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n            Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n            Log(f\"investAssetMoney: ${investAssetMoney}\")\n            Log(f\"remainCashMoney: ${remainCashMoney}\")\n            Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n            # account = exchange.GetAccount()\n            #Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # 卖出\n    money = inverstAssetAmount * price # pirce\n    if money > (originalAssetMoney * (1 + sellRatio)):\n        money = originalAssetMoney * sellRatio # 卖出金额\n        amount = money / price\n        id = exchange.Sell(-1, amount) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"sell money:\", money)\n        Log(\"sell amount:\", amount) \n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        amount = order[\"Amount\"] # 计划卖出资产数量\n        dealAmount = order[\"DealAmount\"] # 成交资产数量，这里好像是从balance扣除的手续费吗?\n        # 从日志来看amount == dealAmount,所以手续费是从balance扣除的\n        price = order[\"AvgPrice\"] # 成交均价\n        dealMoney = dealAmount * price # 未扣除手续费\n        remainCashMoney += dealMoney # 这里需要减去手续费\n        inverstAssetAmount = inverstAssetAmount - dealAmount\n        Log(f\"bull/bear sell {amount} asset at ${price} at time {openTimeStr}\")\n\n        Log(f\"{i} summary:\")\n        originalTotalMoney = originalAssetMoney + originalCashMoney\n        investAssetMoney = inverstAssetAmount * price\n        currentTotalMoney = investAssetMoney + remainCashMoney\n        Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n        Log(f\"originalCashMoney: ${originalCashMoney}\")\n        Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n        Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n        Log(f\"investAssetMoney: ${investAssetMoney}\")\n        Log(f\"remainCashMoney: ${remainCashMoney}\")\n        Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n        # account = exchange.GetAccount()\n        # Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    ##\n    # 仓位调整\n    ##\n    # 当remainCashMoney超过originalCashMoney的10%时，加大投资基准\n    if remainCashMoney >= originalCashMoney * 1.1:\n        money = (remainCashMoney - originalCashMoney) / 2 # 买入金额\n        # amount = money / price\n        id = exchange.Buy(-1, money) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"buy money:\", money)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        money = order[\"Amount\"] # 成交的money\n        dealAmount = order[\"DealAmount\"] # 已扣除手续费\n        price = order[\"AvgPrice\"] # 成交均价  \n        remainCashMoney -= money\n        inverstAssetAmount = inverstAssetAmount + dealAmount\n        originalAssetMoney += money # 增加投资基准\n        originalCashMoney += money # 增加投资基准\n        Log(f\"bull/bear add original invest at time {openTimeStr}\")\n\n    # 当remainCashMoney低于originalCashMoney的90%时，减少投资基准\n    if remainCashMoney <= originalCashMoney * 0.9:\n        money = (originalCashMoney - remainCashMoney) / 2 # 卖出金额\n        amount = money / price\n        id = exchange.Sell(-1, amount) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"sell money:\", money)\n        Log(\"sell amount:\", amount)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        amount = order[\"Amount\"] # 计划卖出资产数量\n        dealAmount = order[\"DealAmount\"] # 成交资产数量，这里好像是从balance扣除的手续费吗?\n        # 从日志来看amount == dealAmount,所以手续费是从balance扣除的\n        price = order[\"AvgPrice\"] # 成交均价\n        dealMoney = dealAmount * price # 未扣除手续费\n        dealMoney = dealAmount * price # 未扣除手续费\n        remainCashMoney += dealMoney # 这里需要减去手续费\n        inverstAssetAmount = inverstAssetAmount - dealAmount\n        originalAssetMoney -= money # 减少投资基准\n        originalCashMoney -= money # 减少投资基准\n        Log(f\"bull/bear reduce original invest at time {openTimeStr}\")\n\n    # tick计算\n    i = i + 1\n\ndef main():\n    Log(totalInvestment, buyRatio, sellRatio)\n\n    while True:\n        onTick()\n        Sleep(1000) # 1秒\n\ndef onexit():\n    global inverstAssetAmount\n\n    # 清仓\n    Log(\"清仓\")\n    if inverstAssetAmount > 0:\n        amount = num_cut(inverstAssetAmount * (1-0.0001), 8) # 留0.01%一丢丢，小数位控制\n        id = exchange.Sell(-1, amount) # 市价单\n        Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])        \n    # 倒计时\n    beginTime = time.time() * 1000\n    while True:\n        ts = time.time() * 1000\n        Log(\"程序停止倒计时...，已经过去：\", (ts - beginTime) / 1000, \"秒！\")\n        Sleep(1000) # 1秒",
        "strategy_description": "策略名称: 子辰量化无限网格交易策略\n\n# Author: 子辰量化"
    },
    {
        "strategy_id": "84_子辰量化香农网格交易策略",
        "strategy_code": "python\n##\n# 香农网格交易策略（公开版）\n# Author: 子辰量化\n# Last Modified: 2024-1-4\n##\n\nimport time\n\nassetRatio = 0.5 # 资产投资比例\n\noriginalTotalMoney = totalInvestment # 基准投资额，总投资额+盈亏后的全部权益\noriginalAssetMoney = totalInvestment * assetRatio # 基准资产价值\noriginalCashMoney = totalInvestment * (1 - assetRatio) # 基准现金\n\nremainCashMoney = originalCashMoney # 当前剩余现金\ninvestAssetMoney = 0 # 当前资产价值\ninverstAssetAmount = 0 # 当前资产数量\n\nboolInited = False # 是否完成了首次建仓\n\ni = 0 # tick计算\n\ndef num_cut(num, c):\n    str_num = str(num)\n    return float(str_num[:str_num.index('.') + 1 + c])\n\ndef onTick():\n    global assetRatio\n    global originalTotalMoney\n    global originalAssetMoney\n    global originalCashMoney\n    global remainCashMoney\n    global investAssetMoney\n    global inverstAssetAmount\n    global boolInited\n    global i\n\n    ticker = exchange.GetTicker()\n    # Log(ticker)\n    openTime = time.localtime(ticker.Time / 1000) # ticker time\n    openTimeStr = time.strftime(\"%Y-%m-%dT%H:%M:%S\", openTime) \n    price = ticker.Last\n\n    # 初始建仓\n    if not boolInited:\n        money = originalAssetMoney\n        id = exchange.Buy(-1, money) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"buy money:\", money)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        money = order[\"Amount\"] # 成交的money\n        dealAmount = order[\"DealAmount\"] # 已扣除手续费的资产数量\n        price = order[\"AvgPrice\"] # 成交均价\n        investAssetMoney = originalAssetMoney\n        remainCashMoney = originalCashMoney\n        inverstAssetAmount = dealAmount       \n        boolInited = True\n        Log(f\"use ${investAssetMoney} buy {inverstAssetAmount} asset at price ${price} at time {openTimeStr}\")\n\n        Log(f\"{i} summary:\")\n        originalTotalMoney = originalAssetMoney + originalCashMoney\n        investAssetMoney = inverstAssetAmount * price\n        currentTotalMoney = investAssetMoney + remainCashMoney\n        Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n        Log(f\"originalCashMoney: ${originalCashMoney}\")\n        Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n        Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n        Log(f\"investAssetMoney: ${investAssetMoney}\")\n        Log(f\"remainCashMoney: ${remainCashMoney}\")\n        Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n        # account = exchange.GetAccount()\n        # Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # 买入\n    money = inverstAssetAmount * price # pirce\n    if money < originalAssetMoney * (1 - buyRatio):\n        money = originalAssetMoney * buyRatio / 2 # 买入金额\n        account = exchange.GetAccount()\n        if remainCashMoney > money and account[\"Balance\"] > money: # 判断是否还有足够的现金，双重检查\n            # amount = money / price\n            id = exchange.Buy(-1, money) # 市价单\n            # Log(\"order id:\", id)\n            order = exchange.GetOrder(id)\n            Log(\"buy money:\", money)\n            Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n            money = order[\"Amount\"] # 成交的money\n            dealAmount = order[\"DealAmount\"] # 已扣除手续费的资产数量\n            price = order[\"AvgPrice\"] # 成交均价  \n            originalAssetMoney -= money #\n            originalCashMoney -= money #\n            remainCashMoney -= money\n            inverstAssetAmount = inverstAssetAmount + dealAmount\n            Log(f\"bull/bear buy {dealAmount} asset at ${price} at time {openTimeStr}\")\n\n            Log(f\"{i} summary:\")\n            originalTotalMoney = originalAssetMoney + originalCashMoney\n            investAssetMoney = inverstAssetAmount * price\n            currentTotalMoney = investAssetMoney + remainCashMoney\n            Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n            Log(f\"originalCashMoney: ${originalCashMoney}\")\n            Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n            Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n            Log(f\"investAssetMoney: ${investAssetMoney}\")\n            Log(f\"remainCashMoney: ${remainCashMoney}\")\n            Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n            # account = exchange.GetAccount()\n            #Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # 卖出\n    money = inverstAssetAmount * price # pirce\n    if money > (originalAssetMoney * (1 + sellRatio)):\n        money = originalAssetMoney * sellRatio / 2 # 卖出金额\n        amount = money / price\n        id = exchange.Sell(-1, amount) # 市价单\n        # Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"sell money:\", money)\n        Log(\"sell amount:\", amount)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])\n        amount = order[\"Amount\"] # 计划卖出资产数量\n        dealAmount = order[\"DealAmount\"] # 成交资产数量，这里好像是从balance扣除的手续费吗?\n        # 从日志来看amount == dealAmount,所以手续费是从balance扣除的\n        price = order[\"AvgPrice\"] # 成交均价\n        dealMoney = dealAmount * price # 未扣除手续费\n        remainCashMoney += dealMoney # 这里需要减去手续费\n        originalAssetMoney += money #\n        originalCashMoney += money #\n        inverstAssetAmount = inverstAssetAmount - dealAmount\n        Log(f\"bull/bear sell {amount} asset at ${price} at time {openTimeStr}\")\n\n        Log(f\"{i} summary:\")\n        originalTotalMoney = originalAssetMoney + originalCashMoney\n        investAssetMoney = inverstAssetAmount * price\n        currentTotalMoney = investAssetMoney + remainCashMoney\n        Log(f\"originalAssetMoney: ${originalAssetMoney}\")\n        Log(f\"originalCashMoney: ${originalCashMoney}\")\n        Log(f\"originalTotalMoney: ${originalTotalMoney}\")\n        Log(f\"inverstAssetAmount: ${inverstAssetAmount}\")\n        Log(f\"investAssetMoney: ${investAssetMoney}\")\n        Log(f\"remainCashMoney: ${remainCashMoney}\")\n        Log(f\"currentTotalMoney: ${currentTotalMoney}\")\n        # account = exchange.GetAccount()\n        # Log(\"Balance:\", account[\"Balance\"], \"FrozenBalance:\", account[\"FrozenBalance\"], \"Stocks:\", account[\"Stocks\"], \"FrozenStocks:\", account[\"FrozenStocks\"])\n\n    # tick计数\n    i = i + 1\n\ndef main():\n    Log(totalInvestment, buyRatio, sellRatio)\n\n    while True:\n        onTick()\n        Sleep(1000) # 1秒\n\ndef onexit():\n    global inverstAssetAmount\n\n    # 清仓\n    Log(\"清仓\")\n    if inverstAssetAmount > 0:\n        amount = num_cut(inverstAssetAmount * (1-0.0001), 8) # 留0.01%一丢丢，小数位控制\n        id = exchange.Sell(-1, amount) # 市价单\n        Log(\"order id:\", id)\n        order = exchange.GetOrder(id)\n        Log(\"order id:\", order[\"Id\"], \"Price:\", order[\"Price\"], \"Amount:\", order[\"Amount\"], \"DealAmount:\", order[\"DealAmount\"], \"AvgPrice:\", order[\"AvgPrice\"], \"Status:\", order[\"Status\"], \"Type:\", order[\"Type\"])        \n    # 倒计时\n    beginTime = time.time() * 1000\n    while True:\n        ts = time.time() * 1000\n        Log(\"程序停止倒计时...，已经过去：\", (ts - beginTime) / 1000, \"秒！\")\n        Sleep(1000) # 1秒",
        "strategy_description": "策略名称: 子辰量化香农网格交易策略\n\n# Author: 子辰量化"
    },
    {
        "strategy_id": "85_定投新手入门每周100USDT-定期定额-100USDT-Invested-Every-Week-Regular-Fixed-Investment",
        "strategy_code": "python\ndef main():\n    amountAll = 0                                              #持有总量\n    cost = 0                                                   #成本\n    marketValueCurrent = 0                                     #当前持有总市值\n    rateOfReturn = 0                                           #收益率\n    while True:\n        ticker = exchange.GetTicker()\n        price = ticker['Last']                                 #获得当前价格\n        amount = 100 / price                                   #计算本次买入量\n        exchange.Buy(price,amount)                             #买入\n        amountAll = amountAll + amount                         #计算持有总量\n        cost = cost + 100                                      #计算总成本\n        marketValueCurrent = amountAll * price                 #计算当前持有总市值\n        rateOfReturn = (marketValueCurrent - cost) / cost      #计算收益率        \n        Log(\"此次投入金额：\", 100, \"本金：\", cost, \"当前总市值：\", marketValueCurrent, \"收益率:\", rateOfReturn * 100,\"%\",\"当前价格\",price)\n        Sleep(7 * 24 * 60 * 60 * 1000)                         #等待一周",
        "strategy_description": "策略名称: 定投新手入门每周100USDT-定期定额-100USDT-Invested-Every-Week-Regular-Fixed-Investment\n\n未找到描述"
    },
    {
        "strategy_id": "86_定投新手入门每周100USDT左右-定期不定额-100USDT-Invested-Every-Week-Regular-Variable-Investment",
        "strategy_code": "python\ndef main():\n    amountAll = 0                                              #持有总量\n    cost = 0                                                   #成本\n    marketValueCurrent = 0                                     #当前持有总市值\n    marketValueExpected = 0                                    #当前期望总市值\n    rateOfReturn = 0                                           #收益率\n    eachBuy = 100\n    while True:\n        marketValueExpected = marketValueExpected + eachBuy        #计算当前期望总市值\n        ticker = exchange.GetTicker()\n        price = ticker['Last']                                 #获得当前价格\n        amount = marketValueExpected / price - amountAll       #计算本次买入量\n        if amount > 0:\n            exchange.Buy(price,amount)                         #买入         \n        else:\n            amount = 0\n        amountAll = amountAll + amount                         #计算持有总量\n        cost = cost + amount * price                           #计算总成本\n        marketValueCurrent = amountAll * price                 #计算当前持有总市值\n        rateOfReturn = (marketValueCurrent - cost) / cost      #计算收益率\n        Log(\"此次投入金额：\", amount * price, \"本金：\", cost,\"当前总持有量\", amountAll,\"当前总市值：\", marketValueCurrent, \"收益率:\", rateOfReturn * 100,\"%\" ,\"当前价格:\", price, )\n        Sleep(7 * 24 * 60 * 60 * 1000)                         #等待一周",
        "strategy_description": "策略名称: 定投新手入门每周100USDT左右-定期不定额-100USDT-Invested-Every-Week-Regular-Variable-Investment\n\n未找到描述"
    },
    {
        "strategy_id": "87_山寨币指数20180222基点1000",
        "strategy_code": "python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-coding\nimport time\nimport urllib2\nimport json\nimport pickle\n            \ndef updateTicker():\n    global index,initPrice\n    ticker = json.loads(urllib2.urlopen('https://api.binance.com/api/v3/ticker/price',timeout=10).read())\n    change = []\n    for t in ticker:\n        if t['symbol'][-3:] == 'BTC':\n            if t['symbol'][:-3] in initPrice.keys():\n                change.append(float(t['price'])/initPrice[t['symbol'][:-3]])\n            else:\n                initPrice[t['symbol'][:-3]] = float(t['price'])\n                f=open('price.pkl','w')\n                pickle.dump(initPrice,f,0)\n                f.close()\n                Log(t['symbol'][:-3],' added')\n    if len(change)>0:\n        index = 1000*sum(change)/len(change)\n    \n\n\ninitPrice = {}\nprice = {}\nindex = 1000\ntry:\n    f=open('price.pkl','r')  \n    initPrice=pickle.load(f)  \n    f.close()\nexcept:\n    initPrice = {}\nLog('共计入山寨币:', len(initPrice))\ndef main():\n    while True:\n        try:\n            updateTicker()\n            LogProfit(round(index,4))\n        except Exception as e:\n            pass\n        Sleep(3600000)",
        "strategy_description": "策略名称: 山寨币指数20180222基点1000\n\nimport time\nimport urllib2\nimport json\nimport pickle\n            \ndef updateTicker():\n    global index,initPrice\n    ticker = json.loads(urllib2.urlopen('https://api.binance.com/api/v3/ticker/price',timeout=10).read())\n    change = []\n    for t in ticker:\n        if t['symbol'][-3:] == 'BTC':\n            if t['symbol'][:-3] in initPrice.keys():\n                change.append(float(t['price'])/initPrice[t['symbol'][:-3]])\n            else:\n                initPrice[t['symbol'][:-3]] = float(t['price'])\n                f=open('price.pkl','w')\n                pickle.dump(initPrice,f,0)\n                f.close()\n                Log(t['symbol'][:-3],' added')\n    if len(change)>0:\n        index = 1000*sum(change)/len(change)\n    \n\n\ninitPrice = {}\nprice = {}\nindex = 1000\ntry:\n    f=open('price.pkl','r')  \n    initPrice=pickle.load(f)  \n    f.close()\nexcept:\n    initPrice = {}\nLog('共计入山寨币:', len(initPrice))\ndef main():\n    while True:\n        try:\n            updateTicker()\n            LogProfit(round(index,4))\n        except Exception as e:\n            pass\n        Sleep(3600000)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/73461\n\n> Last Modified\n\n2019-07-03 16:46:08"
    },
    {
        "strategy_id": "88_币安websocket订阅永续合约行情信息",
        "strategy_code": "python\nimport json\ndef main():\n    LogStatus(\"正在连接...\")\n    # client = Dial(\"wss://stream.binance.com:9443/stream?streams=btcusdt@aggTrade/ethusdt@aggTrade|reconnect=true\")    #多个交易对\n    # client = Dial(\"wss://stream.binance.com:9443/ws/btcusdt@aggTrade|reconnect=true\")    #单个交易对\n    # client = Dial(\"wss://dstream.binance.com/ws/btcusd_perp@aggTrade|reconnect=true\")    #币本位，ticker\n    client = Dial(\"wss://fstream.binance.com/ws/btcusdt@aggTrade|reconnect=true\")\n    if not client:    \n        Log(\"连接失败, 程序退出\")\n        return\n    while True:\n        buf = client.read(-2)\n        Log('tt',buf)\n        if buf:\n            obj = json.loads(buf)\n            # Log(obj)\n            # Log('交易对',obj['data']['s'], ' 价格', obj['data']['p'])    #多个交易对 \n            Log(obj['p'])    #测试\n        Sleep(5000)\n    client.close()",
        "strategy_description": "策略名称: 币安websocket订阅永续合约行情信息\n\n# client = Dial(\"wss://stream.binance.com:9443/ws/btcusdt@aggTrade|reconnect=true\")    #单个交易对\n    # client = Dial(\"wss://dstream.binance.com/ws/btcusd_perp@aggTrade|reconnect=true\")    #币本位，ticker\n    client = Dial(\"wss://fstream.binance.com/ws/btcusdt@aggTrade|reconnect=true\")\n    if not client:    \n        Log(\"连接失败, 程序退出\")\n        return\n    while True:\n        buf = client.read(-2)\n        Log('tt',buf)\n        if buf:\n            obj = json.loads(buf)\n            # Log(obj)\n            # Log('交易对',obj['data']['s'], ' 价格', obj['data']['p'])    #多个交易对 \n            Log(obj['p'])    #测试\n        Sleep(5000)\n    client.close()\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/327491\n\n> Last Modified\n\n2021-11-24 14:29:50"
    },
    {
        "strategy_id": "89_币安合约BNB手续费抵扣-自动购买自动划转",
        "strategy_code": "python\n# Contact : ck@xueqiubot.com / WeChat@stay37\n\nimport time\n\n\ndef supply_bnb(transfer_usdt,i):\n    Log(\"当前BNB不足，补充BNB作为手续费抵扣\")\n    #获取当前BNB_USDT价格\n    depth = _C(exchanges[i].GetDepth)\n    #转出transfer_usdt个USDT\n    timestamp = time.time() * 1000\n    transfer = exchanges[i].IO(\"api\",\"POST\",\"/sapi/v1/futures/transfer\",\"asset=USDT&amount=\"+str(transfer_usdt)+\"&type=2&timestamp=+\"+str(timestamp))\n    time.sleep(1)\n    #获取BNB深度 下单购买\n    depth = _C(exchanges[i].GetDepth)\n    buyamount = round(transfer_usdt / (depth.Asks[0].Price + 0.2) , 2)\n    buyid = exchanges[i].Buy(round(depth.Asks[0].Price + 0.1 , 4) , buyamount)\n    time.sleep(1)\n    #查询购买结果 将购买后的BNB以及剩余的USDT转入合约账户\n    acc = _C(exchanges[i].GetAccount)\n    transfer_usdt = acc.Balance\n    transfer_bnb = acc.Stocks\n    timestamp = time.time() * 1000\n    transfer = exchanges[i].IO(\"api\",\"POST\",\"/sapi/v1/futures/transfer\",\"asset=USDT&amount=\"+str(transfer_usdt)+\"&type=1&timestamp=+\"+str(timestamp))\n    transfer = exchanges[i].IO(\"api\",\"POST\",\"/sapi/v1/futures/transfer\",\"asset=BNB&amount=\"+str(transfer_bnb)+\"&type=1&timestamp=+\"+str(timestamp))\n    Log(\"BNB补充完成\")\n\n\n\n\ndef main():\n    if '合约账户内BNB不足':\n        #transfer_usdt: 需要购买的usdt金额\n        #i: bnb_usdt现货交易对的序号\n        supply_bnb(transfer_usdt,i)",
        "strategy_description": "策略名称: 币安合约BNB手续费抵扣-自动购买自动划转\n\nimport time\n\n\ndef supply_bnb(transfer_usdt,i):\n    Log(\"当前BNB不足，补充BNB作为手续费抵扣\")\n    #获取当前BNB_USDT价格\n    depth = _C(exchanges[i].GetDepth)\n    #转出transfer_usdt个USDT\n    timestamp = time.time() * 1000\n    transfer = exchanges[i].IO(\"api\",\"POST\",\"/sapi/v1/futures/transfer\",\"asset=USDT&amount=\"+str(transfer_usdt)+\"&type=2&timestamp=+\"+str(timestamp))\n    time.sleep(1)\n    #获取BNB深度 下单购买\n    depth = _C(exchanges[i].GetDepth)\n    buyamount = round(transfer_usdt / (depth.Asks[0].Price + 0.2) , 2)\n    buyid = exchanges[i].Buy(round(depth.Asks[0].Price + 0.1 , 4) , buyamount)\n    time.sleep(1)\n    #查询购买结果 将购买后的BNB以及剩余的USDT转入合约账户\n    acc = _C(exchanges[i].GetAccount)\n    transfer_usdt = acc.Balance\n    transfer_bnb = acc.Stocks\n    timestamp = time.time() * 1000\n    transfer = exchanges[i].IO(\"api\",\"POST\",\"/sapi/v1/futures/transfer\",\"asset=USDT&amount=\"+str(transfer_usdt)+\"&type=1&timestamp=+\"+str(timestamp))\n    transfer = exchanges[i].IO(\"api\",\"POST\",\"/sapi/v1/futures/transfer\",\"asset=BNB&amount=\"+str(transfer_bnb)+\"&type=1&timestamp=+\"+str(timestamp))\n    Log(\"BNB补充完成\")\n\n\n\n\ndef main():\n    if '合约账户内BNB不足':\n        #transfer_usdt: 需要购买的usdt金额\n        #i: bnb_usdt现货交易对的序号\n        supply_bnb(transfer_usdt,i)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/236437\n\n> Last Modified\n\n2020-11-11 22:38:54"
    },
    {
        "strategy_id": "90_币安合约网格-002v",
        "strategy_code": "python\n\nimport time\nimport requests\nimport math\n# import pandas as pd\n\nInitPrice = 0\nupdateProfitTime = 0\nassets = {}\ntradeInfo = {}\naccountAssets = {}\nruntimeData = {}\nFunding = 0   #账户资金  为0的时候自动获取\nsymbol = ''\nVersion = '0.0.1'\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\n\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所！')\n    exit()\n\ndef init():\n    initData()\n    CancelOrder()\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()\n    for i in range(len(exchangeInfo['symbols'])):\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\n            assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\n\ndef CancelOrder():\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    for x in range(len(orders)):\n        if orders[x]['Info']['symbol'] == symbol :\n            exchange.CancelOrder(orders[x]['Id'])\n\ndef UpdateStatus():\n    global Funding,updateProfitTime\n    if Funding == 0 :\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\n\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\",  \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数][持仓模式]', '币种信息', '开仓方向','初始价格', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\n        'rows': []\n    }\n\n    profitColors = DangerColor\n    totalProfit = assets['USDT']['total_balance'] - Funding\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday\n    \n    #Log('dayProfit:',dayProfit,'Funding:',Funding)\n    dayRate = dayProfit / Funding * 100\n\n\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n\n    i = 1\n    for x in list(symbol.split(',')):\n        typestr = '多空持仓'\n        if type == 1:\n            typestr = '只持多仓'\n        if type == 2:\n            typestr = '只持空仓'\n        direction = '空仓'\n        margin = direction\n        if assets[x]['amount'] != 0:\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\n        unrealised_profit_color = '#000000'\n        if assets[symbol]['unrealised_profit'] > 0:\n            unrealised_profit_color = SuccessColor\n        if assets[symbol]['unrealised_profit'] < 0:\n            unrealised_profit_color = DangerColor\n\n        infoList = [\n        i,\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']'+'['+typestr+']',\n        x,\n        direction,\n        InitPrice,\n        assets[x]['amount'],\n        assets[x]['hold_price'],\n        assets[x]['price'],\n        assets[x]['liquidationPrice'],\n        float(assets[x]['amount']) * float(assets[x]['price']),\n        assets[x]['positionInitialMargin'],\n        assets[x]['unrealised_profit'],\n        ]\n        table['rows'].append(infoList)\n\n        retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n'\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = assets['USDT']['total_balance']\n        key = \"initialAccount_\" + exchange.GetLabel()\n        initialAccount = _G(key)\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\n        if Show:\n            balance = assets['USDT']['total_balance'] - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n        Profit = _N(balance,0)\n\n\ndef UpdateAccount():\n    # Log('UpdateAccount()')\n    global accountAssets\n    account = exchange.GetAccount()\n    position = exchange.GetPosition()\n    if account is None and position is None :\n        Log('更新账户超时！！！')\n        return\n    accountAssets = account['Info']['assets']\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\n    for  i in range(len(account['Info']['positions'])) :\n        if account['Info']['positions'][i]['symbol'] == symbol :\n            #计算持仓保证金                                           初始保证金                +            维持保证金\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\n            #未实现收益\n            assets[symbol]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\n            assets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\n\n    #计算持仓保证金总额\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\n\n    ps = json.loads(exchange.GetRawJSON())\n    if len(ps) > 0 :\n        for x in range(len(ps)):\n            if ps[x]['symbol'] == symbol:\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProfit'])\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\n                assets[symbol]['marginType'] = ps[x]['marginType']\n\ndef UpdateTick():\n    global InitPrice\n    res = _C(exchange.GetTicker)\n    if res is None:\n        Log(\"行情更新异常！！！\")\n\n    if target:\n        InitPrice = target_price\n        _G('InitPrice',InitPrice)\n    else:\n        if  _G('InitPrice') is None :\n            InitPrice = res.Last\n            _G('InitPrice',InitPrice)\n        else:\n            InitPrice = _G('InitPrice')\n\n    assets[symbol]['price'] = res.Last\n\ndef Trade(direction,price,amount):\n    if amount < 0:\n        amount = -amount\n    Log('amount:',amount,'minQty:',tradeInfo[symbol]['minQty'])\n    if amount < tradeInfo[symbol]['minQty']:\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n    else:\n        para = ''\n        url = '/fapi/v1/order'\n        para += 'symbol='+ symbol\n        para += '&side='+ direction\n        para += '&type=LIMIT&timeInForce=GTC'\n        para += '&quantity='+ str(amount)\n        para += '&price='+ str(price)\n        para += \"&timestamp=\"+str(time.time() * 1000);\n        go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n        ret = go.wait()\n        if ret  is not None:\n            logType = LOG_TYPE_SELL\n            if direction == 'BUY':\n                logType =LOG_TYPE_BUY\n            exchange.Log(logType,price,amount,symbol)\n\ndef batch(buy_price,sell_price):\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    if len(orders) < 2 :\n        return True\n    return False\n\ndef Process():\n    amount = (1 - float(assets[symbol]['price']) / float(InitPrice)) / float(pct) * float(value) / float(assets[symbol]['price'])\n    if abs(amount - assets[symbol]['amount']) > _N(value / float(assets[symbol]['price']), tradeInfo[symbol]['amountSize']):\n        if amount > 0:\n            if assets[symbol]['amount'] < amount:\n                CancelOrder()\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n            if assets[symbol]['amount'] > amount:\n                CancelOrder()\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n        if amount < 0:\n            if assets[symbol]['amount'] < amount:\n                CancelOrder()\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n            if assets[symbol]['amount'] > amount:\n                CancelOrder()\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n\n\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n    sell_price = (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\n        CancelOrder()\n        Trade('BUY', _N(buy_price, tradeInfo[symbol]['priceSize']), _N(value / buy_price, tradeInfo[symbol]['amountSize']))\n        Trade('SELL', _N(sell_price, tradeInfo[symbol]['priceSize']), (_N(value / sell_price, tradeInfo[symbol]['amountSize'])))\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)\n    return initialAccount\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef initData():\n    global symbol\n    if _G('symbol') is None:\n        symbol = exchange.GetCurrency().replace('_','')\n        _G('symbol',symbol)\n        Log('初始化币种：',symbol)\n    else:\n        symbol = _G('symbol')\n        Log('交易币种：',symbol)\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(10)\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n\n        Sleep(1000 * Interval)",
        "strategy_description": "策略名称: 币安合约网格-002v\n\nInitPrice = 0\nupdateProfitTime = 0\nassets = {}\ntradeInfo = {}\naccountAssets = {}\nruntimeData = {}\nFunding = 0   #账户资金  为0的时候自动获取\nsymbol = ''\nVersion = '0.0.1'\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\n\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所！')\n    exit()\n\ndef init():\n    initData()\n    CancelOrder()\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()\n    for i in range(len(exchangeInfo['symbols'])):\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\n            assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\n\ndef CancelOrder():\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    for x in range(len(orders)):\n        if orders[x]['Info']['symbol'] == symbol :\n            exchange.CancelOrder(orders[x]['Id'])\n\ndef UpdateStatus():\n    global Funding,updateProfitTime\n    if Funding == 0 :\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\n\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\",  \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数][持仓模式]', '币种信息', '开仓方向','初始价格', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\n        'rows': []\n    }\n\n    profitColors = DangerColor\n    totalProfit = assets['USDT']['total_balance'] - Funding\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday\n    \n    #Log('dayProfit:',dayProfit,'Funding:',Funding)\n    dayRate = dayProfit / Funding * 100\n\n\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n\n    i = 1\n    for x in list(symbol.split(',')):\n        typestr = '多空持仓'\n        if type == 1:\n            typestr = '只持多仓'\n        if type == 2:\n            typestr = '只持空仓'\n        direction = '空仓'\n        margin = direction\n        if assets[x]['amount'] != 0:\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\n        unrealised_profit_color = '#000000'\n        if assets[symbol]['unrealised_profit'] > 0:\n            unrealised_profit_color = SuccessColor\n        if assets[symbol]['unrealised_profit'] < 0:\n            unrealised_profit_color = DangerColor\n\n        infoList = [\n        i,\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']'+'['+typestr+']',\n        x,\n        direction,\n        InitPrice,\n        assets[x]['amount'],\n        assets[x]['hold_price'],\n        assets[x]['price'],\n        assets[x]['liquidationPrice'],\n        float(assets[x]['amount']) * float(assets[x]['price']),\n        assets[x]['positionInitialMargin'],\n        assets[x]['unrealised_profit'],\n        ]\n        table['rows'].append(infoList)\n\n        retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n'\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = assets['USDT']['total_balance']\n        key = \"initialAccount_\" + exchange.GetLabel()\n        initialAccount = _G(key)\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\n        if Show:\n            balance = assets['USDT']['total_balance'] - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n        Profit = _N(balance,0)\n\n\ndef UpdateAccount():\n    # Log('UpdateAccount()')\n    global accountAssets\n    account = exchange.GetAccount()\n    position = exchange.GetPosition()\n    if account is None and position is None :\n        Log('更新账户超时！！！')\n        return\n    accountAssets = account['Info']['assets']\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\n    for  i in range(len(account['Info']['positions'])) :\n        if account['Info']['positions'][i]['symbol'] == symbol :\n            #计算持仓保证金                                           初始保证金                +            维持保证金\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\n            #未实现收益\n            assets[symbol]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\n            assets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\n\n    #计算持仓保证金总额\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\n\n    ps = json.loads(exchange.GetRawJSON())\n    if len(ps) > 0 :\n        for x in range(len(ps)):\n            if ps[x]['symbol'] == symbol:\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProfit'])\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\n                assets[symbol]['marginType'] = ps[x]['marginType']\n\ndef UpdateTick():\n    global InitPrice\n    res = _C(exchange.GetTicker)\n    if res is None:\n        Log(\"行情更新异常！！！\")\n\n    if target:\n        InitPrice = target_price\n        _G('InitPrice',InitPrice)\n    else:\n        if  _G('InitPrice') is None :\n            InitPrice = res.Last\n            _G('InitPrice',InitPrice)\n        else:\n            InitPrice = _G('InitPrice')\n\n    assets[symbol]['price'] = res.Last\n\ndef Trade(direction,price,amount):\n    if amount < 0:\n        amount = -amount\n    Log('amount:',amount,'minQty:',tradeInfo[symbol]['minQty'])\n    if amount < tradeInfo[symbol]['minQty']:\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n    else:\n        para = ''\n        url = '/fapi/v1/order'\n        para += 'symbol='+ symbol\n        para += '&side='+ direction\n        para += '&type=LIMIT&timeInForce=GTC'\n        para += '&quantity='+ str(amount)\n        para += '&price='+ str(price)\n        para += \"&timestamp=\"+str(time.time() * 1000);\n        go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n        ret = go.wait()\n        if ret  is not None:\n            logType = LOG_TYPE_SELL\n            if direction == 'BUY':\n                logType =LOG_TYPE_BUY\n            exchange.Log(logType,price,amount,symbol)\n\ndef batch(buy_price,sell_price):\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    if len(orders) < 2 :\n        return True\n    return False\n\ndef Process():\n    amount = (1 - float(assets[symbol]['price']) / float(InitPrice)) / float(pct) * float(value) / float(assets[symbol]['price'])\n    if abs(amount - assets[symbol]['amount']) > _N(value / float(assets[symbol]['price']), tradeInfo[symbol]['amountSize']):\n        if amount > 0:\n            if assets[symbol]['amount'] < amount:\n                CancelOrder()\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n            if assets[symbol]['amount'] > amount:\n                CancelOrder()\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n        if amount < 0:\n            if assets[symbol]['amount'] < amount:\n                CancelOrder()\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n            if assets[symbol]['amount'] > amount:\n                CancelOrder()\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\n\n\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n    sell_price = (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\n        CancelOrder()\n        Trade('BUY', _N(buy_price, tradeInfo[symbol]['priceSize']), _N(value / buy_price, tradeInfo[symbol]['amountSize']))\n        Trade('SELL', _N(sell_price, tradeInfo[symbol]['priceSize']), (_N(value / sell_price, tradeInfo[symbol]['amountSize'])))\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)\n    return initialAccount\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef initData():\n    global symbol\n    if _G('symbol') is None:\n        symbol = exchange.GetCurrency().replace('_','')\n        _G('symbol',symbol)\n        Log('初始化币种：',symbol)\n    else:\n        symbol = _G('symbol')\n        Log('交易币种：',symbol)\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(10)\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n\n        Sleep(1000 * Interval)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/322284\n\n> Last Modified\n\n2021-11-19 10:29:27"
    },
    {
        "strategy_id": "91_币安合约网格-基础版本-001",
        "strategy_code": "python\n# 刚开始学python，有不不合理的地方，见谅！！！\nimport time\nimport requests\nimport math\nimport pandas as pd\n\nInitPrice = 0\nupdateProfitTime = 0\nassets = {}\ntradeInfo = {}\naccountAssets = {}\nruntimeData = {}\nFunding = 0   #账户资金  为0的时候自动获取\nsymbol = ''\nVersion = '0.0.1'\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\n\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所！')\n    exit()\n\ndef init():\n    initData()\n    CancelOrder()\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()\n    for i in range(len(exchangeInfo['symbols'])):\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\n            assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\n\ndef CancelOrder():\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    for x in range(len(orders)):\n        if orders[x]['Info']['symbol'] == symbol :\n            exchange.CancelOrder(orders[x]['Id'])\n\ndef UpdateStatus():\n    global Funding,updateProfitTime\n    if Funding == 0 :\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\n\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\",  \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\n        'rows': []\n    }\n\n    profitColors = DangerColor\n    totalProfit = assets['USDT']['total_balance'] - Funding\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday\n    dayRate = dayProfit / Funding * 100\n\n\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n\n    i = 1\n    for x in list(symbol.split(',')):\n        \n        direction = '空仓'\n        margin = direction\n        if assets[x]['amount'] != 0:\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\n        unrealised_profit_color = '#000000'\n        if assets[symbol]['unrealised_profit'] > 0:\n            unrealised_profit_color = SuccessColor\n        if assets[symbol]['unrealised_profit'] < 0:\n            unrealised_profit_color = DangerColor\n\n        infoList = [\n        i,\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']',\n        x,\n        direction,\n        assets[x]['amount'],\n        assets[x]['hold_price'],\n        assets[x]['price'],\n        assets[x]['liquidationPrice'],\n        float(assets[x]['amount']) * float(assets[x]['price']),\n        assets[x]['positionInitialMargin'],\n        assets[x]['unrealised_profit'],\n        ]\n        table['rows'].append(infoList)\n\n        retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n'\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = assets['USDT']['total_balance']\n        key = \"initialAccount_\" + exchange.GetLabel()\n        initialAccount = _G(key)\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\n        if Show:\n            balance = assets['USDT']['total_balance'] - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n        Profit = _N(balance,0)\n\n\ndef UpdateAccount():\n    # Log('UpdateAccount()')\n    global accountAssets\n    account = exchange.GetAccount()\n    position = exchange.GetPosition()\n    if account is None and position is None :\n        Log('更新账户超时！！！')\n        return\n    accountAssets = account['Info']['assets']\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\n    for  i in range(len(account['Info']['positions'])) :\n        if account['Info']['positions'][i]['symbol'] == symbol :\n            #计算持仓保证金                                           初始保证金                +            维持保证金\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\n            #未实现收益\n            assets[symbol]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\n            assets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\n\n    #计算持仓保证金总额\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\n\n    ps = json.loads(exchange.GetRawJSON())\n    if len(ps) > 0 :\n        for x in range(len(ps)):\n            if ps[x]['symbol'] == symbol:\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProfit'])\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\n                assets[symbol]['marginType'] = ps[x]['marginType']\n\ndef UpdateTick():\n    global InitPrice\n    try:\n        res = requests.get(f'https://fapi.binance.com/fapi/v1/ticker/price?symbol={symbol}').json()\n    except:\n        Log('get ticker time out !')\n        return\n\n    if target:\n        InitPrice = target_price\n        _G('InitPrice',InitPrice)\n    else:\n        if  _G('InitPrice') is None :\n            InitPrice = res['price']\n            _G('InitPrice',InitPrice)\n        else:\n            InitPrice = _G('InitPrice')\n\n    assets[symbol]['price'] = res['price']\n\ndef Trade(direction,price,amount):\n    if amount < tradeInfo[symbol]['minQty']:\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n    else:\n        para = ''\n        url = '/fapi/v1/order'\n        para += 'symbol='+ symbol\n        para += '&side='+ direction\n        para += '&type=LIMIT&timeInForce=GTC'\n        para += '&quantity='+ str(amount)\n        para += '&price='+ str(price)\n        para += \"&timestamp=\"+str(time.time() * 1000);\n        go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n        ret = go.wait()\n        if ret  is not None:\n            logType = LOG_TYPE_SELL\n            if direction == 'BUY':\n                logType =LOG_TYPE_BUY\n            exchange.Log(logType,price,amount,symbol)\n\ndef batch(buy_price,sell_price):\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    if len(orders) < 2 :\n        return True\n    return False\n\ndef Process():\n\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n    sell_price = (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\n        CancelOrder()\n        Trade('BUY', _N(buy_price, 5), _N(value / buy_price, 0))\n        Trade('SELL', _N(sell_price, 5), _N(value / sell_price, 0))\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)\n    return initialAccount\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef initData():\n    global symbol\n    if _G('symbol') is None:\n        symbol = exchange.GetCurrency().replace('_','')\n        _G('symbol',symbol)\n        Log('初始化币种：',symbol)\n    else:\n        symbol = _G('symbol')\n        Log('交易币种：',symbol)\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(10)\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n\n        Sleep(1000 * Interval)",
        "strategy_description": "策略名称: 币安合约网格-基础版本-001\n\nimport time\nimport requests\nimport math\nimport pandas as pd\n\nInitPrice = 0\nupdateProfitTime = 0\nassets = {}\ntradeInfo = {}\naccountAssets = {}\nruntimeData = {}\nFunding = 0   #账户资金  为0的时候自动获取\nsymbol = ''\nVersion = '0.0.1'\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\n\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所！')\n    exit()\n\ndef init():\n    initData()\n    CancelOrder()\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()\n    for i in range(len(exchangeInfo['symbols'])):\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\n            assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\n\ndef CancelOrder():\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    for x in range(len(orders)):\n        if orders[x]['Info']['symbol'] == symbol :\n            exchange.CancelOrder(orders[x]['Id'])\n\ndef UpdateStatus():\n    global Funding,updateProfitTime\n    if Funding == 0 :\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\n\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\",  \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\n        'rows': []\n    }\n\n    profitColors = DangerColor\n    totalProfit = assets['USDT']['total_balance'] - Funding\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday\n    dayRate = dayProfit / Funding * 100\n\n\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n\n    i = 1\n    for x in list(symbol.split(',')):\n        \n        direction = '空仓'\n        margin = direction\n        if assets[x]['amount'] != 0:\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\n        unrealised_profit_color = '#000000'\n        if assets[symbol]['unrealised_profit'] > 0:\n            unrealised_profit_color = SuccessColor\n        if assets[symbol]['unrealised_profit'] < 0:\n            unrealised_profit_color = DangerColor\n\n        infoList = [\n        i,\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']',\n        x,\n        direction,\n        assets[x]['amount'],\n        assets[x]['hold_price'],\n        assets[x]['price'],\n        assets[x]['liquidationPrice'],\n        float(assets[x]['amount']) * float(assets[x]['price']),\n        assets[x]['positionInitialMargin'],\n        assets[x]['unrealised_profit'],\n        ]\n        table['rows'].append(infoList)\n\n        retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n'\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = assets['USDT']['total_balance']\n        key = \"initialAccount_\" + exchange.GetLabel()\n        initialAccount = _G(key)\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\n        if Show:\n            balance = assets['USDT']['total_balance'] - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n        Profit = _N(balance,0)\n\n\ndef UpdateAccount():\n    # Log('UpdateAccount()')\n    global accountAssets\n    account = exchange.GetAccount()\n    position = exchange.GetPosition()\n    if account is None and position is None :\n        Log('更新账户超时！！！')\n        return\n    accountAssets = account['Info']['assets']\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\n    for  i in range(len(account['Info']['positions'])) :\n        if account['Info']['positions'][i]['symbol'] == symbol :\n            #计算持仓保证金                                           初始保证金                +            维持保证金\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\n            #未实现收益\n            assets[symbol]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\n            assets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\n\n    #计算持仓保证金总额\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\n\n    ps = json.loads(exchange.GetRawJSON())\n    if len(ps) > 0 :\n        for x in range(len(ps)):\n            if ps[x]['symbol'] == symbol:\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProfit'])\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\n                assets[symbol]['marginType'] = ps[x]['marginType']\n\ndef UpdateTick():\n    global InitPrice\n    try:\n        res = requests.get(f'https://fapi.binance.com/fapi/v1/ticker/price?symbol={symbol}').json()\n    except:\n        Log('get ticker time out !')\n        return\n\n    if target:\n        InitPrice = target_price\n        _G('InitPrice',InitPrice)\n    else:\n        if  _G('InitPrice') is None :\n            InitPrice = res['price']\n            _G('InitPrice',InitPrice)\n        else:\n            InitPrice = _G('InitPrice')\n\n    assets[symbol]['price'] = res['price']\n\ndef Trade(direction,price,amount):\n    if amount < tradeInfo[symbol]['minQty']:\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n    else:\n        para = ''\n        url = '/fapi/v1/order'\n        para += 'symbol='+ symbol\n        para += '&side='+ direction\n        para += '&type=LIMIT&timeInForce=GTC'\n        para += '&quantity='+ str(amount)\n        para += '&price='+ str(price)\n        para += \"&timestamp=\"+str(time.time() * 1000);\n        go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n        ret = go.wait()\n        if ret  is not None:\n            logType = LOG_TYPE_SELL\n            if direction == 'BUY':\n                logType =LOG_TYPE_BUY\n            exchange.Log(logType,price,amount,symbol)\n\ndef batch(buy_price,sell_price):\n    exchange.SetContractType('swap')\n    #撤销所有未成交订单\n    orders = exchange.GetOrders()\n    if len(orders) < 2 :\n        return True\n    return False\n\ndef Process():\n\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n    sell_price = (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\n\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\n        CancelOrder()\n        Trade('BUY', _N(buy_price, 5), _N(value / buy_price, 0))\n        Trade('SELL', _N(sell_price, 5), _N(value / sell_price, 0))\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)\n    return initialAccount\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef initData():\n    global symbol\n    if _G('symbol') is None:\n        symbol = exchange.GetCurrency().replace('_','')\n        _G('symbol',symbol)\n        Log('初始化币种：',symbol)\n    else:\n        symbol = _G('symbol')\n        Log('交易币种：',symbol)\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(10)\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n\n        Sleep(1000 * Interval)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/322060\n\n> Last Modified\n\n2021-10-09 12:58:38"
    },
    {
        "strategy_id": "92_币安永续多币种对冲策略做多超跌做空超涨-张总python版",
        "strategy_code": "python\n#刚学python，希望指正！共同学习！\nimport time\nimport requests\nimport math\nAlpha = 0.001 #指数移动平均的Alpha参数，设置的越大，基准价格跟踪越敏感，最终持仓也会越低，降低了杠杆，但会降低收益，具体需要根据回测结果自己权衡\nUpdate_base_price_time_interval = 60 #多久更新一次基准价格, 单位秒，和Alpha参数相关,Alpha 设置的越小，这个间隔也可以设置的更小\n#Stop_loss设置为0.8表示当资金达到低于初始资金的80%时，止损，清空所有仓位，停止策略。\n#随着策略运行，Stop_loss可以设置大于1（重启生效），比如从1000赚到1500，Stop_loss设置为1.3，则回撤到1300元止损。不想止损可以把这个参数设置的很小。\n#风险是大家都用这种止损会形成踩踏，加大亏损。\n#初始资金在状态栏的init_balance字段，注意提现等操作会影响，别不小心止损了。\n#如果还是怕黑天鹅事件，比如某个币归0等，可以手动提现出来。\n\nStop_loss = 0.8\nMax_diff = 0.03 #当偏差diff大于0.4时，不继续加空仓, 自行设置\nMin_diff = -0.03 #当diff小于-0.3时，不继续加多仓, 自行设置\nVersion = '0.1.3'\nShow = false #默认为false累计收益显示是账户余额,改为true累计收益显示为收益,如果之前是显示的账户余额,你使用LogProfitReset()来清空图表\nFunding = 0 #账户初始金额,为0的时候,自动获取,非0为自定义\nsuccess = '#5cb85c' #成功颜色\ndanger = '#ff0000' #危险颜色\nwarning = '#f0ad4e' #警告颜色\nRunTime = {} #运行时间\nSelfFee = 0.04 #https:#www.binance.com/cn/fee/futureFee\nTotalLong = 0\nTotalShort = 0\nUpProfit = 0\naccountAssets = [] #保存资产\nWinRateData = {} #保存所有币种的胜率及开仓次数\n\nif IsVirtual():\n    Log('不能回测，回测参考 https://www.fmz.com/digest-topic/5294 ')\n    exit()\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所，和现货交易所不同，需要单独添加，名称为Futures_Binance')\n    exit()\ntrade_symbols = Trade_symbols.split(',')\nsymbols = trade_symbols + ['BTC']\nindex = 1 #指数\nupdate_profit_time = 0\nupdate_base_price_time = int(time.time()*1000)\nassets = {}\ninit_prices = {}\ntrade_info = {}\n\ndef init():\n    InitRateData()\n    exchange_info = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchange_info is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()    \n    for i in range(len(exchange_info['symbols'])):\n        if exchange_info['symbols'][i]['baseAsset'] in symbols:            \n            assets[exchange_info['symbols'][i]['baseAsset']] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'btc_price': 0, 'btc_change': 1,'btc_diff': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n            trade_info[exchange_info['symbols'][i]['baseAsset']] = {'minQty': float(exchange_info['symbols'][i]['filters'][1]['minQty']) , 'priceSize': int((math.log10(1.1/float(exchange_info['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchange_info['symbols'][i]['filters'][1]['stepSize']))))}\n\nassets['USDT'] = {\n    'unrealised_profit': 0,\n    'margin': 0,\n    'margin_balance': 0,\n    'total_balance': 0,\n    'leverage': 0,\n    'update_time': 0,\n    'margin_ratio': 0,\n    'init_balance': 0,\n    'stop_balance': 0,\n    'short_value': 0,\n    'long_value': 0,\n    'profit': 0\n}\n\ndef updateAccount() : #更新账户和持仓\n    global accountAssets\n    account = exchange.GetAccount()\n    pos = exchange.GetPosition()\n    if account is None or pos is None:\n        Log('update account time out')\n        return    \n    accountAssets = account['Info']['assets']\n    assets['USDT']['update_time'] = int(time.time()*1000)\n    for i in range(len(trade_symbols)):\n        assets[trade_symbols[i]]['margin'] = 0\n        assets[trade_symbols[i]]['unrealised_profit'] = 0\n        assets[trade_symbols[i]]['hold_price'] = 0\n        assets[trade_symbols[i]]['amount'] = 0\n    \n    for j in range(len(account['Info']['positions'])):        \n        if account['Info']['positions'][j]['positionSide'] == 'BOTH':\n            pair = account['Info']['positions'][j]['symbol']\n            coin = pair[0:len(pair)-4]\n            if coin not in trade_symbols:\n                continue\n            assets[coin]['margin'] = float(account['Info']['positions'][j]['initialMargin']) + float(account['Info']['positions'][j]['maintMargin'])\n            assets[coin]['unrealised_profit'] = float(account['Info']['positions'][j]['unrealizedProfit'])\n            assets[coin]['positionInitialMargin'] = float(account['Info']['positions'][j]['positionInitialMargin'])\n            assets[coin]['leverage'] = account['Info']['positions'][j]['leverage']\n\n    assets['USDT']['margin'] = _N(float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin']), 2)\n    assets['USDT']['margin_balance'] = _N(float(account['Info']['totalMarginBalance']), 2)\n    assets['USDT']['total_balance'] = _N(float(account['Info']['totalWalletBalance']), 2)\n    if assets['USDT']['init_balance'] == 0:\n        if _G('init_balance'):\n            assets['USDT']['init_balance'] = _N(_G('init_balance'), 2)\n        else:\n            assets['USDT']['init_balance'] = assets['USDT']['total_balance']\n            _G('init_balance', assets['USDT']['init_balance'])\n    assets['USDT']['profit'] = _N(assets['USDT']['margin_balance'] - assets['USDT']['init_balance'], 2)\n    assets['USDT']['stop_balance'] = _N(Stop_loss * assets['USDT']['init_balance'], 2)\n    assets['USDT']['total_balance'] = _N(float(account['Info']['totalWalletBalance']), 2)\n    assets['USDT']['unrealised_profit'] = _N(float(account['Info']['totalUnrealizedProfit']), 2)\n    assets['USDT']['leverage'] = _N(assets['USDT']['margin'] / assets['USDT']['total_balance'], 2)\n    assets['USDT']['margin_ratio'] = float(account['Info']['totalMaintMargin']) / float(account['Info']['totalMarginBalance']) * 100\n    pos = json.loads(exchange.GetRawJSON())\n    if len(pos) > 0:\n        for k in range(len(pos)):\n            pair = pos[k]['symbol']\n            coin = pair[0:len(pair)-4]\n            if coin not in trade_symbols:\n                continue            \n            if pos[k]['positionSide'] != 'BOTH':\n                continue       \n            assets[coin]['hold_price'] = float(pos[k]['entryPrice'])\n            assets[coin]['amount'] = float(pos[k]['positionAmt'])\n            assets[coin]['unrealised_profit'] = float(pos[k]['unRealizedProfit'])\n            assets[coin]['liquidationPrice'] = float(pos[k]['liquidationPrice'])\n            assets[coin]['marginType'] = pos[k]['marginType']\n\ndef updateIndex(): #更新指数\n    global update_base_price_time,index,init_prices,Reset\n    if _G('init_prices') is None or Reset:\n        Reset = False\n        for i in range(len(trade_symbols)):\n            init_prices[trade_symbols[i]] = (assets[trade_symbols[i]]['ask_price'] + assets[trade_symbols[i]]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n        Log('保存启动时的价格')\n        _G('init_prices', init_prices)\n        _G(\"StartTime\", None) #重置开始时间\n        _G(\"initialAccount_\" + exchange.GetLabel(), None) #重置开始资金\n        _G('tradeNumber', 0) #重置交易次数\n        _G('tradeVolume', 0) #重置交易量\n        _G('buyNumber', 0) #重置做多次数\n        _G('sellNumber', 0) #重置做空次数\n        _G('totalProfit', 0) #重置打印次数\n        _G('profitNumber', 0) #重置盈利次数\n    else:\n        init_prices = _G('init_prices')\n        if (int(time.time()*1000) - update_base_price_time > Update_base_price_time_interval * 1000):\n            update_base_price_time = int(time.time()*1000)\n            for i in range(len(trade_symbols)): #更新初始价格\n                init_prices[trade_symbols[i]] = init_prices[trade_symbols[i]] * (1 - Alpha) + Alpha * (assets[trade_symbols[i]]['ask_price'] + assets[trade_symbols[i]]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n            _G('init_prices', init_prices)\n        temp = 0\n        for i in range(len(trade_symbols)):\n            assets[trade_symbols[i]]['btc_price'] = (assets[trade_symbols[i]]['ask_price'] + assets[trade_symbols[i]]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n            if trade_symbols[i] not in init_prices:\n                Log('添加新的币种', trade_symbols[i])\n                init_prices[trade_symbols[i]] = assets[trade_symbols[i]]['btc_price']\n                _G('init_prices', init_prices)\n            assets[trade_symbols[i]]['btc_change'] = _N(assets[trade_symbols[i]]['btc_price'] / init_prices[trade_symbols[i]], 4)\n            temp += assets[trade_symbols[i]]['btc_change']        \n        index = _N(temp / len(trade_symbols), 4)\n\ndef updateTick() : #更新行情\n    try:\n        ticker = requests.get('https://fapi.binance.com/fapi/v1/ticker/bookTicker').json()\n    except Exception as e:\n        Log('get ticker time out:',e)\n        return\n    assets['USDT']['short_value'] = 0\n    assets['USDT']['long_value'] = 0\n    for i in range(len(ticker)):\n        pair = ticker[i]['symbol']\n        coin = pair[0:len(pair)-4]\n        if coin not in symbols:\n            continue\n        assets[coin]['ask_price'] = float(ticker[i]['askPrice'])\n        assets[coin]['bid_price'] = float(ticker[i]['bidPrice'])\n        assets[coin]['ask_value'] = _N(assets[coin]['amount'] * assets[coin]['ask_price'], 2)\n        assets[coin]['bid_value'] = _N(assets[coin]['amount'] * assets[coin]['bid_price'], 2)\n        if coin not in trade_symbols:\n            continue\n        if assets[coin]['amount'] < 0 :\n            assets['USDT']['short_value'] += abs((assets[coin]['ask_value'] + assets[coin]['bid_value']) / 2)\n        else:\n            assets['USDT']['long_value'] += abs((assets[coin]['ask_value'] + assets[coin]['bid_value']) / 2)        \n        assets['USDT']['short_value'] = _N(assets['USDT']['short_value'], 0)\n        assets['USDT']['long_value'] = _N(assets['USDT']['long_value'], 0)    \n    updateIndex()\n    for i in range(len(trade_symbols)):\n        assets[trade_symbols[i]]['btc_diff'] = _N(assets[trade_symbols[i]]['btc_change'] - index, 4)\n\ndef trade(symbol, dirction, value) : #交易\n    if (int(time.time()*1000) - assets['USDT']['update_time'] > 10 * 1000):\n        Log('更新账户延时，不交易')\n    else:\n        price = assets[symbol]['bid_price'] if dirction == 'sell' else assets[symbol]['ask_price']\n        amount = _N(min(value, Ice_value) / price, trade_info[symbol]['amountSize'])\n        if amount < trade_info[symbol]['minQty']:\n            Log(symbol, '合约价值偏离或冰山委托订单的大小设置过小，达不到最小成交, 至少需要: ', _N(trade_info[symbol]['minQty'] * price, 0) + 1)\n        else:\n            exchange.IO(\"currency\", symbol + '_' + 'USDT')\n            exchange.SetContractType('swap')\n            exchange.SetDirection(dirction)\n            #f = 'Buy' if dirction == 'buy' else 'Sell'\n            place_order = getattr(exchange,'Buy' if dirction == 'buy' else 'Sell')\n            id = place_order(price, amount, symbol)\n            if id:\n                exchange.CancelOrder(id) #订单会立即撤销\n            tradingCounter('tradeVolume', price * amount) #保存交易量\n            tradingCounter('tradeNumber', 1) #保存交易次数\n            WinRateData[symbol]['tradeNumber'] += 1\n            if dirction == 'buy':\n                tradingCounter('buyNumber', 1)\n                WinRateData[symbol].buyNumber += 1\n            else:\n                tradingCounter('sellNumber', 1)\n                WinRateData[symbol].sellNumber += 1            \n            _G(\"WinRateData\", WinRateData) #保存各币种的交易数据\n            return id\n\ndef InitRateData():\n    global WinRateData\n    if Reset :\n        _G(\"WinRateData\", None)    \n    if _G(\"WinRateData\"):\n        WinRateData = _G(\"WinRateData\")    \n    for i in range(len(symbols)):        \n        if symbols[i] not in WinRateData:\n            WinRateData[symbols[i]] = {'totalProfit': 0, 'profitNumber': 0,'tradeNumber': 0,'buyNumber': 0, 'sellNumber': 0}\n                                            #统计次数        #盈利次数          #交易次数       #做多次数        #做空次数\n    _G(\"WinRateData\", WinRateData)\n\ndef RunCommand():\n    str_cmd = GetCommand()\n    if str_cmd:\n        arrCmd = str_cmd.split(':')\n        symbol = arrCmd[1]\n        amount = float(arrCmd[2])\n        if amount == 0:\n            Log('亲,你还记得大明湖畔的乔碧萝吗?' + danger)\n        else:\n            #f = 'Buy' if amount < 0 else 'Sell'\n            dirction = 'buy' if amount < 0 else 'sell'\n            exchange.IO(\"currency\", symbol + '_' + 'USDT')\n            exchange.SetContractType('swap')\n            exchange.SetDirection(dirction)\n            place_order = getattr(exchange,'Buy' if dirction == 'buy' else 'Sell')\n            id = place_order(-1, abs(amount), symbol)\n            #exchange[f](-1, abs(amount), symbol)\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)    \n    return initialAccount\n\ndef StartTime():\n    StartTime = _G(\"StartTime\")\n    if StartTime is None:\n        StartTime = _D()\n        _G(\"StartTime\", StartTime)    \n    return StartTime\n\ndef RuningTime():\n    ret = {}    \n    dateBegin = StartTime()\n    dateEnd = _D()\n    dateDiff = (time.mktime(time.strptime(dateEnd, '%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(dateBegin, '%Y-%m-%d %H:%M:%S'))) * 1000\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    leave1 = dateDiff % (24 * 3600 * 1000)\n    hours = math.floor(leave1 / (3600 * 1000))\n    leave2 = leave1 % (3600 * 1000)\n    minutes = math.floor(leave2 / (60 * 1000))\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = \"运行时间: \" + str(dayDiff) + \" 天 \" + str(hours) + \" 小时 \" + str(minutes) + \" 分钟\"\n    return ret\n\ndef AppendedStatus():\n    global TotalLong , TotalShort,RunTime,Funding, accountAssets\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\", \"止损\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    feeTable = {\n        'type': 'table',\n        'title': '交易统计',\n        'cols': [\"策略指数\", '交易次数', '做多次数', '做空次数', '预估胜率', '预估成交额', '预估手续费', \"未实现盈利\", '持仓总值', '做多总值', '做空总值'],\n        'rows': []\n    }\n    runday = RunTime['dayDiff']\n    if runday == 0:\n        runday = 1\n    if Funding == 0:\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])\n    profitColors = danger\n    totalProfit = assets['USDT']['total_balance'] - Funding #总盈利\n    if totalProfit > 0:\n        profitColors = success\n    dayProfit = totalProfit / runday #天盈利\n    dayRate = dayProfit / Funding * 100\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(assets['USDT']['stop_balance'], 2)) + danger,\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n    vloume = _G('tradeVolume') if _G('tradeVolume') is not None else 0\n    feeTable['rows'].append([\n        index, #指数\n        _G('tradeNumber') if _G('tradeNumber') is not None else 0, #交易次数\n        _G('buyNumber') if _G('buyNumber') is not None else 0, #做多次数\n        _G('sellNumber') if _G('sellNumber') is not None else 0, #做空次数\n        str(_N(_G('profitNumber') / _G('totalProfit') * 100, 2) if _G('totalProfit') > 0 else 0) + '%', #胜率\n        '$' + str(_N(vloume, 2)) + ' ≈ ฿' + str(_N(vloume / ((assets['BTC']['bid_price'] + assets['BTC']['ask_price']) / 2), 6)), #成交金额\n        '$' + str(_N(vloume * (SelfFee / 100), 4)), #手续费\n        '$' + str(_N(assets['USDT']['unrealised_profit'], 2)) + (success if assets['USDT']['unrealised_profit'] >= 0 else danger),\n        '$' + str(_N(TotalLong + abs(TotalShort), 2)), #持仓总价值\n        '$' + str(_N(TotalLong, 2)) + success, #做多总值\n        '$' + str(_N(abs(TotalShort), 2)) + danger, #做空总值\n    ])\n    assetTable = {\n        'type': 'table',\n        'title': '账户资产信息',\n        'cols': ['编号', '资产名', '起始保证金', '维持保证金', '保证金余额', '最大可提款金额', '挂单起始保证金', '持仓起始保证金', '持仓未实现盈亏', '账户余额'],\n        'rows': []\n    }\n    for i in range(len(accountAssets)):\n        acc = accountAssets[i]\n        assetTable['rows'].append([\n            i + 1,\n            acc['asset'], acc['initialMargin'], acc['maintMargin'], acc['marginBalance'],\n            acc['maxWithdrawAmount'], acc['openOrderInitialMargin'], acc['positionInitialMargin'],\n            acc['unrealizedProfit'], acc['walletBalance']\n        ])\n    indexTable = {\n        'type': 'table',\n        'title': '币指数信息',\n        'cols': ['编号', '币种信息', '当前价格', 'BTC计价', 'BTC计价变化(%)', '偏离平均', '交易次数', '做空次数', '做多次数', '预估胜率'],\n        'rows': []\n    }\n    for i in range(len(symbols)) :\n        price = _N((assets[symbols[i]]['ask_price'] + assets[symbols[i]]['bid_price']) / 2, trade_info[symbols[i]]['priceSize'])\n        if symbols[i] not in symbols:\n            indexTable['rows'].append([i + 1, symbols[i], price, assets[symbols[i]]['btc_price'], _N((1 - assets[symbols[i]]['btc_change']) * 100), assets[symbols[i]]['btc_diff']], 0, 0, 0, '0%')\n        else:\n            rateData = _G(\"WinRateData\")\n            winRate = _N(rateData[symbols[i]]['profitNumber'] / rateData[symbols[i]]['totalProfit'] * 100, 2) if rateData[symbols[i]]['totalProfit'] > 0 else 0\n            indexTable['rows'].append([\n                (i + 1),\n                symbols[i] + warning,\n                price,\n                _N(assets[symbols[i]]['btc_price'], 6),\n                _N((1 - assets[symbols[i]]['btc_change']) * 100),\n                str(assets[symbols[i]]['btc_diff']) + (success if assets[symbols[i]]['btc_diff'] >= 0 else danger),\n                rateData[symbols[i]]['tradeNumber'],\n                rateData[symbols[i]]['sellNumber'],\n                rateData[symbols[i]]['buyNumber'],\n                (str(winRate) if rateData[symbols[i]]['profitNumber'] > 0 and rateData[symbols[i]]['totalProfit'] > 0 else '0') + '%' + (success if winRate >= 50 else danger), #胜率\n            ])    \n    retData = {}\n    retData['upTable'] = RunTime['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version + '\\n' + '`' + json.dumps([accountTable, assetTable]) + '`\\n' + '`' + json.dumps(feeTable) + '`\\n'\n    retData['indexTable'] = indexTable\n    return retData\n\n\ndef WinRate():\n    global WinRateData\n    for i in range(len(symbols)) :\n        unrealised = assets[symbols[i]]['unrealised_profit']\n        WinRateData[symbols[i]]['totalProfit'] += 1\n        if unrealised != 0:\n            if unrealised > 0:\n                WinRateData[symbols[i]]['profitNumber'] += 1    \n    _G(\"WinRateData\", WinRateData)\n\ndef tradingCounter(key, newValue):\n    value = _G(key)\n    if value is None:\n        _G(key, newValue)\n    else:\n        _G(key, value + newValue)\n\ndef updateStatus() : #状态栏信息\n    global TotalLong , TotalShort,Funding,update_profit_time,UpProfit\n    TotalLong = 0\n    TotalShort = 0\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '强平差价', '持仓价值', '保证金', '未实现盈亏', '投降'],\n        'rows': []\n    }\n    \n    for i in range(len(symbols)):        \n        direction = '空仓'\n        margin = direction\n        if assets[symbols[i]]['amount'] != 0:\n            direction = '做多' + success if assets[symbols[i]]['amount'] > 0 else '做空' + danger\n            margin = '全仓' if assets[symbols[i]]['marginType'] == 'cross' else '逐仓'\n        price = _N((assets[symbols[i]]['ask_price'] + assets[symbols[i]]['bid_price']) / 2, trade_info[symbols[i]]['priceSize'])\n        value = _N((assets[symbols[i]]['ask_value'] + assets[symbols[i]]['bid_value']) / 2, 2)\n        if value != 0:\n            if value > 0:\n                TotalLong += value\n            else:\n                TotalShort += value\n        # rateData = _G(\"WinRateData\")\n        infoList = [\n            i + 1,\n            \"[\" + margin + \"] [\" + str(assets[symbols[i]]['leverage']) + 'x] ',\n            symbols[i],\n            direction,\n            abs(assets[symbols[i]]['amount']),\n            assets[symbols[i]]['hold_price'],\n            price,\n            assets[symbols[i]]['liquidationPrice'], #强平价格\n            '0' if assets[symbols[i]]['liquidationPrice'] == 0 else '$' + str(_N(assets[symbols[i]]['liquidationPrice'] - price, 5)) + ' ≈ ' + str(_N(assets[symbols[i]]['liquidationPrice'] / price * 100, 2)) + '%' + warning, #强平价格\n            abs(value),\n            _N(assets[symbols[i]]['positionInitialMargin'], 2),\n            # assets[symbols[i]]['btc_diff'],\n            str(_N(assets[symbols[i]]['unrealised_profit'], 3)) + (success if assets[symbols[i]]['unrealised_profit'] >= 0 else danger),\n            # (rateData[symbols[i]]['profit']Number > 0 and rateData[symbols[i]].totalProfit > 0 ? _N(rateData[symbols[i]]['profit']Number / rateData[symbols[i]].totalProfit * 100, 2) : '0') + '%', #胜率\n            {\n                'type': 'button',\n                'cmd': '说好的没有撤退可言呢？？?:' + symbols[i] + ':' + str(assets[symbols[i]]['amount']) + ':',\n                'name': symbols[i] + ' 投降'\n            }\n        ]\n        table['rows'].append(infoList)\n    #del assets['USDT']['update_time'] #时间戳没什么用,不要了\n    logString = json.dumps(assets['USDT']) + '\\n'\n    StatusData = AppendedStatus()\n    LogStatus(StatusData['upTable'] + '`' + json.dumps([table, StatusData['indexTable']]) + '`\\n' + logString)\n\n    if int(time.time()*1000) - update_profit_time > Log_profit_interval * 1000:\n        balance = assets['USDT']['margin_balance']\n        if Show:\n            balance = assets['USDT']['margin_balance'] - Funding\n        LogProfit(_N(balance, 3), '&')\n        update_profit_time = int(time.time()*1000)\n        if UpProfit != 0 and (_N(balance, 0) != UpProfit): #第一次不计算,并且小数点面的不进行胜率计算\n            tradingCounter(\"totalProfit\", 1) #统计打印次数, 胜率=盈利次数/打印次数*100\n            if _N(balance, 0) > UpProfit:\n                tradingCounter('profitNumber', 1) #盈利次数\n            WinRate()\n        UpProfit = _N(balance, 0)\n\ndef stopLoss() : #止损函数\n    while True:\n        if assets['USDT']['margin_balance'] < Stop_loss * assets['USDT']['init_balance'] and assets['USDT']['init_balance'] > 0:\n            Log('触发止损，当前资金：', assets['USDT']['margin_balance'], '初始资金：', assets['USDT']['init_balance'])\n            Ice_value = 200 #止损的快一些，可修改\n            updateAccount()\n            updateTick()\n            trading = False #是否正在交易\n            for i in range(len(trade_symbols)):\n                symbol = trade_symbols[i]\n                if assets[symbol]['ask_price'] == 0:\n                    continue                \n                if assets[symbol]['bid_value'] >= trade_info[symbol]['minQty'] * assets[symbol]['bid_price']:\n                    trade(symbol, 'sell', assets[symbol]['bid_value'])\n                    trading = True\n                if assets[symbol]['ask_value'] <= -trade_info[symbol]['minQty'] * assets[symbol]['ask_price']:\n                    trade(symbol, 'buy', -assets[symbol]['ask_value'])\n                    trading = True\n            Sleep(1000)\n            if not trading :\n                Log('止损结束,如果需要重新运行策略，需要调低止损') \n                exit()\n        else : #不用止损\n            return None\n\ndef onTick() : #策略逻辑部分\n    for i in range(len(trade_symbols)) :\n        symbol = trade_symbols[i]\n        if assets[symbol]['ask_price'] == 0:\n            continue        \n        aim_value = -Trade_value * _N(assets[symbol]['btc_diff'] / 0.01, 3)        \n        if aim_value - assets[symbol]['ask_value'] >= Adjust_value and assets[symbol]['btc_diff'] > Min_diff and assets['USDT']['long_value'] - assets['USDT']['short_value'] <= 1.1 * Trade_value:\n            Log('做多',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \n            trade(symbol, 'buy', aim_value - assets[symbol]['ask_value'])\n        if aim_value - assets[symbol]['bid_value'] <= -Adjust_value and assets[symbol]['btc_diff'] < Max_diff and assets['USDT']['short_value'] - assets['USDT']['long_value'] <= 1.1 * Trade_value:\n            Log('做空',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \n            trade(symbol, 'sell', -(aim_value - assets[symbol]['bid_value']))\n\ndef main():\n    global RunTime\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    while True:\n        RunTime = RuningTime()\n        RunCommand() #捕获交互命令\n        updateAccount() #更新账户和持仓\n        updateTick() #行情\n        stopLoss() #止损\n        onTick() #策略逻辑部分\n        updateStatus() #输出状态栏信息\n        Sleep(Interval * 1000)",
        "strategy_description": "策略名称: 币安永续多币种对冲策略做多超跌做空超涨-张总python版\n\ninfoList = [\n            i + 1,\n            \"[\" + margin + \"] [\" + str(assets[symbols[i]]['leverage']) + 'x] ',\n            symbols[i],\n            direction,\n            abs(assets[symbols[i]]['amount']),\n            assets[symbols[i]]['hold_price'],\n            price,\n            assets[symbols[i]]['liquidationPrice'], #强平价格\n            '0' if assets[symbols[i]]['liquidationPrice'] == 0 else '$' + str(_N(assets[symbols[i]]['liquidationPrice'] - price, 5)) + ' ≈ ' + str(_N(assets[symbols[i]]['liquidationPrice'] / price * 100, 2)) + '%' + warning, #强平价格\n            abs(value),\n            _N(assets[symbols[i]]['positionInitialMargin'], 2),\n            # assets[symbols[i]]['btc_diff'],\n            str(_N(assets[symbols[i]]['unrealised_profit'], 3)) + (success if assets[symbols[i]]['unrealised_profit'] >= 0 else danger),\n            # (rateData[symbols[i]]['profit']Number > 0 and rateData[symbols[i]].totalProfit > 0 ? _N(rateData[symbols[i]]['profit']Number / rateData[symbols[i]].totalProfit * 100, 2) : '0') + '%', #胜率\n            {\n                'type': 'button',\n                'cmd': '说好的没有撤退可言呢？？?:' + symbols[i] + ':' + str(assets[symbols[i]]['amount']) + ':',\n                'name': symbols[i] + ' 投降'\n            }\n        ]\n        table['rows'].append(infoList)\n    #del assets['USDT']['update_time'] #时间戳没什么用,不要了\n    logString = json.dumps(assets['USDT']) + '\\n'\n    StatusData = AppendedStatus()\n    LogStatus(StatusData['upTable'] + '`' + json.dumps([table, StatusData['indexTable']]) + '`\\n' + logString)\n\n    if int(time.time()*1000) - update_profit_time > Log_profit_interval * 1000:\n        balance = assets['USDT']['margin_balance']\n        if Show:\n            balance = assets['USDT']['margin_balance'] - Funding\n        LogProfit(_N(balance, 3), '&')\n        update_profit_time = int(time.time()*1000)\n        if UpProfit != 0 and (_N(balance, 0) != UpProfit): #第一次不计算,并且小数点面的不进行胜率计算\n            tradingCounter(\"totalProfit\", 1) #统计打印次数, 胜率=盈利次数/打印次数*100\n            if _N(balance, 0) > UpProfit:\n                tradingCounter('profitNumber', 1) #盈利次数\n            WinRate()\n        UpProfit = _N(balance, 0)\n\ndef stopLoss() : #止损函数\n    while True:\n        if assets['USDT']['margin_balance'] < Stop_loss * assets['USDT']['init_balance'] and assets['USDT']['init_balance'] > 0:\n            Log('触发止损，当前资金：', assets['USDT']['margin_balance'], '初始资金：', assets['USDT']['init_balance'])\n            Ice_value = 200 #止损的快一些，可修改\n            updateAccount()\n            updateTick()\n            trading = False #是否正在交易\n            for i in range(len(trade_symbols)):\n                symbol = trade_symbols[i]\n                if assets[symbol]['ask_price'] == 0:\n                    continue                \n                if assets[symbol]['bid_value'] >= trade_info[symbol]['minQty'] * assets[symbol]['bid_price']:\n                    trade(symbol, 'sell', assets[symbol]['bid_value'])\n                    trading = True\n                if assets[symbol]['ask_value'] <= -trade_info[symbol]['minQty'] * assets[symbol]['ask_price']:\n                    trade(symbol, 'buy', -assets[symbol]['ask_value'])\n                    trading = True\n            Sleep(1000)\n            if not trading :\n                Log('止损结束,如果需要重新运行策略，需要调低止损') \n                exit()\n        else : #不用止损\n            return None\n\ndef onTick() : #策略逻辑部分\n    for i in range(len(trade_symbols)) :\n        symbol = trade_symbols[i]\n        if assets[symbol]['ask_price'] == 0:\n            continue        \n        aim_value = -Trade_value * _N(assets[symbol]['btc_diff'] / 0.01, 3)        \n        if aim_value - assets[symbol]['ask_value'] >= Adjust_value and assets[symbol]['btc_diff'] > Min_diff and assets['USDT']['long_value'] - assets['USDT']['short_value'] <= 1.1 * Trade_value:\n            Log('做多',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \n            trade(symbol, 'buy', aim_value - assets[symbol]['ask_value'])\n        if aim_value - assets[symbol]['bid_value'] <= -Adjust_value and assets[symbol]['btc_diff'] < Max_diff and assets['USDT']['short_value'] - assets['USDT']['long_value'] <= 1.1 * Trade_value:\n            Log('做空',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \n            trade(symbol, 'sell', -(aim_value - assets[symbol]['bid_value']))\n\ndef main():\n    global RunTime\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    while True:\n        RunTime = RuningTime()\n        RunCommand() #捕获交互命令\n        updateAccount() #更新账户和持仓\n        updateTick() #行情\n        stopLoss() #止损\n        onTick() #策略逻辑部分\n        updateStatus() #输出状态栏信息\n        Sleep(Interval * 1000)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/201963\n\n> Last Modified\n\n2020-05-02 23:34:14"
    },
    {
        "strategy_id": "93_布林均线突破_vnpy_botvs实现版",
        "strategy_code": "python\n'''\n策略名称: BollingBreaker趋势策略\n策略作者: ipqhjjybj\n策略描述:  \n           这是将 botvs的接口用 Vnpy 的写法 方式简单封装掉，便于后期的调用！\n           这本来是期货的 策略， 直接改参数套在 比特币上。\n           期货上要切换到分钟级别， 比特币期货则用小时级别的\n           实盘时需要调整参数。\n           如有策略改进，请多多与本人交流   250657661\n\n           bar.minute.hour  代表是小时级别 \n           bar.minute.minute  代表是分钟级别\n\n           \n------------------------------------------------------------------\n\n          当前只支持 比特币OKCOIN 期货， 如果要弄到 CTP期货，需要微调\n\n趋势跟踪策略\n'''\nimport time\nfrom datetime import datetime\nimport numpy as np\nimport talib\n\nEMPTY_STRING = \"\"\nEMPTY_INT = 0\nEMPTY_FLOAT = 0.0\nEMPTY_UNICODE = u''\n\nDIRECTION_LONG = u'long'\nDIRECTION_SHORT = u'short'\n\nOFFSET_OPEN = u'kaicang'\nOFFSET_CLOSE = u'pingcang'\n\n# CTA引擎中涉及到的交易方向类型\nCTAORDER_BUY = \"buy\"\nCTAORDER_SELL = \"closebuy\"\nCTAORDER_SHORT = \"sell\"\nCTAORDER_COVER = \"closesell\"\n\n\n# 本地停止单状态\nSTOPORDER_WAITING = u'waiting'\nSTOPORDER_CANCELLED = u'canceled'\nSTOPORDER_TRIGGERED = u'touched'\n\n# 本地停止单前缀\nSTOPORDERPREFIX = 'CtaStopOrder'\n\n\n\n########################################################################\nclass VtBarData:\n    \"\"\"K线数据\"\"\"\n\n    #----------------------------------------------------------------------\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        \n        self.vtSymbol = EMPTY_STRING        # vt系统代码\n        self.symbol = EMPTY_STRING          # 代码\n        self.exchange = EMPTY_STRING        # 交易所\n    \n        self.open = EMPTY_FLOAT             # OHLC\n        self.high = EMPTY_FLOAT\n        self.low = EMPTY_FLOAT\n        self.close = EMPTY_FLOAT\n        \n        self.date = EMPTY_STRING            # bar开始的时间，日期\n        self.time = EMPTY_STRING            # 时间\n        self.datetime = None                # python的datetime时间对象\n        \n        self.volume = EMPTY_INT             # 成交量\n        self.openInterest = EMPTY_INT       # 持仓量    \n\n########################################################################\nclass VtTickData:\n    \"\"\"Tick行情数据类\"\"\"\n\n    #----------------------------------------------------------------------\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        \n        # 代码相关\n        self.exchange = EMPTY_STRING            # 交易所代码\n        self.vtSymbol = EMPTY_STRING            # 合约在vt系统中的唯一代码，通常是 合约代码.交易所代码\n        \n        # 成交数据\n        self.lastPrice = EMPTY_FLOAT            # 最新成交价\n        self.lastVolume = EMPTY_INT             # 最新成交量\n        self.volume = EMPTY_INT                 # 今天总成交量\n        self.openInterest = EMPTY_INT           # 持仓量\n        self.time = EMPTY_STRING                # 时间 11:20:56.5\n        self.date = EMPTY_STRING                # 日期 20151009\n        self.datetime = None                    # python的datetime时间对象\n        \n        # 常规行情\n        self.openPrice = EMPTY_FLOAT            # 今日开盘价\n        self.highPrice = EMPTY_FLOAT            # 今日最高价\n        self.lowPrice = EMPTY_FLOAT             # 今日最低价\n        self.preClosePrice = EMPTY_FLOAT\n        \n        self.upperLimit = EMPTY_FLOAT           # 涨停价\n        self.lowerLimit = EMPTY_FLOAT           # 跌停价\n        \n        # 五档行情\n        self.bidPrice1 = EMPTY_FLOAT\n        self.bidPrice2 = EMPTY_FLOAT\n        self.bidPrice3 = EMPTY_FLOAT\n        self.bidPrice4 = EMPTY_FLOAT\n        self.bidPrice5 = EMPTY_FLOAT\n        \n        self.askPrice1 = EMPTY_FLOAT\n        self.askPrice2 = EMPTY_FLOAT\n        self.askPrice3 = EMPTY_FLOAT\n        self.askPrice4 = EMPTY_FLOAT\n        self.askPrice5 = EMPTY_FLOAT        \n        \n        self.bidVolume1 = EMPTY_INT\n        self.bidVolume2 = EMPTY_INT\n        self.bidVolume3 = EMPTY_INT\n        self.bidVolume4 = EMPTY_INT\n        self.bidVolume5 = EMPTY_INT\n        \n        self.askVolume1 = EMPTY_INT\n        self.askVolume2 = EMPTY_INT\n        self.askVolume3 = EMPTY_INT\n        self.askVolume4 = EMPTY_INT\n        self.askVolume5 = EMPTY_INT         \n\n\n########################################################################\nclass StopOrder(object):\n    \"\"\"本地停止单\"\"\"\n\n    #----------------------------------------------------------------------\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        self.vtSymbol = EMPTY_STRING\n        self.orderType = EMPTY_UNICODE\n        self.direction = EMPTY_UNICODE\n        self.offset = EMPTY_UNICODE\n        self.price = EMPTY_FLOAT\n        self.volume = EMPTY_INT\n        \n        self.strategy = None             # 下停止单的策略对象\n        self.stopOrderID = EMPTY_STRING  # 停止单的本地编号 \n        self.status = EMPTY_STRING       # 停止单状态\n\n\nclass BollingerBreakerStrategy:\n    #品种属性\n    vtSymbol = EMPTY_STRING # 是什么品种\n\n    # 策略参数\n    minute_use = 6              # 多少分钟级别的K线\n\n    bar = None                  # 1分钟K线对象\n    fiveBar = None              # 1分钟K线对象\n\n    # 策略参数\n    bollLength = 20         # 通道窗口数\n    topDev = 1.3            # 开仓偏差\n    trailingPrcnt = 2       # 移动止损百分比\n    use_range = 10          # use_range天内有突破最高价\n    N = 10                  # 多少天突破\n\n    bufferSize = 40                     # 需要缓存的数据的大小\n    bufferCount = 0                     # 目前已经缓存了的数据的计数\n\n\n    realBuyCond = 0                     # 买卖的状态\n    realSellCond = 0                    # 买卖的状态\n    \n    bollMid = 0                         # 布林带中轨\n    bollStd = 0                         # 布林带宽度\n    entryUp = 0                         # 开仓上轨\n\n    barMinute = EMPTY_STRING            # K线当前的分钟\n\n    fixedSize = 1\n\n    stopOrderCount = 0                  # 记录停止单的数量\n\n    pos = 0                             # 仓位\n\n    LastBarTime = None                  # python 上一根Tick\n\n    currency = EMPTY_STRING\n\n    def __init__(self, _exchange , setting ):\n        self.exchange = _exchange\n        for key in setting.keys():\n            if key == \"vtSymbol\":\n                self.vtSymbol = setting[key]\n            if key == \"currency\":\n                self.currency = setting[key]\n            if key == 'minute_use':\n                self.minute_use = setting[key]\n            if key == \"bollLength\":\n                self.bollLength = setting[key]\n            if key == \"topDev\":\n                self.topDev = setting[key]\n            if key == \"trailingPrcnt\":\n                self.trailingPrcnt = setting[key]\n            if key == \"use_range\":\n                self.use_range = setting[key]\n            if key == \"N\":\n                self.N = setting[key]\n        Log(setting)\n\n        self.pos = 0\n        self.order_PreUse = {}            # vtPreID , pushDealAmount  已经推送过的成交数据\n        self.workingStopOrderDict = {}\n        self.stopOrderDict = {}\n        self.orderList = []               # 保存委托代码的列表\n        self.fixedSize = 1\n        ##################\n        self.bufferSize = 40\n        #################\n        self.highArray = np.zeros(self.bufferSize) \n        self.lowArray = np.zeros(self.bufferSize)\n        self.closeArray = np.zeros(self.bufferSize)\n        \n        self.buyValue = np.zeros(self.bufferSize)\n\n\n    def onCall(self):\n        try:\n            #self.exchange.IO(\"currency\" , self.currency)\n            need_remove = []\n            for orderId in self.orderList:\n                # 订单状态, 参考常量里的订单状态，以下是此键值的常量。\n                # ORDER_STATE_PENDING  :未完成\n                # ORDER_STATE_CLOSED   :已关闭   已完成\n                # ORDER_STATE_CANCELED :已取消\n                # STOPORDERPREFIX 是否是 系统内部的 停止单\n                if orderId != None and type(orderId) != type(1) and STOPORDERPREFIX in orderId:\n                    continue\n                botvsOrder = self.exchange.GetOrder(orderId)\n                preAmount = 0.0\n                if botvsOrder != None:\n                    if botvsOrder[\"Status\"] in [ORDER_STATE_CLOSED,ORDER_STATE_CANCELED]:\n                        try:\n                            preAmount = self.order_PreUse[orderId]\n                        except Exception,ex:\n                            Log(\"Error in preAmount\",ex)\n                            preAmount = 0.0\n                        Log(\"preAmount:\" , preAmount)\n                        incAmount = botvsOrder[\"DealAmount\"] - preAmount\n                        if incAmount > 0:\n                            self.order_PreUse[orderId] = botvsOrder[\"DealAmount\"]\n                            botvsOrder[\"preAmount\"] = preAmount\n                            botvsOrder[\"incAmount\"] = incAmount\n                            self.onTrade( botvsOrder )\n\n\n                    if botvsOrder[\"Status\"] == ORDER_STATE_CLOSED:\n                        need_remove.append(orderId)\n                else:\n                    Log(\"None order!\")\n\n            for orderId in need_remove:\n                Log(\"remove order:\" , orderId)\n                self.orderList.remove(orderId)\n\n            \n            # Log(\"currency\",self.currency)\n            botvsTick = self.exchange.GetTicker()\n\n\n            if self.LastBarTime != botvsTick[\"Time\"]:\n                newTick = VtTickData()\n                newTick.datetime = datetime.fromtimestamp(botvsTick[\"Time\"] / 1000.0)\n                newTick.vtSymbol = self.vtSymbol\n                newTick.lastPrice = float(botvsTick[\"Last\"])\n                newTick.lastVolume = float(botvsTick[\"Volume\"])\n                newTick.volume = float(botvsTick[\"Volume\"])\n                newTick.highPrice = float(botvsTick[\"High\"])\n                newTick.lowPrice = float(botvsTick[\"Low\"])\n\n                newTick.upperLimit = newTick.highPrice * 1.03\n                newTick.lowerLimit = newTick.lowPrice * 0.97\n\n                newTick.exchange = self.exchange.GetName()\n\n                newTick.date = newTick.datetime.strftime(\"%Y%m%d\")\n                newTick.time = newTick.datetime.strftime(\"%Y:%m:%d\")\n\n                self.onTick(newTick)\n\n                self.processStopOrder(newTick)\n        except Exception,ex:\n            Log(ex , \"error in onCall , maybe getTicker wrong!\")\n\n    #----------------------------------------------------------------------\n    def onTrade(self, trade):\n        # 发出状态更新事件\n        #'Type': 0           # 订单类型, 参考常量里的订单类型，以下是此键值的常量。\n                             # ORDER_TYPE_BUY   :买单\n                             # ORDER_TYPE_SELL  :卖单\n        try:\n            Log(\"trade:\",trade)\n            newPos = 0.0\n            if trade[\"Type\"] == ORDER_TYPE_BUY:\n                newPos += trade[\"incAmount\"]\n            elif trade[\"Type\"] == ORDER_TYPE_SELL:\n                newPos -= trade[\"incAmount\"]\n            else:\n                Log(\"What ? trade Type error!\")\n            self.pos += newPos\n        except Exception,ex:\n            print ex\n    #----------------------------------------------------------------------\n    def processStopOrder(self, tick):\n        \"\"\"收到行情后处理本地停止单（检查是否要立即发出）\"\"\"\n        vtSymbol = tick.vtSymbol\n        \n        # 遍历等待中的停止单，检查是否会被触发\n        for so in self.workingStopOrderDict.values():\n            if so.vtSymbol == vtSymbol:\n                longTriggered = so.direction==DIRECTION_LONG and tick.lastPrice>=so.price        # 多头停止单被触发\n                shortTriggered = so.direction==DIRECTION_SHORT and tick.lastPrice<=so.price     # 空头停止单被触发\n                \n                if longTriggered or shortTriggered:\n                    # 买入和卖出分别以涨停跌停价发单（模拟市价单）\n                    if so.direction==DIRECTION_LONG:\n                        price = tick.upperLimit\n                    else:\n                        price = tick.lowerLimit\n                    \n                    so.status = STOPORDER_TRIGGERED\n                    orderIDList = self.sendOrder(so.vtSymbol, so.orderType, price, so.volume, False ,so.strategy)\n                    for orderID in orderIDList:\n                        self.orderList.append(orderID)\n                    del self.workingStopOrderDict[so.stopOrderID]\n                    so.strategy.onStopOrder(so)\n\n    def onStopOrder(self, vtStopOrder):\n        Log(\"stopOrder Deal ID:\", vtStopOrder.stopOrderID , vtStopOrder.status )\n\n    def sendStopOrder(self, vtSymbol, orderType, price, volume, strategy ):\n        \"\"\"发停止单（本地实现）\"\"\"\n        self.stopOrderCount += 1\n        stopOrderID = STOPORDERPREFIX + str(self.vtSymbol) + str(self.stopOrderCount)\n\n        so = StopOrder()\n        so.vtSymbol = vtSymbol\n        so.orderType = orderType\n        so.price = price\n        so.volume = volume\n        so.strategy = strategy\n        so.stopOrderID = stopOrderID\n        so.status = STOPORDER_WAITING\n\n        if orderType == CTAORDER_BUY:\n            so.direction = DIRECTION_LONG\n            so.offset = OFFSET_OPEN\n        elif orderType == CTAORDER_SELL:\n            so.direction = DIRECTION_SHORT\n            so.offset = OFFSET_CLOSE\n        elif orderType == CTAORDER_SHORT:\n            so.direction = DIRECTION_SHORT\n            so.offset = OFFSET_OPEN\n        elif orderType == CTAORDER_COVER:\n            so.direction = DIRECTION_LONG\n            so.offset = OFFSET_CLOSE      \n\n        # 保存stopOrder对象到字典中\n        self.stopOrderDict[stopOrderID] = so\n        self.workingStopOrderDict[stopOrderID] = so\n        \n        # 推送停止单状态\n        strategy.onStopOrder(so)\n        return stopOrderID\n\n    def sendOrder(self , vtSymbol , orderType , price, volume , stop , strategy ):\n        #   id1 = exchange.Buy(4300,1)     # 日期                  平台    类型  价格     数量   信息\n        #                                  # 2016-10-21 00:00:00  OKCoin  买入  4300     1\n        #   id2 = exchange.Buy(-1, 8000)   # 市价单 的第二个参数的意义是  购买8000金额的 币数。\n        #   id1 = exchange.Sell(4300,1)    #     日期                     平台        类型      价格      数量     信息\n        #                                  #     2016-10-21 00:00:00     OKCoin      卖出      市价单     1    \n        # id2 = exchange.Sell(-1, 1)       #     日期                     平台        类型      价格      数量     信息\n                                           #     2016-10-21 00:00:00     OKCoin      卖出      4300      1\n                                           # 一般错误提示： 小于允许的最小交易单位，大部分是这个原因（参数1是1块钱而不是1个币）。\n        if stop == True:\n            vtOrderID = self.sendStopOrder(self.vtSymbol, orderType, price, volume, self)\n            return vtOrderID\n        else:\n            ret_order_list = []\n            self.exchange.SetDirection( orderType )\n            if orderType in [ CTAORDER_BUY , CTAORDER_COVER]:\n                ret_order_list.append( self.exchange.Buy( price , volume ))\n            elif orderType in [CTAORDER_SELL , CTAORDER_SHORT]:\n                ret_order_list.append( self.exchange.Sell( price , volume ))\n            return ret_order_list\n\n    def buy(self , price , volume , stop = False):\n        Log(CTAORDER_BUY,price,volume)\n        return self.sendOrder( self.vtSymbol , CTAORDER_BUY , price , volume , stop , self)\n    def sell(self , price , volume , stop = False):\n        Log(CTAORDER_SELL,price,volume)\n        return self.sendOrder( self.vtSymbol , CTAORDER_SELL , price , volume , stop , self)\n    def short(self , price , volume , stop = False):\n        Log(CTAORDER_SELL,price,volume)\n        return self.sendOrder( self.vtSymbol , CTAORDER_SHORT , price , volume , stop , self)\n    def cover(self , price , volume , stop = False):\n        Log(\"cover\",price,volume)\n        return self.sendOrder( self.vtSymbol , CTAORDER_COVER , price , volume , stop , self)\n\n    #----------------------------------------------------------------------\n    def cancelStopOrder(self, stopOrderID):\n        \"\"\"撤销停止单\"\"\"\n        # 检查停止单是否存在\n        if stopOrderID in self.workingStopOrderDict:\n            so = self.workingStopOrderDict[stopOrderID]\n            so.status = STOPORDER_CANCELLED\n            del self.workingStopOrderDict[stopOrderID]\n            so.strategy.onStopOrder(so)\n\n        if stopOrderID in self.orderList:\n            self.orderList.remove(stopOrderID)\n\n    def cancelOrder(self , vtOrderId):\n        Log(\"cancelOrder:\",vtOrderId)\n        if STOPORDERPREFIX in vtOrderId:\n            self.cancelStopOrder(vtOrderId)\n        else:\n            self.exchange.CancelOrder(vtOrderId)\n\n    def onTick(self, tick):\n\n        # self.orderList = []\n        # orderIDList = self.buy(tick.lastPrice , abs(self.fixedSize))\n        # #Log( str(self.vtSymbol) + \" cover 0 1 \" + str(self.fixedSize) +\" \" +str(','.join(orderIDList))  + \"\\n\")\n        # #print str(self.vtSymbol) , \"cover 0 1\" , self.fixedSize , orderID\n        # for orderID in orderIDList:\n        #     self.orderList.append(orderID)\n\n        # 聚合为1分钟K线\n        tickMinute = tick.datetime.hour\n\n        if tickMinute != self.barMinute:  \n            if self.bar:\n                self.onBar(self.bar)\n\n            bar = VtBarData()              \n            bar.vtSymbol = tick.vtSymbol\n            bar.exchange = tick.exchange\n\n            bar.open = tick.lastPrice\n            bar.high = tick.lastPrice\n            bar.low = tick.lastPrice\n            bar.close = tick.lastPrice\n\n            bar.date = tick.date\n            bar.time = tick.time\n            bar.datetime = tick.datetime    # K线的时间设为第一个Tick的时间\n\n            self.bar = bar                  # 这种写法为了减少一层访问，加快速度\n            self.barMinute = tickMinute     # 更新当前的分钟\n        else:                               # 否则继续累加新的K线\n            bar = self.bar                  # 写法同样为了加快速度\n\n            bar.high = max(bar.high, tick.lastPrice)\n            bar.low = min(bar.low, tick.lastPrice)\n            bar.close = tick.lastPrice\n\n    def onBar(self , bar):\n        \n        if bar.datetime.hour  % self.minute_use == 0:         # bar.datetime.minute 则切换成分钟级别\n            # 如果已经有聚合5分钟K线\n            if self.fiveBar:\n                # 将最新分钟的数据更新到目前5分钟线中\n                fiveBar = self.fiveBar\n                fiveBar.high = max(fiveBar.high, bar.high)\n                fiveBar.low = min(fiveBar.low, bar.low)\n                fiveBar.close = bar.close\n                \n                # 推送5分钟线数据\n                self.onFiveBar(fiveBar)\n                \n                # 清空5分钟线数据缓存\n                self.fiveBar = None\n        else:\n            # 如果没有缓存则新建\n            if not self.fiveBar:\n                fiveBar = VtBarData()\n                \n                fiveBar.vtSymbol = bar.vtSymbol\n                fiveBar.symbol = bar.symbol\n                fiveBar.exchange = bar.exchange\n            \n                fiveBar.open = bar.open\n                fiveBar.high = bar.high\n                fiveBar.low = bar.low\n                fiveBar.close = bar.close\n            \n                fiveBar.date = bar.date\n                fiveBar.time = bar.time\n                fiveBar.datetime = bar.datetime \n                \n                self.fiveBar = fiveBar\n            else:\n                fiveBar = self.fiveBar\n                fiveBar.high = max(fiveBar.high, bar.high)\n                fiveBar.low = min(fiveBar.low, bar.low)\n                fiveBar.close = bar.close\n\n\n    def onFiveBar(self , bar):\n        #Log( self.currency , bar.close , self.pos , self.orderList)\n\n        for orderID in self.orderList:\n            self.cancelOrder(orderID)\n        self.orderList = []\n    \n        # 保存K线数据\n        self.closeArray[0:self.bufferSize-1] = self.closeArray[1:self.bufferSize]\n        self.highArray[0:self.bufferSize-1] = self.highArray[1:self.bufferSize]\n        self.lowArray[0:self.bufferSize-1] = self.lowArray[1:self.bufferSize]\n        self.buyValue[0:self.bufferSize-1] = self.buyValue[1:self.bufferSize]\n\n        self.closeArray[-1] = bar.close\n        self.highArray[-1] = bar.high\n        self.lowArray[-1] = bar.low\n    \n        # 计算指标数值\n        self.bollMid = talib.MA(self.closeArray, self.bollLength)[-1]\n        self.bollStd = talib.STDDEV(self.closeArray, self.bollLength)[-1]\n        self.entryUp = self.bollMid + self.bollStd * self.topDev\n\n        self.buyValue[-1] = self.entryUp\n\n        self.bufferCount += 1\n        if self.bufferCount < self.bufferSize:\n            return\n\n        # 判断是否要进行交易\n        cond1 = 0\n        for i in range(1 , self.use_range + 1):\n            if self.highArray[-i] > self.buyValue[-i]:\n                cond1 = 1\n        cond2 = 0\n\n        # newHigh = [float(x) for x in self.highArray]\n        # if bar.high >= max(newHigh[-self.N : ]) and self.highArray[-2] >= max(newHigh[-self.N-1 : -1]):\n        #     cond2 = 1\n        if self.pos == 0 and cond1 > 0:\n            self.intraTradeHigh = bar.high\n            newHigh = [float(x) for x in self.highArray]\n            entryBuyPrice = max(newHigh[-self.N:])\n            orderID = self.buy( entryBuyPrice, self.fixedSize , stop=True)\n            self.orderList.append(orderID)\n\n        elif self.pos > 0:\n            self.intraTradeHigh = max(bar.high , self.intraTradeHigh)\n            exitPrice = self.intraTradeHigh * (1 - self.trailingPrcnt / 100.0) \n            orderID = self.sell( exitPrice , self.fixedSize , stop=True)\n            self.orderList.append(orderID)\n\n'''\nbollLength = 20         # 通道窗口数\ntopDev = 1.3            # 开仓偏差\ntrailingPrcnt = 2       # 移动止损百分比\nuse_range = 10          # use_range天内有突破最高价\nN = 10                  # 多少天突破\n'''\nrunning_key = {\n    \"BTC\":{ \"bollLength\":20 , \"topDev\":1.3 , \"trailingPrcnt\": 2 , \"use_range\": 10 , \"N\":10 , \"minute_use\": 6},\n    \"LTC\":{ \"bollLength\":20 , \"topDev\":1.3 , \"trailingPrcnt\": 2 , \"use_range\": 10 , \"N\":10 , \"minute_use\": 6}\n}\n\ndef main():\n    global LoopInterval \n\n    objs = []\n    for e in exchanges:\n        if e.GetName() != 'Futures_OKCoin':\n            raise Error_noSupport\n        e.SetRate(1)\n        use_symbol = [\"this_week\",\"next_week\",\"quarter\"][ContractTypeIdx]\n        e.SetContractType(use_symbol) \n        e.SetMarginLevel([10,20][MarginLevelIdx])\n\n        e_currency = e.GetCurrency().upper()\n        Log(e_currency)\n        st = BollingerBreakerStrategy(e , {\n        \"vtSymbol\":e.GetName() + \"_\" + use_symbol + \"_\" + e.GetCurrency(), \n        \"currency\":e_currency,\n        \"minute_use\":running_key[e_currency][\"minute_use\"],\n        \"bollLength\":running_key[e_currency][\"bollLength\"],\n        \"topDev\": running_key[e_currency][\"topDev\"],\n        \"trailingPrcnt\": running_key[e_currency][\"trailingPrcnt\"],\n        \"use_range\": running_key[e_currency][\"use_range\"],\n        \"N\": running_key[e_currency][\"N\"]\n        })\n\n        objs.append(st)\n\n    while True:\n        for st in objs:\n            st.onCall()\n        Sleep(LoopInterval * 1000)",
        "strategy_description": "策略名称: 布林均线突破_vnpy_botvs实现版\n\nCTAORDER_BUY = \"buy\"\nCTAORDER_SELL = \"closebuy\"\nCTAORDER_SHORT = \"sell\"\nCTAORDER_COVER = \"closesell\""
    },
    {
        "strategy_id": "94_干货-下单量精度和价格精度-适用各个交易所",
        "strategy_code": "python\nfrom collections import Counter\ndef GetAmountPrecision():\n    depth = _C(exchange.GetDepth)    \n    amountPrecisions = []\n    for ask in depth[\"Asks\"]:\n        i = ask[\"Amount\"]\n        amountPrecision = 0\n        if str(i).count('.') == 1:\n            amountPrecision = len(str(i).split(\".\")[1])\n        amountPrecisions.append(amountPrecision)\n    amountPrecision = max(amountPrecisions)    \n    return amountPrecision\n\ndef GetPricePrecision():\n    depth = _C(exchange.GetDepth)    \n    pricePrecisions = []\n    for ask in depth[\"Asks\"]:\n        j = ask[\"Price\"]\n        pricePrecision = 0\n        if str(j).count('.') == 1:\n            pricePrecision = len(str(j).split(\".\")[1])\n        pricePrecisions.append(pricePrecision)\n    pricePrecision = Counter(pricePrecisions).most_common(1)[0][0]\n    return pricePrecision",
        "strategy_description": "策略名称: 干货-下单量精度和价格精度-适用各个交易所\n\n未找到描述"
    },
    {
        "strategy_id": "95_干货-选币系统-选币因子",
        "strategy_code": "python\nimport numpy as np\nfrom scipy.stats import norm\nfrom sklearn import preprocessing\nimport json\n\n#计算波动率因子值\ndef GetAtrFactorService(records):\n    atrlength = 14\n    atrs = TA.ATR(records, atrlength)\n    acs = sorted(range(len(atrs)), key=lambda k: atrs[k])\n    ac = acs[-1]\n    arr_mean = np.mean(acs)\n    arr_std = np.std(acs,ddof=1)\n    p = norm.cdf(x=ac, loc=arr_mean, scale = arr_std)\n    #P值越大，波动性越大\n    atrFactor = _N(p,3)\n    return atrFactor \n\n#计算机构的行为痕迹因子值        \ndef GetITFactorService(records):\n    #本福特定律分布频数\n    PN = [301, 176, 125, 97, 79, 67, 58, 51, 46]\n    FN = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n    for i in range(len(records)):\n        valume = records[i]['Volume']*10000\n        strValume = str(valume)\n        num = strValume[0]\n        for j in range(len(FN)):\n            key = j + 1\n            if int(num) == key:\n                FN[j] += 1\n    if sum(FN) == 0:\n        FN = PN\n    X = 0\n    for i in range(len(PN)):\n        X += (FN[i] - PN[i])**2\n    ITFactor = X\n    #X 的数值越大，则成交量数据与本福特理想分布的偏离越大，机构的行为痕迹也越大\n    return ITFactor\n\n#计算价格因子值\ndef GetPriceFactorService(records):\n    record = records[-1]\n    price = record[\"Close\"]\n    PFactor = 1/price \n    #PFactor数值越大，则价格越小 \n    return PFactor \n\n#标准化处理   --计算出来的因子值因为数量级不同，要进行标准化处理。暂不处理空值、异常值\ndef StandardizedService(factor):\n    # 标准化处理\n    factorArray = np.asarray(factor)\n    factorArray = preprocessing.scale(factorArray)\n    factor = factorArray.tolist()\n\next.GetAtrFactorService = GetArtFactorService \next.GetITFactorService = GetITFactorService \next.GetPriceFactorService = GetPriceFactorService \next.StandardizedService = StandardizedService",
        "strategy_description": "策略名称: 干货-选币系统-选币因子\n\nfactorArray = np.asarray(factor)\n    factorArray = preprocessing.scale(factorArray)\n    factor = factorArray.tolist()\n\next.GetAtrFactorService = GetArtFactorService \next.GetITFactorService = GetITFactorService \next.GetPriceFactorService = GetPriceFactorService \next.StandardizedService = StandardizedService\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/344801\n\n> Last Modified\n\n2022-02-12 11:17:18"
    },
    {
        "strategy_id": "96_幽灵趋势跟踪策略",
        "strategy_code": "python\nimport json\nimport traceback\n#SYMBOLS = ['1INCH_USDT','ADA_USDT','ALGO_USDT','ATOM_USDT','AVAX_USDT','AAVE_USDT','AXS_USDT',\n#           'BAND_USDT','BCH_USDT','BTC_USDT','COMP_USDT','CHZ_USDT','CRV_USDT','CVC_USDT','DOGE_USDT'\n#           ,'DOT_USDT','DYDX_USDT','DASH_USDT','EGLD_USDT','ENJ_USDT','ENS_USDT','EOS_USDT','ETH_USDT',\n#           'ETC_USDT','FIL_USDT','FTM_USDT','GALA_USDT','GRT_USDT','IOTA_USDT','ICP_USDT','KSM_USDT',\n#           'LINK_USDT','LRC_USDT','LTC_USDT','MANA_USDT','MATIC_USDT','NEAR_USDT','OMG_USDT','SAND_USDT',\n #          'SC_USDT','1000SHIB_USDT','SOL_USDT','SRM_USDT','STORJ_USDT','SUSHI_USDT','THETA_USDT','TRX_USDT',\n  #         'UNI_USDT','XRP_USDT','XLM_USDT','XMR_USDT','XTZ_USDT','YFI_USDT','ZEC_USDT','PEOPLE_USDT',\n  #         'APE_USDT','GMT_USDT','ZIL_USDT','KNC_USDT']\nSYMBOLS = ['1INCH_USDT','ALGO_USDT','ATOM_USDT','AVAX_USDT','AAVE_USDT','AXS_USDT',\n           'BAND_USDT','BCH_USDT','BTC_USDT','COMP_USDT','CVC_USDT','DOGE_USDT'\n           ,'DOT_USDT','DYDX_USDT','DASH_USDT','EGLD_USDT','ENJ_USDT','ENS_USDT','EOS_USDT','ETH_USDT',\n           'ETC_USDT','FTM_USDT','GALA_USDT','GRT_USDT','IOTA_USDT','KSM_USDT',\n           'LINK_USDT','LRC_USDT','LTC_USDT','MANA_USDT','MATIC_USDT','NEAR_USDT','OMG_USDT','SAND_USDT',\n           'SC_USDT','SOL_USDT','SRM_USDT','SUSHI_USDT','THETA_USDT','TRX_USDT',\n           'UNI_USDT','XRP_USDT','XLM_USDT','XMR_USDT','XTZ_USDT','YFI_USDT','ZEC_USDT','PEOPLE_USDT',\n           'APE_USDT','ZIL_USDT','KNC_USDT']\n#主函数\ndef main():\n    try:\n        while True:\n            flage = ext.GetStopService()\n            if flage == 1:\n                break\n            #策略交互\n            ext.GetCommandService()\n            #选币功能\n            ext.GetSymbolService()\n            #下单信号 \n            ext.FirstSignalService()\n            #减仓信号\n            ext.StopSurplusService()\n            #展示数据\n            ext.UpdateLogStatusService()\n            Sleep(tickInterval)\n    except Exception as e:\n        Log(traceback.format_exc())\n        Log(\"策略已停止，请及时查看@\")\n    \n#初始化函数        \ndef init():\n    Log(\"策略开始\")\n    #设置合约永续\n    if len(exchanges) != 2:\n        Log(\"需要设置两组交易对\")\n        return\n    symbolRecord = _G(\"symbolRecord\")\n    Log(\"symbolRecord:\",symbolRecord)\n    if symbolRecord is not None:\n        symbol = symbolRecord['symbol']\n        exchange.SetCurrency(symbol) \n    _G(\"symbolRecord\",None)\n    exchange.SetContractType(\"swap\")\n    exchange.SetMarginLevel(leverage)\n    exchanges[1].SetContractType(\"swap\")\n    exchanges[1].SetMarginLevel(leverage)\n    _G(\"orderValue\",orderValue)\n    _G(\"leverage\",leverage)\n    _G(\"bfCount\",bfCount)\n    _G(\"symbols\",SYMBOLS)\n    _G(\"isFlag\",isFlag)\n    _G(\"isUpdate\",0)\n    _G(\"stopSurplus\",stopSurplus)\n    _G(\"stopSurplusCount\",stopSurplusCount)\n    Log(\"所有交易标的：\",SYMBOLS)\n    if _G(\"initialTotalMarginBalance\") is None:\n        info = exchange.GetAccount().Info\n        if info is None or info == {}:\n            Log(\"获取不到期货数据，无法运行\")\n            return\n        _G(\"initialTotalMarginBalance\", round(float(info.totalMarginBalance),2))#初始金额\n    if _G(\"drawIn\") is None:\n        _G(\"drawIn\",0)\n    if _G(\"drawOut\") is None:\n        _G(\"drawOut\",0)\n    ext.ClearAllService()\n    \n    \n#扫尾函数   \ndef onexit():\n     #平仓\n    #ext.ClearanceService()\n    ext.UpdateLogStatusService()\n    #Log(\"已全部平仓\")\n    Log(\"策略已停止\")",
        "strategy_description": "策略名称: 幽灵趋势跟踪策略\n\n#           ,'DOT_USDT','DYDX_USDT','DASH_USDT','EGLD_USDT','ENJ_USDT','ENS_USDT','EOS_USDT','ETH_USDT',"
    },
    {
        "strategy_id": "97_幽灵趋势跟踪策略业务库",
        "strategy_code": "python\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport time,datetime\nimport json\nimport math\nimport urllib.request\nRECORDS = None\nFLAGE = 0\n#账户信息表格化，用于展示在状态信息上\ndef TableAccountService(account):\n    \n    clos = [] #表头\n    clos.append(\"初始余额\")\n    clos.append(\"钱包余额\")\n    clos.append(\"保证金余额\")\n    clos.append(\"可用余额\")\n    clos.append(\"已用保证金\")\n    clos.append(\"当前杠杆\")\n    clos.append(\"总收益(收益率)\")\n    \n    initialTotalMarginBalance = \"$\" + str(_G(\"initialTotalMarginBalance\")) #初始余额\n    totalWalletBalance = \"$\" + str(account.totalWalletBalance) #钱包余额\n    totalMarginBalance = \"$\" + str(account.totalMarginBalance) #保证金余额\n    availableBalance = \"$\" + str(account.availableBalance) #可用余额\n    totalPositionInitialMargin = account.totalPositionInitialMargin#持仓保证金\n    totalOpenOrderInitialMargin = account.totalOpenOrderInitialMargin#当前挂单保证金\n    #_C(FilterHandlService)\n    drawOut = _N(_G(\"drawOut\"),2) #已划转资金\n    if account.totalMarginBalance==0 :\n        marginRate = \"0\"\n        lever = 0\n        Revenue = \"$0\"\n    else :\n        marginRate = (totalPositionInitialMargin+totalOpenOrderInitialMargin)/account.totalMarginBalance\n        marginRate = \"(\"+str(_N(marginRate,2)) + \")\"#保证金率\n        leverage = _G(\"leverage\")#杠杆 \n        lever = _N(totalPositionInitialMargin*leverage/account.totalMarginBalance,2)#当前杠杆\n        drawIn = _G(\"drawIn\")\n        drawOut = _G(\"drawOut\")\n        totalRevenue = account.totalMarginBalance-_G(\"initialTotalMarginBalance\") + drawOut - drawIn#总收益\n        initialTotalMarginBalance = _G(\"initialTotalMarginBalance\")\n        totalYield = 0\n        if initialTotalMarginBalance != 0:\n            totalYield = totalRevenue/initialTotalMarginBalance\n        totalYield = \"(\" + str(_N(totalYield,2)) + \")\"#总收益率\n        Revenue = \"$\" + str(_N(totalRevenue,2)) + totalYield\n        #记录当前总收益\n        _G(\"totalRevenue\",totalRevenue)\n    totalInitialMargin = \"$\" + str(_N(totalPositionInitialMargin+totalOpenOrderInitialMargin,2))#已用保证金\n    \n    rows = [] #表内容\n    row =[]\n    row.append(initialTotalMarginBalance)\n    row.append(totalWalletBalance)\n    row.append(totalMarginBalance)\n    row.append(availableBalance)\n    row.append(totalInitialMargin+marginRate)\n    row.append(lever)\n    row.append(Revenue)\n    rows.append(row)\n    \n    table = {\n        \"type\" : \"table\",\n        \"title\" : \"账户信息\",\n        \"cols\" : clos,\n        \"rows\" : rows\n    }\n    \n    \n    return table\n    \n#交易对表格化，用于展示在状态信息上    \ndef TablePositionsService(positions):\n    clos = [] #表头\n    clos.append(\"币种\")\n    clos.append(\"方向\")\n    clos.append(\"数量\")\n    clos.append(\"开仓价格\")\n    clos.append(\"强平价格\")\n    clos.append(\"现价\")\n    clos.append(\"未实现盈亏\")\n    rows = [] #表内容\n    for position in positions:\n        row = []\n        symbol = position.symbol\n        leverage = position.leverage\n        row.append(symbol + \"[\" + leverage + \"X]\")\n        \n        positionAmt = position.positionAmt\n        if float(positionAmt)>0:\n            row.append(\"做多\")\n        else:\n            row.append(\"做空\")\n        row.append(math.fabs(float(positionAmt)))\n        row.append(position.entryPrice)\n        row.append(position.liquidationPrice)\n        row.append(position.markPrice)\n        row.append(position.unRealizedProfit)\n        rows.append(row)  \n    table = {\n        \"type\" : \"table\",\n        \"title\" : \"交易对信息\",\n        \"cols\" : clos,\n        \"rows\" : rows\n    }\n    return table \n\n\n\n#跟新状态信息\ndef UpdateLogStatusService():\n    account = ext.GetAccountDao()\n    positions = ext.GetPositionsDao()\n    LogStatus(\"`\" + json.dumps(TableAccountService(account)) + \"`\\n\" +  \"`\" + json.dumps(TablePositionsService(positions)) +  \"`\")\n\n            \n#根据当前价格和下单价值换算成合约数            \ndef GetAmountByOrderValueService(price):\n    ext.GetNumByAmountService()\n    num = _G(\"num\")\n    orderValue = _G(\"orderValue\")\n    leverage = _G(\"leverage\")\n    account = ext.GetAccountDao()\n    totalMarginBalance = account.totalMarginBalance\n    orderValue = orderValue*totalMarginBalance*leverage*0.99/100\n    amount = orderValue/price\n    if orderValue < 5:\n        amount = 5/price + 1\n    amount = _N(amount,num)\n    if price*amount > orderValue:\n        amount = orderValue*0.99/price\n        amount = _N(amount,num)\n    exchange.SetMarginLevel(leverage)\n    return amount   \n\n#平仓\ndef ClearanceService():\n    positions = ext.GetPositionsDao()\n    for position in positions:\n        positionAmt = position.positionAmt\n        amt = math.fabs(float(positionAmt))\n        totalRevenue = _G(\"totalRevenue\")\n        ticker = ext.GetTickerDao(0)\n        price = ticker.last\n        symbol = position.symbol\n        symbol = symbol.replace(\"USDT\",\"_USDT\")\n        if float(positionAmt)>0:\n            #持多仓，--卖出平仓\n            ext.CreateOrderDao2(amt,3,\"{}币种平多单的当前成交价格：{}\".format(symbol,price))\n            LogProfit(_N(totalRevenue,2))\n        else:\n            #持空仓，--买入平仓\n            ext.CreateOrderDao2(amt,1,\"{}币种平空单的当前成交价格：{}\".format(symbol,price))\n            LogProfit(_N(totalRevenue,2))\n            \n#获取合约数位数\ndef GetNumByAmountService():\n    ext.GetNumByAmountDao()            \n\n#计算出交易对最小下单量\ndef GetMinOrderCountService():\n    minCount = 1\n    num = _G(\"num\")\n    if num != 0:\n        minCount = 1/(10**num)\n    return minCount\n \n#获取标志 \ndef GetStopService():\n    return ext.GetStopDao()\n\n#获取交易对信息    \ndef GetPositionsService():\n    return ext.GetPositionsDao()\n\n#获取tick价格\ndef GetPriceService(i):\n    ticker = ext.GetTickerDao(i)\n    price = ticker.last\n    return price \n\n#选出涨跌幅最大的币种\ndef GetSymbolService():\n    global RECORDS \n    #第一次获取所有币种的record数据，缓存起来 \n    R = _G(\"RECORDS\")\n    r = RECORDS\n    if r is None:\n        if R is None:\n            SetSymbolsRecordsService()\n        else:\n            RECORDS = R\n        return\n    #定期获取其中一个币种的最新record数据，和缓存数据比较，如果一样则，将数据更新标识记录为0并跳过\n    #如果不同，则更新缓存中所有币种的record数据,并将数据更新标识记录为1\n    isUpdate = UpdateRecordService()\n    if isUpdate:\n        return \n    #计算所有币种涨跌幅的绝对值，选出数值最大的币种\n    #根据选出来的币种的最新价格和bfCount的k线开盘价对比，判断出下单方向并记录起来\n    GetMaxSymbolService()\n    _G(\"RECORDS\",RECORDS)\n\n#下单信号\ndef FirstSignalService():\n    global FLAGE\n    symbolRecord = _G(\"symbolRecord\")\n    #检测是否已经筛选出币种，如果没有则跳出 \n    if symbolRecord is None:\n        return\n    #检测数据更新标识是否为1，如果不是则跳出 \n    isUpdate = _G(\"isUpdate\")\n    if isUpdate == 0:\n        return\n    symbol = symbolRecord[\"symbol\"] \n    #检测当前是否有持仓 \n    positions = ext.GetPositionsDao()\n    if len(positions) == 0:\n        #如果没有则用筛选出的币种进行下单\n        ext.SetCurrencyDao(symbol,0)\n        leverage = _G(\"leverage\")\n        exchange.SetMarginLevel(leverage)\n        side = symbolRecord[\"side\"]  \n        if side == 1:#做多 \n            price = symbolRecord[\"close\"]\n            amount = GetAmountByOrderValueService(price)\n            ext.CreateOrderDao2(amount,0,\"{}币种下多单的当前成交价格：{}\".format(symbol,price))\n            _G(\"initPrice\",price)\n            _G(\"initSide\",side)\n        else:#做空\n            price = symbolRecord[\"close\"]                      \n            amount = GetAmountByOrderValueService(price)\n            ext.CreateOrderDao2(amount,2,\"{}币种下空单的当前成交价格：{}\".format(symbol,price))\n            _G(\"initPrice\",price)\n            _G(\"initSide\",side)\n    elif len(positions) == 1:\n        position = positions[0]\n        positionAmt = float(position.positionAmt)\n        nSymbol = position.symbol\n        nSymbol = nSymbol.replace(\"USDT\",\"_USDT\")\n        #判断筛选出来的币种和当前下单的币种是否一样\n        if symbol == nSymbol:\n            #判断当前币种是否有浮亏，如果有则清仓，并反向下单\n            isFlag = _G(\"isFlag\")\n            if isFlag == 0:#使用反转信号,如果isFlag=0则不使用反转信号，则不处理当前的持仓\n                firstPrice = _G(\"initPrice\")\n                side = _G(\"initSide\")\n                price = symbolRecord[\"close\"]\n                if side == 1 and price <= firstPrice:#换币后首次下单方向是多，但是当前价格低于首次下单价格（浮亏），所以需要反转下单\n                    Log(\"换币后当前持仓方向是多，但是当前价格{}低于等于首次下单价格{}（浮亏），所以需要反转下单\".format(price,firstPrice))\n                    ClearanceService()\n                    amount = GetAmountByOrderValueService(price)\n                    if positionAmt > 0:#持有多单则清多单再下空单\n                        ext.CreateOrderDao2(amount,2,\"{}币种下空单的当前成交价格：{}\".format(symbol,price))\n                    else:\n                        ext.CreateOrderDao2(amount,0,\"{}币种下多单的当前成交价格：{}\".format(symbol,price))\n                    _G(\"initSide\",0)\n                    FLAGE = 0\n                elif side == 0 and price >= firstPrice:#换币后首次下单方向是空，但是当前价格高于首次下单价格（浮亏），所以需要反转下单\n                    Log(\"换币后当前持仓方向是空，但是当前价格{}高于等于首次下单价格{}（浮亏），所以需要反转下单\".format(price,firstPrice))\n                    #清空仓，再下多单\n                    ClearanceService()\n                    amount = GetAmountByOrderValueService(price)\n                    if positionAmt < 0:\n                        ext.CreateOrderDao2(amount,0,\"{}币种下多单的当前成交价格：{}\".format(symbol,price))\n                    else:\n                        ext.CreateOrderDao2(amount,2,\"{}币种下空单的当前成交价格：{}\".format(symbol,price))\n                    _G(\"initSide\",1)\n                    FLAGE = 0\n                else:\n                    Log(\"当前价格{}，首次下单价格{}，不需要反转下单\".format(price,firstPrice))\n            else:\n                Log(\"策略参数已屏蔽反转信号功能\")\n        else:\n            #将当前持仓清仓，并更换为筛选出的币种进行下单\n            ClearanceService()\n            ext.SetCurrencyDao(symbol,0)\n            side = symbolRecord[\"side\"]  \n            if side == 1:#做多 \n                ticker = ext.GetTickerDao(0)\n                price = ticker.last                          \n                amount = GetAmountByOrderValueService(price)\n                ext.CreateOrderDao2(amount,0,\"{}币种下多单的当前成交价格：{}\".format(symbol,price))\n                _G(\"initPrice\",price)\n                _G(\"initSide\",side)\n                FLAGE = 0\n            else:#做空\n                ticker = ext.GetTickerDao(0)\n                price = ticker.last                          \n                amount = GetAmountByOrderValueService(price)\n                ext.CreateOrderDao2(amount,2,\"{}币种下空单的当前成交价格：{}\".format(symbol,price))\n                _G(\"initPrice\",price)\n                _G(\"initSide\",side)\n                FLAGE = 0\n        \n    \n    \n#缓存record\ndef SetSymbolsRecordsService():\n    global RECORDS \n    symbols = _G(\"symbols\")\n    recordss = {}\n    for symbol in symbols:\n        #Log(\"symbol:\",symbol)\n        ext.SetCurrencyDao(symbol,1)\n        if RECORDS is None:\n            records =  ext.GetRecordsDao(-1,1)\n            recordss[symbol] = records\n        else:\n            oldRecords = RECORDS[symbol]\n            _CDelay(250)\n            records = _C(CheckRecordService,oldRecords)\n            recordss[symbol] = records\n    RECORDS = recordss\n\n#检查记录record数据是否更新\ndef CheckRecordService(oldRecords):\n    oldTime = oldRecords[-1][\"Time\"]\n    records = ext.GetRecordsDao(-1,1)\n    newTime = records[-1][\"Time\"]\n    if oldTime == newTime:\n        #Sleep(100)\n        return False\n    else:\n        return records\n\n#更新所有symbol的record    \ndef UpdateRecordService():\n    global RECORDS \n    symbols = _G(\"symbols\")\n    symbol = symbols[0]\n    ext.SetCurrencyDao(symbol,1)\n    newRecords = ext.GetRecordsDao(-1,1)\n    newTime = newRecords[-1][\"Time\"]\n    oldRecords = RECORDS[symbol]\n    oldTime = oldRecords[-1][\"Time\"]\n    if newTime == oldTime:\n        _G(\"isUpdate\",0)\n        return True\n    else:\n        Sleep(500)\n        SetSymbolsRecordsService()\n        _G(\"isUpdate\",1)\n        Log(\"行情数据已更新\")\n        return False\n\n#计算涨跌幅最大的币种\ndef GetMaxSymbolService():\n    symbols = _G(\"symbols\")\n    bfCount = _G(\"bfCount\") + 1\n    chgs = []\n    symbolList = []\n    tests = []\n    tests2 = []\n    for symbol in symbols:\n        records = RECORDS[symbol]\n        record = records[-1]\n        close = record[\"Open\"]\n        bfRecord = []\n        if len(records) < bfCount:\n            bfRecord = records[-len(records)]\n            Log(\"{}数据过少{}\".format(symbol,len(records)))\n        else:\n            bfRecord = records[-bfCount]\n        bfOpen = bfRecord[\"Open\"]\n        chg = 0\n        if close >= bfOpen:\n            chg = (close - bfOpen)/bfOpen \n        else:\n            chg = (bfOpen - close)/bfOpen\n        chgs.append(chg)\n        symbolList.append(symbol)\n        tests.append([symbol,chg])\n        tests2.append([symbol,bfOpen,close])\n    Log(tests)\n    Log(tests2)\n    maxChg = max(chgs)\n    maxSymbol = symbolList[chgs.index(maxChg)]\n    maxRecords = RECORDS[maxSymbol]\n    maxRecord = maxRecords[-1]\n    maxClose = maxRecord[\"Open\"]\n    maxBfRecord = maxRecords[-bfCount]\n    maxBfOpen = maxBfRecord[\"Open\"] \n    maxSide = GetSideService(maxSymbol,maxClose,maxBfOpen)\n    symbolRecord = {}\n    symbolRecord[\"symbol\"] = maxSymbol \n    symbolRecord[\"initPrice\"] = maxBfOpen \n    #symbolRecord[\"firstPrice\"] = price \n    symbolRecord[\"close\"] = maxClose \n    symbolRecord[\"side\"] = maxSide \n    symbolRecord[\"chg\"] = maxChg\n    _G(\"symbolRecord\",symbolRecord)\n    Log(\"新symbolRecord:\",symbolRecord)\n    #Log(\"最大涨跌幅的币种是：{}，涨跌幅为：{}\".format(maxSymbol,maxChg))\n\n#计算下单方向    \ndef GetSideService(maxSymbol,maxClose,maxBfOpen):\n    symbol = ext.GetCurrencyDao()\n    records = RECORDS[symbol]\n    price = records[-1][\"Open\"]\n    #检测当前是否有持仓 \n    positions = ext.GetPositionsDao()\n    if len(positions) == 0:#没有持仓，则不使用继承模块 \n        Log(\"首次下单，不使用继承模块\")\n        _G(\"oldClose\",maxClose)\n        _G(\"oldBfOpen\",maxBfOpen)\n        if maxClose > maxBfOpen:\n            return 1 #做多方向\n        else:\n            return 0 #做空方向\n    else:\n        position = positions[0]\n        nSymbol = position.symbol\n        nSymbol = nSymbol.replace(\"USDT\",\"_USDT\")\n        initPrice = _G(\"initPrice\")\n        if nSymbol == maxSymbol:#相同币种不需要换币\n            Log(\"筛选出来的币种和当前持仓的币种一样,不需要更换币种\")\n            if price >= initPrice:\n                return 1 #做多方向\n            else:\n                return 0 #做空方向\n        #使用继承模块\n        Log(\"筛选出来的币种和当前持仓的币种不一样,需要更换币种，{}币种更换为{}币种\".format(nSymbol,maxSymbol))\n        oldClose = _G(\"oldClose\")\n        oldBfOpen =_G(\"oldBfOpen\")\n        if (maxClose >= maxBfOpen and oldClose > oldBfOpen) or (maxClose <= maxBfOpen and oldClose < oldBfOpen):#继承上一个币的下单方向 \n            _G(\"oldClose\",maxClose)\n            _G(\"oldBfOpen\",maxBfOpen)\n            Log(\"{}币种继承{}币种的下单方向\".format(maxSymbol,nSymbol))\n            position =  positions[0]\n            positionAmt = float(position.positionAmt)\n            if positionAmt < 0:\n                return 0\n            else:\n                return 1\n        else:#不用使用继承\n            Log(\"不使用继承模块\")\n            _G(\"oldClose\",maxClose)\n            _G(\"oldBfOpen\",maxBfOpen)\n            if maxClose >= maxBfOpen:\n                return 1 #做多方向\n            else:\n                return 0 #做空方向 \n#清仓\ndef ClearAllService():\n    symbols = _G(\"symbols\")\n    for symbol in symbols:\n        ext.SetCurrencyDao(symbol,0)\n        positions = ext.GetPositionsDao()\n        if len(positions) != 0:\n            Log(\"清理已有仓位\")\n            ClearanceService()\n    \n        \n#策略交互\ndef GetCommandService():\n    cmd = GetCommand()\n    if cmd: \n        arr = cmd.split(\":\")\n        if arr[0] == \"一键清仓\": #清空所有交易对持仓\n            ClearanceService()\n            Log(\"全部清仓\")\n        elif arr[0] == \"现货==》合约\": #从现货账户划转USDT到合约账户\n            accountFunds = float(arr[1])\n            ret = ext.SetTransferDao(accountFunds,\"MAIN_UMFUTURE\",\"USDT\")\n            if ret is None:\n                Log(\"现货==》合约,划转资金出错\")  \n        elif arr[0] == \"合约==》现货\": #从合约账户划转USDT到现货账户\n            accountFunds = float(arr[1])\n            ret = ext.SetTransferDao(accountFunds,\"UMFUTURE_MAIN\",\"USDT\")\n            if ret is None:\n                Log(\"合约==》现货,划转资金出错\")\n            drawOut = _G(\"drawOut\")\n            _G(\"drawOut\",accountFunds + drawOut)\n\n#减仓信号\ndef StopSurplusService():\n    global FLAGE\n    if FLAGE == 1:\n        return \n    positions = ext.GetPositionsDao() \n    if len(positions) == 0:\n        return \n    position = positions[0]\n    positionAmt = float(position.positionAmt)\n    entryPrice = float(position.entryPrice)\n    ticker = ext.GetTickerDao(0)\n    price = ticker.last\n    stopSurplus = _G(\"stopSurplus\")/100\n    stopSurplusCount = _G(\"stopSurplusCount\")\n    stopSurplusCount = float(stopSurplusCount)/100\n    if positionAmt > 0:\n        if (price - entryPrice)/entryPrice < stopSurplus:\n            return \n        positionAmt = stopSurplusCount*positionAmt\n        num = _G(\"num\")\n        positionAmt = _N(positionAmt,num)\n        Log(\"减多仓\")\n        ext.CreateOrderDao2(positionAmt,3,\"当前成交价格：{}\".format(price))\n        totalRevenue = _G(\"totalRevenue\")\n        LogProfit(_N(totalRevenue,2))\n        FLAGE = 1\n    else:\n        if (entryPrice - price)/entryPrice  < stopSurplus:\n            return \n        positionAmt = -positionAmt \n        positionAmt = stopSurplusCount*positionAmt\n        num = _G(\"num\")\n        positionAmt = _N(positionAmt,num)\n        Log(\"减空仓\")\n        ext.CreateOrderDao2(positionAmt,1,\"当前成交价格：{}\".format(price))\n        totalRevenue = _G(\"totalRevenue\")\n        LogProfit(_N(totalRevenue,2))\n        FLAGE = 1\n    \n#设置双向持仓           \ndef SetDualService():\n    ext.SetDualDao()\n            \next.TableAccountService = TableAccountService\next.TablePositionsService = TablePositionsService\next.UpdateLogStatusService = UpdateLogStatusService\next.ClearanceService = ClearanceService\next.GetNumByAmountService = GetNumByAmountService\next.GetAmountByOrderValueService = GetAmountByOrderValueService\next.GetStopService = GetStopService\next.GetPositionsService = GetPositionsService\next.GetPriceService = GetPriceService \next.GetSymbolService = GetSymbolService\next.FirstSignalService = FirstSignalService\next.GetCommandService = GetCommandService\next.SetDualService = SetDualService\next.GetSymbolService = GetSymbolService\next.ClearAllService = ClearAllService\next.StopSurplusService = StopSurplusService",
        "strategy_description": "策略名称: 幽灵趋势跟踪策略业务库\n\nimport time,datetime\nimport json\nimport math\nimport urllib.request\nRECORDS = None\nFLAGE = 0"
    },
    {
        "strategy_id": "98_幽灵趋势跟踪策略数据库",
        "strategy_code": "python\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport time,datetime\nimport json\nfrom collections import Counter\nIFLAGE = 0\nclass Account(object):\n    #币安账户信息实体，封装了常用的账户信息\n    #totalWalletBalance：钱包余额\n    #totalMarginBalance：保证金余额\n    #totalPositionInitialMargin：持仓保证金\n    #totalOpenOrderInitialMargin：当前挂单保证金\n    #availableBalance: 可用余额（仅计算usdt资产）\n    def __init__(self, totalWalletBalance, totalMarginBalance, totalPositionInitialMargin, totalOpenOrderInitialMargin, availableBalance):\n        self.totalWalletBalance = totalWalletBalance\n        self.totalMarginBalance = totalMarginBalance\n        self.totalPositionInitialMargin = totalPositionInitialMargin\n        self.totalOpenOrderInitialMargin = totalOpenOrderInitialMargin \n        self.availableBalance = availableBalance\n        \nclass Position(object):\n    #币安交易对实体，封装了常用的交易对信息\n    #entryPrice：持仓成本价\n    #leverage：杠杆倍率\n    #liquidationPrice：强平价格\n    #marginType：逐仓模式或全仓模式\n    #markPrice：标记价格\n    #positionAmt：头寸数量\n    #symbol：交易对\n    #unRealizedProfit：持仓未实现盈亏\n    #positionSide：持仓方向\n    def __init__(self, entryPrice, leverage, liquidationPrice, marginType, markPrice, positionAmt, symbol, unRealizedProfit, positionSide):\n        self.entryPrice = entryPrice\n        self.leverage = leverage\n        self.liquidationPrice = liquidationPrice\n        self.marginType = marginType \n        self.markPrice = markPrice\n        self.positionAmt = positionAmt\n        self.symbol = symbol\n        self.unRealizedProfit = unRealizedProfit\n        self.positionSide = positionSide\n\nclass Ticker(object):\n    #sell: 卖一价\n    #buy: 买一价\n    #last: 最后成交价格\n    def __init__(self, sell, buy, last):\n        self.sell = sell \n        self.buy = buy \n        self.last = last \n        \n        \n        \nclass Order(object):\n    #id:订单唯一标识 \n    #price:下单价格 \n    #amount:下单数量 \n    #status:订单状态--0：未完成；1：已完成；2：已经取消；3：未知状态\n    def __init__(self, id, price, amount, status):\n        self.id = id \n        self.price = price \n        self.amount = amount \n        self.status = status \n        \n        \n#获取账户信息        \ndef GetAccountDao():\n    account = _C(exchange.GetAccount)\n    assets = account.Info.assets\n    busd = {}\n    usdt = {}\n    for asset in assets:\n        symbol = asset[\"asset\"]\n        if symbol == \"BUSD\":\n            busd = asset \n        if symbol == \"USDT\":\n            usdt = asset\n            \n    bTotalWalletBalance = float(busd[\"walletBalance\"])\n    bTotalMarginBalance = float(busd[\"marginBalance\"])\n    bTotalPositionInitialMargin = float(busd[\"positionInitialMargin\"])\n    bTotalOpenOrderInitialMargin = float(busd[\"openOrderInitialMargin\"])\n    bAvailableBalance = float(busd[\"availableBalance\"])\n    uTotalWalletBalance = float(usdt[\"walletBalance\"])\n    uTotalMarginBalance = float(usdt[\"marginBalance\"])\n    uTotalPositionInitialMargin = float(usdt[\"positionInitialMargin\"])\n    uTotalOpenOrderInitialMargin = float(usdt[\"openOrderInitialMargin\"])\n    uAvailableBalance = float(usdt[\"availableBalance\"])\n    totalWalletBalance = _N(uTotalWalletBalance+bTotalWalletBalance,2)\n    totalMarginBalance = _N(uTotalMarginBalance+bTotalMarginBalance,2)\n    totalPositionInitialMargin = _N(uTotalPositionInitialMargin+bTotalPositionInitialMargin,2)\n    totalOpenOrderInitialMargin = _N(uTotalOpenOrderInitialMargin+bTotalOpenOrderInitialMargin,2)\n    availableBalance = _N(uAvailableBalance+bAvailableBalance,2)\n    account = Account(totalWalletBalance, totalMarginBalance, totalPositionInitialMargin, totalOpenOrderInitialMargin, availableBalance)\n    return account\n\n#获取账户所有交易对\ndef GetPositionsDao():\n    positions = [] \n    num2 = _G(\"num2\")\n    for i in _C(exchange.GetPosition):\n        entryPrice = _N(float(i.Info.entryPrice),num2)\n        leverage = i.Info.leverage \n        liquidationPrice = _N(float(i.Info.liquidationPrice),num2)\n        marginType = i.Info.marginType \n        markPrice = _N(float(i.Info.markPrice),num2) \n        positionAmt = i.Info.positionAmt \n        symbol = i.Info.symbol \n        unRealizedProfit = _N(float(i.Info.unRealizedProfit),3)  \n        positionSide = i.Info.positionSide \n        \n        position = Position(entryPrice, leverage, liquidationPrice, marginType, markPrice,\n                            positionAmt, symbol, unRealizedProfit, positionSide)\n        positions.append(position)\n    return positions\n\n#获取tick级别的行情数据\ndef GetTickerDao(i):\n    ticker = _C(exchanges[i].GetTicker)\n    sell = ticker.Sell \n    buy = ticker.Buy \n    last = ticker.Last\n    newTicker = Ticker(sell,buy,last)\n    return newTicker\n\n#创建订单\ndef CreateOrderDao(price,amount,flag):\n    #price: 价格\n    #amount: 合约数\n    #flag: 0(买入开多仓);1(买入平空仓);2(卖出开空仓);3(卖出平多仓)\n    num2 = _G(\"num2\")\n    price = _N(price,num2)\n    id = 0\n    if flag == 0:\n        exchange.SetDirection(\"buy\")\n        id = exchange.Buy(price,amount)\n    elif  flag == 1:\n        exchange.SetDirection(\"closesell\")\n        id = exchange.Buy(price,amount)\n    elif  flag == 2:\n        exchange.SetDirection(\"sell\")\n        id = exchange.Sell(price,amount) \n    elif  flag == 3:\n        exchange.SetDirection(\"closebuy\")\n        id = exchange.Sell(price,amount)\n    return id\n\n#市价平仓\ndef CreateOrderDao2(amount,flag,message):\n    id = 0\n    #flag: 0(买入开多仓);1(买入平空仓);2(卖出开空仓);3(卖出平多仓)\n    if flag == 0:\n        exchange.SetDirection(\"buy\")\n        id = exchange.Buy(-1,amount,message)\n    elif  flag == 1:\n        exchange.SetDirection(\"closesell\")\n        id = exchange.Buy(-1,amount,message)\n    elif  flag == 2:\n        exchange.SetDirection(\"sell\")\n        id = exchange.Sell(-1,amount,message)\n    elif flag == 3:\n        exchange.SetDirection(\"closebuy\")\n        id = exchange.Sell(-1,amount,message)\n    return id \n\n\n#获取合约数位数\ndef GetNumByAmountDao():\n    depth = _C(exchange.GetDepth)\n    nums = []\n    num2s = []\n    for ask in depth[\"Asks\"]:\n        i = ask[\"Amount\"]\n        num = 0\n        if str(i).count('.') == 1:\n            num = len(str(i).split(\".\")[1])\n        nums.append(num)\n        \n        j = ask[\"Price\"]\n        num2 = 0\n        if str(j).count('.') == 1:\n            num2 = len(str(j).split(\".\")[1])\n        num2s.append(num2)\n    num = max(nums)    \n    _G(\"num\",num)\n    num2 = Counter(num2s).most_common(1)[0][0]\n    _G(\"num2\",num2)\n    \n    \n    \n#返回一个K线历史\ndef GetRecordsDao(period,i):\n    if period == -1:\n        return _C(exchanges[i].GetRecords)\n    else:\n        return _C(exchanges[i].GetRecords,period)\n\n#设置币种\ndef SetCurrencyDao(symbol,i):\n    exchanges[i].SetCurrency(symbol)\n\n#划转资金\ndef SetTransferDao(amount, typeEnum, symbol):\n    exchange.SetBase(\"https://api.binance.com\")\n    params = \"amount=\" + str(amount) + \"&type=\" + typeEnum + \"&asset=\" + symbol\n    ret = exchange.IO(\"api\", \"POST\", \"/sapi/v1/asset/transfer\", params)\n    Log(\"资金划转：划转数量为{}\".format(amount))\n    exchange.SetBase(\"https://fapi.binance.com\")\n    return ret\n\n\n#获取当前未完成的所有订单\ndef GetPendingOrdersDao():\n    orders = []\n    for order in _C(exchange.GetOrders):\n        id = order.Id\n        price = order.Price\n        amount = order.Amount\n        status = order.Status\n        newOrder = Order(id, price, amount, status)\n        orders.append(newOrder)\n    return orders \n\n#根据订单ID获取订单详情\ndef GetOrderByIdDao(id):\n    order = _C(exchange.GetOrder,id)\n    id = order.Id\n    price = order.Price\n    amount = order.Amount\n    status = order.Status\n    newOrder = Order(id, price, amount, status)\n    return newOrder    \n\n#取消某个订单\ndef CancelOrderDao(id):\n    if id == 0:\n        return True\n    flag = exchange.CancelOrder(id)\n    if flag == True:\n        return flag \n    else:\n        order =_C(exchange.GetOrder,id)\n        if order[\"Status\"] == 0:\n            flag = exchange.CancelOrder(id)\n        else:\n            flag = True\n        return flag    \n\n#取消所有未完成的订单\ndef AllCanelOrderDao():\n    orders = GetPendingOrdersDao()\n    for order in orders:\n        _C(CancelOrderDao,order.id)\n\n#定时器\ndef TimerDao(m,key):\n    value = _G(key)\n    if value is None:\n        value = time.time()\n        _G(key,value)\n        return True\n    now = time.time()\n    dnow = datetime.datetime.fromtimestamp(now)\n    dvalue = datetime.datetime.fromtimestamp(int(value))\n    c = (dnow - dvalue).total_seconds()\n    if c - m > 0:\n        _G(key,now)\n        return True\n    return False    \n\n#获取Period\ndef GetPeriodDao():\n    return exchange.GetPeriod()\n\n#获取Currency \ndef GetCurrencyDao():\n    return exchange.GetCurrency()\n\n#获取标志 \ndef GetStopDao():\n    i = IFLAGE\n    return i\n\n#设置标志1\ndef SetIFlageDao():\n    global IFLAGE \n    IFLAGE = 1  \n\n#定时器\ndef TimerDao(m,key):\n    value = _G(key)\n    if value is None:\n        value = time.time()\n        _G(key,value)\n        return True\n    now = time.time()\n    dnow = datetime.datetime.fromtimestamp(now)\n    dvalue = datetime.datetime.fromtimestamp(int(value))\n    c = (dnow - dvalue).total_seconds()\n    if c - m > 0:\n        _G(key,now)\n        return True\n    return False        \n#设置双向持仓\ndef SetDualDao():\n    dual = _C(exchange.IO,\"api\", \"GET\", \"/fapi/v1/positionSide/dual\", \"\")\n    if dual.dualSidePosition:\n        Log(\"当前账户为双向持仓模式，不需要转换持仓模式\")\n    else:\n        Log(\"当前账户为单向持仓模式，准备转双向持仓模式\")\n        _C(exchange.IO,\"api\", \"POST\", \"/fapi/v1/positionSide/dual\", \"dualSidePosition=true\")\n        Log(\"已转为双向持仓模式\")    \n\next.GetAccountDao = GetAccountDao\next.GetPositionsDao = GetPositionsDao\next.GetTickerDao = GetTickerDao\next.CreateOrderDao = CreateOrderDao\next.CreateOrderDao2 = CreateOrderDao2\next.GetNumByAmountDao = GetNumByAmountDao\next.GetRecordsDao = GetRecordsDao\next.SetTransferDao = SetTransferDao\next.GetPendingOrdersDao = GetPendingOrdersDao\next.GetOrderByIdDao = GetOrderByIdDao\next.CancelOrderDao = CancelOrderDao\next.TimerDao = TimerDao\next.AllCanelOrderDao = AllCanelOrderDao\next.GetPeriodDao = GetPeriodDao\next.GetCurrencyDao = GetCurrencyDao\next.GetStopDao = GetStopDao\next.SetIFlageDao = SetIFlageDao\next.TimerDao = TimerDao\next.SetDualDao = SetDualDao\next.SetCurrencyDao = SetCurrencyDao",
        "strategy_description": "策略名称: 幽灵趋势跟踪策略数据库\n\nimport time,datetime\nimport json\nfrom collections import Counter\nIFLAGE = 0\nclass Account(object):\n    #币安账户信息实体，封装了常用的账户信息\n    #totalWalletBalance：钱包余额\n    #totalMarginBalance：保证金余额\n    #totalPositionInitialMargin：持仓保证金\n    #totalOpenOrderInitialMargin：当前挂单保证金\n    #availableBalance: 可用余额（仅计算usdt资产）\n    def __init__(self, totalWalletBalance, totalMarginBalance, totalPositionInitialMargin, totalOpenOrderInitialMargin, availableBalance):\n        self.totalWalletBalance = totalWalletBalance\n        self.totalMarginBalance = totalMarginBalance\n        self.totalPositionInitialMargin = totalPositionInitialMargin\n        self.totalOpenOrderInitialMargin = totalOpenOrderInitialMargin \n        self.availableBalance = availableBalance\n        \nclass Position(object):\n    #币安交易对实体，封装了常用的交易对信息\n    #entryPrice：持仓成本价\n    #leverage：杠杆倍率\n    #liquidationPrice：强平价格\n    #marginType：逐仓模式或全仓模式\n    #markPrice：标记价格\n    #positionAmt：头寸数量\n    #symbol：交易对\n    #unRealizedProfit：持仓未实现盈亏\n    #positionSide：持仓方向\n    def __init__(self, entryPrice, leverage, liquidationPrice, marginType, markPrice, positionAmt, symbol, unRealizedProfit, positionSide):\n        self.entryPrice = entryPrice\n        self.leverage = leverage\n        self.liquidationPrice = liquidationPrice\n        self.marginType = marginType \n        self.markPrice = markPrice\n        self.positionAmt = positionAmt\n        self.symbol = symbol\n        self.unRealizedProfit = unRealizedProfit\n        self.positionSide = positionSide\n\nclass Ticker(object):\n    #sell: 卖一价\n    #buy: 买一价\n    #last: 最后成交价格\n    def __init__(self, sell, buy, last):\n        self.sell = sell \n        self.buy = buy \n        self.last = last \n        \n        \n        \nclass Order(object):\n    #id:订单唯一标识 \n    #price:下单价格 \n    #amount:下单数量 \n    #status:订单状态--0：未完成；1：已完成；2：已经取消；3：未知状态\n    def __init__(self, id, price, amount, status):\n        self.id = id \n        self.price = price \n        self.amount = amount \n        self.status = status"
    },
    {
        "strategy_id": "99_指数对冲修罗场-001",
        "strategy_code": "python\n\nimport time\nimport requests\nimport math\nimport pandas as pd\n\nAlpha = 0.001  #指数移动平均的MA参数，设置的越大基准价格跟踪越敏感，最终持仓也会越低降低了杠杆，但会降低收益，具体根据自己需求权衡\nUpdateBasePriceInterval = 60 #多久更新一次基准价格，单位位秒，跟Alpha相关，Alpha设置的越小，这个间隔也可以设置的更小\nStopLossRate = 0.8 #表示当资金达到初始资金的80%时触发止损，停止策略，可以随着策略的盈利，动态设置止损位置\nMaxDiff = 0.5  #当偏差diff大于这个值时停止加仓\nMinDiff = -0.5  #当StopLossRate偏差Diff小于这个值时停止加仓\nVersion = '0.0.1'\nShow = True   #默认false 显示账户余额，true显示累计收益\nFunding = 0    #账户资金，为0的时候自动获取，非0的时候自行设置\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\nSelfFee = 0.04   #手续费率   https:#www.binance.com/cn/fee/futureFee\nTotalLong = 0    #做多总价值\nTotalShort = 0   #做空总价值\nProfit = 0       #收益\nAccount = {}     #保存账户信息\nWinRateData = {}  # 存储胜率信息\nassets = {}\ntradeInfo = {}\naccountAssets = {}\nruntimeData = {}\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\ntradeSymbols = list(TradeSymbols.replace(' ','').split(','))\nIndex = 1   #指数\nUpdateBasePriceTime = 0\nInitPrice = {}\nupdateProfitTime = 0\n\n\n#\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'stop_balance':0,'short_value':0,'long_value':0,'profit':0}\n\nif exchange.GetName() != 'Futures_Binance':\n    Log('只支持币安期货交易所！')\n    exit()\n\ndef init():\n    InitRateData()\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法连接币安网络，需要海外托管者')\n        exit()\n    #Log(exchangeInfo)\n    for i in range(len(exchangeInfo['symbols'])):\n        if len(exchangeInfo['symbols'][i]['symbol'].split('_')) > 1 :continue\n        sp = exchangeInfo['symbols'][i]['symbol'].split('_')[0]\n        symbol = sp.replace('USDT','')\n        #Log(sp)\n        BUSD = sp[-4:len(sp)]\n        if 'BUSD' != BUSD or symbol not in exchangeInfo['symbols'][i]['symbol']:   #排除BUSD交易对\n            if symbol in tradeSymbols:\n                assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'btc_price': 0, 'btc_change': 1,'btc_diff': 0,\n                'realised_profit': 0,'margin': 0,'unrealised_profit': 0,'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\n                tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\n                'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\n\n\ndef UpdateAccount():\n    global accountAssets ,StopLoss\n    #判断当前是模拟交易还是实盘交易\n    if MockTrading:\n        Log('模拟交易更新账户')\n\n    else:\n        #Log('实盘交易更新账户')\n        account = exchange.GetAccount()\n        ps = exchange.GetPosition()\n        if account is None:\n            Log('更新账户超时！')\n            return\n        accountAssets = account['Info']['assets']\n        assets['USDT']['update_time'] = int(time.time() * 1000)\n        #Log(account['Info']['positions'])\n        for i in range(len(account['Info']['positions'])):\n            symbol = account['Info']['positions'][i]['symbol']\n            if len(symbol.split('_')) > 1: continue   #过滤掉 例：symbol:ETHUSDT_211231  合约\n            sp = symbol.split('_')[0]\n            #排除掉BUSD交易对 和不在交易列表的交易对\n            coin = sp.replace('USDT','')\n            BUSD = sp[-4:len(sp)]\n            if 'BUSD' == BUSD or coin not in tradeSymbols: continue\n            #筛选单向持仓币种\n            if account['Info']['positions'][i]['positionSide'] == 'BOTH':\n                # if coin == 'ETH':\n                #     Log(coin,account['Info']['positions'][i])\n                #Log('symbol:',symbol)\n                assets[coin]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\n                assets[coin]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\n                assets[coin]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\n                assets[coin]['leverage'] = account['Info']['positions'][i]['leverage']\n        #Log(assets)\n        #计算持仓保证金总额\n        assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\n        assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\n        assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\n        if assets['USDT']['init_balance'] == 0:\n            if _G('init_balance'):\n                assets['USDT']['init_balance'] = _N(_G('init_balance'),2)\n            else:\n                assets['USDT']['init_balance'] = assets['USDT']['total_balance']\n                _G('init_balance',assets['USDT']['init_balance'])\n        #计算收益\n        assets['USDT']['profit'] = _N(float(assets['USDT']['margin_balance']) - float(assets['USDT']['init_balance']),2)\n        #计算止损位置\n        assets['USDT']['stop_balance'] = _N(StopLossRate * assets['USDT']['init_balance'], 2)\n        #计算未实现收益\n        assets['USDT']['unrealised_profit'] = _N(float(account['Info']['totalUnrealizedProfit']),2)\n        #计算杠杆\n        assets['USDT']['leverage'] = _N(assets['USDT']['margin'] / float(assets['USDT']['total_balance']))\n        #计算保证金率\n        assets['USDT']['margin_ratio'] = _N(float(account['Info']['totalMaintMargin']) / float(account['Info']['totalMarginBalance'])) * 100\n        exchange.SetContractType('swap')\n        ps = json.loads(exchange.GetRawJSON())\n        # 更新持仓\n        #Log('position:',ps)\n        if len(ps) > 0:\n            j = 1\n            for i in range(len(ps)):\n                #Log(ps[i])\n                if len(ps[i]['symbol'].split('_')) > 1: continue   #过滤掉 例：symbol:ETHUSDT_211231  合约\n                sp = ps[i]['symbol'].split('_')[0]\n                BUSD = sp[-4:len(sp)]\n                symbol = sp.replace('USDT','')\n\n\n                if 'BUSD' == BUSD or symbol not in tradeSymbols : continue\n                if ps[i]['positionSide'] != 'BOTH': continue\n                assets[symbol]['hold_price'] = float(ps[i]['entryPrice'])\n                assets[symbol]['amount'] = float(ps[i]['positionAmt'])\n                assets[symbol]['unrealised_profit'] = float(ps[i]['unRealizedProfit'])\n                assets[symbol]['liquidationPrice'] = float(ps[i]['liquidationPrice'])\n                assets[symbol]['marginType'] = ps[i]['marginType']\n                #Log(j,assets[symbol])\n                #j+=1\n        #Log('实盘账户更新完毕！')\n\n\ndef UpdateTick():\n    try:\n        ticker = requests.get('https://fapi.binance.com/fapi/v1/ticker/bookTicker').json()\n    except Exception as e:\n        Log('get ticker time out !')\n        return\n    assets['USDT']['long_value'] = 0\n    assets['USDT']['short_value'] = 0\n    for i in range(len(ticker)):\n        sp = ticker[i]['symbol'].split('_')[0]\n        if len(ticker[i]['symbol'].split('_')) > 1: continue   #过滤掉 例：symbol:ETHUSDT_211231  合约\n        BUSD = sp[-4:len(sp)]\n        symbol = sp.replace('USDT','')\n        if 'BUSD' == BUSD or symbol not in tradeSymbols: continue\n        # if symbol == 'BTCDOM':\n        #     Log(symbol,ticker[i])\n        #Log(ticker[i])\n        assets[symbol]['ask_price'] = float(ticker[i]['askPrice'])\n        assets[symbol]['bid_price'] = float(ticker[i]['bidPrice'])\n        assets[symbol]['ask_value'] = _N(assets[symbol]['amount'] * assets[symbol]['ask_price'], 2)\n        assets[symbol]['bid_value'] = _N(assets[symbol]['amount'] * assets[symbol]['bid_price'], 2)\n\n        # if symbol == 'BTCDOM':\n        #     Log(symbol,assets[symbol])\n        value = (assets[symbol]['ask_value'] + assets[symbol]['bid_value']) / 2\n        if value != 0:\n            if value > 0:\n                assets['USDT']['long_value'] += value\n            else:\n                assets['USDT']['short_value'] += value\n\n        # if assets[symbol]['amount'] < 0:\n        #     assets['USDT']['short_value'] += abs((assets[symbol]['ask_value'] + assets[symbol]['bid_price']) / 2)\n        # else:\n        #     assets['USDT']['long_value'] += abs((assets[symbol]['ask_value'] + assets[symbol]['bid_value']) / 2)\n\n        assets['USDT']['short_value']    = _N(assets['USDT']['short_value'], 2)\n        assets['USDT']['long_value']     = _N(assets['USDT']['long_value'], 2)\n\n        #Log('UpdateTick:',symbol,assets[symbol])\n    #更新指数\n    UpdateIndex()\n    for symbol in  tradeSymbols:\n        assets[symbol]['btc_diff'] = _N((assets[symbol]['btc_change'] - Index), 4)\n\n\ndef UpdateIndex():\n    global UpdateBasePriceTime,InitPrice,Index,Reset\n\n    if MockTrading:\n        Log('模拟交易模式更新指数')\n    else:\n        #Log('实盘交易模式更新指数')\n        if _G('InitPrice') is None or Reset:\n            Reset = False\n            for symbol in tradeSymbols:\n                InitPrice[symbol] = (assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n            Log('保存启动时的价格')\n            _G('InitPrice',InitPrice)\n            _G('StartTime',None)\n            _G('InitAccount_'+exchange.GetLabel(), None)\n            _G('tradeNumber', 0) #重置交易次数\n            _G('tradeVolume', 0) #重置交易量\n            _G('buyNumber', 0) #重置做多次数\n            _G('sellNumber', 0) #重置做空次数\n            _G('totalProfit', 0) #重置打印次数\n            _G('profitNumber', 0) #重置盈利次数\n        else:\n            InitPrice = _G('InitPrice')\n            if int(time.time()*1000) - UpdateBasePriceTime > UpdateBasePriceInterval:\n                UpdateBasePriceTime = int(time.time() * 1000)\n                for symbol in tradeSymbols:\n                    if symbol not in InitPrice: continue\n                    InitPrice[symbol] = InitPrice[symbol] * (1 - Alpha) + Alpha * (assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n                    _G('InitPrice',InitPrice)\n            temp = 0\n            for symbol in tradeSymbols:\n                assets[symbol]['btc_price'] = (assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\n                if symbol not in InitPrice:\n                    Log('添加新的币种：',symbol)\n                    InitPrice[symbol] = assets[symbol]['btc_price']\n                    _G('InitPrice',InitPrice)\n                #Log(symbol,assets[symbol]['btc_price'],InitPrice[symbol])\n                assets[symbol]['btc_change'] = _N(assets[symbol]['btc_price'] / InitPrice[symbol], 4)\n                temp += assets[symbol]['btc_change']\n            Index = _N(temp / len(tradeSymbols), 4)\n            #Log('最新指数：',Index)\n\n\n#止损模块\ndef StopLoss():\n    if assets['USDT']['margin_balance'] < StopLossRate * assets['USDT']['init_balance'] and assets['USDT']['init_balance'] != 0:\n        Log('出发止损！ 当前资金：',assets['USDT']['margin_balance'],'初始资金：',assets['USDT']['init_balance'])\n        UpdateAccount()\n        UpdateTick()\n        Ice_value = 200 #止损的快一些，可修改\n        trading = False\n        for symbol in tradeSymbols:\n            if assets[symbol]['bid_price'] == 0 : continue\n            if assets[symbol]['bid_value'] >= tradeInfo[symbol]['minQty'] * assets[symbol]['bid_price']:\n                ## TODO: 卖出止损\n                trading = True\n                pass\n            if assets[symbol]['ask_value'] <= tradeInfo[symbol]['minQty'] * assets[symbol]['ask_price']:\n                # TODO: 买入止损\n                trading = True\n                pass\n            Sleep(1000)\n            if not trading:\n                Log('止损结束，如果需要重新运行策略，请调低止损参数！')\n                exit()\n    else:  # 不用止损\n        return None\n\ndef Trade(symbol,direction,value):\n    if int(time.time()) - assets['USDT']['update_time'] > 10 * 1000:\n        Log('更新账户延迟，不进行交易！！！')\n    else:\n        price = assets[symbol]['bid_price'] if direction =='SELL' else assets[symbol]['ask_price']\n        amount = _N(min(IceValue,value) / price,tradeInfo[symbol]['amountSize'])\n        if amount < tradeInfo[symbol]['minQty']:\n            Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n        else:\n            # exchange.SetCurrency(symbol+'_USDT')\n            # Log(direction)\n            # exchange.SetDirection(direction)\n            # f = 'Buy' if direction == 'Buy' else 'Sell'\n            # Log(f)\n            # place_order = getattr(exchange,direction) #获取交易对象\n            # id = place_order(price,amount,symbol)\n            para = ''\n            url = '/fapi/v1/order'\n            para += 'symbol='+ symbol + 'USDT'\n            para += '&side='+ direction\n            para += '&type=LIMIT&timeInForce=IOC'\n            para += '&quantity='+ str(amount)\n            para += '&price='+ str(price)\n            para += \"&timestamp=\"+str(time.time() * 1000);\n            go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n            ret = go.wait()\n            if ret  is not None:\n                logType = LOG_TYPE_SELL\n                if direction == 'BUY':\n                    logType =LOG_TYPE_BUY\n                exchange.Log(logType,price,amount,symbol)\n\n            TradingCounter('tradeVolume',amount * price)\n            TradingCounter('tradeNumber',1)\n            WinRateData[symbol]['tradeNumber'] += 1\n            if direction == 'Buy':\n                TradingCounter('buyNumber',1)\n                WinRateData[symbol]['buyNumber'] += 1\n            else:\n                TradingCounter('sellNumber',1)\n                WinRateData[symbol]['sellNumber'] += 1\n            _G('WinRateData',WinRateData)\n            return id\n\ndef FirstAccount():\n    key = \"initialAccount_\" + exchange.GetLabel()\n    initialAccount = _G(key)\n    if initialAccount is None:\n        initialAccount = exchange.GetAccount()\n        _G(key, initialAccount)\n    return initialAccount\n\ndef AppendedStatus():\n    global TotalLong,TotalShort,RunTime,Funding,Account\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"保证金余额\", \"已用保证金\", \"保证金比率\", \"止损\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n    feeTable = {\n        'type': 'table',\n        'title': '交易统计',\n        'cols': [\"策略指数\", '交易次数', '做多次数', '做空次数', '预估胜率', '预估成交额', '预估手续费', \"未实现盈利\", '持仓总值', '做多总值', '做空总值'],\n        'rows': []\n    }\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if Funding == 0:\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])\n    profitColors = DangerColor\n    totalProfit = assets['USDT']['total_balance'] - Funding\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday\n    dayRate = dayProfit / Funding * 100\n\n    accountTable['rows'].append([\n        runday,\n        '$' + str(_N(Funding, 2)),\n        '$' + str(assets['USDT']['total_balance']),\n        '$' + str(assets['USDT']['margin_balance']),\n        '$' + str(assets['USDT']['margin']),\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\n        str(_N(assets['USDT']['stop_balance'], 2)) + DangerColor,\n        str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n        str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n        str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n        str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n    vloume = _G('tradeVolume') if _G('tradeVolume') is not None else 0\n\n    feeTable['rows'].append([\n        Index, #指数\n        _G('tradeNumber') if _G('tradeNumber') is not None else 0, #交易次数\n        _G('buyNumber') if _G('buyNumber') is not None else 0, #做多次数\n        _G('sellNumber') if _G('sellNumber') is not None else 0, #做空次数\n        str(_N(_G('profitNumber') / _G('totalProfit') * 100, 2) if _G('totalProfit') > 0 else 0) + '%', #胜率\n        '$' + str(_N(vloume, 2)) + ' ≈ ฿' + str(_N(vloume / ((assets['BTC']['bid_price'] + assets['BTC']['ask_price']) / 2), 6)), #成交金额\n        '$' + str(_N(vloume * (SelfFee / 100), 4)), #手续费\n        '$' + str(_N(assets['USDT']['unrealised_profit'], 2)) + (SuccessColor if assets['USDT']['unrealised_profit'] >= 0 else DangerColor),\n        '$' + str(_N(TotalLong + abs(TotalShort), 2)), #持仓总价值\n        '$' + str(_N(TotalLong, 2)) + SuccessColor, #做多总值\n        '$' + str(_N(abs(TotalShort), 2)) + DangerColor, #做空总值\n    ])\n\n    assetTable = {\n        'type': 'table',\n        'title': '账户资产信息',\n        'cols': ['编号', '资产名', '起始保证金', '维持保证金', '保证金余额', '最大可提款金额', '挂单起始保证金', '持仓起始保证金', '持仓未实现盈亏', '账户余额'],\n        'rows': []\n    }\n    for i in range(len(accountAssets)):\n        acc = accountAssets[i]\n        assetTable['rows'].append([\n            i + 1,\n            acc['asset'], acc['initialMargin'], acc['maintMargin'], acc['marginBalance'],\n            acc['maxWithdrawAmount'], acc['openOrderInitialMargin'], acc['positionInitialMargin'],\n            acc['unrealizedProfit'], acc['walletBalance']\n        ])\n    indexTable = {\n        'type': 'table',\n        'title': '币指数信息',\n        'cols': ['编号', '币种信息', '当前价格', 'BTC计价', 'BTC计价变化(%)', '偏离平均', '交易次数', '做空次数', '做多次数', '预估胜率'],\n        'rows': []\n    }\n\n    i = 0\n    for symbol in tradeSymbols :\n        price = _N((assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / 2, tradeInfo[symbol]['priceSize'])\n        if symbol not in tradeSymbols:\n            indexTable['rows'].append([i + 1, symbol, price, assets[symbol]['btc_price'], _N((1 - assets[symbol]['btc_change']) * 100), assets[symbol]['btc_diff']], 0, 0, 0, '0%')\n        else:\n            i += 1\n            WinRateData = _G(\"WinRateData\")\n            winRated = _N(WinRateData[symbol]['profitNumber'] / WinRateData[symbol]['totalProfit'] * 100, 2) if WinRateData[symbol]['totalProfit'] > 0 else 0\n            indexTable['rows'].append([\n                i,\n                symbol + WrningColor,\n                price,\n                _N(assets[symbol]['btc_price'], 6),\n                _N((1 - assets[symbol]['btc_change']) * 100),\n                str(assets[symbol]['btc_diff']) + (SuccessColor if assets[symbol]['btc_diff'] >= 0 else DangerColor),\n                WinRateData[symbol]['tradeNumber'],\n                WinRateData[symbol]['sellNumber'],\n                WinRateData[symbol]['buyNumber'],\n                (str(winRated) if WinRateData[symbol]['profitNumber'] > 0 and WinRateData[symbol]['totalProfit'] > 0 else '0') + '%' + (SuccessColor if winRated >= 50 else DangerColor), #胜率\n            ])\n    retData = {}\n    #Log(runtimeData['str'])\n    #retData['upTable'] = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version + '\\n' + '`' + json.dumps([accountTable, assetTable]) + '`\\n' + '`' + json.dumps(feeTable) + '`\\n'\n    retData['upTable'] = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n' + '`' + json.dumps([accountTable, assetTable]) + '`\\n' + '`' + json.dumps(feeTable) + '`\\n'\n    retData['indexTable'] = indexTable\n    return retData\n\n\n\ndef UpdateStatus():\n    global TotalLong,TotalShort,updateProfitTime,Funding,Profit\n    TotalLong = 0\n    TotalShort = 0\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '强平差价', '持仓价值', '保证金', '未实现盈亏', '投降'],\n        'rows': []\n    }\n    i = 0\n    for symbol in tradeSymbols:\n        i += 1\n        direction = '空仓'\n        margin = direction\n        if assets[symbol]['amount'] != 0:\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\n        price = _N((assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / 2 ,tradeInfo[symbol]['priceSize'])\n        value = _N((assets[symbol]['ask_value'] + assets[symbol]['bid_value'])/2 , 2)\n        if value != 0:\n            if value > 0:\n                TotalLong += value\n            else:\n                TotalShort += value\n        unrealised_profit_color = '#000000'\n        if assets[symbol]['unrealised_profit'] > 0:\n            unrealised_profit_color = SuccessColor\n        if assets[symbol]['unrealised_profit'] < 0:\n            unrealised_profit_color = DangerColor\n        infoList = [\n            i,\n            '['+ margin +']' +'[' + str(assets[symbol]['leverage']) +'X]',\n            symbol,\n            direction,\n            abs(assets[symbol]['amount']),\n            assets[symbol]['hold_price'],\n            price,\n            assets[symbol]['liquidationPrice'],\n            '0' if assets[symbol]['liquidationPrice'] == 0 else '$' + str(_N(assets[symbol]['liquidationPrice'] - price, 5)) + ' ≈ ' + str(_N(assets[symbol]['liquidationPrice'] / price * 100, 2)) + '%' + WrningColor, #强平价格\n            abs(value),\n            _N(assets[symbol]['positionInitialMargin'],2),\n            str(_N(assets[symbol]['unrealised_profit'], 3)) + unrealised_profit_color,\n            {\n                'type': 'button',\n                'cmd': '说好的没有撤退可言呢？？?:' + symbol + ':' + str(assets[symbol]['amount']) + ':',\n                'name': symbol + ' 投降'\n            }\n\n        ]\n        table['rows'].append(infoList)\n        logString = json.dumps(assets['USDT'])\n\n        StatusData = AppendedStatus()\n        LogStatus(StatusData['upTable'] + '`' + json.dumps([table, StatusData['indexTable']]) + '`\\n' + logString)\n        # LogStatus('`' + json.dumps([table, StatusData['indexTable']]) + '`\\n' + logString)\n\n        if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n            balance = assets['USDT']['total_balance']\n            if Show:\n                balance = assets['USDT']['total_balance'] - Funding\n            LogProfit(_N(balance, 3), '&')\n            updateProfitTime = int(time.time()*1000)\n            if Profit != 0 and (_N(balance, 0) != Profit): #第一次不计算,并且小数点面的不进行胜率计算\n                TradingCounter(\"totalProfit\", 1) #统计打印次数, 胜率=盈利次数/打印次数*100\n                if _N(balance, 0) > Profit:\n                    TradingCounter('profitNumber', 1) #盈利次数\n                WinRate()\n            Profit = _N(balance,0)\n\n\n# 策略主逻辑\ndef Process():\n    # UpdateTick()\n    for symbol in tradeSymbols:\n        if assets[symbol]['ask_price'] == 0 : continue\n        aim_value = -TradeValue * _N(assets[symbol]['btc_diff'] / 0.01 ,3)  #计算偏离1%需要加的仓位\n        #偏移仓位 - 持有仓位 > 偏离加仓阈值 并且 diff > 预设最小加仓值 并且 多方仓位 - 空方仓位 小于等于 1.1倍的 偏离加仓  则进行开多仓\n        # if symbol == 'IOTA':\n        #     Log(symbol,aim_value - assets[symbol]['ask_value'])\n        if (aim_value - assets[symbol]['ask_value']) >= DeviateValue and assets[symbol]['btc_diff'] > MinDiff :\n            Log('做多',symbol,'   aim_value:',aim_value,'   ask_value:',assets[symbol]['ask_value'],'amount:',(aim_value - assets[symbol]['ask_value']), '   偏离平均:',assets[symbol]['btc_diff'])\n            Trade(symbol,'BUY',aim_value - assets[symbol]['ask_value'])\n        if (aim_value - assets[symbol]['bid_value']) <= -DeviateValue and assets[symbol]['btc_diff'] < MaxDiff:\n            Log('做空',symbol,'   aim_value:',aim_value,'   ask_value:',assets[symbol]['ask_value'],'amount:',(aim_value - assets[symbol]['bid_value']),  '   偏离平均:',assets[symbol]['btc_diff'])\n            Trade(symbol,'SELL',-(aim_value - assets[symbol]['bid_value']) )\n\n\n# 保存交易量\ndef TradingCounter(key,newValue):\n    value = _G(key)\n    if value is None:\n        _G(key,newValue)\n    else:\n        _G(key,value + newValue)\n\n\ndef WinRate():\n    global WinRateData\n    for symbol in tradeSymbols:\n        unrealised = assets[symbol]['unrealised_profit']\n        WinRateData[symbol]['totalProfit'] += 1\n        if unrealised != 0:\n            if unrealised > 0:\n                WinRateData[symbol]['profitNumber'] += 1\n    _G(\"WinRateData\", WinRateData)\n\n#更新胜率信息\ndef InitRateData():\n    global WinRateData\n    if Reset:\n        _G('WinRateData',None)\n    if _G('WinRateData'):\n        WinRateData = _G('WinRateData')\n    for symbols in tradeSymbols:\n        if symbols not in WinRateData:\n                                 #统计次数        #盈利次数          #交易次数       #做多次数        #做空次数\n            WinRateData[symbols] = {'totalProfit': 0, 'profitNumber': 0,'tradeNumber': 0,'buyNumber': 0, 'sellNumber': 0}\n    _G('WinRateData',WinRateData)\n #获取或创建策略第一次启动时间\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\n\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(20)\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #止损模块\n        StopLoss()\n        #策略逻辑\n        Process()\n        #输出状态栏信息\n        UpdateStatus()\n\n        Sleep(Interval * 1000)",
        "strategy_description": "策略名称: 指数对冲修罗场-001\n\nassets = {}\ntradeInfo = {}\naccountAssets = {}\nruntimeData = {}\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\ntradeSymbols = list(TradeSymbols.replace(' ','').split(','))\nIndex = 1   #指数\nUpdateBasePriceTime = 0\nInitPrice = {}\nupdateProfitTime = 0"
    },
    {
        "strategy_id": "100_指标库python版",
        "strategy_code": "python\n# 0级：核心工具函数\n# 1级：应用层函数(通过0级核心函数实现）\n# 2级：技术指标函数(全部通过0级，1级函数实现）\n\nimport math\nimport numpy as np\nimport pandas as pd\n\n\n#------------------ 0级：核心工具函数 --------------------------------------------      \ndef RD(N,D=3):   return np.round(N,D)        #四舍五入取3位小数 \ndef RET(S,N=1):  return np.array(S)[-N]      #返回序列倒数第N个值,默认返回最后一个\ndef ABS(S):      return np.abs(S)            #返回N的绝对值\ndef MAX(S1,S2):  return np.maximum(S1,S2)    #序列max\ndef MIN(S1,S2):  return np.minimum(S1,S2)    #序列min\n         \ndef MA(S,N):              #求序列的N日平均值，返回序列                    \n    return pd.Series(S).rolling(N).mean().values    \n\n#引用X在N个周期前的值\n#例如：REF(CLOSE,5)  #表示引用当前周期的前第5个周期的收盘价，如果是日线周期，即为第5个交易日前的收盘价\ndef REF(S, N=1):          #对序列整体下移动N,返回序列(shift后会产生NAN)    \n    return pd.Series(S).shift(N).values  \n\ndef DIFF(S, N=1):         #前一个值减后一个值,前面会产生nan \n    return pd.Series(S).diff(N)  #np.diff(S)直接删除nan，会少一行\n\ndef STD(S,N):             #求序列的N日标准差，返回序列    \n    return  pd.Series(S).rolling(N).std(ddof=0).values     \n\ndef IF(S_BOOL,S_TRUE,S_FALSE):   #序列布尔判断 return=S_TRUE if S_BOOL==True  else  S_FALSE\n    return np.where(S_BOOL, S_TRUE, S_FALSE)\n\ndef SUM(S, N):            #对序列求N天累计和，返回序列    N=0对序列所有依次求和         \n    return pd.Series(S).rolling(N).sum().values if N>0 else pd.Series(S).cumsum()  \n\ndef HHV(S,N):             # HHV(C, 5)  # 最近5天收盘最高价        \n    return pd.Series(S).rolling(N).max().values     \n\ndef LLV(S,N):             # LLV(C, 5)  # 最近5天收盘最低价     \n    return pd.Series(S).rolling(N).min().values    \n\ndef EMA(S,N):             #指数移动平均,为了精度 S>4*N  EMA至少需要120周期     alpha=2/(span+1)    \n    return pd.Series(S).ewm(span=N, adjust=False).mean().values     \n\ndef SMA(S, N, M=1):        #中国式的SMA,至少需要120周期才精确 (雪球180周期)    alpha=1/(1+com)\n    return pd.Series(S).ewm(com=N-M, adjust=True).mean().values     \n\ndef AVEDEV(S,N):           #平均绝对偏差  (序列与其平均值的绝对差的平均值)   \n    return pd.Series(S).rolling(N).apply(lambda x: (np.abs(x - x.mean())).mean()).values \n\ndef SLOPE(S,N,RS=False):    #返S序列N周期回线性回归斜率 (默认只返回斜率,不返回整个直线序列)\n    M=pd.Series(S[-N:]);   poly = np.polyfit(M.index, M.values,deg=1);    Y=np.polyval(poly, M.index); \n    if RS: return Y[1]-Y[0],Y\n    return Y[1]-Y[0]\n\n  \n#------------------   1级：应用层函数(通过0级核心函数实现） ----------------------------------\ndef COUNT(S_BOOL, N):                  # COUNT(CLOSE>O, N):  最近N天满足S_BOO的天数  True的天数\n    return SUM(S_BOOL,N)    \n\ndef EVERY(S_BOOL, N):                  # EVERY(CLOSE>O, 5)   最近N天是否都是True\n    R=SUM(S_BOOL, N)\n    return  IF(R==N, True, False)\n  \ndef LAST(S_BOOL, A, B):                #从前A日到前B日一直满足S_BOOL条件   \n    if A<B: A=B                        #要求A>B    例：LAST(CLOSE>OPEN,5,3)  5天前到3天前是否都收阳线     \n    return S_BOOL[-A:-B].sum()==(A-B)  #返回单个布尔值    \n\ndef EXIST(S_BOOL, N=5):                # EXIST(CLOSE>3010, N=5)  n日内是否存在一天大于3000点\n    R=SUM(S_BOOL,N)    \n    return IF(R>0, True ,False)\n\ndef BARSLAST(S_BOOL):                  #上一次条件成立到当前的周期  \n    M=np.argwhere(S_BOOL);             # BARSLAST(CLOSE/REF(CLOSE)>=1.1) 上一次涨停到今天的天数\n    return len(S_BOOL)-int(M[-1])-1  if M.size>0 else -1\n\ndef FORCAST(S,N):                      #返S序列N周期回线性回归后的预测值\n    K,Y=SLOPE(S,N,RS=True)\n    return Y[-1]+K\n  \ndef CROSS(S1,S2):                      #判断穿越 CROSS(MA(C,5),MA(C,10))               \n    CROSS_BOOL=IF(S1>S2, True ,False)   \n    return COUNT(CROSS_BOOL>0,2)==1    #上穿：昨天0 今天1   下穿：昨天1 今天0\n\n\n\n#------------------   2级：技术指标函数(全部通过0级，1级函数实现） ------------------------------\ndef MACD(CLOSE,SHORT=12,LONG=26,M=9):            # EMA的关系，S取120日，和雪球小数点2位相同\n    DIF = EMA(CLOSE,SHORT)-EMA(CLOSE,LONG);  \n    DEA = EMA(DIF,M);      MACD=(DIF-DEA)*2\n    return RD(DIF),RD(DEA),RD(MACD)\n\ndef KDJ(CLOSE,HIGH,LOW, N=9,M1=3,M2=3):         # KDJ指标\n    RSV = (CLOSE - LLV(LOW, N)) / (HHV(HIGH, N) - LLV(LOW, N)) * 100\n    K = EMA(RSV, (M1*2-1));    D = EMA(K,(M2*2-1));        J=K*3-D*2\n    return K, D, J\n\ndef RSI(CLOSE, N=24):                           # RSI指标,和通达信小数点2位相同\n    DIF = CLOSE-REF(CLOSE,1) \n    return RD(SMA(MAX(DIF,0), N) / SMA(ABS(DIF), N) * 100)  \n\ndef WR(CLOSE, HIGH, LOW, N=10, N1=6):            #W&R 威廉指标\n    WR = (HHV(HIGH, N) - CLOSE) / (HHV(HIGH, N) - LLV(LOW, N)) * 100\n    WR1 = (HHV(HIGH, N1) - CLOSE) / (HHV(HIGH, N1) - LLV(LOW, N1)) * 100\n    return RD(WR), RD(WR1)\n\ndef BIAS(CLOSE,L1=6, L2=12, L3=24):              # BIAS乖离率\n    BIAS1 = (CLOSE - MA(CLOSE, L1)) / MA(CLOSE, L1) * 100\n    BIAS2 = (CLOSE - MA(CLOSE, L2)) / MA(CLOSE, L2) * 100\n    BIAS3 = (CLOSE - MA(CLOSE, L3)) / MA(CLOSE, L3) * 100\n    return RD(BIAS1), RD(BIAS2), RD(BIAS3)\n\ndef BOLL(CLOSE,N=20, P=2):                       #BOLL指标，布林带    \n    MID = MA(CLOSE, N); \n    UPPER = MID + STD(CLOSE, N) * P\n    LOWER = MID - STD(CLOSE, N) * P\n    return RD(UPPER), RD(MID), RD(LOWER)    \n\ndef PSY(CLOSE,N=12, M=6):  \n    PSY=COUNT(CLOSE>REF(CLOSE,1),N)/N*100\n    PSYMA=MA(PSY,M)\n    return RD(PSY),RD(PSYMA)\n\ndef CCI(CLOSE,HIGH,LOW,N=20):  \n    TP=(HIGH+LOW+CLOSE)/3\n    return (TP-MA(TP,N))/(0.015*AVEDEV(TP,N))\n        \ndef ATR(CLOSE,HIGH,LOW, N=20):                    #真实波动N日平均值\n    TR = MAX(MAX((HIGH - LOW), ABS(REF(CLOSE, 1) - HIGH)), ABS(REF(CLOSE, 1) - LOW))\n    return MA(TR, N)\n\ndef BBI(CLOSE,M1=3,M2=6,M3=12,M4=20):             #BBI多空指标   \n    return (MA(CLOSE,M1)+MA(CLOSE,M2)+MA(CLOSE,M3)+MA(CLOSE,M4))/4    \n\ndef DMI(CLOSE,HIGH,LOW,M1=14,M2=6):               #动向指标：结果和同花顺，通达信完全一致\n    TR = SUM(MAX(MAX(HIGH - LOW, ABS(HIGH - REF(CLOSE, 1))), ABS(LOW - REF(CLOSE, 1))), M1)\n    HD = HIGH - REF(HIGH, 1);     LD = REF(LOW, 1) - LOW\n    DMP = SUM(IF((HD > 0) & (HD > LD), HD, 0), M1)\n    DMM = SUM(IF((LD > 0) & (LD > HD), LD, 0), M1)\n    PDI = DMP * 100 / TR;         MDI = DMM * 100 / TR\n    ADX = MA(ABS(MDI - PDI) / (PDI + MDI) * 100, M2)\n    ADXR = (ADX + REF(ADX, M2)) / 2\n    return PDI, MDI, ADX, ADXR  \n\ndef TAQ(HIGH,LOW,N):                               #唐安奇通道(海龟)交易指标，大道至简，能穿越牛熊\n    UP=HHV(HIGH,N);    DOWN=LLV(LOW,N);    MID=(UP+DOWN)/2\n    return UP,MID,DOWN\n\ndef KTN(CLOSE,HIGH,LOW,N=20,M=10):                 #肯特纳交易通道, N选20日，ATR选10日\n    MID=EMA((HIGH+LOW+CLOSE)/3,N)\n    ATRN=ATR(CLOSE,HIGH,LOW,M)\n    UPPER=MID+2*ATRN;   LOWER=MID-2*ATRN\n    return UPPER,MID,LOWER       \n  \ndef TRIX(CLOSE,M1=12, M2=20):                      #三重指数平滑平均线\n    TR = EMA(EMA(EMA(CLOSE, M1), M1), M1)\n    TRIX = (TR - REF(TR, 1)) / REF(TR, 1) * 100\n    TRMA = MA(TRIX, M2)\n    return TRIX, TRMA\n\ndef VR(CLOSE,VOL,M1=26):                            #VR容量比率\n    LC = REF(CLOSE, 1)\n    return SUM(IF(CLOSE > LC, VOL, 0), M1) / SUM(IF(CLOSE <= LC, VOL, 0), M1) * 100\n\ndef EMV(HIGH,LOW,VOL,N=14,M=9):                     #简易波动指标 \n    VOLUME=MA(VOL,N)/VOL;       MID=100*(HIGH+LOW-REF(HIGH+LOW,1))/(HIGH+LOW)\n    EMV=MA(MID*VOLUME*(HIGH-LOW)/MA(HIGH-LOW,N),N);    MAEMV=MA(EMV,M)\n    return EMV,MAEMV\n\n\ndef DPO(CLOSE,M1=20, M2=10, M3=6):                  #区间震荡线\n    DPO = CLOSE - REF(MA(CLOSE, M1), M2);    MADPO = MA(DPO, M3)\n    return DPO, MADPO\n\ndef BRAR(OPEN,CLOSE,HIGH,LOW,M1=26):                 #BRAR-ARBR 情绪指标  \n    AR = SUM(HIGH - OPEN, M1) / SUM(OPEN - LOW, M1) * 100\n    BR = SUM(MAX(0, HIGH - REF(CLOSE, 1)), M1) / SUM(MAX(0, REF(CLOSE, 1) - LOW), M1) * 100\n    return AR, BR\n\ndef DMA(CLOSE,N1=10,N2=50,M=10):                     #平行线差指标  \n    DIF=MA(CLOSE,N1)-MA(CLOSE,N2);    DIFMA=MA(DIF,M)\n    return DIF,DIFMA\n\ndef MTM(CLOSE,N=12,M=6):                             #动量指标\n    MTM=CLOSE-REF(CLOSE,N);         MTMMA=MA(MTM,M)\n    return MTM,MTMMA\n\ndef MASS(HIGH,LOW,N1=9,N2=25,M=6):                   # 梅斯线\n    MASS=SUM(MA(HIGH-LOW,N1)/MA(MA(HIGH-LOW,N1),N1),N2)\n    MA_MASS=MA(MASS,M)\n    return MASS,MA_MASS\n  \ndef ROC(CLOSE,N=12,M=6):                             #变动率指标\n    ROC=100*(CLOSE-REF(CLOSE,N))/REF(CLOSE,N);    MAROC=MA(ROC,M)\n    return ROC,MAROC  \n\ndef EXPMA(CLOSE,N1=12,N2=50):                        #EMA指数平均数指标\n    return EMA(CLOSE,N1),EMA(CLOSE,N2);\n\ndef OBV(CLOSE,VOL):                                  #能量潮指标\n    return SUM(IF(CLOSE>REF(CLOSE,1),VOL,IF(CLOSE<REF(CLOSE,1),-VOL,0)),0)/10000\n\ndef MFI(CLOSE,HIGH,LOW,VOL,N=14):                    #MFI指标是成交量的RSI指标\n    TYP = (HIGH + LOW + CLOSE)/3\n    V1=SUM(IF(TYP>REF(TYP,1),TYP*VOL,0),N)/SUM(IF(TYP<REF(TYP,1),TYP*VOL,0),N)  \n    return 100-(100/(1+V1))     \n  \ndef ASI(OPEN,CLOSE,HIGH,LOW,M1=26,M2=10):            #振动升降指标\n    LC=REF(CLOSE,1);      AA=ABS(HIGH-LC);     BB=ABS(LOW-LC);\n    CC=ABS(HIGH-REF(LOW,1));   DD=ABS(LC-REF(OPEN,1));\n    R=IF( (AA>BB) & (AA>CC),AA+BB/2+DD/4,IF( (BB>CC) & (BB>AA),BB+AA/2+DD/4,CC+DD/4));\n    X=(CLOSE-LC+(CLOSE-OPEN)/2+LC-REF(OPEN,1));\n    SI=16*X/R*MAX(AA,BB);   ASI=SUM(SI,M1);   ASIT=MA(ASI,M2);\n    return ASI,ASIT  \n\ndef VWAP(CLOSE,VOL,HIGH,LOW,N=14):                    #交易量加权平均价格\n    TYP = (HIGH + LOW + CLOSE)/3\n    VWAP = SUM(VOL*TYP, N) / SUM(VOL, N)\n    return VWAP\n\n\next.MACD = MACD \next.KDJ = KDJ\next.RSI = RSI\next.WR = WR\next.BIAS = BIAS\next.BOLL = BOLL\next.PSY = PSY\next.CCI = CCI    \next.ATR = ATR\next.BBI = BBI\next.DMI = DMI\next.TAQ = TAQ\next.KTN = KTN\next.TRIX = TRIX\next.VR = VR\next.EMV = EMV\next.DPO = DPO\next.BRAR = BRAR\next.DMA = DMA\next.MTM = MTM\next.MASS = MASS\next.ROC = ROC\next.EXPMA = EXPMA\next.OBV = OBV\next.MFI = MFI\next.ASI = ASI\next.VWAP = VWAP",
        "strategy_description": "策略名称: 指标库python版\n\n# 1级：应用层函数(通过0级核心函数实现）"
    },
    {
        "strategy_id": "101_数字货币定投",
        "strategy_code": "python\ndef onTick():\n\t\n\texchange_count = len(exchanges)\n\tfor i in range(exchange_count):\n\t\taccount = exchanges[i].GetAccount()\n\n\t\tmarketName = exchanges[i].GetName()\n\t\tdepth = exchanges[i].GetDepth()\n\t\tLog(\"Market \",marketName,exchanges[i].GetCurrency(),\"Account Balance [\",account[\"Balance\"],\"] Stocks[\",account[\"Stocks\"],\"]\")\n\t\tif account and depth and account[\"Balance\"] > accountLimitMoney :\n\t\t\tbidPrice = depth[\"Asks\"][0][\"Price\"] \n\t\t\tif bidPrice <  maxBidPrice :\n\t\t\t\tamount = orderAmount\n\t\t\t\tif amount <= account[\"Balance\"]:\n\t\t\t\t\texchanges[i].Buy(amount)\n\t\t\t\telse:\n\t\t\t\t\tLog(\"Account Balance is less than bid Amount\")\n\t\t\telse:\n\t\t\t\tLog(\"Bid Price >= maxBidPrice, not process\")\n\t\telse:\n\t\t\tLog(\"Account Balance <= accountLimitMoney\")\ndef main() :\n\twhile 1:\n\t\t\n\t\tonTick()\n\t\ttime.sleep(orderTimeInterval)",
        "strategy_description": "策略名称: 数字货币定投\n\norderAmount #定投金额 BTCCNY和BCCCNY 单位 CNY, BCCBTC 单位 BTC 等等\n\naccountLimitMoney #账户限额,保留一部分钱，账户达到最低限额就停止定投\n\n\norderTimeInterval #定投间隔,单位秒, 每分钟=60 每小时= 3600  每天=86400 每周=604800\n\nmaxBidPrice  #最大交易价格，超过价格就跳过，等待下次交易机会出现\n\n> Strategy Arguments\n\n\n\n|Argument|Default|Description|\n|----|----|----|\n|orderAmount|true|order amount|\n|maxBidPrice|false|max bid price|\n|accountLimitMoney|false|account limit money|\n|orderTimeInterval|60|Order Time Interval|\n\n\n> Source (python)\n\n``` python\ndef onTick():\n\t\n\texchange_count = len(exchanges)\n\tfor i in range(exchange_count):\n\t\taccount = exchanges[i].GetAccount()\n\n\t\tmarketName = exchanges[i].GetName()\n\t\tdepth = exchanges[i].GetDepth()\n\t\tLog(\"Market \",marketName,exchanges[i].GetCurrency(),\"Account Balance [\",account[\"Balance\"],\"] Stocks[\",account[\"Stocks\"],\"]\")\n\t\tif account and depth and account[\"Balance\"] > accountLimitMoney :\n\t\t\tbidPrice = depth[\"Asks\"][0][\"Price\"] \n\t\t\tif bidPrice <  maxBidPrice :\n\t\t\t\tamount = orderAmount\n\t\t\t\tif amount <= account[\"Balance\"]:\n\t\t\t\t\texchanges[i].Buy(amount)\n\t\t\t\telse:\n\t\t\t\t\tLog(\"Account Balance is less than bid Amount\")\n\t\t\telse:\n\t\t\t\tLog(\"Bid Price >= maxBidPrice, not process\")\n\t\telse:\n\t\t\tLog(\"Account Balance <= accountLimitMoney\")\ndef main() :\n\twhile 1:\n\t\t\n\t\tonTick()\n\t\ttime.sleep(orderTimeInterval)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/54256\n\n> Last Modified\n\n2017-09-08 14:43:38"
    },
    {
        "strategy_id": "102_暴雪网格-724小时交易机器人每日更新实盘效果",
        "strategy_code": "python\n#!python2\n# -*- coding:utf-8 -*-\n'''\n主要是使用发明者量化API进行网格买卖，当前只支持单品网格买卖\n'''\nfrom time import sleep\nimport datetime,copy\n\nsale_price_list = [] #卖出的价格列表\nbuy_price_list = []  #买入的价格列表\n\nclass fmz_market():\n    def get_data_depth(self):\n        data_depth = exchange.GetDepth()\n        return data_depth\n\n\n\n    #检查当前是否可以进行买卖操作\n    def make_trade_check(self,symbol):\n        trade_infor = {'price':0,'trade_type':''}\n        #进行买卖列表判断，先更新交易记录列表\n        trade_price_list = self.get_trade_price_list(symbol)\n        sale_price_list = trade_price_list[0]\n        buy_price_list = trade_price_list[1]\n        #获取深度数据\n        data_depth = self.get_data_depth()\n        #买单列表：\n        data_depth_bids = data_depth.Bids[0]\n        #卖单列表：\n        data_depth_asks = data_depth.Asks[0]\n        #如果买入记录不为空\n        sale_buy_diff_now = two_distance*len(sale_price_list) if len(sale_price_list) >0 else sale_buy_diff\n        sale_buy_diff_sale = two_distance if len(sale_price_list) > 0 else sale_buy_diff\n        # sale_price_last = float(sale_price_list[len(sale_price_list)-1]) if len(sale_price_list) >0 else base_price\n        # buy_price_last = float(buy_price_list[len(buy_price_list)-1]) if len(buy_price_list) >0 else base_price\n        sale_price_last = float(sale_price_list[0]) if len(sale_price_list) > 0 and float(sale_price_list[0]) > base_price else base_price\n        buy_price_last = float(buy_price_list[0]) if len(buy_price_list) > 0 and float(buy_price_list[0]) < base_price else base_price\n        #判断当前价格是否满足 卖出的价格请求\n        if float(data_depth_bids.Price) - sale_price_last > sale_buy_diff_sale and float(data_depth_bids.Amount) > trade_amount * 1.5:\n            Log(\"当前卖价：\",str(data_depth_bids.Price),\"订单中最高卖价：\",str(sale_price_last),\"生成卖单\")\n            trade_infor['price'] = float(data_depth_bids.Price)\n            trade_infor['trade_type'] = 'sale'\n        #判断当前价格是否满足 买入的价格请求\n        if  buy_price_last - float(data_depth_asks.Price) > sale_buy_diff_now and float(data_depth_bids.Amount) > trade_amount * 1.5:\n            #Log(\"当前买价：\", str(data_depth_asks.Price), \"订单中最高买价：\", str(sale_price_last),\"生成买单\")\n            trade_infor['price'] = float(data_depth_bids.Price)\n            trade_infor['trade_type'] = 'buy'\n        #判断当前价格是否破格，破格则置空买卖信息\n        if float(data_depth_bids.Price) - sale_price_max > 0 or buy_price_min - float(data_depth_asks.Price) > 0:\n            trade_infor['price'] = 0\n            trade_infor['trade_type'] = ''\n        timestr = (datetime.datetime.now()).strftime('%Y-%m-%d %H:%M:%S')\n        Log(trade_infor,\"...time：\",timestr)\n        if trade_infor['price'] != 0:\n            #Log(trade_infor,\"...time：\",timestr)\n            pass\n        return trade_infor\n\n    #根据委托信息生成买卖价格列表\n    def get_trade_price_list(self,symbol):\n        sale_list = []\n        buy_list = []\n        #获取所有的交易记录，根据不同的类型 分配到 买卖列表中\n        orders = exchange.GetOrders()\n        for i in range(len(orders)):\n            if orders[i].Type == 1:\n                sale_price = float(orders[i].Price)\n                sale_price_bak = copy.deepcopy(sale_price)\n                sale_list.append(sale_price_bak)\n            if orders[i].Type == 0:\n                buy_price = float(orders[i].Price)\n                buy_price_bak = copy.deepcopy(buy_price)\n                buy_list.append(buy_price_bak)\n        #判断为0的数组进处理\n        if len(sale_list) == 0:\n            for i in range(len(buy_list)):\n                sale_list.append(float('%.6f' % (buy_list[i] + sale_buy_diff)))\n        if len(buy_list) == 0:\n            for i in range(len(sale_list)):\n                buy_list.append(float('%.6f' % (sale_list[i] - sale_buy_diff)))\n        trade_price_list = [sale_list,buy_list]\n        return trade_price_list\n\n    #网格交易入口：\n    def grid_trade_start(self,symbol):\n        #进行状态获取，上涨/下跌\n        # trend_status = self.kline_trend_check(symbol)\n        \n        #获取可否进行交易\n        trade_infor = self.make_trade_check(symbol)\n        #进行判断是否交易，判断是否可以卖出\n        # if trend_status == 'is_up' and trade_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\n            buy_price = float('%.6f' % (trade_infor['price'] - sale_buy_diff))\n            #调用下单功能,先调用卖，再调用买\n            order_id = exchange.Sell(trade_infor['price'], trade_amount)\n            #Log('order_id:',order_id)\n            #检查下单是否成功，不成功，则直接返回\n            if order_id is None:\n                Log(\"下单失败，等待600s继续.........\")\n                sleep(600)\n                return 0\n            #检查主交易是否成功：判断卖单单是否交易成功,交易成功则进行买单下单\n            for i in range(100):\n                sale_orders = exchange.GetOrder(order_id)\n                #Log('sale_orders:',sale_orders)\n                if sale_orders.Status == 1:\n                    #如果卖单已成交，则进行买单提交\n                    exchange.Buy(buy_price, trade_amount)\n                    return 0\n                sleep(10)\n            #如果循环1000次还未成交，则取消订单\n            exchange.CancelOrder(order_id)\n        # 进行判断是否交易，判断是否可以买入\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'buy':\n            sale_price = float('%.6f' % (trade_infor['price'] + sale_buy_diff))\n            # 调用下单功能，先调用买入，再调用卖出\n            order_id = exchange.Buy(trade_infor['price'], trade_amount)\n            # 检查下单是否成功，不成功，则直接返回\n            if order_id is None:\n                #Log(\"下单失败，等待600s继续.........\")\n                sleep(600)\n                return 0\n            # 检查主交易是否成功：判断买单是否交易成功,交易成功则进行卖单下单\n            for i in range(100):\n                buy_orders = exchange.GetOrder(order_id)\n                if buy_orders.Status == 1:\n                    # 如果买单已成交，则进行卖单提交\n                    exchange.Sell(sale_price, trade_amount)\n                    return 0\n                sleep(10)\n            # 如果循环1000次还未成交，则取消订单\n            exchange.CancelOrder(order_id)\n\n    #进行循环调用\n    def grid_trade_cycle(self,symbol):\n        cycle_num = 0\n        while(True):\n            timestr = (datetime.datetime.now()).strftime('%H%M%S')\n            self.grid_trade_start(symbol)\n            sleep(10)\n            cycle_num = cycle_num + 1\n            if cycle_num % 100 == 0:\n                account_infor = exchange.GetAccount()\n                Log(\"当前用户的账号信息：%s,....当前已循环检查次数：%s\"%(account_infor,str(cycle_num)))\n\ndef main():\n    Log(exchange.GetAccount())\n    Log(\"测试\")\n    fmz_market_instances = fmz_market()\n    fmz_market_instances.grid_trade_cycle(100)\n    #order_id = exchange.Sell(10000,1)",
        "strategy_description": "策略名称: 暴雪网格-724小时交易机器人每日更新实盘效果\n\n'''\n主要是使用发明者量化API进行网格买卖，当前只支持单品网格买卖\n'''\nfrom time import sleep\nimport datetime,copy\n\nsale_price_list = [] #卖出的价格列表\nbuy_price_list = []  #买入的价格列表\n\nclass fmz_market():\n    def get_data_depth(self):\n        data_depth = exchange.GetDepth()\n        return data_depth\n\n\n\n    #检查当前是否可以进行买卖操作\n    def make_trade_check(self,symbol):\n        trade_infor = {'price':0,'trade_type':''}\n        #进行买卖列表判断，先更新交易记录列表\n        trade_price_list = self.get_trade_price_list(symbol)\n        sale_price_list = trade_price_list[0]\n        buy_price_list = trade_price_list[1]\n        #获取深度数据\n        data_depth = self.get_data_depth()\n        #买单列表：\n        data_depth_bids = data_depth.Bids[0]\n        #卖单列表：\n        data_depth_asks = data_depth.Asks[0]\n        #如果买入记录不为空\n        sale_buy_diff_now = two_distance*len(sale_price_list) if len(sale_price_list) >0 else sale_buy_diff\n        sale_buy_diff_sale = two_distance if len(sale_price_list) > 0 else sale_buy_diff\n        # sale_price_last = float(sale_price_list[len(sale_price_list)-1]) if len(sale_price_list) >0 else base_price\n        # buy_price_last = float(buy_price_list[len(buy_price_list)-1]) if len(buy_price_list) >0 else base_price\n        sale_price_last = float(sale_price_list[0]) if len(sale_price_list) > 0 and float(sale_price_list[0]) > base_price else base_price\n        buy_price_last = float(buy_price_list[0]) if len(buy_price_list) > 0 and float(buy_price_list[0]) < base_price else base_price\n        #判断当前价格是否满足 卖出的价格请求\n        if float(data_depth_bids.Price) - sale_price_last > sale_buy_diff_sale and float(data_depth_bids.Amount) > trade_amount * 1.5:\n            Log(\"当前卖价：\",str(data_depth_bids.Price),\"订单中最高卖价：\",str(sale_price_last),\"生成卖单\")\n            trade_infor['price'] = float(data_depth_bids.Price)\n            trade_infor['trade_type'] = 'sale'\n        #判断当前价格是否满足 买入的价格请求\n        if  buy_price_last - float(data_depth_asks.Price) > sale_buy_diff_now and float(data_depth_bids.Amount) > trade_amount * 1.5:\n            #Log(\"当前买价：\", str(data_depth_asks.Price), \"订单中最高买价：\", str(sale_price_last),\"生成买单\")\n            trade_infor['price'] = float(data_depth_bids.Price)\n            trade_infor['trade_type'] = 'buy'\n        #判断当前价格是否破格，破格则置空买卖信息\n        if float(data_depth_bids.Price) - sale_price_max > 0 or buy_price_min - float(data_depth_asks.Price) > 0:\n            trade_infor['price'] = 0\n            trade_infor['trade_type'] = ''\n        timestr = (datetime.datetime.now()).strftime('%Y-%m-%d %H:%M:%S')\n        Log(trade_infor,\"...time：\",timestr)\n        if trade_infor['price'] != 0:\n            #Log(trade_infor,\"...time：\",timestr)\n            pass\n        return trade_infor\n\n    #根据委托信息生成买卖价格列表\n    def get_trade_price_list(self,symbol):\n        sale_list = []\n        buy_list = []\n        #获取所有的交易记录，根据不同的类型 分配到 买卖列表中\n        orders = exchange.GetOrders()\n        for i in range(len(orders)):\n            if orders[i].Type == 1:\n                sale_price = float(orders[i].Price)\n                sale_price_bak = copy.deepcopy(sale_price)\n                sale_list.append(sale_price_bak)\n            if orders[i].Type == 0:\n                buy_price = float(orders[i].Price)\n                buy_price_bak = copy.deepcopy(buy_price)\n                buy_list.append(buy_price_bak)\n        #判断为0的数组进处理\n        if len(sale_list) == 0:\n            for i in range(len(buy_list)):\n                sale_list.append(float('%.6f' % (buy_list[i] + sale_buy_diff)))\n        if len(buy_list) == 0:\n            for i in range(len(sale_list)):\n                buy_list.append(float('%.6f' % (sale_list[i] - sale_buy_diff)))\n        trade_price_list = [sale_list,buy_list]\n        return trade_price_list\n\n    #网格交易入口：\n    def grid_trade_start(self,symbol):\n        #进行状态获取，上涨/下跌\n        # trend_status = self.kline_trend_check(symbol)\n        \n        #获取可否进行交易\n        trade_infor = self.make_trade_check(symbol)\n        #进行判断是否交易，判断是否可以卖出\n        # if trend_status == 'is_up' and trade_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\n            buy_price = float('%.6f' % (trade_infor['price'] - sale_buy_diff))\n            #调用下单功能,先调用卖，再调用买\n            order_id = exchange.Sell(trade_infor['price'], trade_amount)\n            #Log('order_id:',order_id)\n            #检查下单是否成功，不成功，则直接返回\n            if order_id is None:\n                Log(\"下单失败，等待600s继续.........\")\n                sleep(600)\n                return 0\n            #检查主交易是否成功：判断卖单单是否交易成功,交易成功则进行买单下单\n            for i in range(100):\n                sale_orders = exchange.GetOrder(order_id)\n                #Log('sale_orders:',sale_orders)\n                if sale_orders.Status == 1:\n                    #如果卖单已成交，则进行买单提交\n                    exchange.Buy(buy_price, trade_amount)\n                    return 0\n                sleep(10)\n            #如果循环1000次还未成交，则取消订单\n            exchange.CancelOrder(order_id)\n        # 进行判断是否交易，判断是否可以买入\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'buy':\n            sale_price = float('%.6f' % (trade_infor['price'] + sale_buy_diff))\n            # 调用下单功能，先调用买入，再调用卖出\n            order_id = exchange.Buy(trade_infor['price'], trade_amount)\n            # 检查下单是否成功，不成功，则直接返回\n            if order_id is None:\n                #Log(\"下单失败，等待600s继续.........\")\n                sleep(600)\n                return 0\n            # 检查主交易是否成功：判断买单是否交易成功,交易成功则进行卖单下单\n            for i in range(100):\n                buy_orders = exchange.GetOrder(order_id)\n                if buy_orders.Status == 1:\n                    # 如果买单已成交，则进行卖单提交\n                    exchange.Sell(sale_price, trade_amount)\n                    return 0\n                sleep(10)\n            # 如果循环1000次还未成交，则取消订单\n            exchange.CancelOrder(order_id)\n\n    #进行循环调用\n    def grid_trade_cycle(self,symbol):\n        cycle_num = 0\n        while(True):\n            timestr = (datetime.datetime.now()).strftime('%H%M%S')\n            self.grid_trade_start(symbol)\n            sleep(10)\n            cycle_num = cycle_num + 1\n            if cycle_num % 100 == 0:\n                account_infor = exchange.GetAccount()\n                Log(\"当前用户的账号信息：%s,....当前已循环检查次数：%s\"%(account_infor,str(cycle_num)))\n\ndef main():\n    Log(exchange.GetAccount())\n    Log(\"测试\")\n    fmz_market_instances = fmz_market()\n    fmz_market_instances.grid_trade_cycle(100)\n    #order_id = exchange.Sell(10000,1)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/175807\n\n> Last Modified\n\n2020-03-12 13:53:43"
    },
    {
        "strategy_id": "103_期现成对下单_Public",
        "strategy_code": "python\ndef main():\n\texchange.SetContractType(ContractSwap)\n\tTickerSwap = exchange.GetTicker()\n\tTickerSwap['BuyAmount'] = TickerSwap['Info']['result']['best_bid_amount']\n\tTickerSwap['SellAmount'] = TickerSwap['Info']['result']['best_ask_amount']\n\texchange.SetContractType(ContractFuture)\n\tTickerFuture = exchange.GetTicker()\n\tTickerFuture['BuyAmount'] = TickerFuture['Info']['result']['best_bid_amount']\n\tTickerFuture['SellAmount'] = TickerFuture['Info']['result']['best_ask_amount']\n\n\tDiff = _N(TickerFuture['Buy'] - TickerSwap['Sell'],2)\n\n\tMsg = ''\n\tMsg += str(ContractSwap) +' '+ str(TickerSwap['Sell']) +' '+ str(TickerSwap['SellAmount'])+ '\\n'\n\tMsg += str(ContractFuture) +' '+ str(TickerFuture['Buy']) +' '+ str(TickerFuture['BuyAmount']) + '\\n'\n\tMsg += '差价: ' + str(Diff) + '\\n'\n\n\tif Diff <= DiffMin:\n\t\treturn '差价为 ' + str(_N(Diff,2)) + ' 小于设定价差 '+str(DiffMin)+'，不下单' + '\\n\\n附加信息\\n' +Msg\n\n\tif TickerFuture['BuyAmount'] < Amount or TickerFuture['SellAmount'] < Amount:\n\t\treturn '某方向挂单量小于设定下单量 '+str(Amount)+'，不下单' + '\\n\\n附加信息\\n' +Msg\n\n\tif not RealTrade:\n\t\treturn '非真实交易' + '\\n' + Msg\n\n\texchange.SetContractType(ContractSwap)\n\texchange.SetDirection(\"buy\")\n\tBuyOrderId = exchange.Buy(TickerSwap['Sell'] + 0.2, Amount)\n\n\texchange.SetContractType(ContractFuture)\n\texchange.SetDirection(\"sell\")\n\tSellOrderId = exchange.Sell(TickerFuture['Buy'] - 0.2, Amount)\n\n\tBuyOrder = exchange.GetOrder(BuyOrderId)\n\tSellOrder = exchange.GetOrder(SellOrderId)\n\n\tTradeMsg = '交易完成\\n'\n\tTradeMsg += '买单 ' + str(BuyOrder['ContractType']) + ' ' + str(BuyOrder['Price']) + ' ' + str(BuyOrder['DealAmount']) + '/' + str(BuyOrder['Amount']) + '\\n'\n\tTradeMsg += '卖单 ' + str(SellOrder['ContractType']) + ' ' + str(SellOrder['Price']) + ' ' + str(SellOrder['DealAmount']) + '/' + str(SellOrder['Amount']) + '\\n'\n\tTradeMsg += '\\n\\n附加信息\\n' +Msg\n\treturn TradeMsg",
        "strategy_description": "策略名称: 期现成对下单_Public\n\n未找到描述"
    },
    {
        "strategy_id": "104_本地存储",
        "strategy_code": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# encoding: utf-8\n#\n#  Persistent Storage for FMZ\n#\n# Copyright 2020 FawkesPan\n# Contact : i@fawkex.me / Telegram@FawkesPan\n#\n#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE \n#                    Version 2, December 2004 \n#\n# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net> \n#\n# Everyone is permitted to copy and distribute verbatim or modified \n# copies of this license document, and changing it is allowed as long \n# as the name is changed. \n#\n#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE \n#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION \n#\n#  0. You just DO WHAT THE FUCK YOU WANT TO.\n#\n\nclass PersistentStorage:\n    \n    def __init__(self):\n        keys = _G('__keys__')\n        if isinstance(keys, list):\n            self.__keys__ = keys\n        else:\n            self.__keys__ = []\n            self.__setitem__('__keys__', self.__keys__)\n        return\n    \n    def _add_key(self, key):\n        if key == '__keys__':\n            return\n        self.__keys__.append(key)\n        self.__setitem__('__keys__', self.__keys__)\n        return\n        \n    def _del_key(self, key):\n        if key == '__keys__':\n            return\n        if key in self.__keys__:\n            del self.__keys__[self.__keys__.index(key)]\n        self.__setitem__('__keys__', self.__keys__)\n        return\n    \n    def __setitem__(self, key, value):\n        _G(key, value)\n        self._add_key(key)\n        return\n    \n    def __delitem__(self, key):\n        _G(key, None)\n        self._del_key(key)\n        return\n    \n    def __getitem__(self, key):\n        return _G(key)\n\n    def keys(self):\n        return self.__keys__\n        \n\next.PersistentStorage = PersistentStorage",
        "strategy_description": "策略名称: 本地存储\n\nFMZ本地存储调用简化工具\n关于本地存储，请访问[FMZ API文档](https://www.fmz.com/api)"
    },
    {
        "strategy_id": "105_检查https-quantla-Argus-是否正常",
        "strategy_code": "python\nimport urllib2\ndef main():\n    Log(\"开始检查@\")\n    while True:\n        try:\n            urllib2.urlopen(\"https://quant.la/API/Argus/predict\", timeout=15)\n            Log(\"服务正常\")\n        except:\n            Log(_D(),\" 服务异常@\")\n        Sleep(10*60*1000)",
        "strategy_description": "策略名称: 检查https-quantla-Argus-是否正常\n\n未找到描述"
    },
    {
        "strategy_id": "106_测试多图表展示Python版",
        "strategy_code": "python\nimport random\nimport time\ndef main():\n    cfgA = {\n        \"title\" : {\"text\" : \"盘口图表\"},\n        \"xAxis\" : {\n            \"type\" : \"datetime\"\n        }, \n        \"series\" : [{\n            \"name\" : \"买一\", \n            \"data\" : [],        \n        },{\n            \"name\" : \"卖一\",\n            \"data\" : [],\n        }]\n    }\n\n    cfgB = {\n        \"title\" : {\"text\" : \"差价图\"},\n        \"xAxis\" : {\n            \"type\" : \"datetime\"\n        },\n        \"series\" : [{\n            \"name\" : \"差价\",\n            \"type\" : \"column\",\n            \"data\" : [],\n        }]\n    }\n\n    cfgC = {\n        \"__isStock\" : False,\n        \"title\" : {\n            \"text\" : \"饼图\"\n        },\n        \"series\" : [{\n            \"type\" : \"pie\",\n            \"name\" : \"one\",\n            \"data\" : [\n                [\"A\", 25],\n                [\"B\", 25],\n                [\"C\", 25],\n                [\"D\", 25],\n            ]\n        }]\n    }\n\n    chart = Chart([cfgA, cfgB, cfgC])\n    chart.reset()\n    chart.add(3, {\n        \"name\" : \"ZZ\", \n        \"y\" : random.random() * 100\n    })\n\n\n    chart.update([cfgA, cfgB, cfgC])\n    chart.add(0, [_N(time.time() * 1000, 0), 50])\n    chart.add(1, [_N(time.time() * 1000, 0), 80])\n    chart.add(2, [_N(time.time() * 1000, 0), 90])\n    chart.add(3, {\n        \"name\" : \"ZZ\",\n        \"y\" : random.random() * 100\n    }, -1)",
        "strategy_description": "策略名称: 测试多图表展示Python版\n\n未找到描述"
    },
    {
        "strategy_id": "107_测试托管者与交易所服务器的真实网络延迟-支持同时测试多个交易所",
        "strategy_code": "python\n# Contact : ck@xueqiubot.com / WeChat@stay37\n\nimport time\nimport numpy as np\n\n\ndef test():\n    #延迟数据接收器\n    delay_list = []\n    for i in range(len(exchanges)):\n        delay_list.append([])\n    while True:\n        #延迟数据获取\n        for i in range(len(exchanges)):\n            send_t = time.time()\n            ticker = exchanges[i].GetTicker()\n            delay_list[i].append(round((time.time() - send_t) * 1000 , 2))\n        #数据输出 \n        delay_table = {\"type\":'table',\"title\":'延迟数据',\"cols\": ['账号序号','最近一次延迟','平均延迟','已测试次数'],\"rows\":[]}\n        for i in range(len(delay_list)):\n            delay_table['rows'].append([i + 1, str(delay_list[i][-1])+' ms', str(round(np.mean(delay_list[i]) , 2)) + ' ms', len(delay_list[i])])\n        LogStatus(\"输出的延迟为：发送一次get_ticker请求到获取到数据的真实时间\" + \"\\n\" + \"`\" + json.dumps(delay_table) + \"`\")\n        time.sleep(0.05)\n\n                \ndef main():\n    for i in range(len(exchanges)):\n        exchanges[i].SetContractType('swap')\n    test()",
        "strategy_description": "策略名称: 测试托管者与交易所服务器的真实网络延迟-支持同时测试多个交易所\n\nimport time\nimport numpy as np\n\n\ndef test():\n    #延迟数据接收器\n    delay_list = []\n    for i in range(len(exchanges)):\n        delay_list.append([])\n    while True:\n        #延迟数据获取\n        for i in range(len(exchanges)):\n            send_t = time.time()\n            ticker = exchanges[i].GetTicker()\n            delay_list[i].append(round((time.time() - send_t) * 1000 , 2))\n        #数据输出 \n        delay_table = {\"type\":'table',\"title\":'延迟数据',\"cols\": ['账号序号','最近一次延迟','平均延迟','已测试次数'],\"rows\":[]}\n        for i in range(len(delay_list)):\n            delay_table['rows'].append([i + 1, str(delay_list[i][-1])+' ms', str(round(np.mean(delay_list[i]) , 2)) + ' ms', len(delay_list[i])])\n        LogStatus(\"输出的延迟为：发送一次get_ticker请求到获取到数据的真实时间\" + \"\\n\" + \"`\" + json.dumps(delay_table) + \"`\")\n        time.sleep(0.05)\n\n                \ndef main():\n    for i in range(len(exchanges)):\n        exchanges[i].SetContractType('swap')\n    test()\n                \n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/236426\n\n> Last Modified\n\n2021-01-10 19:22:52"
    },
    {
        "strategy_id": "108_海龟",
        "strategy_code": "python\nimport json\nimport time\n\nclass Turtle:\n    def __init__(self, account=None, donchian_channel_open_position=20, donchian_channel_stop_profit=10, atr_day_length=20, max_risk_ratio=0.5):\n        self.donchian_channel_open_position = donchian_channel_open_position  # 唐奇安通道的天数周期(开仓)\n        self.donchian_channel_stop_profit = donchian_channel_stop_profit  # 唐奇安通道的天数周期(止盈)\n        self.atr_day_length = atr_day_length  # ATR计算所用天数\n        self.max_risk_ratio = max_risk_ratio  # 最高风险度\n        self.state = {\n            \"position\": 0,  # 本策略净持仓数(正数表示多头，负数表示空头，0表示空仓)\n            \"last_price\": float(\"nan\"),  # 上次调仓价\n        }\n        positions = _C(exchange.GetPosition)\n        self.equity=0\n        for position in positions:\n            if position[\"Type\"]==PD_LONG:\n                self.state[\"position\"]=position[\"Amount\"]\n                self.state[\"last_price\"] = position[\"Price\"]\n                self.equity+=position[\"Margin\"]\n            elif position[\"Type\"]==PD_SHORT:\n                self.state[\"position\"]=-position[\"Amount\"]\n                self.state[\"last_price\"] = position[\"Price\"]\n                self.equity+=position[\"Margin\"]\n        self.account = _C(exchange.GetAccount)\n        self.equity += self.account[\"Stocks\"]+self.account[\"FrozenStocks\"]\n        #Log(self.equity)\n\n        self.n = 0  # 平均真实波幅(N值)\n        self.unit = 0  # 买卖单位\n        self.donchian_channel_high = 0  # 唐奇安通道上轨\n        self.donchian_channel_low = 0  # 唐奇安通道下轨\n        # 由于ATR是路径依赖函数，因此使用更长的数据序列进行计算以便使其值稳定下来\n        self.klines = exchange.GetRecords()\n\n    def recalc_paramter(self):\n        # 平均真实波幅(N值)\n        self.equity=0\n        positions = _C(exchange.GetPosition)\n        for position in positions:\n            if position[\"Type\"]==PD_LONG:\n                self.equity+=position[\"Margin\"]\n            elif position[\"Type\"]==PD_SHORT:\n                self.equity+=position[\"Margin\"]\n        self.account = _C(exchange.GetAccount)\n        self.equity += self.account[\"Stocks\"]+self.account[\"FrozenStocks\"]\n        #Log(self.equity)\n        records = _C(exchange.GetRecords)\n        self.n =TA.ATR(records, self.atr_day_length)[-1]\n        # 买卖单位\n        self.current_price = records[-1][\"Close\"]\n        self.unit = int((self.equity * 0.01*self.current_price*self.current_price) / (100 * self.n))\n        # 唐奇安通道上轨：前N个交易日的最高价\n        #Log(records)\n        self.donchian_channel_high =TA.Highest(records, self.donchian_channel_open_position , 'High') #唐奇安通道上轨：前N个交易日的最高价\n        self.donchian_channel_high =TA.Highest(records, 55 , 'High')\n        # 唐奇安通道下轨：前N个交易日的最低价\n        self.donchian_channel_low = TA.Lowest(records, self.donchian_channel_open_position , 'Low')\n        self.donchian_channel_low = TA.Lowest(records, 55 , 'Low')\n        #Log(\"唐其安通道上下轨: %f, %f\" % (self.donchian_channel_high, self.donchian_channel_low))\n        \n        self.stop_high = TA.Highest(records, self.donchian_channel_stop_profit , 'High') \n        self.stop_high = TA.Highest(records, 20 , 'High') \n        self.stop_low = TA.Highest(records, self.donchian_channel_stop_profit , 'Low') \n        self.stop_low = TA.Highest(records, 20, 'Low') \n\n        \n        boll = TA.BOLL(records, 50, 2)\n        self.up_line = boll[0][-1]\n        self.mid_line = boll[1][-1]\n        self.down_line = boll[2][-1]\n        close1 = records[-2]['Close']  # 最新收盘价\n        close30 = records[-30]['Close']  # 前30根K线的收盘价\n        hh30 = TA.Highest(records, 30, 'High')  # 最近30根K线的最高价\n        ll30 = TA.Lowest(records, 30, 'Low')  # 最近30根K线的最低价\n        self.cmi = abs((close1 - close30) / (hh30 - ll30)) * 100  # 计算市场波动指数\n\n        return True\n    def set_position(self, pos):\n        self.state[\"position\"] = pos\n        self.state[\"last_price\"] = self.current_price\n        positions = _C(exchange.GetPosition)\n        sell_amount =0\n        long_amount = 0\n        for position in positions:\n            if position[\"Type\"]==PD_LONG:\n                long_amount=position[\"Amount\"]\n            elif position[\"Type\"]==PD_SHORT:\n                sell_amount=position[\"Amount\"]\n\n        if pos>0:\n            if sell_amount>0:\n                exchange.SetDirection(\"closesell\")\n                exchange.Buy(self.current_price*1.005,sell_amount)\n            if pos>long_amount:\n                exchange.SetDirection(\"buy\")\n                exchange.Buy(self.current_price*1.005,pos-long_amount)\n            elif pos<long_amount:\n                exchange.SetDirection(\"closebuy\")\n                exchange.Sell(self.current_price*0.995,long_amount-pos)\n        elif pos<0:\n            pos=-pos \n            if long_amount>0:\n                exchange.SetDirection(\"closebuy\")\n                exchange.Sell(self.current_price*0.995,long_amount)\n            if pos>sell_amount:\n                exchange.SetDirection(\"sell\")\n                exchange.Sell(self.current_price*0.995,pos-sell_amount)\n            elif pos<sell_amount:\n                exchange.SetDirection(\"closesell\")\n                exchange.Buy(self.current_price*1.005,sell_amount-pos)\n        else:\n            if long_amount>0:\n                exchange.SetDirection(\"closebuy\")\n                exchange.Sell(self.current_price*0.995,long_amount)      \n            if sell_amount>0:\n                exchange.SetDirection(\"closesell\")\n                exchange.Buy(self.current_price*1.005,sell_amount)                \n        #self.target_pos.set_target_volume(self.state[\"position\"])\n    def try_open(self):\n        \"\"\"开仓策略\"\"\"\n        while self.state[\"position\"] == 0:\n            self.recalc_paramter()\n            #Log(\"最新价: %f\" % self.current_price)\n            if self.current_price > self.donchian_channel_high:  # 当前价>唐奇安通道上轨，买入1个Unit；(持多仓)\n            #if self.cmi>20 and self.current_price>self.up_line:\n                #Log(\"当前价>唐奇安通道上轨，买入1个Unit(持多仓): %d 手\" % self.unit)\n                self.set_position(self.state[\"position\"] + self.unit)\n            elif self.current_price < self.donchian_channel_low:  # 当前价<唐奇安通道下轨，卖出1个Unit；(持空仓)\n            #elif self.cmi>20 and self.current_price<self.down_line:\n                #Log(\"当前价<唐奇安通道下轨，卖出1个Unit(持空仓): %d 手\" % self.unit)\n                self.set_position(self.state[\"position\"] - self.unit)\n    def try_close(self):\n        \"\"\"交易策略\"\"\"\n        while self.state[\"position\"] != 0:\n            if True:\n                self.recalc_paramter()\n                Log(\"最新价: \", self.current_price)\n                #if self.cmi<20:\n                #    self.set_position(0)\n                if self.state[\"position\"] > 0:  # 持多单\n                    # 加仓策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了0.5N，就再加一个Unit的多仓,并且风险度在设定范围内(以防爆仓)\n                    if self.current_price >= self.state[\"last_price\"] + 0.5 * self.n and self.state[\"position\"] + self.unit<=4*self.unit:\n                        Log(\"加仓:加1个Unit的多仓\")\n                        self.set_position(self.state[\"position\"] + self.unit)\n                    # 止损策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了2N，就卖出全部头寸止损\n                    elif self.current_price <= self.state[\"last_price\"] - 2 * self.n:\n                        Log(\"止损:卖出全部头寸\")\n                        self.set_position(0)\n                    # 止盈策略: 如果是多仓且行情最新价跌破了10日唐奇安通道的下轨，就清空所有头寸结束策略,离场\n                    if self.current_price <= self.stop_low:\n                    #if self.current_price<self.mid_line:\n                        Log(\"止盈:清空所有头寸结束策略,离场\")\n                        self.set_position(0)\n                elif self.state[\"position\"] < 0:  # 持空单\n                    # 加仓策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了0.5N，就再加一个Unit的空仓,并且风险度在设定范围内(以防爆仓)\n                    if self.current_price <= self.state[\"last_price\"] - 0.5 * self.n and (-self.state[\"position\"]) + self.unit<=4*self.unit:\n                        Log(\"加仓:加1个Unit的空仓\")\n                        self.set_position(self.state[\"position\"] - self.unit)\n                    # 止损策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了2N，就平仓止损\n                    elif self.current_price >= self.state[\"last_price\"] + 2 * self.n:\n                        Log(\"止损:卖出全部头寸\")\n                        self.set_position(0)\n                    # 止盈策略: 如果是空仓且行情最新价升破了10日唐奇安通道的上轨，就清空所有头寸结束策略,离场\n                    if self.current_price >= self.stop_high:\n                    #if self.current_price>self.mid_line:\n                        Log(\"止盈:清空所有头寸结束策略,离场\")\n                        self.set_position(0)\n    def strategy(self):\n        \"\"\"海龟策略\"\"\"\n        Log(\"等待K线及账户数据...\")\n        while not self.recalc_paramter():\n            raise Exception(\"获取数据失败，请确认行情连接正常并已经登录交易账户\")\n        while True:\n            self.try_open()\n            self.try_close()\n\n\ndef main():\n    exchange.SetContractType(\"quarter\")\n    turtle = Turtle(donchian_channel_open_position=Donchian_open,donchian_channel_stop_profit=Donchian_stop,atr_day_length=Atr)\n    Log(\"策略开始运行\")\n\n    Log(\"当前持仓数: %d, 上次调仓价: %f\" % (turtle.state[\"position\"], turtle.state[\"last_price\"]))\n    turtle.strategy()",
        "strategy_description": "策略名称: 海龟\n\nself.donchian_channel_stop_profit = donchian_channel_stop_profit  # 唐奇安通道的天数周期(止盈)\n        self.atr_day_length = atr_day_length  # ATR计算所用天数\n        self.max_risk_ratio = max_risk_ratio  # 最高风险度\n        self.state = {\n            \"position\": 0,  # 本策略净持仓数(正数表示多头，负数表示空头，0表示空仓)\n            \"last_price\": float(\"nan\"),  # 上次调仓价\n        }\n        positions = _C(exchange.GetPosition)\n        self.equity=0\n        for position in positions:\n            if position[\"Type\"]==PD_LONG:\n                self.state[\"position\"]=position[\"Amount\"]\n                self.state[\"last_price\"] = position[\"Price\"]\n                self.equity+=position[\"Margin\"]\n            elif position[\"Type\"]==PD_SHORT:\n                self.state[\"position\"]=-position[\"Amount\"]\n                self.state[\"last_price\"] = position[\"Price\"]\n                self.equity+=position[\"Margin\"]\n        self.account = _C(exchange.GetAccount)\n        self.equity += self.account[\"Stocks\"]+self.account[\"FrozenStocks\"]\n        #Log(self.equity)\n\n        self.n = 0  # 平均真实波幅(N值)\n        self.unit = 0  # 买卖单位\n        self.donchian_channel_high = 0  # 唐奇安通道上轨\n        self.donchian_channel_low = 0  # 唐奇安通道下轨\n        # 由于ATR是路径依赖函数，因此使用更长的数据序列进行计算以便使其值稳定下来\n        self.klines = exchange.GetRecords()\n\n    def recalc_paramter(self):\n        # 平均真实波幅(N值)\n        self.equity=0\n        positions = _C(exchange.GetPosition)\n        for position in positions:\n            if position[\"Type\"]==PD_LONG:\n                self.equity+=position[\"Margin\"]\n            elif position[\"Type\"]==PD_SHORT:\n                self.equity+=position[\"Margin\"]\n        self.account = _C(exchange.GetAccount)\n        self.equity += self.account[\"Stocks\"]+self.account[\"FrozenStocks\"]\n        #Log(self.equity)\n        records = _C(exchange.GetRecords)\n        self.n =TA.ATR(records, self.atr_day_length)[-1]\n        # 买卖单位\n        self.current_price = records[-1][\"Close\"]\n        self.unit = int((self.equity * 0.01*self.current_price*self.current_price) / (100 * self.n))\n        # 唐奇安通道上轨：前N个交易日的最高价\n        #Log(records)\n        self.donchian_channel_high =TA.Highest(records, self.donchian_channel_open_position , 'High') #唐奇安通道上轨：前N个交易日的最高价\n        self.donchian_channel_high =TA.Highest(records, 55 , 'High')\n        # 唐奇安通道下轨：前N个交易日的最低价\n        self.donchian_channel_low = TA.Lowest(records, self.donchian_channel_open_position , 'Low')\n        self.donchian_channel_low = TA.Lowest(records, 55 , 'Low')\n        #Log(\"唐其安通道上下轨: %f, %f\" % (self.donchian_channel_high, self.donchian_channel_low))\n        \n        self.stop_high = TA.Highest(records, self.donchian_channel_stop_profit , 'High') \n        self.stop_high = TA.Highest(records, 20 , 'High') \n        self.stop_low = TA.Highest(records, self.donchian_channel_stop_profit , 'Low') \n        self.stop_low = TA.Highest(records, 20, 'Low') \n\n        \n        boll = TA.BOLL(records, 50, 2)\n        self.up_line = boll[0][-1]\n        self.mid_line = boll[1][-1]\n        self.down_line = boll[2][-1]\n        close1 = records[-2]['Close']  # 最新收盘价\n        close30 = records[-30]['Close']  # 前30根K线的收盘价\n        hh30 = TA.Highest(records, 30, 'High')  # 最近30根K线的最高价\n        ll30 = TA.Lowest(records, 30, 'Low')  # 最近30根K线的最低价\n        self.cmi = abs((close1 - close30) / (hh30 - ll30)) * 100  # 计算市场波动指数\n\n        return True\n    def set_position(self, pos):\n        self.state[\"position\"] = pos\n        self.state[\"last_price\"] = self.current_price\n        positions = _C(exchange.GetPosition)\n        sell_amount =0\n        long_amount = 0\n        for position in positions:\n            if position[\"Type\"]==PD_LONG:\n                long_amount=position[\"Amount\"]\n            elif position[\"Type\"]==PD_SHORT:\n                sell_amount=position[\"Amount\"]\n\n        if pos>0:\n            if sell_amount>0:\n                exchange.SetDirection(\"closesell\")\n                exchange.Buy(self.current_price*1.005,sell_amount)\n            if pos>long_amount:\n                exchange.SetDirection(\"buy\")\n                exchange.Buy(self.current_price*1.005,pos-long_amount)\n            elif pos<long_amount:\n                exchange.SetDirection(\"closebuy\")\n                exchange.Sell(self.current_price*0.995,long_amount-pos)\n        elif pos<0:\n            pos=-pos \n            if long_amount>0:\n                exchange.SetDirection(\"closebuy\")\n                exchange.Sell(self.current_price*0.995,long_amount)\n            if pos>sell_amount:\n                exchange.SetDirection(\"sell\")\n                exchange.Sell(self.current_price*0.995,pos-sell_amount)\n            elif pos<sell_amount:\n                exchange.SetDirection(\"closesell\")\n                exchange.Buy(self.current_price*1.005,sell_amount-pos)\n        else:\n            if long_amount>0:\n                exchange.SetDirection(\"closebuy\")\n                exchange.Sell(self.current_price*0.995,long_amount)      \n            if sell_amount>0:\n                exchange.SetDirection(\"closesell\")\n                exchange.Buy(self.current_price*1.005,sell_amount)                \n        #self.target_pos.set_target_volume(self.state[\"position\"])\n    def try_open(self):\n        \"\"\"开仓策略\"\"\"\n        while self.state[\"position\"] == 0:\n            self.recalc_paramter()\n            #Log(\"最新价: %f\" % self.current_price)\n            if self.current_price > self.donchian_channel_high:  # 当前价>唐奇安通道上轨，买入1个Unit；(持多仓)\n            #if self.cmi>20 and self.current_price>self.up_line:\n                #Log(\"当前价>唐奇安通道上轨，买入1个Unit(持多仓): %d 手\" % self.unit)\n                self.set_position(self.state[\"position\"] + self.unit)\n            elif self.current_price < self.donchian_channel_low:  # 当前价<唐奇安通道下轨，卖出1个Unit；(持空仓)\n            #elif self.cmi>20 and self.current_price<self.down_line:\n                #Log(\"当前价<唐奇安通道下轨，卖出1个Unit(持空仓): %d 手\" % self.unit)\n                self.set_position(self.state[\"position\"] - self.unit)\n    def try_close(self):\n        \"\"\"交易策略\"\"\"\n        while self.state[\"position\"] != 0:\n            if True:\n                self.recalc_paramter()\n                Log(\"最新价: \", self.current_price)\n                #if self.cmi<20:\n                #    self.set_position(0)\n                if self.state[\"position\"] > 0:  # 持多单\n                    # 加仓策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了0.5N，就再加一个Unit的多仓,并且风险度在设定范围内(以防爆仓)\n                    if self.current_price >= self.state[\"last_price\"] + 0.5 * self.n and self.state[\"position\"] + self.unit<=4*self.unit:\n                        Log(\"加仓:加1个Unit的多仓\")\n                        self.set_position(self.state[\"position\"] + self.unit)\n                    # 止损策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了2N，就卖出全部头寸止损\n                    elif self.current_price <= self.state[\"last_price\"] - 2 * self.n:\n                        Log(\"止损:卖出全部头寸\")\n                        self.set_position(0)\n                    # 止盈策略: 如果是多仓且行情最新价跌破了10日唐奇安通道的下轨，就清空所有头寸结束策略,离场\n                    if self.current_price <= self.stop_low:\n                    #if self.current_price<self.mid_line:\n                        Log(\"止盈:清空所有头寸结束策略,离场\")\n                        self.set_position(0)\n                elif self.state[\"position\"] < 0:  # 持空单\n                    # 加仓策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了0.5N，就再加一个Unit的空仓,并且风险度在设定范围内(以防爆仓)\n                    if self.current_price <= self.state[\"last_price\"] - 0.5 * self.n and (-self.state[\"position\"]) + self.unit<=4*self.unit:\n                        Log(\"加仓:加1个Unit的空仓\")\n                        self.set_position(self.state[\"position\"] - self.unit)\n                    # 止损策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了2N，就平仓止损\n                    elif self.current_price >= self.state[\"last_price\"] + 2 * self.n:\n                        Log(\"止损:卖出全部头寸\")\n                        self.set_position(0)\n                    # 止盈策略: 如果是空仓且行情最新价升破了10日唐奇安通道的上轨，就清空所有头寸结束策略,离场\n                    if self.current_price >= self.stop_high:\n                    #if self.current_price>self.mid_line:\n                        Log(\"止盈:清空所有头寸结束策略,离场\")\n                        self.set_position(0)\n    def strategy(self):\n        \"\"\"海龟策略\"\"\"\n        Log(\"等待K线及账户数据...\")\n        while not self.recalc_paramter():\n            raise Exception(\"获取数据失败，请确认行情连接正常并已经登录交易账户\")\n        while True:\n            self.try_open()\n            self.try_close()\n\n\ndef main():\n    exchange.SetContractType(\"quarter\")\n    turtle = Turtle(donchian_channel_open_position=Donchian_open,donchian_channel_stop_profit=Donchian_stop,atr_day_length=Atr)\n    Log(\"策略开始运行\")\n\n    Log(\"当前持仓数: %d, 上次调仓价: %f\" % (turtle.state[\"position\"], turtle.state[\"last_price\"]))\n    turtle.strategy()\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/192353\n\n> Last Modified\n\n2020-03-23 14:44:24"
    },
    {
        "strategy_id": "109_海龟策略btc现货版",
        "strategy_code": "python\n'''backtest\nstart: 2019-01-01 00:00:00\nend: 2020-03-02 00:00:00\nperiod: 1d\nexchanges: [{\"eid\":\"OKEX\",\"currency\":\"BTC_USDT\",\"stocks\":0}]\nargs: [[\"fresh_rete\",24],[\"DC_range\",20],[\"atrlength\",14]]\n'''\n\n\nimport numpy as np\nimport pandas as pd\nimport datetime\n\n\ndata = {'ordertime':[],'id':[],'price':[]}\nhisorder = pd.DataFrame(data)\n    \ndef turtle():\n    #声明全局变量\n    global hisorder\n    \n    acct = exchange.GetAccount()\n\n    records=exchange.GetRecords(fresh_rete*60*60)\n\n    ticker = exchange.GetTicker()\n    \n\n    portfolio_value = acct.Balance+acct.FrozenBalance+(acct.Stocks+acct.FrozenStocks)*records[-1]['Close']\n    atr = TA.ATR(records, atrlength)[-1]\n    #计算得到unit大小\n    value = portfolio_value*trade_percent\n    unit =  min(round(value/atr,4),round(acct.Balance/(ticker['Last']+100),4))\n    #unit =  round(value/atr,2)\n\n    df = pd.DataFrame(records)\n    current_price = records[-1]['Close']\n    last_price = 0\n    if len(hisorder)!=0:\n        last_price = hisorder.iloc[-1]['price']\n    max_price = df[-DC_range:-2]['High'].max()\n    min_price = df[-int(DC_range/2):-2]['Low'].min() \n    \n    opensign = len(hisorder)==0 and current_price > max_price\n    \n\n    addsign = len(hisorder)!=0 and current_price > last_price + 0.5*atr\n\n\n    stopsign = len(hisorder)!=0 and current_price < min_price\n    \n    \n    closesign = len(hisorder)!=0 and current_price < (last_price - 2*atr)\n\n    \n#    if _D(records[-1]['Time']/1000) == '2020-01-25 00:00:00':\n#        Log(\"records[-1]\",records[-1])\n\n\n\n\n\n    if opensign | addsign:\n        if acct.Balance >= (ticker['Last']+10)*unit and unit >0:\n            id = exchange.Buy(ticker['Last']+10,unit)\n            orderinfo = exchange.GetOrder(id)\n            data = {'ordertime':_D(records[-1]['Time']/1000),'id':id,'price':records[-1]['Close']}\n            hisorder = hisorder.append(data,ignore_index=True)\n            Log('买入后，最新账户信息：', exchange.GetAccount())\n            Log(\"opensign\",opensign,\"addsign\",addsign)\n    #    else:\n    #        Log('余额已不足，请充值......', exchange.GetAccount())\n    if stopsign | closesign:\n        exchange.Sell(-1, acct.Stocks+acct.FrozenStocks)\n        data = {'ordertime':[],'id':[],'price':[]}\n        hisorder = pd.DataFrame(data)\n        Log('卖出后，最新账户信息：', exchange.GetAccount())\n        Log(\"stopsign\",stopsign,\"closesign\",closesign)\n\n    \n\n    \ndef main():\n    while True:\n        turtle()\n        Sleep(fresh_rete*60*60*1000)",
        "strategy_description": "策略名称: 海龟策略btc现货版\n\n#        Log(\"records[-1]\",records[-1])\n\n\n\n\n\n    if opensign | addsign:\n        if acct.Balance >= (ticker['Last']+10)*unit and unit >0:\n            id = exchange.Buy(ticker['Last']+10,unit)\n            orderinfo = exchange.GetOrder(id)\n            data = {'ordertime':_D(records[-1]['Time']/1000),'id':id,'price':records[-1]['Close']}\n            hisorder = hisorder.append(data,ignore_index=True)\n            Log('买入后，最新账户信息：', exchange.GetAccount())\n            Log(\"opensign\",opensign,\"addsign\",addsign)\n    #    else:\n    #        Log('余额已不足，请充值......', exchange.GetAccount())\n    if stopsign | closesign:\n        exchange.Sell(-1, acct.Stocks+acct.FrozenStocks)\n        data = {'ordertime':[],'id':[],'price':[]}\n        hisorder = pd.DataFrame(data)\n        Log('卖出后，最新账户信息：', exchange.GetAccount())\n        Log(\"stopsign\",stopsign,\"closesign\",closesign)\n\n    \n\n    \ndef main():\n    while True:\n        turtle()\n        Sleep(fresh_rete*60*60*1000)        \n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/186598\n\n> Last Modified\n\n2020-03-06 12:04:41"
    },
    {
        "strategy_id": "110_深度做市-盘口控制-操盘机器人-做市工具",
        "strategy_code": "python\n# -*- coding: UTF-8 -*-\nimport requests\nimport time\nimport random\nimport hashlib\nimport sys\nimport threading\nfrom api import *\n\nsymbol = sys.argv[1]\ngap= float(sys.argv[2]) #密度/价差\nbaseamount = float(sys.argv[3])\nbasebuy = float(sys.argv[4])\namount_add\t= float(sys.argv[5]) \t#挂单增量\t数字型(number)\namount_add2 = float(sys.argv[6]) \t#挂单增量\t数字型(number)\nlongperoidlimit = int(sys.argv[7])\nbigbase = float(sys.argv[8])\t\t\t\t#大单基准量\norderlimit = int(sys.argv[9])   #总单量\napi_key = sys.argv[10]\nsecret_key = sys.argv[11]\n\nshortperoidlimit = 3\t#高频单量\n\npre_short_id = []\t#高平id标记\npre_long_id = []\t#低频id标记\npre_big_id = 0\n\nrequests.packages.urllib3.disable_warnings()\n\ndef GetTicker():\n\ndef GetPV():\n\ndef GetDepth():\n\ndef GetSign(sign_str):\n\n\ndef GetOrders():\n\ndef create_order(side,price,amount):\n\ndef CancelOrder(order_id):\n\ndef Buy(price,amount):\n\ndef Sell(price,amount):\n\ndef GetRecords(symbol,period):\n\ndef GetPrecision():\n\ndef getrr():\n\ndef ordersend_shortperoid():\n\ndef ordersend_longperoid():\n\ndef send_big_order():\n\ndef cancel():\n\n\nif __name__ == '__main__':\n\tprecision = GetPrecision()\n\tprint(precision)\n\ti = 0\n\tfor x in precision:\n\t\tif precision[i]['symbol'] == symbol:\n\t\t\tpricedot = precision[i]['price_precision']\n\t\t\tamountdot = precision[i]['amount_precision']\n\t\ti += 1\n\tpricegap =  max(gap,pow(10,-pricedot))\n\tthreading_list = [ordersend_shortperoid,ordersend_longperoid,send_big_order,cancel]\n\tthreadingList = []\n\tthreadingDict = {}\n\tfor x in threading_list:\n\t\tth = threading.Thread(target=x)\n\t\tthreadingList.append(th)\n\t\tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\n\t\tth.start()\n\n\twhile True:\n\t\ttry:\n\t\t\ttime.sleep(200)\n\t\t\tfor i in threadingList:\n\t\t\t\tif i.is_alive() is False:\n\t\t\t\t\tthreadingList.remove(i)\n\t\t\t\t\tresult = threadingDict.pop(i.name)\n\t\t\t\t\tth = threading.Thread(target=result)\n\t\t\t\t\tthreadingList.append(th)\n\t\t\t\t\tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\n\t\t\t\t\tth.start()\n\t\texcept Exception as e:\n\t\t\tprint('check error',e)",
        "strategy_description": "策略名称: 深度做市-盘口控制-操盘机器人-做市工具\n\nimport requests\nimport time\nimport random\nimport hashlib\nimport sys\nimport threading\nfrom api import *\n\nsymbol = sys.argv[1]\ngap= float(sys.argv[2]) #密度/价差\nbaseamount = float(sys.argv[3])\nbasebuy = float(sys.argv[4])\namount_add\t= float(sys.argv[5]) \t#挂单增量\t数字型(number)\namount_add2 = float(sys.argv[6]) \t#挂单增量\t数字型(number)\nlongperoidlimit = int(sys.argv[7])\nbigbase = float(sys.argv[8])\t\t\t\t#大单基准量\norderlimit = int(sys.argv[9])   #总单量\napi_key = sys.argv[10]\nsecret_key = sys.argv[11]\n\nshortperoidlimit = 3\t#高频单量\n\npre_short_id = []\t#高平id标记\npre_long_id = []\t#低频id标记\npre_big_id = 0\n\nrequests.packages.urllib3.disable_warnings()\n\ndef GetTicker():\n\ndef GetPV():\n\ndef GetDepth():\n\ndef GetSign(sign_str):\n\n\ndef GetOrders():\n\ndef create_order(side,price,amount):\n\ndef CancelOrder(order_id):\n\ndef Buy(price,amount):\n\ndef Sell(price,amount):\n\ndef GetRecords(symbol,period):\n\ndef GetPrecision():\n\ndef getrr():\n\ndef ordersend_shortperoid():\n\ndef ordersend_longperoid():\n\ndef send_big_order():\n\ndef cancel():\n\n\nif __name__ == '__main__':\n\tprecision = GetPrecision()\n\tprint(precision)\n\ti = 0\n\tfor x in precision:\n\t\tif precision[i]['symbol'] == symbol:\n\t\t\tpricedot = precision[i]['price_precision']\n\t\t\tamountdot = precision[i]['amount_precision']\n\t\ti += 1\n\tpricegap =  max(gap,pow(10,-pricedot))\n\tthreading_list = [ordersend_shortperoid,ordersend_longperoid,send_big_order,cancel]\n\tthreadingList = []\n\tthreadingDict = {}\n\tfor x in threading_list:\n\t\tth = threading.Thread(target=x)\n\t\tthreadingList.append(th)\n\t\tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\n\t\tth.start()\n\n\twhile True:\n\t\ttry:\n\t\t\ttime.sleep(200)\n\t\t\tfor i in threadingList:\n\t\t\t\tif i.is_alive() is False:\n\t\t\t\t\tthreadingList.remove(i)\n\t\t\t\t\tresult = threadingDict.pop(i.name)\n\t\t\t\t\tth = threading.Thread(target=result)\n\t\t\t\t\tthreadingList.append(th)\n\t\t\t\t\tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\n\t\t\t\t\tth.start()\n\t\texcept Exception as e:\n\t\t\tprint('check error',e)\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/146238\n\n> Last Modified\n\n2019-12-10 13:39:07"
    },
    {
        "strategy_id": "111_现货平衡策略-001v",
        "strategy_code": "python\n\n\nimport time\nimport requests\nimport math\n\naccount = 0          #保存用户资产\nupdateProfitTime = 0   #更新收益率间隔时间\ntradeInfo = {}         #保存交易对信息\naccountAssets = {}\nticker = {}\nruntimeData = {}\nFunding = 0   #账户资金  为0的时候自动获取\nVersion = '0.0.1'\nsbs = list(symbols.split(','))\n\n\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Binance':\n    Log('只支持币安现货交易所！')\n    exit()\n\ndef init():\n    exchangeInfo = requests.get('https://api.binance.com/api/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法链接币安网络，需要海外托管者！！！')\n        exit()\n    for x in range(len(exchangeInfo['symbols'])):\n        for symbol in sbs:\n            if exchangeInfo['symbols'][x]['symbol'] == symbol+'USDT':\n                tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][x]['filters'][2]['minQty']) ,\n                'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][2]['stepSize']))))}\n    # Log('tradeInfo:',tradeInfo)\n\ndef UpdateAccount():\n    global accountAssets,Funding,account\n    acc = exchange.GetAccount()\n    if _G('Funding') is None:\n        Funding = account['Balance']\n        Log('Funding:',Funding)\n        _G('Funding',Funding)\n    else:\n        Funding = _G('Funding')\n\n    if account is None:\n        Log('更新账户超时！！！')\n        return\n\n    for x in range(len(acc['Info']['balances'])):\n        for symbol in sbs:\n            # Log(account['Info']['balances'])\n            if acc['Info']['balances'][x]['asset'] == symbol:\n                accountAssets[symbol] = acc['Info']['balances'][x]\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\n                # Log('USDT:',acc['Info']['balances'][x])\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\n\n    # Log('accountAssets:',accountAssets)\n\n\ndef UpdateTick():\n    global ticker,account\n    try:\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\n    except:\n        Log('更新行情超时')\n        return\n    for x in range(len(res)):\n        for symbol in sbs:\n            if res[x]['symbol'] == symbol + 'USDT':\n                # Log('res[x]:',res[x])\n                ticker[symbol] = res[x]\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\n    # Log('ticker:',ticker)\n    # account = 0\n    for symbol in sbs:\n        account += _N(ticker[symbol]['value'],4)\n\ndef Trade(symbol,direction,price,amount):\n    if amount < tradeInfo[symbol]['minQty']:\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n    else:\n        para = ''\n        url = '/api/v3/order'\n        para += 'symbol='+ symbol +'USDT'\n        para += '&side='+ direction\n        para += '&type=LIMIT&timeInForce=IOC'\n        para += '&quantity='+ str(amount)\n        para += '&price='+ str(price)\n        para += '&timestamp='+str(time.time() * 1000);\n        go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n        ret = go.wait()\n        if ret  is not None:\n            logType = LOG_TYPE_SELL\n            if direction == 'BUY':\n                logType =LOG_TYPE_BUY\n            exchange.Log(logType,price,amount,symbol)\n\ndef UpdateStatus():\n    global updateProfitTime\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\n        'rows': []\n    }\n    totalProfit = account - Funding\n    profitColors = DangerColor\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday   #平均日收益\n    dayRate = totalProfit / Funding * 100\n    accountTable['rows'].append([\n    runday,\n    Funding,\n    account,\n    str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n    str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n    str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n    str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n    i=1\n    for symbol in sbs:\n        table['rows'].append([\n        i,\n        symbol,\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\n        str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\n        str(_N(ticker[symbol]['value'],4))\n        ])\n        i += 1\n\n    retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n'\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = account - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n\ndef Process():\n\n    # Log('实时资金：',account)\n    for symbol in sbs:\n\n        pct = float(ticker[symbol]['value']) / float(account)\n        # Log(symbol,'amount:',amount,1 / len(sbs))\n        if pct > (1 / len(sbs) + 0.015):\n            # Log('SELL',pct)\n            Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\n            amount = _N( ( (pct-1/len(sbs) ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\n            Trade(symbol,'SELL',_N(float(ticker[symbol]['askPrice']), int(tradeInfo[symbol]['priceSize'])),  amount)\n        if pct < (1 / len(sbs) - 0.015):\n            # Log('Buy', pct)\n            Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\n            amount = _N( ( (1/len(sbs)-pct ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\n            Trade(symbol,'BUY',_N(float(ticker[symbol]['bidPrice']), tradeInfo[symbol]['priceSize']),  amount)\n\n\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef main():\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n        #休眠时间\n        Sleep(Interval * 1000)",
        "strategy_description": "策略名称: 现货平衡策略-001v\n\ndef UpdateAccount():\n    global accountAssets,Funding,account\n    acc = exchange.GetAccount()\n    if _G('Funding') is None:\n        Funding = account['Balance']\n        Log('Funding:',Funding)\n        _G('Funding',Funding)\n    else:\n        Funding = _G('Funding')\n\n    if account is None:\n        Log('更新账户超时！！！')\n        return\n\n    for x in range(len(acc['Info']['balances'])):\n        for symbol in sbs:\n            # Log(account['Info']['balances'])\n            if acc['Info']['balances'][x]['asset'] == symbol:\n                accountAssets[symbol] = acc['Info']['balances'][x]\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\n                # Log('USDT:',acc['Info']['balances'][x])\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\n\n    # Log('accountAssets:',accountAssets)\n\n\ndef UpdateTick():\n    global ticker,account\n    try:\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\n    except:\n        Log('更新行情超时')\n        return\n    for x in range(len(res)):\n        for symbol in sbs:\n            if res[x]['symbol'] == symbol + 'USDT':\n                # Log('res[x]:',res[x])\n                ticker[symbol] = res[x]\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\n    # Log('ticker:',ticker)\n    # account = 0\n    for symbol in sbs:\n        account += _N(ticker[symbol]['value'],4)\n\ndef Trade(symbol,direction,price,amount):\n    if amount < tradeInfo[symbol]['minQty']:\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\n    else:\n        para = ''\n        url = '/api/v3/order'\n        para += 'symbol='+ symbol +'USDT'\n        para += '&side='+ direction\n        para += '&type=LIMIT&timeInForce=IOC'\n        para += '&quantity='+ str(amount)\n        para += '&price='+ str(price)\n        para += '&timestamp='+str(time.time() * 1000);\n        go = exchange.Go(\"IO\", \"api\", \"POST\", url, para)\n        ret = go.wait()\n        if ret  is not None:\n            logType = LOG_TYPE_SELL\n            if direction == 'BUY':\n                logType =LOG_TYPE_BUY\n            exchange.Log(logType,price,amount,symbol)\n\ndef UpdateStatus():\n    global updateProfitTime\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\n        'rows': []\n    }\n    totalProfit = account - Funding\n    profitColors = DangerColor\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday   #平均日收益\n    dayRate = totalProfit / Funding * 100\n    accountTable['rows'].append([\n    runday,\n    Funding,\n    account,\n    str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n    str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n    str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n    str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n    i=1\n    for symbol in sbs:\n        table['rows'].append([\n        i,\n        symbol,\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\n        str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\n        str(_N(ticker[symbol]['value'],4))\n        ])\n        i += 1\n\n    retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + 'Version:' + Version  + '\\n'\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = account - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n\ndef Process():\n\n    # Log('实时资金：',account)\n    for symbol in sbs:\n\n        pct = float(ticker[symbol]['value']) / float(account)\n        # Log(symbol,'amount:',amount,1 / len(sbs))\n        if pct > (1 / len(sbs) + 0.015):\n            # Log('SELL',pct)\n            Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\n            amount = _N( ( (pct-1/len(sbs) ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\n            Trade(symbol,'SELL',_N(float(ticker[symbol]['askPrice']), int(tradeInfo[symbol]['priceSize'])),  amount)\n        if pct < (1 / len(sbs) - 0.015):\n            # Log('Buy', pct)\n            Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\n            amount = _N( ( (1/len(sbs)-pct ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\n            Trade(symbol,'BUY',_N(float(ticker[symbol]['bidPrice']), tradeInfo[symbol]['priceSize']),  amount)\n\n\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef main():\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n        #休眠时间\n        Sleep(Interval * 1000)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/322357\n\n> Last Modified\n\n2021-10-10 20:50:05"
    },
    {
        "strategy_id": "112_现货指数平衡策略-v11曾实盘跑过一段时间现在疑似有bug因为不用了懒得改",
        "strategy_code": "python\n\nimport json\nimport time\nimport requests\nimport math\n\naccount = 0  \nupdateProfitTime = 0 \ntradeInfo = {} \naccountAssets = {}\nticker = {}\nruntimeData = {}\nFunding = 0\n\nsbs = list(symbols.split(','))\npcts = list(percent.split(','))\nfor i in range(len(pcts)):\n    pcts[i] = float(pcts[i])\n\np_dic = {\n            'ETH':[2,4], 'BTC':[2,5], 'XRP':[4,0], 'TRX':[5,1], 'LTC':[1,3], 'BNB':[1,3]\n         }    #价格、数量精度，按需求添加\n\n\nSuccessColor = '#5cb85c' #成功颜色\nDangerColor = '#ff0000' #危险颜色\nWrningColor = '#f0ad4e' #警告颜色\n\nif IsVirtual():\n    Log('不能进行回测')\n    exit()\n\nif exchange.GetName() != 'Binance':\n    Log('只支持币安现货交易所！')\n    exit()\n\ndef init():\n    exchangeInfo = requests.get('https://api.binance.com/api/v1/exchangeInfo').json()\n    if exchangeInfo is None:\n        Log('无法链接币安网络，需要海外托管者！！！')\n        exit()\n    for x in range(len(exchangeInfo['symbols'])):\n        for symbol in sbs:\n            if exchangeInfo['symbols'][x]['symbol'] == symbol+'USDT':\n                tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][x]['filters'][2]['minQty']) ,\n                'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][2]['stepSize']))))}\n    # Log('tradeInfo:',tradeInfo)\n\ndef UpdateAccount():\n    global accountAssets,Funding,account\n    acc = exchange.GetAccount()\n\n    if acc is None:\n        Log('更新账户超时！！！')\n        return\n\n    if _G('Funding') is None:\n        Funding = acc['Balance']\n        Log('Funding:',Funding)\n        _G('Funding',Funding)\n    else:\n        Funding = _G('Funding')\n    if init_fund >0:\n        Funding = init_fund\n    \n\n    for x in range(len(acc['Info']['balances'])):\n        for symbol in sbs:\n            # Log(account['Info']['balances'])\n            if acc['Info']['balances'][x]['asset'] == symbol:\n                accountAssets[symbol] = acc['Info']['balances'][x]\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\n                # Log('USDT:',acc['Info']['balances'][x])\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\n\n    # Log('accountAssets:',accountAssets)\n\ndef UpdateTick():\n    global ticker,account\n    try:\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\n    except:\n        Log('更新行情超时')\n        return\n    for x in range(len(res)):\n        for symbol in sbs:\n            if res[x]['symbol'] == symbol + 'USDT':\n                # Log('res[x]:',res[x])\n                ticker[symbol] = res[x]\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\n    # Log('ticker:',ticker)\n    # account = 0\n    for symbol in sbs:\n        account += _N(ticker[symbol]['value'],4)\n\ndef UpdateStatus():\n    global updateProfitTime\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\n        'rows': []\n    }\n    totalProfit = account - Funding\n    profitColors = DangerColor\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday   #平均日收益\n    dayRate = totalProfit / Funding * 100\n    accountTable['rows'].append([\n    runday,\n    Funding,\n    account,\n    str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n    str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n    str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n    str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n    i=1\n    for symbol in sbs:\n        table['rows'].append([\n        i,\n        symbol,\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\n        str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\n        str(_N(ticker[symbol]['value'],4))\n        ])\n        i += 1\n\n    retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + '本策略改编自XMaxZone大佬的现货平衡策略-0.0.1v，原策略地址：https://www.fmz.com/strategy/322357' + '\\n'\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = account - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n\ndef Process():\n    # Log('实时资金：',account)\n    for i in range(len(sbs)):\n        pct = float(ticker[sbs[i]]['value']) / float(account)\n        # Log(symbol,'amount:',amount,1 / len(sbs))\n        if pct > (pcts[i] + delta):\n            # Log('SELL',pct)\n            amount = _N( ( (pct-pcts[i] ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\n                # Trade(sbs[i],'SELL',_N(float(ticker[sbs[i]]['askPrice']), int(tradeInfo[sbs[i]]['priceSize'])),  amount)\n                exchange.SetCurrency(sbs[i]+'_USDT')\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\n                exchange.Sell(float(ticker[sbs[i]]['bidPrice'])*(1-slip), amount)\n        if pct < (pcts[i] - delta):\n            # Log('Buy', pct)\n            amount = _N( ( (pcts[i]-pct ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\n                # Trade(sbs[i],'BUY',_N(float(ticker[sbs[i]]['bidPrice']), tradeInfo[sbs[i]]['priceSize']),  amount)\n                exchange.SetCurrency(sbs[i]+'_USDT')\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\n                exchange.Buy(float(ticker[sbs[i]]['bidPrice'])*(1+slip), amount)\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef main():\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n        #休眠时间\n        Sleep(Interval * 1000)",
        "strategy_description": "策略名称: 现货指数平衡策略-v11曾实盘跑过一段时间现在疑似有bug因为不用了懒得改\n\ndef UpdateAccount():\n    global accountAssets,Funding,account\n    acc = exchange.GetAccount()\n\n    if acc is None:\n        Log('更新账户超时！！！')\n        return\n\n    if _G('Funding') is None:\n        Funding = acc['Balance']\n        Log('Funding:',Funding)\n        _G('Funding',Funding)\n    else:\n        Funding = _G('Funding')\n    if init_fund >0:\n        Funding = init_fund\n    \n\n    for x in range(len(acc['Info']['balances'])):\n        for symbol in sbs:\n            # Log(account['Info']['balances'])\n            if acc['Info']['balances'][x]['asset'] == symbol:\n                accountAssets[symbol] = acc['Info']['balances'][x]\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\n                # Log('USDT:',acc['Info']['balances'][x])\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\n\n    # Log('accountAssets:',accountAssets)\n\ndef UpdateTick():\n    global ticker,account\n    try:\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\n    except:\n        Log('更新行情超时')\n        return\n    for x in range(len(res)):\n        for symbol in sbs:\n            if res[x]['symbol'] == symbol + 'USDT':\n                # Log('res[x]:',res[x])\n                ticker[symbol] = res[x]\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\n    # Log('ticker:',ticker)\n    # account = 0\n    for symbol in sbs:\n        account += _N(ticker[symbol]['value'],4)\n\ndef UpdateStatus():\n    global updateProfitTime\n    accountTable = {\n        'type': \"table\",\n        'title': \"盈利统计\",\n        'cols': [\"运行天数\", \"初始资金\", \"现有资金\", \"总收益\", \"预计年化\", \"预计月化\", \"平均日化\"],\n        'rows': []\n    }\n\n    table = {\n        'type': 'table',\n        'title': '交易对信息',\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\n        'rows': []\n    }\n    totalProfit = account - Funding\n    profitColors = DangerColor\n    runday = runtimeData['dayDiff']\n    if runday == 0:\n        runday = 1\n    if totalProfit > 0:\n        profitColors = SuccessColor\n    dayProfit = totalProfit / runday   #平均日收益\n    dayRate = totalProfit / Funding * 100\n    accountTable['rows'].append([\n    runday,\n    Funding,\n    account,\n    str(_N(totalProfit / Funding * 100, 2)) + \"% = $\" + str(_N(totalProfit, 2)) + (profitColors),\n    str(_N(dayRate * 365, 2)) + \"% = $\" + str(_N(dayProfit * 365, 2)) + (profitColors),\n    str(_N(dayRate * 30, 2)) + \"% = $\" + str(_N(dayProfit * 30, 2)) + (profitColors),\n    str(_N(dayRate, 2)) + \"% = $\" + str(_N(dayProfit, 2)) + (profitColors)\n    ])\n\n    i=1\n    for symbol in sbs:\n        table['rows'].append([\n        i,\n        symbol,\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\n        str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\n        str(_N(ticker[symbol]['value'],4))\n        ])\n        i += 1\n\n    retData = runtimeData['str'] + '\\n' + \"最后更新: \" + _D() + '\\n' + '本策略改编自XMaxZone大佬的现货平衡策略-0.0.1v，原策略地址：https://www.fmz.com/strategy/322357' + '\\n'\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\n'+ '`' + json.dumps(table) + '`\\n')\n\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\n        balance = account - Funding\n        LogProfit(_N(balance, 3))\n        updateProfitTime = int(time.time()*1000)\n\ndef Process():\n    # Log('实时资金：',account)\n    for i in range(len(sbs)):\n        pct = float(ticker[sbs[i]]['value']) / float(account)\n        # Log(symbol,'amount:',amount,1 / len(sbs))\n        if pct > (pcts[i] + delta):\n            # Log('SELL',pct)\n            amount = _N( ( (pct-pcts[i] ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\n                # Trade(sbs[i],'SELL',_N(float(ticker[sbs[i]]['askPrice']), int(tradeInfo[sbs[i]]['priceSize'])),  amount)\n                exchange.SetCurrency(sbs[i]+'_USDT')\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\n                exchange.Sell(float(ticker[sbs[i]]['bidPrice'])*(1-slip), amount)\n        if pct < (pcts[i] - delta):\n            # Log('Buy', pct)\n            amount = _N( ( (pcts[i]-pct ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\n                # Trade(sbs[i],'BUY',_N(float(ticker[sbs[i]]['bidPrice']), tradeInfo[sbs[i]]['priceSize']),  amount)\n                exchange.SetCurrency(sbs[i]+'_USDT')\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\n                exchange.Buy(float(ticker[sbs[i]]['bidPrice'])*(1+slip), amount)\n\ndef StartTime():\n    StartTime = _G('StartTime')\n    if StartTime is None:\n        StartTime = _D()\n        _G('StartTime',StartTime)\n    return StartTime\n\ndef RunTime():\n    ret = {}\n    startTime = StartTime()\n    nowTime = _D()\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\n    lever1 = dateDiff % (24 * 3600 * 1000 )\n    hours = math.floor(lever1 / (3600 * 1000))\n    lever2 = lever1 % (3600 * 1000)\n    minutes = math.floor(lever2 / (60 * 1000))\n\n    ret['dayDiff'] = dayDiff\n    ret['hours'] = hours\n    ret['minutes'] = minutes\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\n    return ret\n\ndef main():\n    SetErrorFilter(\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\")\n    global runtimeData\n\n    while True:\n        runtimeData = RunTime()\n        #更新账户和持仓\n        UpdateAccount()\n        #更新行情\n        UpdateTick()\n        #策略主逻辑\n        Process()\n        #更新图表\n        UpdateStatus()\n        #休眠时间\n        Sleep(Interval * 1000)\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/329093\n\n> Last Modified\n\n2021-12-04 20:53:35"
    },
    {
        "strategy_id": "113_画线机器人一年翻倍回撤1完美曲线",
        "strategy_code": "python\nimport random\n\ndef main():\n    account = exchange.GetAccount()\n    balance = account[\"Balance\"]\n    while True:\n        LogProfit(balance - account[\"Balance\"])\n        balance = balance * (1 + (0.5 - random.random()) / 1000 + 1 / 100000)\n        Sleep(1000 * 60)",
        "strategy_description": "策略名称: 画线机器人一年翻倍回撤1完美曲线\n\n未找到描述"
    },
    {
        "strategy_id": "114_简单的做市对冲功能",
        "strategy_code": "python\n# -*- coding: UTF-8 -*-\nimport time\nfrom api import *\nfrom Huobiapi import *\nimport sqlite3\n\ndef wechatmsg(text,desp):\n\tserver = 'https://sc.ftqq.com/xxxxxx.send'\n\tpayload = {'text':text,'desp':desp}\n\trequests.post(server,params = payload)\n\ndef dingmsg(title,msg):\n\turl = 'https://oapi.dingtalk.com/robot/send?access_token=xxxxxx'\n\tdata = {\n\t\t\t \"msgtype\": \"markdown\",\n\t\t\t \"markdown\": {\n\t\t\t\t \"title\":title+msg,\n\t\t\t\t \"text\": \"#### \" + title + \"\\n\"\n\t\t\t\t\t\t \"> \" + msg\t\t\t\t\t\t \n\t\t\t}}\t\t \n\theader = {'Content-Type':'application/json'}\n\tr = requests.post(url = url ,headers=header,data = json.dumps(data)).json()\n\treturn r\n\ndef check():\n\ttry:\n\t\tpre_balance = {}\n\t\tconn = sqlite3.connect(\"/root/bot/hedge.db\")\n\t\tcursor = conn.cursor()\n\t\tsql = 'select * from balance order by id desc limit 20;'\n\t\tresult = list(cursor.execute(sql))\n\t\tfor a in result:\n\t\t\tif a[1] in list(pre_balance.keys()):\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tpre_balance[a[1]] = a[2]   #读取之前balance\n\t\tcoinname = list(pre_balance.keys())\n\t\tprint(pre_balance,coinname)\n\n\t\tbalance = GetBalance()\n\t\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\n\t\tfor x in balance:  \n\t\t\tsql = \"insert into balance (coin,balance,time) values(?,?,?);\"\n\t\t\tb = x['balance']+x['frozenBalance']\n\t\t\tif b != 0:\n\t\t\t\tv = (x['coin']['unit'],b,t)\n\t\t\t\tprint(v)\n\t\t\t\tcursor.execute(sql,v)\n\t\t\tfor n in coinname:\n\t\t\t\tif n == x['coin']['unit']:\n\t\t\t\t\td = round(b - pre_balance[n],5)   #数量差\n\t\t\t\t\tif d > 0:\n                        Sell(n,d)\n\t\t\t\t\t\tmsg = '对冲卖出'+n+'数量：'+str(d)\n\t\t\t\t\t\tprint(msg)\n\t\t\t\t\t\twechatmsg('对冲',msg)\n\t\t\t\t\t\tdingmsg('对冲',msg)\n\t\t\t\t\t\tsql = \"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\"\n\t\t\t\t\t\tv = (n,d,0,t)\n\t\t\t\t\t\tcursor.execute(sql,v)\n\t\t\t\t\telif d < 0:\n                        Buy(n,d)\n\t\t\t\t\t\tmsg = '对冲买入：'+n+'数量：'+str(d)\n\t\t\t\t\t\tprint(msg)\n\t\t\t\t\t\twechatmsg('对冲',msg)\n\t\t\t\t\t\tdingmsg('对冲',msg)\n\t\t\t\t\t\tsql = \"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\"\n\t\t\t\t\t\tv = (n,d,0,t)\n\t\t\t\t\t\tcursor.execute(sql,v)\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint('no hedge')\n\n\t\tconn.commit()\n\t\tconn.close()\n\texcept Exception as e:\n\t\traise e\n\t\ndef insert_balance():\n\ttry:\n\t\tconn = sqlite3.connect(\"hedge.db\")\n\t\tcursor = conn.cursor()\n\t\tbalance = GetBalance()\n\t\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\n\t\tfor x in balance:\n\t\t\tsql = \"insert into balance (coin,balance,time) values(?,?,?);\"\n\t\t\tb = x['balance']+x['frozenBalance']\n\t\t\tif b != 0:\n\t\t\t\tv = (x['coin']['unit'],b,t)\n\t\t\t\tcursor.execute(sql,v)\n\t\tconn.commit()\n\t\tconn.close()\n\t\tprint('finish')\n\texcept Exception as e:\n\t\tprint('err',e)\n\nif __name__ == '__main__':\n\twhile 1:\n\t\ttry:\n\t\t\tcheck()\n\t\texcept Exception as e:\n\t\t\tprint(e)\n\t\ttime.sleep(30)",
        "strategy_description": "策略名称: 简单的做市对冲功能\n\nimport time\nfrom api import *\nfrom Huobiapi import *\nimport sqlite3\n\ndef wechatmsg(text,desp):\n\tserver = 'https://sc.ftqq.com/xxxxxx.send'\n\tpayload = {'text':text,'desp':desp}\n\trequests.post(server,params = payload)\n\ndef dingmsg(title,msg):\n\turl = 'https://oapi.dingtalk.com/robot/send?access_token=xxxxxx'\n\tdata = {\n\t\t\t \"msgtype\": \"markdown\",\n\t\t\t \"markdown\": {\n\t\t\t\t \"title\":title+msg,\n\t\t\t\t \"text\": \"#### \" + title + \"\\n\"\n\t\t\t\t\t\t \"> \" + msg\t\t\t\t\t\t \n\t\t\t}}\t\t \n\theader = {'Content-Type':'application/json'}\n\tr = requests.post(url = url ,headers=header,data = json.dumps(data)).json()\n\treturn r\n\ndef check():\n\ttry:\n\t\tpre_balance = {}\n\t\tconn = sqlite3.connect(\"/root/bot/hedge.db\")\n\t\tcursor = conn.cursor()\n\t\tsql = 'select * from balance order by id desc limit 20;'\n\t\tresult = list(cursor.execute(sql))\n\t\tfor a in result:\n\t\t\tif a[1] in list(pre_balance.keys()):\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tpre_balance[a[1]] = a[2]   #读取之前balance\n\t\tcoinname = list(pre_balance.keys())\n\t\tprint(pre_balance,coinname)\n\n\t\tbalance = GetBalance()\n\t\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\n\t\tfor x in balance:  \n\t\t\tsql = \"insert into balance (coin,balance,time) values(?,?,?);\"\n\t\t\tb = x['balance']+x['frozenBalance']\n\t\t\tif b != 0:\n\t\t\t\tv = (x['coin']['unit'],b,t)\n\t\t\t\tprint(v)\n\t\t\t\tcursor.execute(sql,v)\n\t\t\tfor n in coinname:\n\t\t\t\tif n == x['coin']['unit']:\n\t\t\t\t\td = round(b - pre_balance[n],5)   #数量差\n\t\t\t\t\tif d > 0:\n                        Sell(n,d)\n\t\t\t\t\t\tmsg = '对冲卖出'+n+'数量：'+str(d)\n\t\t\t\t\t\tprint(msg)\n\t\t\t\t\t\twechatmsg('对冲',msg)\n\t\t\t\t\t\tdingmsg('对冲',msg)\n\t\t\t\t\t\tsql = \"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\"\n\t\t\t\t\t\tv = (n,d,0,t)\n\t\t\t\t\t\tcursor.execute(sql,v)\n\t\t\t\t\telif d < 0:\n                        Buy(n,d)\n\t\t\t\t\t\tmsg = '对冲买入：'+n+'数量：'+str(d)\n\t\t\t\t\t\tprint(msg)\n\t\t\t\t\t\twechatmsg('对冲',msg)\n\t\t\t\t\t\tdingmsg('对冲',msg)\n\t\t\t\t\t\tsql = \"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\"\n\t\t\t\t\t\tv = (n,d,0,t)\n\t\t\t\t\t\tcursor.execute(sql,v)\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint('no hedge')\n\n\t\tconn.commit()\n\t\tconn.close()\n\texcept Exception as e:\n\t\traise e\n\t\ndef insert_balance():\n\ttry:\n\t\tconn = sqlite3.connect(\"hedge.db\")\n\t\tcursor = conn.cursor()\n\t\tbalance = GetBalance()\n\t\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\n\t\tfor x in balance:\n\t\t\tsql = \"insert into balance (coin,balance,time) values(?,?,?);\"\n\t\t\tb = x['balance']+x['frozenBalance']\n\t\t\tif b != 0:\n\t\t\t\tv = (x['coin']['unit'],b,t)\n\t\t\t\tcursor.execute(sql,v)\n\t\tconn.commit()\n\t\tconn.close()\n\t\tprint('finish')\n\texcept Exception as e:\n\t\tprint('err',e)\n\nif __name__ == '__main__':\n\twhile 1:\n\t\ttry:\n\t\t\tcheck()\n\t\texcept Exception as e:\n\t\t\tprint(e)\n\t\ttime.sleep(30)\n\n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/178194\n\n> Last Modified\n\n2019-12-12 14:39:05"
    },
    {
        "strategy_id": "115_移植-OKCoin-韭菜收割机-多品种版-注释python版",
        "strategy_code": "python\n'''backtest\nstart: 2022-03-28 00:00:00\nend: 2022-03-28 23:59:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\",\"stocks\":0,\"fee\":[0,0]},{\"eid\":\"Binance\",\"currency\":\"ETH_USDT\"}]\nmode: 1\nargs: [[\"BurstThresholdPct\",0.00127],[\"MinStock\",0.001]]\n'''\n\nimport time\nclass LeeksReaper():  \n    def __init__(self,exchange):                                      #创建构造函数LeeksReaper                                          #构造一个空的对象\n        self.numTick = 0\n        self.lastTradeId = 0\n        self.vol = 0\n        self.askPrice = 0\n        self.bidPrice = 0\n        self.orderBook = {}\n        self.prices = []\n        self.tradeOrderId = 0\n        self.p = 0.5\n        self.account = None\n        self.preCalc = 0\n        self.preNet = 0\n\n        self.sgnum = 0\n        # self.cny = 0\n        # self.btc = 0\n\n        self.exchange = exchange\n        #以上都是self对象的属性\n\n    #创建一个方法\n    def updateTrades(self):\n\n        trades = _C(self.exchange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\n                trades = _C(self.exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\n\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\n\n        tradesvol = 0\n        for trade in trades:\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\n                temp = trade.Time if trade.Id == 0 else trade.Id\n                self.lastTradeId = max(temp, self.lastTradeId)\n                tradesvol = tradesvol + trade.Amount\n\n\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\n\n\n    #self对象的一个方法\n    def updateOrderBook(self):\n\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\n        orderBook = _C(self.exchange.GetDepth)\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\n            #返回undefined\n            return\n        \n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\n        #同上\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\n        #删除price数组的第一个值，并返回第一个值\n        del(self.prices[0])\n        #prices数组向后添加值，值为函数_N的返回值\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\n            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\n\n    #self对象的一个方法\n    def balanceAccount(self):\n        # 创建一个变量account用来接收GetAccount函数返回的值\n        account = _C(self.exchange.GetAccount)\n        #判断account是否为空，是就返回undefined\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n        #获取当前时间的时间戳数据\n        now = time.time()\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\n            #赋值\n            self.preCalc = now\n            #创建一个变量net用来接收_N函数的返回值\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\n            #判断net是否不等于self.preNet，如果是就执行下方语句\n            if (net != self.preNet):\n                #赋值\n                self.preNet = net\n                #调用函数LogProfit并传入net\n                LogProfit(net-10000)\n\n        #赋值\n        self.btc = account.Stocks\n        self.cny = account.Balance\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\n        balanced = False\n        #判断self.p的值是否小于0.48\n        # Log(self.p)\n        if (self.p < 0.48):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.cny =self.cny-300\n            self.cny -= 300\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Bids) > 0):\n                #调用buy函数并传入相应的参数\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.001)\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.001)\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.001)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #如果self.p大于0.52就执行下方语句\n        elif (self.p > 0.52):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.btc=self.btc-0.03\n            self.btc -= 0.03\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Asks) > 0):\n                #调用Sell函数并传入相应的参数\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.001)\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.001)\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.001)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n        #调用函数Sleep并传入参数BalanceTimeout\n        Sleep(BalanceTimeout)\n        #创建标量order来接收GetOrders函数返回的值\n        orders = _C(self.exchange.GetOrders)\n        #判断orders是否为真\n        if (orders):\n            #遍历orders\n            Log(orders)\n            for i in range(len(orders)):\n                #判断orders的id是否不等于self.tradeOrderId\n                if (orders[i].Id != self.tradeOrderId):\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\n                    Log(orders[i].Id)\n                    self.exchange.CancelOrder(orders[i].Id)\n\n\n\n\n\n    #self的一个方法\n    def poll(self):\n\n        #self.numTick自加1\n        self.numTick +=1\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\n        self.updateTrades()\n        self.updateOrderBook()\n        self.balanceAccount()\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\n        burstPrice = self.prices[-1] * BurstThresholdPct\n        #创建变量并赋值\n        bull = False\n        bear = False\n        tradeAmount = 0\n        #判断self.account是否为真\n        if (self.account):\n            #是真的话就调用LogStatus函数并传入相应的参数\n            Log(self.exchange.GetCurrency(),self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\",收割机当前启动次数:\",self.sgnum)\n\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\n        if (self.numTick > 2 and ((self.prices[-1] - max(self.prices[-6:-1]) > burstPrice) or (self.prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2]))):\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\n            bull = True\n            tradeAmount = self.cny / self.bidPrice * 0.99\n\n        #同上面if\n        elif (self.numTick > 2 and ((self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice) or (self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2]))):\n            bear = True\n            #赋值\n            tradeAmount = self.btc\n\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\n        if (self.vol < BurstThresholdVol):\n            tradeAmount *= self.vol / BurstThresholdVol\n\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\n        if (self.numTick < 5):\n            #tradeAmount=tradeAmount*0.8\n            tradeAmount *= 0.8\n\n        #判断self.numTick是否小于10\n        if (self.numTick < 10):\n            tradeAmount *= 0.8\n\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\n            return\n\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\n        tradePrice = self.bidPrice if bull else self.askPrice\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\n        while (tradeAmount >= MinStock):\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\n            orderId = self.exchange.Buy(self.bidPrice, tradeAmount) if bull else self.exchange.Sell(self.askPrice, tradeAmount)\n            self.sgnum+=1\n            Log(\"收割机第\",self.sgnum,\"次启动\")\n            #调用Sleep函数传入参数400，0.4秒后执行\n            Sleep(400)\n            #判断orderId是否为true\n            if (orderId):\n                #赋值\n                self.tradeOrderId = orderId\n                #赋值\n                order = None\n                while (True):\n                    #rder的值等于GetOrder函数的返回值\n                    order = self.exchange.GetOrder(orderId)\n                    #判断order是否为true\n                    if (order):\n                        #判断两边的值是否相等\n                        if (order.Status == ORDER_STATE_PENDING):\n                            #调用CancelOrder函数\n                            self.exchange.CancelOrder(orderId)\n                            #0.2秒后执行\n                            Sleep(200)\n                        else:\n                            #跳出循环\n                            break\n\n\n                #赋值\n                self.tradeOrderId = 0\n                tradeAmount -= order.DealAmount\n                tradeAmount *= 0.9\n                #判断两边是否相等\n                if (order.Status == ORDER_STATE_CANCELED):\n                    #调用self的updateOrderBook方法\n                    self.updateOrderBook()\n                    #判断是否为true,如果时就进行循环\n                    while (bull and self.bidPrice - tradePrice > 0.1):\n                        #赋值\n                        tradeAmount *= 0.99\n                        tradePrice += 0.1\n\n                    #判断是否为true,如果时就进行循环\n                    while (bear and self.askPrice - tradePrice < -0.1):\n                        tradeAmount *= 0.99\n                        tradePrice -= 0.1\n        #赋值\n        self.numTick = 0\n\n\n\n\n#函数main\ndef main():\n    #reaper 是构造函数的实例\n    reaperlist=[]\n    for coinexchange in exchanges:\n        reaper = LeeksReaper(coinexchange)\n        reaperlist.append(reaper)\n        reaper=None\n    while (True):\n        #通过实例调用poll方法\n        for coinreaper in reaperlist:\n            coinreaper.poll()\n        Sleep(TickInterval)",
        "strategy_description": "策略名称: 移植-OKCoin-韭菜收割机-多品种版-注释python版\n\n# self.btc = 0\n\n        self.exchange = exchange\n        #以上都是self对象的属性\n\n    #创建一个方法\n    def updateTrades(self):\n\n        trades = _C(self.exchange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\n                trades = _C(self.exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\n\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\n\n        tradesvol = 0\n        for trade in trades:\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\n                temp = trade.Time if trade.Id == 0 else trade.Id\n                self.lastTradeId = max(temp, self.lastTradeId)\n                tradesvol = tradesvol + trade.Amount\n\n\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\n\n\n    #self对象的一个方法\n    def updateOrderBook(self):\n\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\n        orderBook = _C(self.exchange.GetDepth)\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\n            #返回undefined\n            return\n        \n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\n        #同上\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\n        #删除price数组的第一个值，并返回第一个值\n        del(self.prices[0])\n        #prices数组向后添加值，值为函数_N的返回值\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\n            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\n\n    #self对象的一个方法\n    def balanceAccount(self):\n        # 创建一个变量account用来接收GetAccount函数返回的值\n        account = _C(self.exchange.GetAccount)\n        #判断account是否为空，是就返回undefined\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n        #获取当前时间的时间戳数据\n        now = time.time()\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\n            #赋值\n            self.preCalc = now\n            #创建一个变量net用来接收_N函数的返回值\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\n            #判断net是否不等于self.preNet，如果是就执行下方语句\n            if (net != self.preNet):\n                #赋值\n                self.preNet = net\n                #调用函数LogProfit并传入net\n                LogProfit(net-10000)\n\n        #赋值\n        self.btc = account.Stocks\n        self.cny = account.Balance\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\n        balanced = False\n        #判断self.p的值是否小于0.48\n        # Log(self.p)\n        if (self.p < 0.48):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.cny =self.cny-300\n            self.cny -= 300\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Bids) > 0):\n                #调用buy函数并传入相应的参数\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.001)\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.001)\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.001)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #如果self.p大于0.52就执行下方语句\n        elif (self.p > 0.52):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.btc=self.btc-0.03\n            self.btc -= 0.03\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Asks) > 0):\n                #调用Sell函数并传入相应的参数\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.001)\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.001)\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.001)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n        #调用函数Sleep并传入参数BalanceTimeout\n        Sleep(BalanceTimeout)\n        #创建标量order来接收GetOrders函数返回的值\n        orders = _C(self.exchange.GetOrders)\n        #判断orders是否为真\n        if (orders):\n            #遍历orders\n            Log(orders)\n            for i in range(len(orders)):\n                #判断orders的id是否不等于self.tradeOrderId\n                if (orders[i].Id != self.tradeOrderId):\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\n                    Log(orders[i].Id)\n                    self.exchange.CancelOrder(orders[i].Id)\n\n\n\n\n\n    #self的一个方法\n    def poll(self):\n\n        #self.numTick自加1\n        self.numTick +=1\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\n        self.updateTrades()\n        self.updateOrderBook()\n        self.balanceAccount()\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\n        burstPrice = self.prices[-1] * BurstThresholdPct\n        #创建变量并赋值\n        bull = False\n        bear = False\n        tradeAmount = 0\n        #判断self.account是否为真\n        if (self.account):\n            #是真的话就调用LogStatus函数并传入相应的参数\n            Log(self.exchange.GetCurrency(),self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\",收割机当前启动次数:\",self.sgnum)\n\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\n        if (self.numTick > 2 and ((self.prices[-1] - max(self.prices[-6:-1]) > burstPrice) or (self.prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2]))):\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\n            bull = True\n            tradeAmount = self.cny / self.bidPrice * 0.99\n\n        #同上面if\n        elif (self.numTick > 2 and ((self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice) or (self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2]))):\n            bear = True\n            #赋值\n            tradeAmount = self.btc\n\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\n        if (self.vol < BurstThresholdVol):\n            tradeAmount *= self.vol / BurstThresholdVol\n\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\n        if (self.numTick < 5):\n            #tradeAmount=tradeAmount*0.8\n            tradeAmount *= 0.8\n\n        #判断self.numTick是否小于10\n        if (self.numTick < 10):\n            tradeAmount *= 0.8\n\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\n            return\n\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\n        tradePrice = self.bidPrice if bull else self.askPrice\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\n        while (tradeAmount >= MinStock):\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\n            orderId = self.exchange.Buy(self.bidPrice, tradeAmount) if bull else self.exchange.Sell(self.askPrice, tradeAmount)\n            self.sgnum+=1\n            Log(\"收割机第\",self.sgnum,\"次启动\")\n            #调用Sleep函数传入参数400，0.4秒后执行\n            Sleep(400)\n            #判断orderId是否为true\n            if (orderId):\n                #赋值\n                self.tradeOrderId = orderId\n                #赋值\n                order = None\n                while (True):\n                    #rder的值等于GetOrder函数的返回值\n                    order = self.exchange.GetOrder(orderId)\n                    #判断order是否为true\n                    if (order):\n                        #判断两边的值是否相等\n                        if (order.Status == ORDER_STATE_PENDING):\n                            #调用CancelOrder函数\n                            self.exchange.CancelOrder(orderId)\n                            #0.2秒后执行\n                            Sleep(200)\n                        else:\n                            #跳出循环\n                            break\n\n\n                #赋值\n                self.tradeOrderId = 0\n                tradeAmount -= order.DealAmount\n                tradeAmount *= 0.9\n                #判断两边是否相等\n                if (order.Status == ORDER_STATE_CANCELED):\n                    #调用self的updateOrderBook方法\n                    self.updateOrderBook()\n                    #判断是否为true,如果时就进行循环\n                    while (bull and self.bidPrice - tradePrice > 0.1):\n                        #赋值\n                        tradeAmount *= 0.99\n                        tradePrice += 0.1\n\n                    #判断是否为true,如果时就进行循环\n                    while (bear and self.askPrice - tradePrice < -0.1):\n                        tradeAmount *= 0.99\n                        tradePrice -= 0.1\n        #赋值\n        self.numTick = 0"
    },
    {
        "strategy_id": "116_移植-OKCoin-韭菜收割机-注释python版",
        "strategy_code": "python\n'''backtest\nstart: 2019-09-05 00:00:00\nend: 2019-09-05 22:00:00\nperiod: 1h\nbasePeriod: 1h\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"BTC_USDT\",\"stocks\":0,\"fee\":[0,0]}]\nmode: 1\n'''\n\nimport time\nclass LeeksReaper():  \n    def __init__(self):                                      #创建构造函数LeeksReaper                                          #构造一个空的对象\n        self.numTick = 0\n        self.lastTradeId = 0\n        self.vol = 0\n        self.askPrice = 0\n        self.bidPrice = 0\n        self.orderBook = {}\n        self.prices = []\n        self.tradeOrderId = 0\n        self.p = 0.5\n        self.account = None\n        self.preCalc = 0\n        self.preNet = 0\n\n        self.sgnum = 0\n        # self.cny = 0\n        # self.btc = 0\n        #以上都是self对象的属性\n\n    #创建一个方法\n    def updateTrades(self):\n\n        trades = _C(exchange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\n                trades = _C(exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\n\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\n\n        tradesvol = 0\n        for trade in trades:\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\n                temp = trade.Time if trade.Id == 0 else trade.Id\n                self.lastTradeId = max(temp, self.lastTradeId)\n                tradesvol = tradesvol + trade.Amount\n\n\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\n\n\n    #self对象的一个方法\n    def updateOrderBook(self):\n\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\n        orderBook = _C(exchange.GetDepth)\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\n            #返回undefined\n            return\n        \n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\n        #同上\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\n        #删除price数组的第一个值，并返回第一个值\n        del(self.prices[0])\n        #prices数组向后添加值，值为函数_N的返回值\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\n            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\n\n    #self对象的一个方法\n    def balanceAccount(self):\n        # 创建一个变量account用来接收GetAccount函数返回的值\n        account = _C(exchange.GetAccount)\n        #判断account是否为空，是就返回undefined\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n        #获取当前时间的时间戳数据\n        now = time.time()\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\n            #赋值\n            self.preCalc = now\n            #创建一个变量net用来接收_N函数的返回值\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\n            #判断net是否不等于self.preNet，如果是就执行下方语句\n            if (net != self.preNet):\n                #赋值\n                self.preNet = net\n                #调用函数LogProfit并传入net\n                LogProfit(net-10000)\n\n        #赋值\n        self.btc = account.Stocks\n        self.cny = account.Balance\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\n        balanced = False\n        #判断self.p的值是否小于0.48\n        # Log(self.p)\n        if (self.p < 0.48):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.cny =self.cny-300\n            self.cny -= 300\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Bids) > 0):\n                #调用buy函数并传入相应的参数\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.01)\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.01)\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.01)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #如果self.p大于0.52就执行下方语句\n        elif (self.p > 0.52):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.btc=self.btc-0.03\n            self.btc -= 0.03\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Asks) > 0):\n                #调用Sell函数并传入相应的参数\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.01)\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.01)\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.01)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n        #调用函数Sleep并传入参数BalanceTimeout\n        Sleep(BalanceTimeout)\n        #创建标量order来接收GetOrders函数返回的值\n        orders = _C(exchange.GetOrders)\n        #判断orders是否为真\n        if (orders):\n            #遍历orders\n            Log(orders)\n            for i in range(len(orders)):\n                #判断orders的id是否不等于self.tradeOrderId\n                if (orders[i].Id != self.tradeOrderId):\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\n                    Log(orders[i].Id)\n                    exchange.CancelOrder(orders[i].Id)\n\n\n\n\n\n    #self的一个方法\n    def poll(self):\n\n        #self.numTick自加1\n        self.numTick +=1\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\n        self.updateTrades()\n        self.updateOrderBook()\n        self.balanceAccount()\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\n        burstPrice = self.prices[-1] * BurstThresholdPct\n        #创建变量并赋值\n        bull = False\n        bear = False\n        tradeAmount = 0\n        #判断self.account是否为真\n        if (self.account):\n            #是真的话就调用LogStatus函数并传入相应的参数\n            LogStatus(self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\",收割机当前启动次数:\",self.sgnum)\n\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\n        if (self.numTick > 2 and (self.prices[-1] - max(self.prices[-6:-1]) > burstPrice or self.prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2])):\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\n            bull = True\n            tradeAmount = self.cny / self.bidPrice * 0.99\n\n        #同上面if\n        elif (self.numTick > 2 and (self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice or self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2])):\n            bear = True\n            #赋值\n            tradeAmount = self.btc\n\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\n        if (self.vol < BurstThresholdVol):\n            tradeAmount *= self.vol / BurstThresholdVol\n\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\n        if (self.numTick < 5):\n            #tradeAmount=tradeAmount*0.8\n            tradeAmount *= 0.8\n\n        #判断self.numTick是否小于10\n        if (self.numTick < 10):\n            tradeAmount *= 0.8\n\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\n            return\n\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\n        tradePrice = self.bidPrice if bull else self.askPrice\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\n        while (tradeAmount >= MinStock):\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\n            orderId = exchange.Buy(self.bidPrice, tradeAmount) if bull else exchange.Sell(self.askPrice, tradeAmount)\n            self.sgnum+=1\n            Log(\"收割机第\",self.sgnum,\"次启动\")\n            #调用Sleep函数传入参数400，0.4秒后执行\n            Sleep(400)\n            #判断orderId是否为true\n            if (orderId):\n                #赋值\n                self.tradeOrderId = orderId\n                #赋值\n                order = None\n                while (True):\n                    #rder的值等于GetOrder函数的返回值\n                    order = exchange.GetOrder(orderId)\n                    #判断order是否为true\n                    if (order):\n                        #判断两边的值是否相等\n                        if (order.Status == ORDER_STATE_PENDING):\n                            #调用CancelOrder函数\n                            exchange.CancelOrder(orderId)\n                            #0.2秒后执行\n                            Sleep(200)\n                        else:\n                            #跳出循环\n                            break\n\n\n                #赋值\n                self.tradeOrderId = 0\n                tradeAmount -= order.DealAmount\n                tradeAmount *= 0.9\n                #判断两边是否相等\n                if (order.Status == ORDER_STATE_CANCELED):\n                    #调用self的updateOrderBook方法\n                    self.updateOrderBook()\n                    #判断是否为true,如果时就进行循环\n                    while (bull and self.bidPrice - tradePrice > 0.1):\n                        #赋值\n                        tradeAmount *= 0.99\n                        tradePrice += 0.1\n\n                    #判断是否为true,如果时就进行循环\n                    while (bear and self.askPrice - tradePrice < -0.1):\n                        tradeAmount *= 0.99\n                        tradePrice -= 0.1\n        #赋值\n        self.numTick = 0\n\n\n\n\n#函数main\ndef main():\n    #reaper 是构造函数的实例\n    reaper = LeeksReaper()\n    while (True):\n        #通过实例调用poll方法\n        reaper.poll()\n        Sleep(TickInterval)",
        "strategy_description": "策略名称: 移植-OKCoin-韭菜收割机-注释python版\n\n# self.btc = 0\n        #以上都是self对象的属性\n\n    #创建一个方法\n    def updateTrades(self):\n\n        trades = _C(exchange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\n                trades = _C(exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\n\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\n\n        tradesvol = 0\n        for trade in trades:\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\n                temp = trade.Time if trade.Id == 0 else trade.Id\n                self.lastTradeId = max(temp, self.lastTradeId)\n                tradesvol = tradesvol + trade.Amount\n\n\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\n\n\n    #self对象的一个方法\n    def updateOrderBook(self):\n\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\n        orderBook = _C(exchange.GetDepth)\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\n            #返回undefined\n            return\n        \n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\n        #同上\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\n        #删除price数组的第一个值，并返回第一个值\n        del(self.prices[0])\n        #prices数组向后添加值，值为函数_N的返回值\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\n            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\n\n    #self对象的一个方法\n    def balanceAccount(self):\n        # 创建一个变量account用来接收GetAccount函数返回的值\n        account = _C(exchange.GetAccount)\n        #判断account是否为空，是就返回undefined\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n        #获取当前时间的时间戳数据\n        now = time.time()\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\n            #赋值\n            self.preCalc = now\n            #创建一个变量net用来接收_N函数的返回值\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\n            #判断net是否不等于self.preNet，如果是就执行下方语句\n            if (net != self.preNet):\n                #赋值\n                self.preNet = net\n                #调用函数LogProfit并传入net\n                LogProfit(net-10000)\n\n        #赋值\n        self.btc = account.Stocks\n        self.cny = account.Balance\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\n        balanced = False\n        #判断self.p的值是否小于0.48\n        # Log(self.p)\n        if (self.p < 0.48):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.cny =self.cny-300\n            self.cny -= 300\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Bids) > 0):\n                #调用buy函数并传入相应的参数\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.01)\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.01)\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.01)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #如果self.p大于0.52就执行下方语句\n        elif (self.p > 0.52):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n            #self.btc=self.btc-0.03\n            self.btc -= 0.03\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\n            if (len(self.orderBook.Asks) > 0):\n                #调用Sell函数并传入相应的参数\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.01)\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.01)\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.01)\n\n                Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n        #调用函数Sleep并传入参数BalanceTimeout\n        Sleep(BalanceTimeout)\n        #创建标量order来接收GetOrders函数返回的值\n        orders = _C(exchange.GetOrders)\n        #判断orders是否为真\n        if (orders):\n            #遍历orders\n            Log(orders)\n            for i in range(len(orders)):\n                #判断orders的id是否不等于self.tradeOrderId\n                if (orders[i].Id != self.tradeOrderId):\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\n                    Log(orders[i].Id)\n                    exchange.CancelOrder(orders[i].Id)\n\n\n\n\n\n    #self的一个方法\n    def poll(self):\n\n        #self.numTick自加1\n        self.numTick +=1\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\n        self.updateTrades()\n        self.updateOrderBook()\n        self.balanceAccount()\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\n        burstPrice = self.prices[-1] * BurstThresholdPct\n        #创建变量并赋值\n        bull = False\n        bear = False\n        tradeAmount = 0\n        #判断self.account是否为真\n        if (self.account):\n            #是真的话就调用LogStatus函数并传入相应的参数\n            LogStatus(self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\",收割机当前启动次数:\",self.sgnum)\n\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\n        if (self.numTick > 2 and (self.prices[-1] - max(self.prices[-6:-1]) > burstPrice or self.prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2])):\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\n            bull = True\n            tradeAmount = self.cny / self.bidPrice * 0.99\n\n        #同上面if\n        elif (self.numTick > 2 and (self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice or self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2])):\n            bear = True\n            #赋值\n            tradeAmount = self.btc\n\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\n        if (self.vol < BurstThresholdVol):\n            tradeAmount *= self.vol / BurstThresholdVol\n\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\n        if (self.numTick < 5):\n            #tradeAmount=tradeAmount*0.8\n            tradeAmount *= 0.8\n\n        #判断self.numTick是否小于10\n        if (self.numTick < 10):\n            tradeAmount *= 0.8\n\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\n            return\n\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\n        tradePrice = self.bidPrice if bull else self.askPrice\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\n        while (tradeAmount >= MinStock):\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\n            orderId = exchange.Buy(self.bidPrice, tradeAmount) if bull else exchange.Sell(self.askPrice, tradeAmount)\n            self.sgnum+=1\n            Log(\"收割机第\",self.sgnum,\"次启动\")\n            #调用Sleep函数传入参数400，0.4秒后执行\n            Sleep(400)\n            #判断orderId是否为true\n            if (orderId):\n                #赋值\n                self.tradeOrderId = orderId\n                #赋值\n                order = None\n                while (True):\n                    #rder的值等于GetOrder函数的返回值\n                    order = exchange.GetOrder(orderId)\n                    #判断order是否为true\n                    if (order):\n                        #判断两边的值是否相等\n                        if (order.Status == ORDER_STATE_PENDING):\n                            #调用CancelOrder函数\n                            exchange.CancelOrder(orderId)\n                            #0.2秒后执行\n                            Sleep(200)\n                        else:\n                            #跳出循环\n                            break\n\n\n                #赋值\n                self.tradeOrderId = 0\n                tradeAmount -= order.DealAmount\n                tradeAmount *= 0.9\n                #判断两边是否相等\n                if (order.Status == ORDER_STATE_CANCELED):\n                    #调用self的updateOrderBook方法\n                    self.updateOrderBook()\n                    #判断是否为true,如果时就进行循环\n                    while (bull and self.bidPrice - tradePrice > 0.1):\n                        #赋值\n                        tradeAmount *= 0.99\n                        tradePrice += 0.1\n\n                    #判断是否为true,如果时就进行循环\n                    while (bear and self.askPrice - tradePrice < -0.1):\n                        tradeAmount *= 0.99\n                        tradePrice -= 0.1\n        #赋值\n        self.numTick = 0"
    },
    {
        "strategy_id": "117_简易等差合约网格",
        "strategy_code": "python\n'''backtest\nstart: 2021-01-01 00:00:00\nend: 2021-11-17 00:00:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"BTC_USDT\",\"balance\":2500}]\nargs: [[\"H\",30],[\"n1\",0.001],[\"grid\",300],[\"xia\",50000]]\n'''\n\ndef CancelPendingOrders():\n    orders = _C(exchanges[0].GetOrders)\n    if len(orders)>0:\n        for j in range(len(orders)):\n            exchanges[0].CancelOrder(orders[j].Id, orders[j])\n            j=j+1\n\ndef main():\n    exchange.SetContractType('swap')\n    exchange.SetMarginLevel(M)\n    currency=exchange.GetCurrency()\n    if _G('buyp') and _G('sellp'):\n        buyp=_G('buyp')\n        sellp=_G('sellp')\n        Log('读取网格价格')\n    else:\n        ticker=exchange.GetTicker()\n        buyp=ticker[\"Last\"]-grid\n        sellp=ticker[\"Last\"]+grid\n        _G('buyp',buyp)\n        _G('sellp',sellp)\n        Log('网格数据初始化')\n    while True:\n            account=exchange.GetAccount()\n            ticker=exchange.GetTicker()\n            position=exchange.GetPosition()\n            orders=exchange.GetOrders()\n            if len(position)==0:\n                if ticker[\"Last\"]>shang:\n                    exchange.SetDirection('sell')\n                    exchange.Sell(-1,n1*H)\n                    Log(currency,'到达开空区域,买入空头底仓')\n                    \n                else:\n                    exchange.SetDirection('buy')\n                    exchange.Buy(-1,n1*H)\n                    Log(currency,'到达开多区域,买入多头底仓')\n            if len(position)==1:\n                if position[0][\"Type\"]==1:\n                    if ticker[\"Last\"]<xia:\n                        Log(currency,'空单全部止盈反手')\n                        exchange.SetDirection('closesell')\n                        exchange.Buy(-1,position[0].Amount)\n                    else:\n                        orders=exchange.GetOrders()\n                        if len(orders)==0:\n                            exchange.SetDirection('sell')\n                            exchange.Sell(sellp,n1)\n                            exchange.SetDirection('closesell')\n                            exchange.Buy(buyp,n1)\n                        if len(orders)==1:\n                            if orders[0][\"Type\"]==1: #止盈成交\n                                Log(currency,'网格减仓,当前份数:',position[0].Amount)\n                                CancelPendingOrders()\n                                buyp=buyp-grid\n                                sellp=sellp-grid\n                                LogProfit(account[\"Balance\"])\n                            if orders[0][\"Type\"]==0:\n                                Log(currency,'网格加仓,当前份数:',position[0].Amount)\n                                CancelPendingOrders()\n                                buyp=buyp+grid\n                                sellp=sellp+grid\n                                LogProfit(account[\"Balance\"])\n            \n                if position[0][\"Type\"]==0:\n                    if ticker[\"Last\"]>float(shang):\n                        Log(currency,'多单全部止盈反手')\n                        exchange.SetDirection('closebuy')\n                        exchange.Sell(-1,position[0].Amount)\n                    else:\n                        orders=exchange.GetOrders()\n                        if len(orders)==0:\n                            exchange.SetDirection('buy')\n                            exchange.Buy(buyp,n1)\n                            exchange.SetDirection('closebuy')\n                            exchange.Sell(sellp,n1)\n                        if len(orders)==1:\n                            if orders[0][\"Type\"]==0: #止盈成交\n                                Log(currency,'网格减仓,当前份数:',position[0].Amount)\n                                CancelPendingOrders()\n                                buyp=buyp+grid\n                                sellp=sellp+grid\n                                LogProfit(account[\"Balance\"])\n                            if orders[0][\"Type\"]==1:\n                                Log(currency,'网格加仓,当前份数:',position[0].Amount)\n                                CancelPendingOrders()\n                                buyp=buyp-grid\n                                sellp=sellp-grid\n                                LogProfit(account[\"Balance\"])",
        "strategy_description": "策略名称: 简易等差合约网格\n\n未找到描述"
    },
    {
        "strategy_id": "118_练习01RSI",
        "strategy_code": "python\n\ndef RSI():\n    ticker = exchange.GetTicker()\n    account = exchange.GetAccount()\n    r = exchange.GetRecords(PERIOD_H1 * 4)\n    rsi = TA.RSI(r, 14)\n    is_buy = False\n    is_sell = False\n    if rsi[-1] > 70 and account[\"Stocks\"] > 0:\n        id = exchange.Sell(ticker[\"Buy\"], account[\"Stocks\"] * 0.01)\n        is_buy = True\n    elif rsi[-1] < 30 and account[\"Balance\"] > 0:\n        id = exchange.Buy(ticker[\"Sell\"], account[\"Balance\"] / ticker[\"Sell\"] * 0.01)\n        is_sell = True\n\n\n    if is_buy or is_sell:\n        Sleep(1000 * 60 * 4)\n        \n#    if rsi[-1] < 40 and account[\"Balance\"] > 0:\n#        id = exchange.Buy(ticker[\"Buy\"], account[\"Balance\"] / ticker[\"Sell\"] * 0.0005)\n#    if rsi[-1] > 60 and account[\"Stocks\"] > 0:\n#        id = exchange.Sell(ticker[\"Sell\"], account[\"Stocks\"] * 0.0005)\n#    if rsi[-1] < 40 and account[\"Balance\"] > 0:\n#        id = exchange.Buy(ticker[\"Buy\"], account[\"Balance\"] / ticker[\"Sell\"] * 0.05)\n    return\n \ndef main():\n    Log(\"策略开始 !\")\n    i = 0\n    while True:        #循环\n        RSI()       #执行策略主函数\n        i = i + 1\n        if i % 50 == 0:\n            account = exchange.GetAccount()\n            Log(account[\"Balance\"], account[\"Stocks\"])\n        \n'''\ndef main():\n    Log(\"策略开始 !\")\n    ticker = exchange.GetTicker()\n    account = exchange.GetAccount()\n    id = exchange.Buy(ticker[\"Buy\"], 0.01)\n    Log(account[\"Balance\"])\n    Log(id)\n    Sleep(60 * 1000)\n'''",
        "strategy_description": "策略名称: 练习01RSI\n\n#        id = exchange.Buy(ticker[\"Buy\"], account[\"Balance\"] / ticker[\"Sell\"] * 0.0005)"
    },
    {
        "strategy_id": "119_网格合约",
        "strategy_code": "python\n'''backtest\nstart: 2020-02-27 00:00:00\nend: 2020-02-27 00:00:00\nperiod: 1d\nexchanges: [{\"eid\":\"Futures_OKCoin\",\"currency\":\"ETH_USD\",\"stocks\":1.6}]\n'''\n#常规上下网格\nimport json\nglobal_param={\n              'sell_id':0,\n              'buy_id':0,\n              'buy_amount':0,#当前多单数量\n              'sell_amount':0,#当前空单数量\n              'buy_profit':0,#多单利润\n              'sell_profit':0#空单利润\n             }\n\ndef open_order(price):\n    net_buy_count = global_param['buy_amount'] / net_amount\n    net_sell_count = global_param['sell_amount'] / net_amount\n    if(net_buy_count>= net_limit or net_sell_count>=net_limit):\n        Log(\"超过网格数量限制，不开仓！\")\n        return\n    if(net_type == 1 or net_type == 2):#如果设置为开空或者多空双开\n        exchange.SetDirection(\"sell\")#设置下单类型为做空\n        order_id = exchange.Sell(_N(price*(1+net_interval),2),net_amount)#以当前价格上限开空，合约数量为10张下单\n        global_param['sell_id'] = order_id\n    if(net_type == 0 or net_type == 2):#如果设置为开多或者多空双开\n        exchange.SetDirection(\"buy\")#设置下单类型为做多\n        order_id = exchange.Buy(_N(price*(1-net_interval),2),net_amount)#以当前价格下限开多，合约数量为10张下单                        \n        global_param['buy_id'] = order_id\n        \ndef cancel_order():\n    for order in _C(exchange.GetOrders):\n        _C(exchange.CancelOrder,int(order['Id']))\n    global_param['sell_id']=0\n    global_param['buy_id']=0\n        \ndef judge_order_finish():\n    if(global_param['buy_id']!=0):\n        order = exchange.GetOrder(global_param['buy_id'])\n        if(order[\"Status\"]==ORDER_STATE_CLOSED):\n            return True\n        else:\n            return False\n    if(global_param['sell_id']!=0):\n        order = exchange.GetOrder(global_param['sell_id'])\n        if(order[\"Status\"]==ORDER_STATE_CLOSED):\n            return True  \n        else:\n            return False\n    return True\n        \ndef get_position():\n    global_param['sell_amount'] = 0\n    global_param['sell_profit'] = 0\n    global_param['buy_amount'] = 0\n    global_param['buy_profit'] = 0\n    positions= exchange.GetPosition()\n    for position in positions:\n        if(position['Type']==PD_SHORT): #空仓      \n            global_param['sell_amount'] = position['Amount']#获取空单持仓\n            global_param['sell_profit'] = position['Profit']#获取空单盈利\n        elif(position['Type']==PD_LONG):\n            global_param['buy_amount'] = position['Amount']#获取多单持仓\n            global_param['buy_profit'] = position['Profit']#获取多单盈利\n\n    \ndef check_stop(price):#止盈止损判断\n    total_profit = global_param['sell_profit'] + global_param['buy_profit']\n    if( total_profit>= stop_profit or total_profit<=-stop_loss):#如果获利达到止盈值或者亏损达到止损值 平仓\n        Log(\"止盈止损平仓，当前持仓总盈利\",total_profit)\n        if(global_param['sell_amount']>0):  \n            Log(\"sell_amount\",global_param['sell_amount'])\n            exchange.SetDirection(\"closesell\");#设置下单类型为平空\n            exchange.Buy(_N(price*1.005,2),global_param['sell_amount'])\n        if(global_param['buy_amount']>0):\n            Log(\"buy_amount\",global_param['buy_amount'])\n            exchange.SetDirection(\"closebuy\");#设置下单类型为平多\n            exchange.Sell(_N(price*0.995,2),global_param['buy_amount'])\n                \ndef main():\n    exchange.SetContractType(contract_type)#设置合约\n    exchange.SetMarginLevel(margin_level)#杠杆比例\n    while True:\n        ticker = exchange.GetTicker()\n        price = ticker['Last']\n        get_position()\n        check_stop(price)\n        if(judge_order_finish()):\n            Log(\"当前价格为:\",price)\n            cancel_order()#撤单\n            open_order(price)#下单\n        Sleep(1000)",
        "strategy_description": "策略名称: 网格合约\n\n未找到描述"
    },
    {
        "strategy_id": "120_网格管理工具",
        "strategy_code": "# 创建了一个价格1000-800，数量为10的等差网格\nGridPriceManager(upper_price=1000, lower_price=800, grid_num=10)\n\n# 创建了一个价格1000-800，间隔为1%的等比网格\nGridPriceManager(upper_price=1000, lower_price=800, interval=1)\n\n# 传入已有网格信息\ndata = {\n\t\"grid_list\":    {99:None,100:None,101:None,102:None,103:None,104:None},\n\t\"interval\":     None,\n\t\"upper_price\":  104,\n\t\"lower_price\":  99,\n\t\"grid_num\":     6,\n\t\"side\":         \"long\",\n\t\"grid_diff\":    1,\n\t\"type\":         \"等差\",\n}\nGridPriceManager(Data=data)\n\n# ==========================================\n\ngm = GridPriceManager(1000, 800, 10)\n\n# 底仓事件，在调用base_position方法时会触发此事件\n@gm.event('base_position')\ndef base_position(price):\n    # 传入最近的网格价格，以此价格作为买入价格参考\n    print(price)\n    return 123456\t# 返回底仓订单，manger将订单记录\n\n# ==========================================\n\npython\ngm = GridPriceManager(1000, 800, 10)\n\n# 底仓事件，在调用base_position方法时会触发此事件\n@gm.event('base_position')\ndef base_position(price):\n    # 传入最近的网格价格，以此价格作为买入价格参考\n    print(price)\n    return 123456\t# 返回底仓订单，manger将订单记录\n\n# ==========================================\n\npython\nclass GridPriceManager:\n    def __init__(self, Data=None, upper_price=None, lower_price=None, interval=None, grid_num=None, side: Literal['long','short']='long') -> dict:\n        self.interval = interval\n        self.upper_price = upper_price\n        self.lower_price = lower_price\n        self.grid_num = grid_num\n        self.side = side\n        self.grid_diff = None\n        self.type = None    # 网格类型\n        if self.grid_num is not None:\n            self.grid_diff = (self.upper_price - self.lower_price) / (self.grid_num - 1)\n        if Data is None: \n            if self.interval is None:\n                self.grid_list = self._generate_grid_list_difference()\n                self.type = \"等差\"\n            else:\n                self.grid_list = self._generate_grids_list_ratio()\n                self.type = \"等比\"\n        else:\n            self.grid_list = Data[\"grid_list\"]\n            self.interval = Data[\"interval\"]\n            self.upper_price = Data[\"upper_price\"]\n            self.lower_price = Data[\"lower_price\"]\n            self.grid_num = Data[\"grid_num\"]\n            self.side = Data[\"side\"]\n            self.grid_diff = Data[\"grid_diff\"]\n            self.type = Data[\"type\"]\n        self.data = f\"网格类型: {self.type}, 网格数量: {len(self.grid_list)}, 上下区间: [{self.upper_price}-{self.lower_price}, 方向: {self.side}]\"\n        self.callback = {}\n\n    def event(self, event_name):\n        \"\"\"事件\"\"\"\n        def decorator(func):\n            self.callback[event_name] = func\n            return func\n        return decorator\n\n    def _generate_grid_list_difference(self) -> dict:\n        \"\"\"等差网格生成\"\"\"\n        grid_list = {}\n        price = self.lower_price\n        for _ in range(self.grid_num):\n            grid_list[price] = None\n            price += self.grid_diff\n        grid_list[self.upper_price] = None\n        return grid_list\n\n    def _generate_grids_list_ratio(self) -> dict:\n        \"\"\"等比网格生成\"\"\"\n        ratio = 1 + self.interval / 100\n        grid = [self.lower_price * (ratio ** i) for i in range(-100, 101)]\n        return {round(g, 8): None for g in grid if self.lower_price <= g <= self.upper_price}\n\n\n    def get_nearest_buy_price(self, current_price) -> float:\n        \"\"\"获取最近网格买入价格\"\"\"\n        nearest_price = None\n        for price in sorted(self.grid_list.keys()):\n            if price > current_price:\n                break\n            nearest_price = price\n        return nearest_price\n\n    def get_nearest_sell_price(self, current_price) -> float:\n        \"\"\"获取最近网格卖出价格\"\"\"\n        nearest_price = None\n        for price in sorted(self.grid_list.keys(), reverse=True):\n            if price < current_price:\n                break\n            nearest_price = price\n        return nearest_price\n    \n    def base_position(self, ticker) -> Union[str, int]:\n        \"\"\"底仓\"\"\"\n        if self.side == \"short\":\n            t = self.get_nearest_sell_price(ticker)\n        else:\n            t = self.get_nearest_buy_price(ticker)\n        order_id = self.callback[\"base_position\"](t)\n        self.grid_list[t] = order_id\n        self.callback[\"change\"](self.grid_list)\n        return order_id\n    \n    def add_order(self, order_id) -> Union[Dict, bool]:\n        \"\"\"增加网格上下挂单\"\"\"\n        up_price = None\n        down_price = None\n        ticker = None\n        keys = list(self.grid_list.keys())\n        for i in range(len(keys)-1):\n            if self.grid_list[keys[i]] == order_id:\n                ticker = keys[i]\n                try:\n                    if self.side is None or self.side == \"long\":\n                        up_price = keys[i+1]\n                        down_price = keys[i-1]\n                    else:\n                        up_price = keys[i-1]\n                        down_price = keys[i+1]\n                except IndexError:\n                    return False\n                break\n\n        PriceDict = {\"up\": up_price, \"down\": down_price}\n        d = self.callback[\"add_order\"](PriceDict)\n        d = {\"up\": d[\"up\"], \"down\": d[\"down\"]}\n        self.grid_list[up_price] = d[\"up\"]\n        self.grid_list[down_price] = d[\"down\"]\n        self.grid_list[ticker] = None\n        self.callback[\"change\"](self.grid_list)\n        return d\n    \n    def cancel_order(self, order_id):\n        \"\"\"撤销订单\"\"\"\n        result = self.callback[\"cancel_order\"](order_id)\n        if result == True:\n            for items in self.grid_list.items():\n                if items[1] == order_id:\n                    self.grid_list[items[0]] = None\n                    self.callback[\"change\"](self.grid_list)\n                    break\n\ndef main():\n    gm = GridPriceManager(1000, 500, 10)\n\n    @gm.event('add_order')\n    def add_order(price):\n        print(price)\n        return {\n            'up': 36543,\n            'down': 87957,\n        }\n\n    @gm.event('cancel_order')\n    def cancel_order(order_id):\n        return True\n\n    @gm.event('base_position')\n    def base_position(price):\n        print(price)\n        return 123456\n\n    a = gm.base_position(600)\n    print(a)\n    a = gm.add_order(123456)\n    print(gm.grid_list)\n    gm.cancel_order(87957)\n    print(gm.grid_list)",
        "strategy_description": "策略名称: 网格管理工具\n\n| 参数        | 是否必需 | 描述                                        |\n| ----------- | -------- | ------------------------------------------- |\n| upper_price | NO       | 网格上边界价格                              |\n| lower_price | NO       | 网格下边界价格                              |\n| grid_num    | NO       | 网格数量(等差)                              |\n| interval    | NO       | 网格间隔(等比)                              |\n| side        | NO       | 支持传入`long`，`short`，不填写则默认`long` |\n| Data        | NO       | 已有网格信息，类型为字典                    |\n\n```python"
    },
    {
        "strategy_id": "121_自动获取币安永续合约交易精度最小开仓u已弃坑",
        "strategy_code": "python\ndef init():\n    global symbols, min_value\n    # 获取交易规则\n    exchange.SetBase('https://dapi.binance.com')\n    rule = exchange.IO(\"api\", \"GET\", \"/dapi/v1/exchangeInfo\", \"\", \"\")[\"symbols\"]\n    Log(rule)\n    # 获取交易对名称\n    for i in range(len(exchanges)):\n        exchanges[i].SetMarginLevel(M)\n        exchanges[i].SetContractType(\"swap\")  # 设置永续合约\n        _symbol = exchanges[i].GetCurrency().split(\"_\")[0]   # +'USDT'币本位交易对名称\n        # 设置交易精度\n        j = 0\n        flag1 = False\n        flag2 = False\n        #Log(rule)\n        while (j < len(rule)) and flag1 == False and flag2 == False:\n            if str(rule[j][\"symbol\"]).rfind(_symbol)>=0:\n                for x in rule[j][\"filters\"]:\n                    if x[\"filterType\"] == \"PRICE_FILTER\" and flag1 == False:\n                        #Log(\"价格\",x[\"tickSize\"])\n                        #Log(len(str(float(x[\"tickSize\"])).split('.')[-1]))\n                        price_precision = len(str(float(x[\"tickSize\"])).split('.')[-1])\n                        flag1 = True\n                    elif x[\"filterType\"] == \"LOT_SIZE\" and flag2 == False:\n                        amount_precision = len(x[\"minQty\"].split('.')[-1])\n                        flag2 = True\n            j = j + 1\n        exchanges[i].SetPrecision(price_precision, amount_precision)\n    Log(\"初始化结束\")",
        "strategy_description": "策略名称: 自动获取币安永续合约交易精度最小开仓u已弃坑\n\nexchange.SetBase('https://dapi.binance.com')\n    rule = exchange.IO(\"api\", \"GET\", \"/dapi/v1/exchangeInfo\", \"\", \"\")[\"symbols\"]\n    Log(rule)\n    # 获取交易对名称\n    for i in range(len(exchanges)):\n        exchanges[i].SetMarginLevel(M)\n        exchanges[i].SetContractType(\"swap\")  # 设置永续合约\n        _symbol = exchanges[i].GetCurrency().split(\"_\")[0]   # +'USDT'币本位交易对名称\n        # 设置交易精度\n        j = 0\n        flag1 = False\n        flag2 = False\n        #Log(rule)\n        while (j < len(rule)) and flag1 == False and flag2 == False:\n            if str(rule[j][\"symbol\"]).rfind(_symbol)>=0:\n                for x in rule[j][\"filters\"]:\n                    if x[\"filterType\"] == \"PRICE_FILTER\" and flag1 == False:\n                        #Log(\"价格\",x[\"tickSize\"])\n                        #Log(len(str(float(x[\"tickSize\"])).split('.')[-1]))\n                        price_precision = len(str(float(x[\"tickSize\"])).split('.')[-1])\n                        flag1 = True\n                    elif x[\"filterType\"] == \"LOT_SIZE\" and flag2 == False:\n                        amount_precision = len(x[\"minQty\"].split('.')[-1])\n                        flag2 = True\n            j = j + 1\n        exchanges[i].SetPrecision(price_precision, amount_precision)\n    Log(\"初始化结束\")\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/322632\n\n> Last Modified\n\n2021-11-12 15:44:44"
    },
    {
        "strategy_id": "122_获取和讯期货数据Python版本",
        "strategy_code": "python\n#coding: utf-8\nimport urllib2 as url\nimport json\nimport time\n\ndef hxRecords(instrument,timeFrame=1,size=1,includeLastBar=True,to_df=True):\n    ##从和讯获取期货实时数据\n    pInst=instrument.lower()\n    if pInst[-4]!='1':\n        pInst=pInst[:-3]+'1'+pInst[-3:]\n    xchg=None\n    for i in instList:\n        if pInst[:-4] in i['inst']:\n            xchg=i['xchg']\n    if xchg is None:\n        print (\"获取K线时发生错误: 找不到合约\")\n        return None\n    tfs=[1,5,15,30,60,'D','W']\n    tf=None\n    for i in range(len(tfs)):\n        if timeFrame==tfs[i]:\n            tf=i\n    if tf is None:\n        print(\"获取K线时发生错误: K线周期不正确\")\n        return None\n    now=time.localtime()\n    timestr=str(now.tm_year+1)+str(12)+str(31)+'000000'\n    resp='http://webftcn.hermes.hexun.com/shf/kline?code=' + xchg + pInst + '&start=' + timestr + '&number=-' + str(size) + '&type=' + str(tf)\n    try:\n        resp=url.urlopen(resp)\n        resp=resp.read()[1:-2]\n        resp=json.loads(resp)['Data']\n    except:\n        print '获取K线时发生错误: 不完整的JSON数据'\n        return None\n    re=[]\n    pw=float(resp[4])\n    for i in resp[0]:\n        res=dict(Time=time.mktime(time.strptime(str(i[0]),'%Y%m%d%H%M%S'))*1000,Open=i[2]/pw,High=i[4]/pw\n                ,Low=i[5]/pw,Close=i[3]/pw,Volume=i[6])\n        re.append(res)\n    if to_df:\n        re=pd.DataFrame(re)\n        col=[]\n        for i in re.columns:\n            if i is 'Time':\n                i='Date'\n            col.append(i.lower())\n        re.columns=col\n        re['date']=re['date'].map(ts_dt64)\n    return re\n        \n\ninstList = [{\n    \"xchg\": \"SHFE\",\n    \"inst\": [\"fu\", \"ru\", \"wr\"]\n}, {\n    \"xchg\": \"SHFE2\",\n    \"inst\": [\"ag\", \"au\"]\n}, {\n    \"xchg\": \"SHFE3\",\n    \"inst\": [\"al\", \"bu\", \"cu\", \"hc\", \"ni\", \"pb\", \"rb\", \"sn\", \"zn\"]\n}, {\n    \"xchg\": \"CZCE\",\n    \"inst\": [\"cf\", \"fg\", \"lr\", \"ma\", \"oi\", \"pm\", \"ri\", \"rm\", \"rs\", \"sf\", \"sm\", \"sr\", \"ta\", \"wh\", \"zc\"]\n}, {\n    \"xchg\": \"DCE\",\n    \"inst\": [\"a\", \"b\", \"bb\", \"c\", \"cs\", \"fb\", \"i\", \"j\", \"jd\", \"jm\", \"l\", \"m\", \"p\", \"pp\", \"v\", \"y\"]\n}]\n\ndef main():\n    Log(exchange.GetAccount())",
        "strategy_description": "策略名称: 获取和讯期货数据Python版本\n\n未找到描述"
    },
    {
        "strategy_id": "123_获取持仓均价你用对了吗",
        "strategy_code": "python\ndef  getAvgPrice(position):\n    if hasattr(position[0],'Info') and hasattr(position[0].Info,'cost_open'):# Huobi\n        return position[0].Info.cost_open\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'avg_cost'):#OKex\n        return position[0].Info.avg_cost\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'entryPrice'):#binance\n        return position[0].Info.entryPrice\n    else:\n        return position[0][\"Price\"] \n\ndef main():\n    Log(exchange.GetAccount())\n    position = exchanges[0].GetPosition()\n    if len(position)>0:\n        avgPrice = getAvgPrice(position)\n        Log(avgPrice)",
        "strategy_description": "策略名称: 获取持仓均价你用对了吗\n\nreturn position[0].Info.cost_open\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'avg_cost'):#OKex\n        return position[0].Info.avg_cost\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'entryPrice'):#binance\n        return position[0].Info.entryPrice\n    else:\n        return position[0][\"Price\"] \n\ndef main():\n    Log(exchange.GetAccount())\n    position = exchanges[0].GetPosition()\n    if len(position)>0:\n        avgPrice = getAvgPrice(position)\n        Log(avgPrice)\n    \n    \n\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/261288\n\n> Last Modified\n\n2021-03-11 14:45:53"
    },
    {
        "strategy_id": "124_要饭机器人30",
        "strategy_code": "python\n\n#!,encrypt\n'''backtest\nstart: 2022-01-01 00:00:00\nend: 2022-01-31 23:59:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"OKX\",\"currency\":\"ETH_USDT\",\"balance\":1000,\"stocks\":0,\"fee\":[0.08,0.1]}]\n'''\n\nfrom datetime import datetime, timedelta, timezone\nimport json\n\nIs_Debug = False\nmanager = None\ndebug = None\nlog = None\n\ndef main():\n    Log('开始要饭了')\n    EnableLog(Is_Debug)\n    OnInit()\n    while True:\n        Sleep(1000)\n        manager.LoadData()\n        OnCommand()\n        manager.OnTick()\n        manager.SaveData()\n    Log('要饭结束了')\n\n#如果曾经没有数据，则初始化所有数据。\ndef OnInit():\n    #设置重试时间间隔\n    _CDelay(600000)\n    #过滤网络错误日志\n    global Is_Debug\n    if Is_Debug == False:\n        SetErrorFilter(\"400:|503:|429:|504:\")\n    \n    global manager\n    manager = Manager()\n\n    return\n\n#处理来自UI的交互响应\ndef OnCommand():\n    pass\n\n\nclass Manager:\n    Account = None\n    Tick = None\n    State = \"\"\n    Node_List = []\n\n    BuyPrice = 0\n    SellPrice = 0\n    Balance = 0\n    Stocks = 0\n    TickTime = 0\n    FrozenBalance = 0\n    FrozenStocks = 0\n\n    #防守模式中的盈利次数\n    DefenceProfitCount = 0\n\n    ClearOrder = 0\n\n    def Ins():\n        global manager\n        if manager == None:\n            manager = Manager()\n        return manager\n\n    def GetInfo(self):\n        self.Tick = _C(exchange.GetTicker)\n        if self.Tick == None:\n            return False\n        \n        self.Account = _C(exchange.GetAccount)\n        if self.Account == None:\n            return False\n        \n        self.SellPrice = self.Tick[\"Sell\"]\n        self.BuyPrice = self.Tick[\"Buy\"]\n        self.Balance = self.Account[\"Balance\"]\n        self.Stocks = self.Account['Stocks']\n        self.TickTime = self.Tick['Time']\n        self.FrozenBalance = self.Account['FrozenBalance']\n        self.FrozenStocks = self.Account['FrozenStocks']\n        return True\n\n    def OnTick(self):\n        if self.GetInfo() == False:\n            return\n\n        if self.State == \"\":\n            #第一次运行\n            MyLog.Ins().StartTime = self.TickTime\n            MyLog.Ins().StartMoney = self.TotalMoney()\n            self.ToAttack()\n        else:\n            MyLog.Ins().PrintLog()\n\n        if self.State == \"平仓\":\n            self.ClearTick()\n            return\n\n        if self.State == '防守':\n            if self.DefenceProfitCount >= UI_AttackThreshold:\n                MyLog.Write(\"防守计分足够，进入进攻模式。\")\n                self.ToAttack()\n                return\n\n        if len(self.Node_List) == 0:\n            #仓位空，原地买\n            node = Node.Buy(self.SellPrice, self.GetBuyNumber())\n            if node != None:\n                self.Node_List.append(node)\n                last_node = Node.Buy(Node.MinLeftPrice(), self.GetBuyNumber())\n                if last_node != None:\n                    self.Node_List.insert(0, last_node)\n            return\n\n        if Node.CenterNode() != None:\n            #我在节点中间\n            if self.NodeCheck(Node.CenterNode()):\n                #检查自己\n                return\n            \n            index = Manager.Ins().Node_List.index(Node.CenterNode())\n            if index > 0:\n                #说明左边有节点\n                left = self.Node_List[index-1]\n                #问问节点\n                if self.NodeCheck(left):\n                    return\n                #问问买单\n                if Node.CenterNode()['buy_order'] == 0:\n                    self.NodeBuy(Node.CenterNode())\n                    MyLog.AddBuyBuyTimes()\n                    return\n            else:\n                #说明左边没节点\n                if len(self.Node_List) < UI_NodeCount:\n                    #那就建一个节点\n                    left_node = Node.Buy(Node.CenterNode()['buy_price'] * 0.995, self.GetBuyNumber())\n                    if left_node != None:\n                        self.Node_List.insert(0, left_node)\n                    MyLog.AddBuyBuyTimes()\n                    return\n\n            #再看看右边有没有\n            if index < len(self.Node_List) - 1:\n                right = self.Node_List[index + 1]\n                if self.NodeCheck(right):\n                    return\n                #右边的，不用下买单，不然会亏\n\n        if self.SellPrice < Node.MinPrice():\n            #重新检查自己是不是在所有节点左边\n            if len(self.Node_List) >= UI_NodeCount:\n                #看看高位有没有垃圾仓\n                if Node.HasSell(Node.MaxNode()) == False:\n                    #再看看买单是不是成功了，以防万一\n                    if Node.CheckBuy(Node.MaxNode()) == False:\n                        #这是个垃圾单，可以删除\n                        Node.NodeClear(Node.MaxNode())\n                        self.Node_List.remove(Node.MaxSellPrice)\n                        return\n                #平仓\n                MyLog.Write(\"节点在最左边，并且仓位满了，平仓\" + \"当前价格：\" + str(self.SellPrice))\n                self.ToClear()\n                return\n            else:\n                #贴边买一个\n                MyLog.Write(\"节点在最左边，仓位没好，买一单\" + \"当前价格：\" + str(self.SellPrice))\n                new_node = Node.Buy(Node.MinLeftPrice(),self.GetBuyNumber())\n                if new_node != None:\n                    self.Node_List.insert(0,new_node)\n                MyLog.AddBuyBuyTimes()\n                return\n\n        if self.SellPrice > Node.MaxSellPrice():\n            #我在所有节点的右边\n            #看看满了没，没满就下单，满了就减仓\n            if len(self.Node_List) >= UI_NodeCount:\n                #满了，减仓\n                if Node.HasSell(Node.MinNode()) == False:\n                    if Node.HasBuy(Node.MinNode()) == False or Node.CheckBuy(Node.MinNode()) == False:\n                        MyLog.Write(\"突然暴涨，单还满了，减个仓\" + \"。当前价格：\" + str(self.SellPrice))\n                        Node.NodeClear(Node.MinNode())\n                        self.Node_List.remove(Node.MinNode())\n                        return\n                self.NodeCheck(Node.MinNode())\n            else:\n                #下单，贴\n                MyLog.Write(\"突然暴涨，单没满，从下往上补仓位\" + \"当前价格：\" + str(self.SellPrice))\n                new_node = Node.Buy(Node.MaxSellPrice(), self.GetBuyNumber())\n                if new_node != None:\n                    self.Node_List.append(new_node)\n\n\n    def NodeBuy(self,_node):\n        node = Node.Buy(_node['buy_price'], self.GetBuyNumber())\n        if node == None:\n            return None\n        _node['buy_order'] = node['buy_order']\n        _node['state'] = node['state']\n        _node['number'] = 0\n        \n        return _node\n\n    def NodeCheck(self,_node):\n        if Node.HasSell(_node):\n            #我有卖单,检查卖单\n            if Node.CheckSell(_node):\n                MyLog.Write(\"我所处的节点卖好了。\" + \"当前价格：\" + str(self.SellPrice))\n                MyLog.Ins().WriteProfit(Node.GetProfit(_node))\n                Node.Reset_Node(_node)\n                MyLog.Ins().BuyBuy_Count = 0#重新计数\n                return True\n        else:\n            if Node.HasBuy(_node):\n                if Node.CheckBuy(_node):\n                    Node.Sell(_node)\n                    return True\n        return False\n\n    def DelEmptyNode(self,_node):\n        self.Node_List.remove(_node)\n        Node.NodeClear(_node)\n        return\n\n    #处理卖掉的节点。\n    def DelSellNode(self,_node):\n        self.Node_List.remove(_node)\n        MyLog.Ins().WriteProfit(Node.GetProfit(_node))\n        return\n\n\n    #平仓\n    def ClearTick(self):\n        #收集清单，逐一取消\n        MyLog.Write(\"平仓运行中\")\n        orders = exchange.GetOrders()\n        if len(orders) > 0:\n            MyLog.Write(\"未处理订单大于0，取消订单\")\n            for _o in orders:\n                Node.CancelOrder(_o['Id'])\n            return\n        self.Node_List.clear()\n        #统计仓位，统一售卖\n        if self.Stocks + self.FrozenStocks > 50 / self.BuyPrice:\n            MyLog.Write(\"有持仓，卖掉\")\n            if self.ClearOrder == 0:\n                #售卖\n                MyLog.Write(\"有持仓，数量：\" + str(_N(self.Stocks,4)) + \"。 卖价：\" + str(_N(self.BuyPrice * 0.999,4)))\n                order_id = exchange.Sell(self.BuyPrice * 0.999, self.Stocks)\n                if order_id == None:\n                    MyLog.Write(\"奇怪的错误产生了，160行左右。\")\n                    return\n                self.ClearOrder = order_id\n                Sleep(100000)\n                return\n            else:\n                order = _C(exchange.GetOrder,self.ClearOrder)\n                if order['Status'] != 1:\n                    MyLog.Write(\"订单没有卖掉，重新换价格\")\n                    Node.CancelOrder(self.ClearOrder)\n                    self.ClearOrder = 0\n                    return\n                elif order['Status'] == 1:\n                    MyLog.Write(\"订单卖掉了，退出平仓模式\")\n                    self.ClearOrder = 0\n\n                #无限循环，直到卖完币\n        \n        #当清单为0，仓位为0，则进入防守模式。\n        self.ToDefence()\n\n    #转移到防守阶段\n    def ToDefence(self):\n        MyLog.Write('进入防守')\n        if self.State == \"平仓\":\n            MyLog.Ins().Defence_Count += 1\n        MyLog.Ins().StateWrite(\"防守\",self.State)\n        self.State = \"防守\"\n        self.DefenceProfitCount = 0\n    \n    #转移到进攻阶段\n    def ToAttack(self):\n        MyLog.Write('进入进攻模式')\n        MyLog.Ins().StateWrite(\"进攻\",self.State)\n        MyLog.Ins().Attack_Count += 1\n        self.State = \"进攻\"\n        self.Node_List.clear()\n\n    #转移到平仓阶段\n    def ToClear(self):\n        MyLog.Write('开始平仓')\n        if self.State == \"防守\":#如果来自于防守模式，不用平仓，直接重新进入防守模式。\n            self.Node_List.clear()\n            self.ToDefence()\n            return\n        MyLog.Ins().StateWrite(\"平仓\",self.State)\n        self.State = \"平仓\"\n        self.ClearOrder = 0\n\n    def LoadData(self):\n        MyLog.Ins().LoadData()\n        if MyLog.Ins().StartTime == None:\n            #第一次运行，不加载后续数据了\n            return\n        self.Node_List = json.loads(_G('Node_List'))\n        self.State = _G(\"State\")\n        self.DefenceProfitCount = _G('DefenceProfitCount')\n        self.ClearOrder = _G('ClearOrder')\n\n    def SaveData(self):\n        MyLog.Ins().SaveData()\n        _G(\"Node_List\",json.dumps(self.Node_List))\n        _G(\"State\",self.State)\n        _G(\"DefenceProfitCount\",self.DefenceProfitCount)\n        _G(\"ClearOrder\",self.ClearOrder)\n    \n    def TotalMoney(self):\n        return self.Balance + self.FrozenBalance + (self.Stocks + self.FrozenStocks) * self.BuyPrice\n\n    def GetBuyNumber(self):\n        number = self.TotalMoney() * UI_AttackRatio / UI_NodeCount / self.SellPrice\n        #去掉太多的精度\n        return _N(number,4)\n\nclass Node:\n\n    #创建一个数据并返回\n    def CreateNodeData(_state):\n        data = {}\n        data['state'] = _state\n        data['buy_price'] = 0\n        data['sell_price'] = 0\n        data['buy_order'] = 0\n        data['sell_order']=0\n        data['number'] = 0\n        return data\n\n    #Node还要用，重置下\n    def Reset_Node(_node):\n        _node['number'] = 0\n        _node['buy_order'] = 0\n        _node['sell_order'] = 0\n\n\n    def Buy(_price,_number):\n        MyLog.Write('买单，价格：' + str(_price) + '. 数量：' + str(_number) + \"。 价值：\" + str(_N(_number * _price,2)))\n        if Manager.Ins().State == \"进攻\":\n            buy_id = exchange.Buy(_price, _number)\n            if buy_id == None:\n                return None\n        else:\n            buy_id = 1\n        node = Node.CreateNodeData(Manager.Ins().State)\n        node['state'] = Manager.Ins().State\n        node['buy_price'] = _price\n        node['sell_price'] = _price * 1.005\n        node['buy_order'] = buy_id\n        node['number'] = 0\n\n        return node\n\n    def HasBuy(_node):\n        return _node['buy_order'] != 0\n\n    def HasSell(_node):\n        return _node['sell_order'] != 0\n    \n    #查看这个节点是不是右边的节点\n    def IsRight(_node):\n        right_price = Manager.Ins().SellPrice * 1.005\n        if right_price > _node['buy_price'] and right_price < _node['sell_price']:\n            return True\n        return False\n\n    def IsLeft(_node):\n        right_price = Manager.Ins().SellPrice * 0.995\n        if right_price > _node['buy_price'] and right_price < _node['sell_price']:\n            return True\n        return False\n\n    def CenterNode():\n        for node in Manager.Ins().Node_List:\n            if Manager.Ins().SellPrice > node['buy_price'] and Manager.Ins().SellPrice < node['sell_price']:\n                return node\n        return None\n\n    def MaxNode():\n        return Manager.Ins().Node_List[-1]\n\n    def MaxBuyPrice():\n        return Node.MaxNode()['buy_price']\n\n    def MaxSellPrice():\n        return Node.MaxNode()['sell_price']\n\n    def MaxHasSell():\n        return Node.MaxNode()['sell_order'] != 0\n\n    def MinNode():\n        return Manager.Ins().Node_List[0]\n\n    def MinPrice():\n        return Manager.Ins().Node_List[0]['buy_price']\n\n    def MinLeftPrice():\n        return _N(Node.MinPrice() * 0.995,4)\n\n    #检查买单是否OK\n    def CheckBuy(_node):\n        if _node['state'] == \"防守\":\n            _node['number'] = 1\n            return True\n        order = _C(exchange.GetOrder,_node['buy_order'])\n        if order['Status'] == 1:\n            _node['number'] = order['DealAmount']\n            return True\n        return  False\n\n    def MinSellPrice():\n        return Manager.Ins().Node_List[0]['sell_price']\n\n    def MinHasSell():\n        return Manager.Ins().Node_List[0]['sell_order'] != 0\n    \n    def Sell(_node):\n        MyLog.Write('卖单，价格：' + str(_node['sell_price']))\n        if _node['state'] == \"防守\":\n            _node['sell_order'] = 1\n            return True\n        # 仓位判断，容差\n        # if Manager.Ins().Stocks < _node['number']:\n        #     _node['number'] = Manager.Ins().Stocks\n        \n        order_id = exchange.Sell(_node['sell_price'], _node['number'])\n        if order_id == None:\n            return False\n        _node['sell_order'] = order_id\n        return True\n\n    def CheckSell(_node):\n        if _node['state'] == \"防守\":\n            if Manager.Ins().BuyPrice > _node['sell_price']:\n                return True\n            return False\n        \n        order = _C(exchange.GetOrder,_node['sell_order'])\n        #再次精准仓位\n        if order['Status'] == 1:\n            return True\n        return False\n\n    def GetProfit(_node):\n        value = (_node['sell_price'] - _node['buy_price']) * _node['number']\n        return _N(value,2)\n    \n    def NodeClear(_node):\n        if _node['state'] == \"防守\":\n            return\n\n        if _node['sell_order'] != 0:\n            Node.CancelOrder(_node['sell_order'])\n        if _node['buy_order'] != 0:\n            Node.CancelOrder(_node['buy_order'])\n\n    #确保订单取消成功\n    def CancelOrder(_id):\n        MyLog.Write('取消订单:' + str(_id))\n        while True:\n            order = _C(exchange.GetOrder,_id)\n            if order['Status'] == 1:\n                return True\n            if order['Status'] != 2:\n                result = exchange.CancelOrder(_id)\n                if result == True:\n                    return True\n                Sleep(1000)\n            elif order['Status'] == 2:\n                return True\n\n\nclass MyLog:\n    #第一次运行的时间\n    StartTime = 0\n    StartMoney = 0\n    Profit_List = []\n    State_List = []\n    Log_Tables = []\n\n    Attack_Count = 0\n    Defence_Count = 0\n    Exchange_Count = 0\n\n    #当期网格收益\n    StateProfit = 0\n\n    #连续购买计数\n    BuyBuy_Count = 0\n    BuyBuyClear_Count = 0\n\n    def Ins():\n        global log\n        if log == None:\n            log = MyLog()\n        \n        return log\n    \n    def LoadData(self):\n        self.Log_Tables = []\n        self.StartTime = _G(\"StartTime\")\n        if self.StartTime == None:\n            return\n        \n        self.StartMoney = _G(\"StartMoney\")\n        self.Profit_List = json.loads(_G(\"Profit_List\"))\n        self.State_List = json.loads(_G(\"State_List\"))\n        self.Attack_Count = _G(\"Attack_Count\")\n        self.Defence_Count = _G(\"Defence_Count\")\n        self.Exchange_Count = _G(\"Exchange_Count\")\n        self.StateProfit = _G(\"StateProfit\")\n        self.BuyBuy_Count = _G(\"BuyBuy_Count\")\n        self.BuyBuyClear_Count = _G(\"BuyBuyClear_Count\")\n\n    def SaveData(self):\n        _G(\"StartTime\",self.StartTime)\n        _G(\"StartMoney\",self.StartMoney)\n        _G(\"Profit_List\",json.dumps(self.Profit_List))\n        _G(\"State_List\",json.dumps(self.State_List))\n        _G(\"Attack_Count\",self.Attack_Count)\n        _G(\"Defence_Count\",self.Defence_Count)\n        _G(\"Exchange_Count\",self.Exchange_Count)\n        _G(\"StateProfit\",self.StateProfit)\n        _G(\"BuyBuy_Count\", self.BuyBuy_Count)\n        _G(\"BuyBuyClear_Count\", self.BuyBuyClear_Count)\n\n    def WriteProfit(self,_value):\n        if Manager.Ins().State == \"防守\":\n            #Log(\"防守计分一次\")\n            Manager.Ins().DefenceProfitCount += 1\n            return\n\n        #Log(\"感谢好心人，给了我\" + str(_value) + \"USDT。\")\n        self.StateProfit += _value\n        self.Exchange_Count += 1\n        data = []\n        #日期，利润，当前浮亏,当前币价\n        data.append(self.GetTimeStr(Manager.Ins().TickTime))\n        data.append(_value)\n        data.append(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\n        data.append(_N(Manager.Ins().BuyPrice,2))\n        if len(self.Profit_List) > 10:\n            self.Profit_List.pop()\n        self.Profit_List.insert(0,data)\n        #利润日志\n        LogProfit(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\n\n    def AddBuyBuyTimes():\n        MyLog.Ins().BuyBuy_Count += 1\n        if MyLog.Ins().BuyBuy_Count >= UI_DefenceThreshold and Manager.Ins().State == \"进攻\":\n            MyLog.Write(\"达到了连续购买阈值，进入防守模式\")\n            if Manager.Ins().State == \"进攻\":\n                MyLog.Ins().BuyBuyClear_Count += 1\n            Manager.Ins().ToClear()\n\n\n    def GetTimeStr(self,_time):\n        utc_dt = datetime.utcfromtimestamp(_time/1000)\n        cn_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))\n        d = cn_dt.strftime('%Y-%m-%d %H:%M:%S')\n        return d\n    \n    def GetRunDays(self):\n        now_date = datetime.utcfromtimestamp(Manager.Ins().TickTime/1000)\n        start_date = datetime.utcfromtimestamp(self.StartTime/1000)\n        span = now_date - start_date\n        run_time = span.days\n        if run_time < 1:\n            run_time = 1\n        return run_time\n\n    def GetToTalProfit(self):\n        return Manager.Ins().TotalMoney() - self.StartMoney\n\n    def GetAnnualized(self):\n        a = self.GetToTalProfit() / self.GetRunDays() * 365 / self.StartMoney * 100\n        return _N(a,2)\n\n    def PrintLog(self):\n        #基础信息表\n        rows = []\n        rows.append([\"当期启动时间：\",self.GetTimeStr(self.StartTime)])\n        rows.append([\"当期初始资金：\", self.StartMoney])\n        rows.append([\"当前总仓：\", _N(Manager.Ins().TotalMoney(),4)])\n        rows.append([\"当前利润：\",_N(self.GetToTalProfit(),4)])\n        rows.append([\"当前年化：\",str(self.GetAnnualized()) + \"%\"])\n        rows.append([\"当前持币:\",_N(Manager.Ins().Stocks,4)])\n        rows.append([\"当前锁币：\", _N(Manager.Ins().FrozenStocks,4)])\n        rows.append([\"钱包剩余：\", _N(Manager.Ins().Balance,4)])\n        rows.append([\"钱包冻结：\", _N(Manager.Ins().FrozenBalance,4)])\n        rows.append(['当前状态：',Manager.Ins().State])\n        rows.append([\"防御次数：\", self.Defence_Count])\n        rows.append([\"强平次数：\", self.BuyBuyClear_Count])\n        self.Add_Log_Table(\"基础信息\",[\"项目\",\"内容\"], rows)\n        #Log(json.dumps(rows))\n        #构建并添加仓位表\n        n_list = []\n        for _node in Manager.Ins().Node_List:\n            n = []\n            n.append(_node['buy_price'])\n            n.append(_node['buy_order'])\n            n.append(_node['sell_price'])\n            n.append(_node['sell_order'])\n            n.append(_node['number'])\n            n_list.append(n)\n        global Is_Debug\n        if Is_Debug:\n            self.Add_Log_Table(\"仓位信息\",['买价','买单',\"卖价\",\"卖单\",\"仓位数量\"],n_list)\n        #添加利润表\n        self.Add_Log_Table(\"收益记录\",[\"时间\",\"利润\",\"当前浮亏\",\"当前币价\"], self.Profit_List)\n        #添加状态表\n        self.Add_Log_Table(\"状态表\",[\"时间\",\"进入状态\",\"上一个状态\",\"当前币价\",\"当前盈利\",\"上期网格收益\",\"上期成交数\"],self.State_List)\n        #调参日志\n        \n        LogStatus('`' + json.dumps(self.Log_Tables) + '`')\n    \n    def StateWrite(self,_name,_lastname):\n        #时间，状态，上一个状态，此时市场价，此时盈利\n        data = [self.GetTimeStr(Manager.Ins().TickTime), _name, _lastname, _N(Manager.Ins().SellPrice,2), _N(self.GetToTalProfit(),2),_N(self.StateProfit,2),self.Exchange_Count]\n        self.State_List.insert(0, data)\n\n        if len(self.State_List) >= 100:\n            self.State_List.pop()\n        \n        self.StateProfit = 0\n        self.Exchange_Count = 0\n        self.BuyBuy_Count = 0\n\n    def Add_Log_Table(self, _title, _cols, _rows):\n        table = {\n            \"type\" : \"table\", \n            \"title\" : _title, \n            \"cols\" : _cols, \n            \"rows\" : _rows\n        }\n        self.Log_Tables.append(table)\n\n    def Write(_str):\n        global Is_Debug\n        if Is_Debug:\n            Log(str(_str))",
        "strategy_description": "策略名称: 要饭机器人30\n\n# if Manager.Ins().Stocks < _node['number']:\n        #     _node['number'] = Manager.Ins().Stocks\n        \n        order_id = exchange.Sell(_node['sell_price'], _node['number'])\n        if order_id == None:\n            return False\n        _node['sell_order'] = order_id\n        return True\n\n    def CheckSell(_node):\n        if _node['state'] == \"防守\":\n            if Manager.Ins().BuyPrice > _node['sell_price']:\n                return True\n            return False\n        \n        order = _C(exchange.GetOrder,_node['sell_order'])\n        #再次精准仓位\n        if order['Status'] == 1:\n            return True\n        return False\n\n    def GetProfit(_node):\n        value = (_node['sell_price'] - _node['buy_price']) * _node['number']\n        return _N(value,2)\n    \n    def NodeClear(_node):\n        if _node['state'] == \"防守\":\n            return\n\n        if _node['sell_order'] != 0:\n            Node.CancelOrder(_node['sell_order'])\n        if _node['buy_order'] != 0:\n            Node.CancelOrder(_node['buy_order'])\n\n    #确保订单取消成功\n    def CancelOrder(_id):\n        MyLog.Write('取消订单:' + str(_id))\n        while True:\n            order = _C(exchange.GetOrder,_id)\n            if order['Status'] == 1:\n                return True\n            if order['Status'] != 2:\n                result = exchange.CancelOrder(_id)\n                if result == True:\n                    return True\n                Sleep(1000)\n            elif order['Status'] == 2:\n                return True\n\n\nclass MyLog:\n    #第一次运行的时间\n    StartTime = 0\n    StartMoney = 0\n    Profit_List = []\n    State_List = []\n    Log_Tables = []\n\n    Attack_Count = 0\n    Defence_Count = 0\n    Exchange_Count = 0\n\n    #当期网格收益\n    StateProfit = 0\n\n    #连续购买计数\n    BuyBuy_Count = 0\n    BuyBuyClear_Count = 0\n\n    def Ins():\n        global log\n        if log == None:\n            log = MyLog()\n        \n        return log\n    \n    def LoadData(self):\n        self.Log_Tables = []\n        self.StartTime = _G(\"StartTime\")\n        if self.StartTime == None:\n            return\n        \n        self.StartMoney = _G(\"StartMoney\")\n        self.Profit_List = json.loads(_G(\"Profit_List\"))\n        self.State_List = json.loads(_G(\"State_List\"))\n        self.Attack_Count = _G(\"Attack_Count\")\n        self.Defence_Count = _G(\"Defence_Count\")\n        self.Exchange_Count = _G(\"Exchange_Count\")\n        self.StateProfit = _G(\"StateProfit\")\n        self.BuyBuy_Count = _G(\"BuyBuy_Count\")\n        self.BuyBuyClear_Count = _G(\"BuyBuyClear_Count\")\n\n    def SaveData(self):\n        _G(\"StartTime\",self.StartTime)\n        _G(\"StartMoney\",self.StartMoney)\n        _G(\"Profit_List\",json.dumps(self.Profit_List))\n        _G(\"State_List\",json.dumps(self.State_List))\n        _G(\"Attack_Count\",self.Attack_Count)\n        _G(\"Defence_Count\",self.Defence_Count)\n        _G(\"Exchange_Count\",self.Exchange_Count)\n        _G(\"StateProfit\",self.StateProfit)\n        _G(\"BuyBuy_Count\", self.BuyBuy_Count)\n        _G(\"BuyBuyClear_Count\", self.BuyBuyClear_Count)\n\n    def WriteProfit(self,_value):\n        if Manager.Ins().State == \"防守\":\n            #Log(\"防守计分一次\")\n            Manager.Ins().DefenceProfitCount += 1\n            return\n\n        #Log(\"感谢好心人，给了我\" + str(_value) + \"USDT。\")\n        self.StateProfit += _value\n        self.Exchange_Count += 1\n        data = []\n        #日期，利润，当前浮亏,当前币价\n        data.append(self.GetTimeStr(Manager.Ins().TickTime))\n        data.append(_value)\n        data.append(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\n        data.append(_N(Manager.Ins().BuyPrice,2))\n        if len(self.Profit_List) > 10:\n            self.Profit_List.pop()\n        self.Profit_List.insert(0,data)\n        #利润日志\n        LogProfit(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\n\n    def AddBuyBuyTimes():\n        MyLog.Ins().BuyBuy_Count += 1\n        if MyLog.Ins().BuyBuy_Count >= UI_DefenceThreshold and Manager.Ins().State == \"进攻\":\n            MyLog.Write(\"达到了连续购买阈值，进入防守模式\")\n            if Manager.Ins().State == \"进攻\":\n                MyLog.Ins().BuyBuyClear_Count += 1\n            Manager.Ins().ToClear()\n\n\n    def GetTimeStr(self,_time):\n        utc_dt = datetime.utcfromtimestamp(_time/1000)\n        cn_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))\n        d = cn_dt.strftime('%Y-%m-%d %H:%M:%S')\n        return d\n    \n    def GetRunDays(self):\n        now_date = datetime.utcfromtimestamp(Manager.Ins().TickTime/1000)\n        start_date = datetime.utcfromtimestamp(self.StartTime/1000)\n        span = now_date - start_date\n        run_time = span.days\n        if run_time < 1:\n            run_time = 1\n        return run_time\n\n    def GetToTalProfit(self):\n        return Manager.Ins().TotalMoney() - self.StartMoney\n\n    def GetAnnualized(self):\n        a = self.GetToTalProfit() / self.GetRunDays() * 365 / self.StartMoney * 100\n        return _N(a,2)\n\n    def PrintLog(self):\n        #基础信息表\n        rows = []\n        rows.append([\"当期启动时间：\",self.GetTimeStr(self.StartTime)])\n        rows.append([\"当期初始资金：\", self.StartMoney])\n        rows.append([\"当前总仓：\", _N(Manager.Ins().TotalMoney(),4)])\n        rows.append([\"当前利润：\",_N(self.GetToTalProfit(),4)])\n        rows.append([\"当前年化：\",str(self.GetAnnualized()) + \"%\"])\n        rows.append([\"当前持币:\",_N(Manager.Ins().Stocks,4)])\n        rows.append([\"当前锁币：\", _N(Manager.Ins().FrozenStocks,4)])\n        rows.append([\"钱包剩余：\", _N(Manager.Ins().Balance,4)])\n        rows.append([\"钱包冻结：\", _N(Manager.Ins().FrozenBalance,4)])\n        rows.append(['当前状态：',Manager.Ins().State])\n        rows.append([\"防御次数：\", self.Defence_Count])\n        rows.append([\"强平次数：\", self.BuyBuyClear_Count])\n        self.Add_Log_Table(\"基础信息\",[\"项目\",\"内容\"], rows)\n        #Log(json.dumps(rows))\n        #构建并添加仓位表\n        n_list = []\n        for _node in Manager.Ins().Node_List:\n            n = []\n            n.append(_node['buy_price'])\n            n.append(_node['buy_order'])\n            n.append(_node['sell_price'])\n            n.append(_node['sell_order'])\n            n.append(_node['number'])\n            n_list.append(n)\n        global Is_Debug\n        if Is_Debug:\n            self.Add_Log_Table(\"仓位信息\",['买价','买单',\"卖价\",\"卖单\",\"仓位数量\"],n_list)\n        #添加利润表\n        self.Add_Log_Table(\"收益记录\",[\"时间\",\"利润\",\"当前浮亏\",\"当前币价\"], self.Profit_List)\n        #添加状态表\n        self.Add_Log_Table(\"状态表\",[\"时间\",\"进入状态\",\"上一个状态\",\"当前币价\",\"当前盈利\",\"上期网格收益\",\"上期成交数\"],self.State_List)\n        #调参日志\n        \n        LogStatus('`' + json.dumps(self.Log_Tables) + '`')\n    \n    def StateWrite(self,_name,_lastname):\n        #时间，状态，上一个状态，此时市场价，此时盈利\n        data = [self.GetTimeStr(Manager.Ins().TickTime), _name, _lastname, _N(Manager.Ins().SellPrice,2), _N(self.GetToTalProfit(),2),_N(self.StateProfit,2),self.Exchange_Count]\n        self.State_List.insert(0, data)\n\n        if len(self.State_List) >= 100:\n            self.State_List.pop()\n        \n        self.StateProfit = 0\n        self.Exchange_Count = 0\n        self.BuyBuy_Count = 0\n\n    def Add_Log_Table(self, _title, _cols, _rows):\n        table = {\n            \"type\" : \"table\", \n            \"title\" : _title, \n            \"cols\" : _cols, \n            \"rows\" : _rows\n        }\n        self.Log_Tables.append(table)\n\n    def Write(_str):\n        global Is_Debug\n        if Is_Debug:\n            Log(str(_str))\n```\n\n> Detail\n\nhttps://www.fmz.com/strategy/377408\n\n> Last Modified\n\n2022-10-06 14:58:03"
    },
    {
        "strategy_id": "125_轮询价格买入卖出",
        "strategy_code": "python\nimport numpy as np\nimport json\n\n#全局变量\nprice_precision = {}\namount_precision = {}\nhands = {}\ncan_buy_price = {}\ncan_sell_price = {}\nclass mid_class():\n    def __init__(self, this_exchange):\n        '''\n        初始化数据填充交易所的信息，首次获取价格，首次获取account信息\n        设定好密钥……\n        \n        Args:\n            this_exchange: FMZ的交易所结构\n        \n        '''\n        self.init_timestamp = time.time()\n        self.exchange = this_exchange\n        self.name = self.exchange.GetName()\n        self.jyd = self.exchange.GetCurrency()        \n    \n    def get_precision(self,pair):\n        '''\n        获取交易对的价格精度和数量精度\n        '''\n        precision = [4,6,1]\n        if pair not in price_precision.keys():\n            Log('没有配置价格精度： ' + pair)\n            return precision\n        if pair not in amount_precision.keys():\n            Log('没有配置数量精度: ' + pair)\n            return precision\n        if pair not in hands.keys():\n            Log('没有配置一手数量: ' + pair)\n            return precision\n        return [price_precision[pair], amount_precision[pair], hands[pair]]\n        \n    def switch_currency(self,pair):\n        '''\n        替换交易对\n        '''\n        self.exchange.IO(\"currency\",pair)\n\n    def get_account(self):\n        '''\n        获取账户信息\n        \n        Returns:\n            获取信息成功返回True，获取信息失败返回False\n        '''\n        self.Balance = '---'\n        self.Amount = '---'\n        self.FrozenBalance = '---'\n        self.FrozenStocks = '---'\n        \n        try:\n            self.account = self.exchange.GetAccount()\n\n            self.Balance =  self.account['Balance']\n            self.Amount = self.account['Stocks']\n            self.FrozenBalance =  self.account['FrozenBalance']\n            self.FrozenStocks = self.account['FrozenStocks']\n            return True\n        except:\n            return False\n    \n    def get_ticker(self):\n        '''\n        获取市价信息\n        \n        Returns:\n            获取信息成功返回True，获取信息失败返回False\n        '''\n        self.high = '---'\n        self.low = '---'\n        self.Sell =  '---'\n        self.Buy =  '---'\n        self.last =  '---'\n        self.Volume = '---'\n        \n        try:\n            self.ticker = self.exchange.GetTicker()\n        \n            self.high = self.ticker['High']\n            self.low = self.ticker['Low']\n            self.Sell =  self.ticker['Sell']\n            self.Buy =  self.ticker['Buy']\n            self.last =  self.ticker['Last']\n            self.Volume = self.ticker['Volume']\n            return True\n        except:\n            return False\n        \n        \n    def get_depth(self):\n        '''\n        获取深度信息\n        \n        Returns:\n            获取信息成功返回True，获取信息失败返回False\n        '''\n        self.Ask = '---'\n        self.Bids = '---'\n        \n        try:\n            self.Depth = self.exchange.GetDepth()\n            self.Ask = self.Depth['Asks']\n            self.Bids = self.Depth ['Bids']\n            return True\n        except:\n            return False\n        \n        \n    \n    def get_ohlc_data(self, period = PERIOD_M1):\n        '''\n        获取K线信息\n        \n        Args:\n            period: K线周期，PERIOD_M1 指1分钟, PERIOD_M5 指5分钟, PERIOD_M15 指15分钟,\n            PERIOD_M30 指30分钟, PERIOD_H1 指1小时, PERIOD_D1 指一天。\n        '''\n        self.ohlc_data = exchange.GetRecords(period)\n        \n        \n    \n    def create_order(self, order_type, price, amount):\n        '''\n        post一个挂单信息\n        \n        Args:\n            order_type：挂单类型，'buy'指挂买单，'sell'指挂卖单\n            price：挂单价格\n            amount:挂单数量\n            \n        Returns:\n            挂单Id号，可用以取消挂单\n        '''\n        if order_type == 'buy':\n            try:\n                order_id = self.exchange.Buy( price, amount)\n            except:\n                return False\n            \n        elif order_type == 'sell':\n            try:\n                order_id = self.exchange.Sell( price, amount)\n            except:\n                return False\n        \n        return order_id\n    \n    def get_orders(self):\n        self.undo_ordes = self.exchange.GetOrders()\n        return self.undo_ordes\n    \n    def cancel_order(self, order_id):\n        '''\n        取消一个挂单信息\n        \n        Args:\n            order_id：希望取消的挂单ID号\n            \n        Returns:\n            取消挂单成功返回True，取消挂单失败返回False\n        '''\n        return self.exchange.CancelOrder(order_id)\n        \n    def refreash_data(self):\n        '''\n        刷新信息\n        \n        Returns:\n            刷新信息成功返回 'refreash_data_finish!' 否则返回相应刷新失败的信息提示\n        '''\n\n        if not self.get_account():\n            return 'false_get_account'\n        \n        if not self.get_ticker():\n            return 'false_get_ticker'\n        if not self.get_depth():\n            return 'false_get_depth'\n        try:\n            self.get_ohlc_data()\n        except:\n            return 'false_get_K_line_info'\n        \n        return 'refreash_data_finish!'\n\n \nclass qushi_class():\n    def __init__(self, mid_class, amount_N, price_N):\n        '''\n        设定好初始需要考虑的参数\n        Args:\n            mid_class: 所使用的交易所中间层\n            amount_N：数量小数点限制\n            price_N：价格小数点限制\n            \n        Attributes：\n            amount_N：数量小数点限制\n            price_N：价格小数点限制\n            init_time：初始时间\n            last_time：上一次执行操作的时间\n            trade_list:交易请求的id\n        '''\n        self.jys = mid_class\n        \n        self.init_time = time.time()\n        self.last_time = time.time()\n        \n        self.amount_N = amount_N\n        self.price_N = price_N\n        \n        self.trade_list = []\n    \n    def cancel_orders(self):\n        '''\n        遍历当前挂单，如果时间超时则取消\n        '''\n        undo_orders = self.jys.get_orders()\n        for i in range(len(undo_orders)):\n           self.jys.cancel_order(undo_orders[i].Id)\n\n            \n    def refreash_data(self):\n        '''\n        用来从交易所获取最新的价格和数量信息\n        \n        Attributes：\n            B：商品币数量\n            money：计价币数量\n            can_buy_B：当前理论可购买商品币数量\n            Buy_price:当前市场上最近的一单挂单买价\n        '''\n        \n        message = self.jys.refreash_data()\n        if message == 'refreash_data_finish!':\n            self.B = self.jys.Amount\n            self.money = self.jys.Balance\n            self.Buy_price = self.jys.Buy\n            self.Sell_price = self.jys.Sell\n            self.can_buy_B = self.money/ self.Sell_price * 0.9\n            #要求仓位只能是30%\n            if self.B > ((self.B + self.can_buy_B)*0.3):\n                self.can_buy_B = 0\n            else:\n                self.can_buy_B = _N(self.can_buy_B, self.amount_N )\n            return True\n        else:\n            return False\n            \n    def make_trade_by_dict(self, trade_dicts):\n        '''\n        用来批量完成交易订单\n        \n        Attributes：\n            trade_list:已提交的交易请求的id\n        '''\n        for this_trade in trade_dicts:\n            this_price = _N(this_trade['price'], self.price_N )\n            this_amount = _N(this_trade['amount'], self.amount_N )\n            \n            this_trade_id = self.jys.create_order( this_trade['side'], this_price , this_amount ) \n            self.trade_list.append( this_trade_id )\n    \n    def condition_chicang(self, hands_num):\n        '''\n        根据持仓情况来做交易判定的条件\n        Args:\n            hands_num：表示交易一共几手（我们假设当前每次交易不高于一手）\n            \n        Attributes：\n            min_trade_B: 一手最多交易的商品币数量\n            min_trade_money: 一手最多交易的计价币数量\n        \n        '''\n        self.min_trade_B = (self.can_buy_B + self.B) / hands_num\n        self.min_buy_B = min(self.min_trade_B, self.can_buy_B)\n        self.min_sell_B = min(self.min_trade_B, self.B)\n        self.min_trade_money = self.min_trade_B* self.jys.Buy\n\n\n    \n    def condition_qushi(self):\n        '''\n        根据市场价格情况来做交易判定的条件\n        '''\n        rt = False\n        currency = self.jys.jyd\n        #Log('cur price' + self.jys.Sell)\n        #Log('cur range' + can_buy_price[currency][0])\n        if self.jys.Sell > can_buy_price[currency][0] and self.jys.Sell < can_buy_price[currency][1]:\n            rt = 'Buy'\n        if self.jys.Buy > can_sell_price[currency][0] and self.jys.Buy < can_sell_price[currency][1]:\n            rt = 'Sell'\n       \n        return rt\n    \n    \n    def make_trade_dicts(self, hands_num ):\n        '''\n        制作交易用字典表单\n        Args:\n            hands_num：一共交易多少手\n            change_pct：价格变化多少交易一手\n            \n        Returns：\n            this_trade_dicts: 根据当前价格变化，制作出需交易的字典的列表\n        \n        '''\n        self.condition_chicang(hands_num)\n        rt = self.condition_qushi()\n        this_trade_dicts = []\n        if rt:\n            if rt == 'Buy':\n                if self.min_buy_B > 10**-self.amount_N:\n                    this_trade_dicts.append({\n                        'side':'buy',\n                        'price':self.jys.Buy,\n                        'amount':self.min_buy_B\n                    })\n            else:\n                if self.min_sell_B > 10**-self.amount_N:\n                    this_trade_dicts.append({\n                        'side':'sell',\n                        'price':self.jys.Sell,\n                        'amount':self.min_sell_B\n                    })\n            return this_trade_dicts\n        else:\n            return False\n\n\n\ndef main():\n\n    #获取配置的值\n    global price_precision\n    price_precision = json.loads(PRICE_PRECISION)\n    global amount_precision \n    amount_precision = json.loads(AMOUNT_PRECISION)\n    global hands \n    hands = json.loads(HANDS)\n    global can_buy_price\n    can_buy_price = json.loads(CAN_BUY_PRICE)\n    global can_sell_price\n    can_sell_price = json.loads(CAN_SELL_PRICE)\n    round = 1\n    while True:\n        Sleep(1000)\n        for i in range(len(exchanges)):\n            #定义交易中间件\n            test_mid = mid_class(exchanges[i])\n            currency = test_mid.jyd\n            #获取交易对的价格，数量精度\n            currency_precision = test_mid.get_precision(currency)\n            #生成策略类\n            test_qushi = qushi_class(test_mid , currency_precision[0], currency_precision[1])\n            #获取最新数据\n            result  = test_qushi.refreash_data()\n            if result == True:\n                now_trade_dicts = test_qushi.make_trade_dicts(currency_precision[2])\n                if now_trade_dicts:\n                    test_qushi.make_trade_by_dict(now_trade_dicts)\n                    now_trade_dicts = False\n            #检查挂单情况\n            if round % 20 == 0:\n                Log('开始撤单')\n                Log(test_mid.account)\n                test_qushi.cancel_orders()\n        \n        round = round + 1",
        "strategy_description": "策略名称: 轮询价格买入卖出\n\n未找到描述"
    },
    {
        "strategy_id": "126_追涨杀跌",
        "strategy_code": "python\nlist=[]\n\ndef doTicker():\n    #Log(exchange.GetAccount())\n    #Log(list)\n    ticker = exchange.GetTicker()\n    last = ticker.Last\n    if len(list) < LENGTH:\n        list.append(last)\n    else:\n        pMax = max(list)\n        pMin = min(list)\n        if last > pMax:\n            Log(\"buy \" + str(exchange.GetAccount()))\n            account = exchange.GetAccount()\n            if account.Balance > last:\n                #id = exchange.Buy(last, 1)\n                id = exchange.Buy(-1, 1)\n                Log(\"buy id --> \" + str(id))\n        elif last < pMin:\n            Log(\"sell \" + str(exchange.GetAccount()))\n            account = exchange.GetAccount()\n            if account.Stocks > 0:\n                #id = exchange.Sell(last, 1)\n                id = exchange.Sell(-1, 1)\n                Log(\"sell id --> \" + str(id))\n        list.pop(0)\n        list.append(last)\n\ndef main():\n    while(true):\n        doTicker() #执行策略\n        Sleep(PERIOD * 1000) #休息一段时间",
        "strategy_description": "策略名称: 追涨杀跌\n\n未找到描述"
    },
    {
        "strategy_id": "127_钉钉群机器人推送超长信息必备",
        "strategy_code": "python\n#!Python3\n\n\"\"\"\n《策略代写》 与 （此程序帮助），致信QQ：35787501\n\n钉钉长消息推送，用于群自定义机器人\n由于@可推送的信息过短，在字符串长度过长时，可以使用此程序\n\"\"\"\n\nimport time\nimport json\nimport hmac\nimport hashlib\nimport base64\nimport urllib.parse\nimport urllib.request\n\n\ndef send_request(url, data):\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\n                      'AppleWebKit/537.36 (KHTML, like Gecko) '\n                      'Chrome/92.0.4515.159 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;'\n                  'q=0.9,image/avif,image/webp,image/apng,*/*;'\n                  'q=0.8,application/signed-exchange;v=b3;q=0.9',\n        \"Content-Type\": \"application/json\",\n        \"Charset\": \"UTF-8\",\n    }\n    request = urllib.request.Request(url=url, data=json.dumps(data).encode(\"utf-8\"), headers=headers)\n    opener = urllib.request.urlopen(request)\n    return opener.read().decode()\n\n\ndef get_time_sign(secret):\n    timestamp = str(round(time.time() * 1000))\n    secret_enc = secret.encode('utf-8')\n    string_to_sign = '{}\\n{}'.format(timestamp, secret)\n    string_to_sign_enc = string_to_sign.encode('utf-8')\n    h_mac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()\n    sign = urllib.parse.quote_plus(base64.b64encode(h_mac_code))\n    return timestamp, sign\n\n\ndef send(text):\n    timestamp, sign = get_time_sign(ding_secret)\n    my_url = \"{}&timestamp={}&sign={}\".format(ding_url, timestamp, sign)\n    data = {\"msgtype\": \"text\", \"text\": {\"content\": text}}\n    return send_request(my_url, data)\n\n\ndef LogDing(*args):\n    Log(send(\" \".join(args)))\n\n\ndef main():\n    LogDing(\" test \" * 1000)\n\n\next.LogDing = LogDing",
        "strategy_description": "策略名称: 钉钉群机器人推送超长信息必备\n\n未找到描述"
    },
    {
        "strategy_id": "128_震荡突破策略",
        "strategy_code": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\nimport json\nimport time\n\nimport requests\nfrom kumex.client import Trade\n\n\ndef check_response_data(response_data):\n    if response_data.status_code == 200:\n        try:\n            d = response_data.json()\n        except ValueError:\n            raise Exception(response_data.content)\n        else:\n            if d and d.get('s'):\n                if d.get('s') == 'ok':\n                    return d\n                else:\n                    raise Exception(\"{}-{}\".format(response_data.status_code, response_data.text))\n    else:\n        raise Exception(\"{}-{}\".format(response_data.status_code, response_data.text))\n\n\ndef get_kline(s, r, f, t, timeout=5, is_sandbox=False):\n    headers = {}\n    url = 'https://kitchen.kumex.com/kumex-kline/history'\n    if is_sandbox:\n        url = 'https://kitchen-sdb.kumex.com/kumex-kline/history'\n    uri_path = url\n    data_json = ''\n    p = []\n    if s:\n        p.append(\"{}={}\".format('symbol', s))\n    if r:\n        p.append(\"{}={}\".format('resolution', r))\n    if f:\n        p.append(\"{}={}\".format('from', f))\n    if t:\n        p.append(\"{}={}\".format('to', t))\n    data_json += '&'.join(p)\n    uri_path += '?' + data_json\n\n    response_data = requests.request('GET', uri_path, headers=headers, timeout=timeout)\n    return check_response_data(response_data)\n\n\nclass Shock(object):\n\n    def __init__(self):\n        # read configuration from json file\n        with open('config.json', 'r') as file:\n            config = json.load(file)\n\n        self.api_key = config['api_key']\n        self.api_secret = config['api_secret']\n        self.api_passphrase = config['api_passphrase']\n        self.sandbox = config['is_sandbox']\n        self.symbol = config['symbol']\n        self.resolution = int(config['resolution'])\n        self.valve = float(config['valve'])\n        self.leverage = float(config['leverage'])\n        self.size = int(config['size'])\n        self.trade = Trade(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\n\n\nif __name__ == \"__main__\":\n    shock = Shock()\n\n    while 1:\n        time_to = int(time.time())\n        time_from = time_to - shock.resolution * 60 * 35\n        data = get_kline(shock.symbol, shock.resolution, time_from, time_to, is_sandbox=shock.sandbox)\n        print('now time =', time_to)\n        print('symbol closed time =', data['t'][-1])\n        if time_to != data['t'][-1]:\n            continue\n        now_price = int(data['c'][-1])\n        print('closed price =', now_price)\n        # high_track\n        high = data['h'][-31:-1]\n        high.sort(reverse=True)\n        high_track = float(high[0])\n        print('high_track =', high_track)\n\n        # low_track\n        low = data['l'][-31:-1]\n        low.sort()\n        low_track = float(low[0])\n        print('low_track =', low_track)\n\n        # interval_range\n        interval_range = (high_track - low_track) / (high_track + low_track)\n        print('interval_range =', interval_range)\n\n        order_flag = 0\n        # current position qty of the symbol\n        position_details = shock.trade.get_position_details(shock.symbol)\n        position_qty = int(position_details['currentQty'])\n        print('current position qty of the symbol =', position_qty)\n        if position_qty > 0:\n            order_flag = 1\n        elif position_qty < 0:\n            order_flag = -1\n\n        if order_flag == 1 and now_price < low_track:\n            order = shock.trade.create_limit_order(shock.symbol, 'sell', position_details['realLeverage'],\n                                                   position_qty, now_price)\n            print('order_flag == 1,order id =', order['orderId'])\n            order_flag = 0\n        elif order_flag == -1 and now_price > high_track:\n            order = shock.trade.create_limit_order(shock.symbol, 'buy', position_details['realLeverage'],\n                                                   position_qty, now_price)\n            print('order_flag == -1,order id =', order['orderId'])\n            order_flag = 0\n\n        if interval_range < shock.valve and order_flag == 0:\n            if now_price > high_track:\n                order = shock.trade.create_limit_order(shock.symbol, 'buy', shock.leverage, shock.size, now_price)\n                print('now price > high track,buy order id =', order['orderId'])\n                order_flag = 1\n            if now_price < high_track:\n                order = shock.trade.create_limit_order(shock.symbol, 'sell', shock.leverage, shock.size, now_price)\n                print('now price < high track,sell order id =', order['orderId'])\n                order_flag = -1",
        "strategy_description": "策略名称: 震荡突破策略\n\n上轨：过去30根K线的最高价\n\n下轨：过去30根K线的最低价\n\n区间幅度：（上轨 - 下轨）/ （上轨 + 下轨）\n\n如果区间幅度小于阈值a，价格向上突破上轨，买入开仓，价格跌破下轨平仓\n\n如果区间幅度小于阈值a，价格向下突破上轨，卖出开仓，价格突破上轨平仓\n ![IMG](https://www.fmz.com/upload/asset/15f35e56ef95b1f550644.png)"
    },
    {
        "strategy_id": "129_韭菜保护程序唐安奇通道均仓策略",
        "strategy_code": "python\n'''backtest\nstart: 2021-04-01 00:00:00\nend: 2021-04-30 23:59:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Binance\",\"currency\":\"ETH_USDT\",\"stocks\":0}]\n'''\n\nimport time\nclass juncang_strategy():  \n    def __init__(self,exchange):\n        self.p = 0.5\n        self.account = None\n        self.cny = 0\n        self.btc = 0\n        self.exchange =exchange\n    \n    #K线合成函数\n    def k_compose(self,Recordlist,num):\n        newRecordlist = []\n        for i in range(len(Recordlist)):\n            if (i+1)%num == 1:\n                tempk = {}\n                tempk[\"Time\"]=Recordlist[i][\"Time\"]\n                tempk[\"Open\"]=Recordlist[i][\"Open\"]\n                tempk[\"High\"]=Recordlist[i][\"High\"]\n                tempk[\"Low\"]=Recordlist[i][\"Low\"]\n                tempk[\"Close\"]=Recordlist[i][\"Close\"]\n                tempk[\"Volume\"]=Recordlist[i][\"Volume\"]\n                newRecordlist.append(tempk)\n            elif (i+1)%num == 0:\n                if Recordlist[i][\"High\"]>tempk[\"High\"]:\n                    tempk[\"High\"] = Recordlist[i][\"High\"]\n                if Recordlist[i][\"Low\"]<tempk[\"Low\"]:\n                    tempk[\"Low\"] = Recordlist[i][\"Low\"]\n                tempk[\"Time\"]=Recordlist[i][\"Time\"]\n                tempk[\"Close\"]=Recordlist[i][\"Close\"]\n                tempk[\"Volume\"]=tempk[\"Volume\"]+Recordlist[i][\"Volume\"]\n                del(newRecordlist[-1])\n                newRecordlist.append(tempk)\n            else:\n                if Recordlist[i][\"High\"]>tempk[\"High\"]:\n                    tempk[\"High\"] = Recordlist[i][\"High\"]\n                if Recordlist[i][\"Low\"]<tempk[\"Low\"]:\n                    tempk[\"Low\"] = Recordlist[i][\"Low\"]\n                del(newRecordlist[-1])\n                newRecordlist.append(tempk)\n        return newRecordlist\n\n    #唐安奇通道计算，分析出当前什么行情\n    def donchian(self):\n        exchange.SetMaxBarLen(2000)\n        temp_k = _C(self.exchange.GetRecords,PERIOD_D1)\n        week_kline = self.k_compose(temp_k,7)\n        rt=False\n        # Log(len(week_kline),week_kline[-1][\"High\"],TA.Highest(week_kline, 20, 'High'))\n        if len(week_kline)>20:\n            if week_kline[-1][\"High\"]>TA.Highest(week_kline, 20, 'High'):\n                rt = '全仓'\n            elif week_kline[-1][\"High\"]<TA.Highest(week_kline, 20, 'High') and week_kline[-1][\"Low\"]>TA.MA(week_kline, 10)[-1]:\n                rt = '均仓'\n            elif week_kline[-1][\"Low\"]<TA.MA(week_kline, 10)[-1]:\n                rt = '空仓'\n        else:\n            rt = '均仓'\n        return rt\n    def cancelAllOrders(self):\n        orders = self.exchange.GetOrders()\n        for order in orders:\n            self.exchange.CancelOrder(order['Id'], order)\n        return True\n    #全仓买入函数\n    def allin(self):\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\n        account = _C(self.exchange.GetAccount)\n        self.cny = account.Balance\n        buynum=_N(self.cny*0.99/kr[-1].Close,3)\n        if buynum>0:\n            Log(\"全仓allin\")\n            self.exchange.Buy(kr[-1].Close,buynum)\n        \n    #全仓卖出函数\n    def allout(self):\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\n        account = _C(self.exchange.GetAccount)\n        self.btc = _N(account.Stocks,3)\n        if self.btc>0:\n            Log(\"空仓allout\")\n            self.exchange.Sell(kr[-1].Close,self.btc)\n    #均仓函数\n    def balanceAccount(self):\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\n        account = _C(self.exchange.GetAccount)\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n\n        #赋值\n        self.btc = account.Stocks\n        self.cny = account.Balance\n        \n        accountmoney=self.btc * kr[-1].Close + self.cny\n        self.p = self.btc * kr[-1].Close / accountmoney\n        tradenum=_N(accountmoney/kr[-1].Close/100,3)\n        if tradenum<0.001:\n            tradenum=0.001\n        #判断self.p的值是否小于0.48\n        # Log(self.p)\n        if (0.45<self.p < 0.49):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #判断self.p的值是否大于0.52\n        elif (0.55 > self.p > 0.51):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            #调用Sell函数并传入相应的参数\n            self.exchange.Sell(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p >= 0.55):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡,快速平仓\", self.p)\n\n            self.exchange.Sell(kr[-1].Close, _N(tradenum*10,3))\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p <= 0.45):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡，快速建仓\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, _N(tradenum*10,3))\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n    #交易循环\n    def loop(self):\n        self.cancelAllOrders()\n        rt=self.donchian()\n        if rt=='全仓':\n            self.allin()\n        elif rt=='均仓':\n            self.balanceAccount()\n        else:\n            self.allout()\n        Sleep(1000*60)\n\n\n\n\n#函数main\ndef main():\n    #reaper 是构造函数的实例\n    reaper = juncang_strategy(exchange)\n    while (True):\n        reaper.loop()",
        "strategy_description": "策略名称: 韭菜保护程序唐安奇通道均仓策略\n\nif len(week_kline)>20:\n            if week_kline[-1][\"High\"]>TA.Highest(week_kline, 20, 'High'):\n                rt = '全仓'\n            elif week_kline[-1][\"High\"]<TA.Highest(week_kline, 20, 'High') and week_kline[-1][\"Low\"]>TA.MA(week_kline, 10)[-1]:\n                rt = '均仓'\n            elif week_kline[-1][\"Low\"]<TA.MA(week_kline, 10)[-1]:\n                rt = '空仓'\n        else:\n            rt = '均仓'\n        return rt\n    def cancelAllOrders(self):\n        orders = self.exchange.GetOrders()\n        for order in orders:\n            self.exchange.CancelOrder(order['Id'], order)\n        return True\n    #全仓买入函数\n    def allin(self):\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\n        account = _C(self.exchange.GetAccount)\n        self.cny = account.Balance\n        buynum=_N(self.cny*0.99/kr[-1].Close,3)\n        if buynum>0:\n            Log(\"全仓allin\")\n            self.exchange.Buy(kr[-1].Close,buynum)\n        \n    #全仓卖出函数\n    def allout(self):\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\n        account = _C(self.exchange.GetAccount)\n        self.btc = _N(account.Stocks,3)\n        if self.btc>0:\n            Log(\"空仓allout\")\n            self.exchange.Sell(kr[-1].Close,self.btc)\n    #均仓函数\n    def balanceAccount(self):\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\n        account = _C(self.exchange.GetAccount)\n        if account is None:\n            return\n\n        #赋值\n        self.account = account\n\n        #赋值\n        self.btc = account.Stocks\n        self.cny = account.Balance\n        \n        accountmoney=self.btc * kr[-1].Close + self.cny\n        self.p = self.btc * kr[-1].Close / accountmoney\n        tradenum=_N(accountmoney/kr[-1].Close/100,3)\n        if tradenum<0.001:\n            tradenum=0.001\n        #判断self.p的值是否小于0.48\n        # Log(self.p)\n        if (0.45<self.p < 0.49):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n\n            #判断self.p的值是否大于0.52\n        elif (0.55 > self.p > 0.51):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡\", self.p)\n\n            #调用Sell函数并传入相应的参数\n            self.exchange.Sell(kr[-1].Close, tradenum)\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p >= 0.55):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡,快速平仓\", self.p)\n\n            self.exchange.Sell(kr[-1].Close, _N(tradenum*10,3))\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n        elif (self.p <= 0.45):\n            #调用Log函数并传入参数\"开始平衡\", self.p\n            Log(\"开始平衡，快速建仓\", self.p)\n\n            self.exchange.Buy(kr[-1].Close, _N(tradenum*10,3))\n\n            Log(\"持币数:\",self.btc,\"现金数:\",self.cny)\n    #交易循环\n    def loop(self):\n        self.cancelAllOrders()\n        rt=self.donchian()\n        if rt=='全仓':\n            self.allin()\n        elif rt=='均仓':\n            self.balanceAccount()\n        else:\n            self.allout()\n        Sleep(1000*60)"
    },
    {
        "strategy_id": "130_马丁变种原始版",
        "strategy_code": "python\n'''backtest\nstart: 2021-05-01 00:00:00\nend: 2021-05-14 00:00:00\nperiod: 1m\nbasePeriod: 1m\nexchanges: [{\"eid\":\"Futures_Binance\",\"currency\":\"EOS_USDT\",\"balance\":1000}]\nargs: [[\"zuokong\",true],[\"n\",3],[\"E\",0.02]]\n'''\ndef main():\n    while True:\n        exchange.SetContractType(\"swap\")\n        exchange.SetMarginLevel(MarginLevel)\n        ticker = _C(exchange.GetTicker)\n        account = _C(exchange.GetAccount)\n        position = _C(exchange.GetPosition)\n        if zuoduo:\n            if len(position) == 0:   \n                    exchange.SetDirection(\"buy\")\n                    exchange.Buy(-1, k, \"开多\")\n            if len(position) > 0:\n                if position[0].Type==0:\n                    \n                    if position[0].Price+Q<ticker[\"Last\"]:\n                        exchange.SetDirection(\"closebuy\")\n                        exchange.Sell(-1, position[0].Amount) \n                        account = exchange.GetAccount()\n                        LogProfit(account[\"Balance\"]) \n                    fx=(E/n)*position[0].Amount  \n                    if position[0].Profit<position[0].Margin * -fx :\n                        #轮询加仓\n                            exchange.SetDirection(\"buy\")\n                            exchange.Buy(-1, k)\n                            LogProfit(account[\"Balance\"])     \n        if zuokong:\n            if len(position) == 0:   \n                    exchange.SetDirection(\"sell\")\n                    exchange.Sell(-1, k, \"开空\")\n            if len(position) > 0:\n                if position[0].Type == 1 :\n                    fp=Q*position[0].Amount\n                    if position[0].Profit > 0.01*fp*ticker[\"Last\"] :\n                        exchange.SetDirection(\"closesell\")\n                        exchange.Buy(-1, position[0].Amount) \n                        account = exchange.GetAccount()\n                        LogProfit(account[\"Balance\"]) \n                    fx=(E/n)*position[0].Amount  \n                    if position[0].Profit<position[0].Margin * -fx :\n                        #轮询加仓\n                            exchange.SetDirection(\"sell\")\n                            exchange.Sell(-1, n)\n                            LogProfit(account[\"Balance\"])\n        \n        Sleep(3000)",
        "strategy_description": "策略名称: 马丁变种原始版\n\n未找到描述"
    },
    {
        "strategy_id": "131_高频跨期套利策略",
        "strategy_code": "python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport json\nimport time\n\nfrom kumex.client import Trade, Market\n\n\nclass Hf(object):\n\n    def __init__(self):\n        # read configuration from json file\n        with open('config.json', 'r') as file:\n            config = json.load(file)\n\n        self.api_key = config['api_key']\n        self.api_secret = config['api_secret']\n        self.api_passphrase = config['api_passphrase']\n        self.sandbox = config['is_sandbox']\n        self.symbol_a = config['symbol_a']\n        self.symbol_b = config['symbol_b']\n        self.spread_mean = float(config['spread_mean'])\n        self.leverage = float(config['leverage'])\n        self.size = int(config['size'])\n        self.num_param = float(config['num_param'])\n        self.trade = Trade(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\n        self.market = Market(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\n\n    def get_symbol_price(self, symbol):\n        ticker = self.market.get_ticker(symbol)\n        return float(ticker['price'])\n\n\nif __name__ == '__main__':\n    hf = Hf()\n    while 1:\n        # ticker of symbols\n        price_af = hf.get_symbol_price(hf.symbol_a)\n        price_bf = hf.get_symbol_price(hf.symbol_b)\n        # position of symbols\n        position_a = hf.trade.get_position_details(hf.symbol_a)\n        position_a_qty = int(position_a['currentQty'])\n        position_b = hf.trade.get_position_details(hf.symbol_b)\n        position_b_qty = int(position_b['currentQty'])\n        # interval of price\n        new_spread = price_af - price_bf\n        print('new_spread =', new_spread)\n\n        if position_a_qty == position_b_qty == 0 and new_spread < (hf.spread_mean - hf.num_param):\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'buy', hf.leverage, hf.size, price_af + 1)\n            print('buy %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'sell', hf.leverage, hf.size, price_bf - 1)\n            print('sell %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\n        elif position_a_qty == position_b_qty == 0 and new_spread > (hf.spread_mean + hf.num_param):\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'sell', hf.leverage, hf.size, price_af - 1)\n            print('sell %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'buy', hf.leverage, hf.size, price_bf + 1)\n            print('buy %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\n        elif position_a_qty > 0 and position_b_qty < 0 and new_spread > hf.spread_mean:\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'sell', position_a['realLeverage'],\n                                                    position_a_qty, price_af + 1)\n            print('sell %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'buy', position_a['realLeverage'],\n                                                     position_a_qty, price_bf - 1)\n            print('buy %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\n        elif position_a_qty < 0 and position_b_qty > 0 and new_spread < hf.spread_mean:\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'buy', position_a['realLeverage'],\n                                                    position_a_qty, price_af - 1)\n            print('buy %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'sell', position_a['realLeverage'],\n                                                     position_a_qty, price_bf + 1)\n            print('sell %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\n\n        time.sleep(60)",
        "strategy_description": "策略名称: 高频跨期套利策略\n\n交易标的：比特币（BTC）\n\n价差数据：BTC 永续 - BTC 季度（省略协整性检验）\n\n交易周期：1 分钟\n\n头寸匹配：1:1\n\n交易类型：同品种跨期\n\n做多价差开仓条件：如果当前账户没有持仓，并且价差 < （长期价差水平 - 阈值），就做多价差。即：买开 BTC 永续，卖开 BTC 季度。\n\n做空价差开仓条件：如果当前账户没有持仓，并且价差 > （长期价差水平 + 阈值），就做空价差。即：卖开 BTC 永续，买开 BTC 季度。\n\n做多价差平仓条件：如果当前账户持有 BTC 永续多单，并且持有 BTC 季度空单，并且价差 > 长期价差水平，就平多价差。即：卖平 BTC 永续，买平 BTC 季度。\n\n做空价差平仓条件：如果当前账户持有 BTC 永续空单，并且持有 BTC 季度多单，并且价差 < 长期价差水平，就平空价差。即：买平 BTC 永续，卖平 BTC 季度。\n\n**举个例子**，假设 BTC 永续 和 BTC 当季的价差长期维持在 35 左右。如果某一天价差达到 50 ，我们预计价差会在未来某段时间回归到 35 及以下。那么就可以卖出 BTC 永续，同时买入 BTC 当季，来做空这个价差。反之亦然，注意 BTC 永续 和 BTC 当季 的价差总会回归到0附近（到期交割），所以价差为正的时候，优先做空价差，价差为负的时候，优先做多价差。"
    }
]